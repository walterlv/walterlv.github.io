<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="天前"><meta name="hour-prompt" content="小时前"><meta name="minute-prompt" content="分钟前"><meta name="justnow-prompt" content="刚刚"><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="基于 Roslyn 同时为 Visual Studio 插件和 NuGet 包开发 .NET/C# 源代码分析器 Analyzer 和修改器 CodeFixProvider" /><meta name="author" content="吕毅" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="Roslyn 是 .NET 平台下十分强大的编译器，其提供的 API 也非常丰富好用。本文将基于 Roslyn 开发一个 C# 代码分析器，你不止可以将分析器作为 Visual Studio 代码分析和重构插件发布，还可以作为 NuGet 包发布。不管哪一种，都可以让我们编写的 C# 代码分析器工作起来并真正起到代码建议和重构的作用。" /><meta property="og:description" content="Roslyn 是 .NET 平台下十分强大的编译器，其提供的 API 也非常丰富好用。本文将基于 Roslyn 开发一个 C# 代码分析器，你不止可以将分析器作为 Visual Studio 代码分析和重构插件发布，还可以作为 NuGet 包发布。不管哪一种，都可以让我们编写的 C# 代码分析器工作起来并真正起到代码建议和重构的作用。" /><link rel="canonical" href="https://blog.walterlv.com/post/develop-a-code-analyzer-for-both-nuget-and-visual-studio-extension.html" /><meta property="og:url" content="https://blog.walterlv.com/post/develop-a-code-analyzer-for-both-nuget-and-visual-studio-extension.html" /><meta property="og:site_name" content="walterlv" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-05-17T17:35:16+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="基于 Roslyn 同时为 Visual Studio 插件和 NuGet 包开发 .NET/C# 源代码分析器 Analyzer 和修改器 CodeFixProvider" /><meta name="twitter:site" content="@_lvyi_" /><meta name="twitter:creator" content="@吕毅" /> <script type="application/ld+json"> {"datePublished":"2022-05-17T17:35:16+08:00","description":"Roslyn 是 .NET 平台下十分强大的编译器，其提供的 API 也非常丰富好用。本文将基于 Roslyn 开发一个 C# 代码分析器，你不止可以将分析器作为 Visual Studio 代码分析和重构插件发布，还可以作为 NuGet 包发布。不管哪一种，都可以让我们编写的 C# 代码分析器工作起来并真正起到代码建议和重构的作用。","dateModified":"2022-05-17T17:39:05+08:00","headline":"基于 Roslyn 同时为 Visual Studio 插件和 NuGet 包开发 .NET/C# 源代码分析器 Analyzer 和修改器 CodeFixProvider","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.walterlv.com/post/develop-a-code-analyzer-for-both-nuget-and-visual-studio-extension.html"},"publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"https://blog.walterlv.com/assets/img/logo.png"},"name":"吕毅"},"url":"https://blog.walterlv.com/post/develop-a-code-analyzer-for-both-nuget-and-visual-studio-extension.html","author":{"@type":"Person","name":"吕毅"},"@type":"BlogPosting","@context":"https://schema.org"}</script><title>基于 Roslyn 同时为 Visual Studio 插件和 NuGet 包开发 .NET/C# 源代码分析器 Analyzer 和修改器 CodeFixProvider - walterlv</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="walterlv"><meta name="application-name" content="walterlv"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc"><div id="page-bluring-bg" style=" background-image: url('/static/posts/2019-07-05-20-23-39.png'); "></div><div id="topbar-wrapper" class="row topbar-down"><div id="topbar" class="col-12 d-flex h-100 align-items-center"><div id="topbar-logoside" class="col"> <a id="topbar-logo" href="https://blog.walterlv.com" alt="avatar"> <img src="/assets/img/logo.png" alt="avatar" onerror="this.style.display='none'"> </a> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i> <a id="topbar-title" class="site-title" href="https://blog.walterlv.com" alt="walterlv"> walterlv </a></div><div id="topbar-searchside" class="justify-content-center col-5"> <i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >取消</span></div><div class="col"></div></div></div><div id="sidebar" class="d-flex flex-column align-items-end" lang="zh-CN"><div class="sidebar-box post-item-box profile-wrapper text-center"><div class="site-title mt-3"> <a href="/">吕毅</a></div><div class="site-subtitle font-italic">.NET and Windows App Developer, Microsoft MVP</div></div><ul class="sidebar-box post-item-box"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/friends/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>朋友和收藏</span> </a><li class="nav-item"> <a href="/mind/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>胡思乱想</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/walterlv" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/_lvyi_" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['walter.lv','qq.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>基于 Roslyn 同时为 Visual Studio 插件和 NuGet 包开发 .NET/C# 源代码分析器 Analyzer 和修改器 CodeFixProvider</h1><div class="post-meta text-muted"><div class="d-flex"> <span> 吕毅 </span> <span> 发表于 <em class="timeago" date="2019-07-06 09:20:23 +0800" data-toggle="tooltip" data-placement="bottom" title="2019-07-06, 09:20 +0800" >2019-07-06</em> </span> <span> 更新于 <em class="timeago" date="2022-05-17 17:35:16 +0800" data-toggle="tooltip" data-placement="bottom" title="2022-05-17, 17:35 +0800" >2022-05-17</em> </span></div></div><div class="post-content"><p>Roslyn 是 .NET 平台下十分强大的编译器，其提供的 API 也非常丰富好用。本文将基于 Roslyn 开发一个 C# 代码分析器，你不止可以将分析器作为 Visual Studio 代码分析和重构插件发布，还可以作为 NuGet 包发布。不管哪一种，都可以让我们编写的 C# 代码分析器工作起来并真正起到代码建议和重构的作用。</p><hr /><p>本文将教大家如何从零开始开发一个基于 Roslyn 的 C# 源代码分析器 Analyzer 和修改器 CodeFixProvider。可以作为 Visual Studio 插件安装和使用，也可以作为 NuGet 包安装到项目中使用（无需安装插件）。无论哪一种，你都可以在支持 Roslyn 分析器扩展的 IDE（如 Visual Studio）中获得如下面动图所展示的效果。</p><p><img data-proofer-ignore data-src="/static/posts/2019-07-06-preview-of-roslyn-code-fix.gif" alt="本文教大家可以做到的效果" /></p><div id="toc"></div><h2 id="开发准备">开发准备<a href="#开发准备"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="安装-visual-studio-扩展开发工作负载">安装 Visual Studio 扩展开发工作负载<a href="#安装-visual-studio-扩展开发工作负载"><i class="fas fa-hashtag"></i></a></h3></h3><p>你需要先安装 Visual Studio 的扩展开发工作负载，如果你还没有安装，那么请先阅读以下博客安装：</p><p><img data-proofer-ignore data-src="/static/posts/2019-07-05-20-23-39.png" alt="Visual Studio 扩展开发" /></p><ul><li><a href="/post/how-to-prepare-visual-studio-extension-development-environment">如何安装和准备 Visual Studio 扩展/插件开发环境</a></ul><h3 id="创建一个分析器项目">创建一个分析器项目<a href="#创建一个分析器项目"><i class="fas fa-hashtag"></i></a></h3></h3><p>启动 Visual Studio，新建项目，然后在项目模板中找到 “Analyzer with Code Fix (.NET Standard)”，下一步。</p><p><img data-proofer-ignore data-src="/static/posts/2019-07-05-20-27-06.png" alt="Analyzer with Code Fix 模板" /></p><p>随后，取好项目名字之后，点击“创建”，你将来到 Visual Studio 的主界面。</p><p>我为项目取的名称是 <code class="language-plaintext highlighter-rouge">Walterlv.Demo.Analyzers</code>，接下来都将以此名称作为示例。你如果使用了别的名称，建议你自己找到名称的对应关系。</p><p>在创建完项目之后，你可选可以更新一下项目的 .NET Standard 版本（默认是 1.3，建议更新为 2.0）以及几个 NuGet 包。</p><h3 id="首次调试">首次调试<a href="#首次调试"><i class="fas fa-hashtag"></i></a></h3></h3><p>如果你现在按下 F5，那么将会启动一个 Visual Studio 的实验实例用于调试。</p><p><img data-proofer-ignore data-src="/static/posts/2019-07-05-20-53-50.png" alt="Visual Studio 实验实例" /></p><p>由于我们是一个分析器项目，所以我们需要在第一次启动实验实例的时候新建一个专门用来测试的小型项目。</p><p>简单起见，我新建一个 .NET Core 控制台项目。新建的项目如下：</p><p><img data-proofer-ignore data-src="/static/posts/2019-07-05-20-58-03.png" alt="测试用的控制台项目" /></p><p>我们目前只是基于模板创建了一个分析器，而模板中自带的分析器功能是 “只要类型名称中有任何一个字符是小写的，就给出建议将其改为全部大写”。</p><p>于是我们看到 <code class="language-plaintext highlighter-rouge">Program</code> 类名底下标了绿色的波浪线，我们将光标定位到 <code class="language-plaintext highlighter-rouge">Program</code> 类名上，可以看到出现了一个 “小灯泡” 提示。按下重构快捷键（默认是 <code class="language-plaintext highlighter-rouge">Ctrl + .</code>）后可以发现，我们的分析器项目提供的 “Make uppercase” 建议显示了出来。于是我们可以快速地将类名修改为全部大写。</p><p><img data-proofer-ignore data-src="/static/posts/2019-07-05-code-fix-make-upper-case.gif" alt="模板中自带的分析器建议" /></p><p>因为我们在前面安装了 Visual Studio 扩展开发的工作负载，所以可以在 “视图”-&gt;“其他窗口” 中找到并打开 Syntax Visualizer 窗格。现在，请将它打开，因为接下来我们的代码分析会用得到这个窗格。</p><p><img data-proofer-ignore data-src="/static/posts/2019-07-05-22-42-05.png" alt="打开语法可视化窗格" /></p><p>如果体验完毕，可以关闭 Visual Studio；当然也可以在我们的分析器项目中 Shift + F5 强制结束调试。</p><p>下次调试的时候，我们不需要再次新建项目了，因为我们刚刚新建的项目还在我们新建的文件夹下。下次调试只要像下面那样再次打开这个项目测试就好了。</p><p><img data-proofer-ignore data-src="/static/posts/2019-07-05-23-29-33.png" alt="打开历史记录中的项目" /></p><h2 id="解读模板自带的分析器项目">解读模板自带的分析器项目<a href="#解读模板自带的分析器项目"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="项目和解决方案">项目和解决方案<a href="#项目和解决方案"><i class="fas fa-hashtag"></i></a></h3></h3><p>在创建完项目之后，你会发现解决方案中有三个项目：</p><p><img data-proofer-ignore data-src="/static/posts/2019-07-05-20-46-27.png" alt="Visual Studio 分析器解决方案" /></p><ul><li>Walterlv.Demo.Analyzers<ul><li>分析器主项目，我们接下来分析器的主要逻辑代码都在这个项目中<li>这个项目在编译成功之后会生成一个 NuGet 包，安装了此包的项目将会运行我们的分析器</ul><li>Walterlv.Demo.Analyzers.Vsix<ul><li>Visual Studio 扩展项目，我们会在这里 Visual Studio 插件相关的信息<li>这个项目在便已成功之后会生成一个 Visual Studio 插件安装包，Visual Studio 安装了此插件后将会对所有正在编辑的项目运行我们的分析器<li>这个项目在默认情况下是启动项目（按下 F5 会启动这个项目调试），调试时会启动一个 Visual Studio 的实验实例</ul><li>Walterlv.Demo.Analyzers.Test<ul><li>单元测试项目<li>模板为我们生成了比较多的辅助代码帮助我们快速编写用于测试我们分析器可用性的单元测试，我们接下来的代码质量也靠这个来保证</ul></ul><p>在项目内部：</p><ul><li>WalterlvDemoAnalyzersAnalyzer.cs<ul><li>模板中自带的分析器（Analyzer）的主要代码<li>我们什么都还没有写的时候，里面已经包含一份示例用的分析器，其功能是找到包含小写的类名。</ul><li>WalterlvDemoAnalyzersCodeFixProvider.cs<ul><li>模板中自带的代码修改器（CodeFixProvider）的主要代码<li>我们什么都还没有写的时候，里面已经包含一份示例用的代码修改器，根据前面分析器中找到的诊断信息，给出修改建议，即只要类型名称中有任何一个字符是小写的，就给出建议将其改为全部大写</ul><li>Resources.resx<ul><li>这里包含分析器建议使用的多语言信息</ul></ul><p><img data-proofer-ignore data-src="/static/posts/2019-07-05-21-33-34.png" alt="多语言资源文件" /></p><h3 id="分析器代码analyzer">分析器代码（Analyzer）<a href="#分析器代码analyzer"><i class="fas fa-hashtag"></i></a></h3></h3><p>别看我们分析器文件中的代码很长，但实际上关键的信息并不多。</p><p>我们现在还没有自行修改 <code class="language-plaintext highlighter-rouge">WalterlvDemoAnalyzersAnalyzer</code> 类中的任何内容，而到目前位置这个类里面包含的最关键代码我提取出来之后是下面这些。为了避免你吐槽这些代码编译不通过，我将一部分的实现替换成了 <code class="language-plaintext highlighter-rouge">NotImplementedException</code>。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="p">[</span><span class="nf">DiagnosticAnalyzer</span><span class="p">(</span><span class="n">LanguageNames</span><span class="p">.</span><span class="n">CSharp</span><span class="p">)]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">WalterlvDemoAnalyzersAnalyzer</span> <span class="p">:</span> <span class="n">DiagnosticAnalyzer</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">override</span> <span class="n">ImmutableArray</span><span class="p">&lt;</span><span class="n">DiagnosticDescriptor</span><span class="p">&gt;</span> <span class="n">SupportedDiagnostics</span>
        <span class="p">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nf">NotImplementedException</span><span class="p">();</span>

    <span class="k">public</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">Initialize</span><span class="p">(</span><span class="n">AnalysisContext</span> <span class="n">context</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nf">NotImplementedException</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><p>最关键的点：</p><ol><li><code class="language-plaintext highlighter-rouge">[DiagnosticAnalyzer(LanguageNames.CSharp)]</code><ul><li>为 C# 语言提供诊断分析器</ul><li><code class="language-plaintext highlighter-rouge">override SupportedDiagnostics</code><ul><li>返回此分析器支持的诊断规则</ul><li><code class="language-plaintext highlighter-rouge">override Initialize</code><ul><li>在此分析器初始化的时候执行某些代码</ul></ol><p>现在我们分别细化这些关键代码。为了简化理解，我将多语言全部替换成了实际的字符串值。</p><p>重写 <code class="language-plaintext highlighter-rouge">SupportedDiagnostics</code> 的部分，创建并返回了一个 <code class="language-plaintext highlighter-rouge">DiagnosticDescriptor</code> 类型的只读集合。目前只有一个 <code class="language-plaintext highlighter-rouge">DiagnosticDescriptor</code>，名字是 <code class="language-plaintext highlighter-rouge">Rule</code>，构造它的时候传入了一大堆字符串，包括分析器 Id、标题、消息提示、类型、级别、默认开启、描述信息。</p><p>可以很容易看出，如果我们这个分析器带有多个诊断建议，那么在只读集合中返回多个 <code class="language-plaintext highlighter-rouge">DiagnosticDescriptor</code> 的实例。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="k">const</span> <span class="kt">string</span> <span class="n">DiagnosticId</span> <span class="p">=</span> <span class="s">"WalterlvDemoAnalyzers"</span><span class="p">;</span>

<span class="k">private</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">LocalizableString</span> <span class="n">Title</span> <span class="p">=</span> <span class="s">"Type name contains lowercase letters"</span><span class="p">;</span>
<span class="k">private</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">LocalizableString</span> <span class="n">MessageFormat</span> <span class="p">=</span> <span class="s">"Type name '{0}' contains lowercase letters"</span><span class="p">;</span>
<span class="k">private</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">LocalizableString</span> <span class="n">Description</span> <span class="p">=</span> <span class="s">"Type names should be all uppercase."</span><span class="p">;</span>
<span class="k">private</span> <span class="k">const</span> <span class="kt">string</span> <span class="n">Category</span> <span class="p">=</span> <span class="s">"Naming"</span><span class="p">;</span>

<span class="k">private</span> <span class="k">static</span> <span class="n">DiagnosticDescriptor</span> <span class="n">Rule</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">DiagnosticDescriptor</span><span class="p">(</span><span class="n">DiagnosticId</span><span class="p">,</span> <span class="n">Title</span><span class="p">,</span> <span class="n">MessageFormat</span><span class="p">,</span> <span class="n">Category</span><span class="p">,</span> <span class="n">DiagnosticSeverity</span><span class="p">.</span><span class="n">Warning</span><span class="p">,</span> <span class="n">isEnabledByDefault</span><span class="p">:</span> <span class="k">true</span><span class="p">,</span> <span class="n">description</span><span class="p">:</span> <span class="n">Description</span><span class="p">);</span>

<span class="k">public</span> <span class="k">override</span> <span class="n">ImmutableArray</span><span class="p">&lt;</span><span class="n">DiagnosticDescriptor</span><span class="p">&gt;</span> <span class="n">SupportedDiagnostics</span> <span class="p">=&gt;</span> <span class="n">ImmutableArray</span><span class="p">.</span><span class="nf">Create</span><span class="p">(</span><span class="n">Rule</span><span class="p">);</span>
</pre></table></code></div></div><p>重写 <code class="language-plaintext highlighter-rouge">Initialize</code> 的部分，模板中注册了一个类名分析器，其实就是下面那个静态方法 <code class="language-plaintext highlighter-rouge">AnalyzeSymbol</code>。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">Initialize</span><span class="p">(</span><span class="n">AnalysisContext</span> <span class="n">context</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">context</span><span class="p">.</span><span class="nf">RegisterSymbolAction</span><span class="p">(</span><span class="n">AnalyzeSymbol</span><span class="p">,</span> <span class="n">SymbolKind</span><span class="p">.</span><span class="n">NamedType</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">private</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">AnalyzeSymbol</span><span class="p">(</span><span class="n">SymbolAnalysisContext</span> <span class="n">context</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 省略实现。</span>
    <span class="c1">// 在模板自带的实现中，这里判断类名是否包含小写字母，如果包含则创建一个新的诊断建议以改为大写字母。</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="代码修改器codefixprovider">代码修改器（CodeFixProvider）<a href="#代码修改器codefixprovider"><i class="fas fa-hashtag"></i></a></h3></h3><p>代码修改器文件中的代码更长，但关键信息也没有增加多少。</p><p>我们现在也没有自行修改 <code class="language-plaintext highlighter-rouge">WalterlvDemoAnalyzersCodeFixProvider</code> 类中的任何内容，而到目前位置这个类里面包含的最关键代码我提取出来之后是下面这些。为了避免你吐槽这些代码编译不通过，我将一部分的实现替换成了 <code class="language-plaintext highlighter-rouge">NotImplementedException</code>。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="p">[</span><span class="nf">ExportCodeFixProvider</span><span class="p">(</span><span class="n">LanguageNames</span><span class="p">.</span><span class="n">CSharp</span><span class="p">,</span> <span class="n">Name</span> <span class="p">=</span> <span class="k">nameof</span><span class="p">(</span><span class="n">WalterlvDemoAnalyzersCodeFixProvider</span><span class="p">)),</span> <span class="n">Shared</span><span class="p">]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">WalterlvDemoAnalyzersCodeFixProvider</span> <span class="p">:</span> <span class="n">CodeFixProvider</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">sealed</span> <span class="k">override</span> <span class="n">ImmutableArray</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">FixableDiagnosticIds</span>
        <span class="p">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nf">NotImplementedException</span><span class="p">();</span>

    <span class="k">public</span> <span class="k">sealed</span> <span class="k">override</span> <span class="n">FixAllProvider</span> <span class="nf">GetFixAllProvider</span><span class="p">()</span>
        <span class="p">=&gt;</span> <span class="n">WellKnownFixAllProviders</span><span class="p">.</span><span class="n">BatchFixer</span><span class="p">;</span>

    <span class="k">public</span> <span class="k">sealed</span> <span class="k">override</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">RegisterCodeFixesAsync</span><span class="p">(</span><span class="n">CodeFixContext</span> <span class="n">context</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nf">NotImplementedException</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><p>最关键的点：</p><ol><li><code class="language-plaintext highlighter-rouge">[ExportCodeFixProvider(LanguageNames.CSharp, Name = nameof(WalterlvDemoAnalyzersCodeFixProvider)), Shared]</code><ul><li>为 C# 语言提供代码修改器</ul><li><code class="language-plaintext highlighter-rouge">override FixableDiagnosticIds</code><ul><li>注意到前面 <code class="language-plaintext highlighter-rouge">WalterlvDemoAnalyzersAnalyzer</code> 类型中有一个公共字段 <code class="language-plaintext highlighter-rouge">DiagnosticId</code> 吗？在这里返回，可以为那里分析器找到的代码提供修改建议</ul><li><code class="language-plaintext highlighter-rouge">override GetFixAllProvider</code><ul><li>在最简单的示例中，我们将仅仅返回 <code class="language-plaintext highlighter-rouge">BatchFixer</code>，其他种类的 <code class="language-plaintext highlighter-rouge">FixAllProvider</code> 我将通过其他博客进行说明</ul><li><code class="language-plaintext highlighter-rouge">override RegisterCodeFixesAsync</code><ul><li>在 <code class="language-plaintext highlighter-rouge">FixableDiagnosticIds</code> 属性中我们返回的那些诊断建议这个方法中可以拿到，于是为每一个返回的诊断建议注册一个代码修改器（CodeFix）</ul></ol><p>在这个模板提供的例子中，<code class="language-plaintext highlighter-rouge">FixableDiagnosticIds</code> 返回了 <code class="language-plaintext highlighter-rouge">WalterlvDemoAnalyzersAnalyzer</code> 类中的公共字段 <code class="language-plaintext highlighter-rouge">DiagnosticId</code>：</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="k">sealed</span> <span class="k">override</span> <span class="n">ImmutableArray</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">FixableDiagnosticIds</span> <span class="p">=&gt;</span>
    <span class="n">ImmutableArray</span><span class="p">.</span><span class="nf">Create</span><span class="p">(</span><span class="n">WalterlvDemoAnalyzersAnalyzer</span><span class="p">.</span><span class="n">DiagnosticId</span><span class="p">);</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">RegisterCodeFixesAsync</code> 中找到我们在 <code class="language-plaintext highlighter-rouge">WalterlvDemoAnalyzersAnalyzer</code> 类中找到的一个 <code class="language-plaintext highlighter-rouge">Diagnostic</code>，然后对这个 <code class="language-plaintext highlighter-rouge">Diagnostic</code> 注册一个代码修改（CodeFix）。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="k">sealed</span> <span class="k">override</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">RegisterCodeFixesAsync</span><span class="p">(</span><span class="n">CodeFixContext</span> <span class="n">context</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">root</span> <span class="p">=</span> <span class="k">await</span> <span class="n">context</span><span class="p">.</span><span class="n">Document</span><span class="p">.</span><span class="nf">GetSyntaxRootAsync</span><span class="p">(</span><span class="n">context</span><span class="p">.</span><span class="n">CancellationToken</span><span class="p">).</span><span class="nf">ConfigureAwait</span><span class="p">(</span><span class="k">false</span><span class="p">);</span>

    <span class="c1">// TODO: Replace the following code with your own analysis, generating a CodeAction for each fix to suggest</span>
    <span class="kt">var</span> <span class="n">diagnostic</span> <span class="p">=</span> <span class="n">context</span><span class="p">.</span><span class="n">Diagnostics</span><span class="p">.</span><span class="nf">First</span><span class="p">();</span>
    <span class="kt">var</span> <span class="n">diagnosticSpan</span> <span class="p">=</span> <span class="n">diagnostic</span><span class="p">.</span><span class="n">Location</span><span class="p">.</span><span class="n">SourceSpan</span><span class="p">;</span>

    <span class="c1">// Find the type declaration identified by the diagnostic.</span>
    <span class="kt">var</span> <span class="n">declaration</span> <span class="p">=</span> <span class="n">root</span><span class="p">.</span><span class="nf">FindToken</span><span class="p">(</span><span class="n">diagnosticSpan</span><span class="p">.</span><span class="n">Start</span><span class="p">).</span><span class="n">Parent</span><span class="p">.</span><span class="nf">AncestorsAndSelf</span><span class="p">().</span><span class="n">OfType</span><span class="p">&lt;</span><span class="n">TypeDeclarationSyntax</span><span class="p">&gt;().</span><span class="nf">First</span><span class="p">();</span>

    <span class="c1">// Register a code action that will invoke the fix.</span>
    <span class="n">context</span><span class="p">.</span><span class="nf">RegisterCodeFix</span><span class="p">(</span>
        <span class="n">CodeAction</span><span class="p">.</span><span class="nf">Create</span><span class="p">(</span>
            <span class="n">title</span><span class="p">:</span> <span class="n">title</span><span class="p">,</span>
            <span class="n">createChangedSolution</span><span class="p">:</span> <span class="n">c</span> <span class="p">=&gt;</span> <span class="nf">MakeUppercaseAsync</span><span class="p">(</span><span class="n">context</span><span class="p">.</span><span class="n">Document</span><span class="p">,</span> <span class="n">declaration</span><span class="p">,</span> <span class="n">c</span><span class="p">),</span>
            <span class="n">equivalenceKey</span><span class="p">:</span> <span class="n">title</span><span class="p">),</span>
        <span class="n">diagnostic</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">private</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">Solution</span><span class="p">&gt;</span> <span class="nf">MakeUppercaseAsync</span><span class="p">(</span><span class="n">Document</span> <span class="n">document</span><span class="p">,</span> <span class="n">TypeDeclarationSyntax</span> <span class="n">typeDecl</span><span class="p">,</span> <span class="n">CancellationToken</span> <span class="n">cancellationToken</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 省略实现。</span>
    <span class="c1">// 将类名改为全大写，然后返回解决方案。</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="开发自己的分析器analyzer">开发自己的分析器（Analyzer）<a href="#开发自己的分析器analyzer"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="一个简单的目标">一个简单的目标<a href="#一个简单的目标"><i class="fas fa-hashtag"></i></a></h3></h3><p>作为示例，我们写一个属性转换分析器，将自动属性转换为可通知属性。</p><p>就是像以下上面的一种属性转换成下面的一种：</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="kt">string</span> <span class="n">Foo</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
</pre></table></code></div></div><div class="language-csharp highlighter-rouge"><div class="code-header"> <span label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">private</span> <span class="kt">string</span> <span class="n">_foo</span><span class="p">;</span>

<span class="k">public</span> <span class="kt">string</span> <span class="n">Foo</span>
<span class="p">{</span>
    <span class="k">get</span> <span class="p">=&gt;</span> <span class="n">_foo</span><span class="p">;</span>
    <span class="k">set</span> <span class="p">=&gt;</span> <span class="nf">SetValue</span><span class="p">(</span><span class="k">ref</span> <span class="n">_foo</span><span class="p">,</span> <span class="k">value</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>这里我们写了一个 <code class="language-plaintext highlighter-rouge">SetValue</code> 方法，有没有这个 <code class="language-plaintext highlighter-rouge">SetValue</code> 方法存在对我们后面写的分析器其实没有任何影响。不过你如果强迫症，可以看本文最后的“一些补充”章节，把 <code class="language-plaintext highlighter-rouge">SetValue</code> 方法加进来。</p><h3 id="开始添加最基础的代码">开始添加最基础的代码<a href="#开始添加最基础的代码"><i class="fas fa-hashtag"></i></a></h3></h3><p>于是，我们将 <code class="language-plaintext highlighter-rouge">Initialize</code> 方法中的内容改成我们期望的分析自动属性的语法节点分析。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">Initialize</span><span class="p">(</span><span class="n">AnalysisContext</span> <span class="n">context</span><span class="p">)</span>
    <span class="p">=&gt;</span> <span class="n">context</span><span class="p">.</span><span class="nf">RegisterSyntaxNodeAction</span><span class="p">(</span><span class="n">AnalyzeAutoProperty</span><span class="p">,</span> <span class="n">SyntaxKind</span><span class="p">.</span><span class="n">PropertyDeclaration</span><span class="p">);</span>

<span class="k">private</span> <span class="k">void</span> <span class="nf">AnalyzeAutoProperty</span><span class="p">(</span><span class="n">SyntaxNodeAnalysisContext</span> <span class="n">context</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 你可以在这一行打上一个断点，这样你可以观察 `context` 参数。</span>
<span class="p">}</span>
</pre></table></code></div></div><p>上面的 <code class="language-plaintext highlighter-rouge">AnalyzeAutoProperty</code> 只是我们随便取的名字，而 <code class="language-plaintext highlighter-rouge">SyntaxKind.PropertyDeclaration</code> 是靠智能感知提示帮我找到的。</p><p>现在我们来试着分析一个自动属性。</p><p>按下 F5 调试，在新的调试的 Visual Studio 实验实例中，我们将鼠标光标放在 <code class="language-plaintext highlighter-rouge">public string Foo { get; set; }</code> 行上。如果我们提前在 <code class="language-plaintext highlighter-rouge">AnalyzeAutoProperty</code> 方法中打了断点，那么我们可以在此时观察到 <code class="language-plaintext highlighter-rouge">context</code> 参数。</p><p><img data-proofer-ignore data-src="/static/posts/2019-07-05-23-31-47.png" alt="context 参数" /></p><ul><li><code class="language-plaintext highlighter-rouge">CancellationToken</code> 指示当前是否已取消分析<li><code class="language-plaintext highlighter-rouge">Node</code> 语法节点<li><code class="language-plaintext highlighter-rouge">SemanticModel</code><li><code class="language-plaintext highlighter-rouge">ContainingSymbol</code> 语义分析节点<li><code class="language-plaintext highlighter-rouge">Compilation</code><li><code class="language-plaintext highlighter-rouge">Options</code></ul><p>其中，<code class="language-plaintext highlighter-rouge">Node.KindText</code> 属性的值为 <code class="language-plaintext highlighter-rouge">PropertyDeclaration</code>。还记得前面让你先提前打开 Syntax Visualizer 窗格吗？是的，我们可以在这个窗格中找到 <code class="language-plaintext highlighter-rouge">PropertyDeclaration</code> 节点。</p><p>我们可以借助这个语法可视化窗格，找到 <code class="language-plaintext highlighter-rouge">PropertyDeclaration</code> 的子节点。当我们一级一级分析其子节点的语法的时候，便可以取得这个语法节点的全部所需信息（可见性、属性类型、属性名称），也就是具备生成可通知属性的全部信息了。</p><p><img data-proofer-ignore data-src="/static/posts/2019-07-05-23-42-01.png" alt="在语法可视化窗格中分析属性" /></p><h3 id="添加分析自动属性的代码">添加分析自动属性的代码<a href="#添加分析自动属性的代码"><i class="fas fa-hashtag"></i></a></h3></h3><p>由于我们在前面 <code class="language-plaintext highlighter-rouge">Initialize</code> 方法中注册了仅在属性声明语法节点的时候才会执行 <code class="language-plaintext highlighter-rouge">AnalyzeAutoProperty</code> 方法，所以我们在这里可以简单的开始报告一个代码分析 <code class="language-plaintext highlighter-rouge">Diagnostic</code>：</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kt">var</span> <span class="n">propertyNode</span> <span class="p">=</span> <span class="p">(</span><span class="n">PropertyDeclarationSyntax</span><span class="p">)</span><span class="n">context</span><span class="p">.</span><span class="n">Node</span><span class="p">;</span>
<span class="kt">var</span> <span class="n">diagnostic</span> <span class="p">=</span> <span class="n">Diagnostic</span><span class="p">.</span><span class="nf">Create</span><span class="p">(</span><span class="n">_rule</span><span class="p">,</span> <span class="n">propertyNode</span><span class="p">.</span><span class="nf">GetLocation</span><span class="p">());</span>
<span class="n">context</span><span class="p">.</span><span class="nf">ReportDiagnostic</span><span class="p">(</span><span class="n">diagnostic</span><span class="p">);</span>
</pre></table></code></div></div><p>现在，<code class="language-plaintext highlighter-rouge">WalterlvDemoAnalyzersAnalyzer</code> 类的完整代码如下：</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="p">[</span><span class="nf">DiagnosticAnalyzer</span><span class="p">(</span><span class="n">LanguageNames</span><span class="p">.</span><span class="n">CSharp</span><span class="p">)]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">WalterlvDemoAnalyzersAnalyzer</span> <span class="p">:</span> <span class="n">DiagnosticAnalyzer</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">const</span> <span class="kt">string</span> <span class="n">DiagnosticId</span> <span class="p">=</span> <span class="s">"WalterlvDemoAnalyzers"</span><span class="p">;</span>

    <span class="k">private</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">LocalizableString</span> <span class="n">_title</span> <span class="p">=</span> <span class="s">"自动属性"</span><span class="p">;</span>
    <span class="k">private</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">LocalizableString</span> <span class="n">_messageFormat</span> <span class="p">=</span> <span class="s">"这是一个自动属性"</span><span class="p">;</span>
    <span class="k">private</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">LocalizableString</span> <span class="n">_description</span> <span class="p">=</span> <span class="s">"可以转换为可通知属性。"</span><span class="p">;</span>
    <span class="k">private</span> <span class="k">const</span> <span class="kt">string</span> <span class="n">_category</span> <span class="p">=</span> <span class="s">"Usage"</span><span class="p">;</span>

    <span class="k">private</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">DiagnosticDescriptor</span> <span class="n">_rule</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">DiagnosticDescriptor</span><span class="p">(</span>
        <span class="n">DiagnosticId</span><span class="p">,</span> <span class="n">_title</span><span class="p">,</span> <span class="n">_messageFormat</span><span class="p">,</span> <span class="n">_category</span><span class="p">,</span> <span class="n">DiagnosticSeverity</span><span class="p">.</span><span class="n">Info</span><span class="p">,</span>
        <span class="n">isEnabledByDefault</span><span class="p">:</span> <span class="k">true</span><span class="p">,</span> <span class="n">description</span><span class="p">:</span> <span class="n">_description</span><span class="p">);</span>

    <span class="k">public</span> <span class="k">override</span> <span class="n">ImmutableArray</span><span class="p">&lt;</span><span class="n">DiagnosticDescriptor</span><span class="p">&gt;</span> <span class="n">SupportedDiagnostics</span> <span class="p">=&gt;</span> <span class="n">ImmutableArray</span><span class="p">.</span><span class="nf">Create</span><span class="p">(</span><span class="n">_rule</span><span class="p">);</span>

    <span class="k">public</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">Initialize</span><span class="p">(</span><span class="n">AnalysisContext</span> <span class="n">context</span><span class="p">)</span> <span class="p">=&gt;</span>
        <span class="n">context</span><span class="p">.</span><span class="nf">RegisterSyntaxNodeAction</span><span class="p">(</span><span class="n">AnalyzeAutoProperty</span><span class="p">,</span> <span class="n">SyntaxKind</span><span class="p">.</span><span class="n">PropertyDeclaration</span><span class="p">);</span>

    <span class="k">private</span> <span class="k">void</span> <span class="nf">AnalyzeAutoProperty</span><span class="p">(</span><span class="n">SyntaxNodeAnalysisContext</span> <span class="n">context</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">propertyNode</span> <span class="p">=</span> <span class="p">(</span><span class="n">PropertyDeclarationSyntax</span><span class="p">)</span><span class="n">context</span><span class="p">.</span><span class="n">Node</span><span class="p">;</span>
        <span class="kt">var</span> <span class="n">diagnostic</span> <span class="p">=</span> <span class="n">Diagnostic</span><span class="p">.</span><span class="nf">Create</span><span class="p">(</span><span class="n">_rule</span><span class="p">,</span> <span class="n">propertyNode</span><span class="p">.</span><span class="nf">GetLocation</span><span class="p">());</span>
        <span class="n">context</span><span class="p">.</span><span class="nf">ReportDiagnostic</span><span class="p">(</span><span class="n">diagnostic</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>可以发现代码并不多，现在运行，可以在光标落在属性声明的行时看到修改建议。如下图所示：</p><p><img data-proofer-ignore data-src="/static/posts/2019-07-06-00-33-03.png" alt="在属性上有修改建议" /></p><p>你可能会觉得有些不满，看起来似乎只有我们写的那些标题和描述在工作。但实际上你还应该注意到这些：</p><ol><li><code class="language-plaintext highlighter-rouge">DiagnosticId</code>、<code class="language-plaintext highlighter-rouge">_messageFormat</code>、<code class="language-plaintext highlighter-rouge">_description</code> 已经工作起来了；<li>只有光标在属性声明的语句块时，这个提示才会出现，因此说明我们的已经找到了正确的代码块了；<li>不要忘了我们还有个 <code class="language-plaintext highlighter-rouge">CodeFixProvider</code> 没有写呢，你现在看到的依然还在修改大小写的部分代码是那个类（<code class="language-plaintext highlighter-rouge">WalterlvDemoAnalyzersCodeFixProvider</code>）里的。</ol><h2 id="开发自己的代码修改器codefixprovider">开发自己的代码修改器（CodeFixProvider）<a href="#开发自己的代码修改器codefixprovider"><i class="fas fa-hashtag"></i></a></h2></h2><p>现在，我们开始进行代码修改，将 <code class="language-plaintext highlighter-rouge">WalterlvDemoAnalyzersCodeFixProvider</code> 类改成我们希望的将属性修改为可通知属性的代码。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
</pre><td class="rouge-code"><pre><span class="p">[</span><span class="nf">ExportCodeFixProvider</span><span class="p">(</span><span class="n">LanguageNames</span><span class="p">.</span><span class="n">CSharp</span><span class="p">,</span> <span class="n">Name</span> <span class="p">=</span> <span class="k">nameof</span><span class="p">(</span><span class="n">WalterlvDemoAnalyzersCodeFixProvider</span><span class="p">)),</span> <span class="n">Shared</span><span class="p">]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">WalterlvDemoAnalyzersCodeFixProvider</span> <span class="p">:</span> <span class="n">CodeFixProvider</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">const</span> <span class="kt">string</span> <span class="n">_title</span> <span class="p">=</span> <span class="s">"转换为可通知属性"</span><span class="p">;</span>

    <span class="k">public</span> <span class="k">sealed</span> <span class="k">override</span> <span class="n">ImmutableArray</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">FixableDiagnosticIds</span> <span class="p">=&gt;</span>
        <span class="n">ImmutableArray</span><span class="p">.</span><span class="nf">Create</span><span class="p">(</span><span class="n">WalterlvDemoAnalyzersAnalyzer</span><span class="p">.</span><span class="n">DiagnosticId</span><span class="p">);</span>

    <span class="k">public</span> <span class="k">sealed</span> <span class="k">override</span> <span class="n">FixAllProvider</span> <span class="nf">GetFixAllProvider</span><span class="p">()</span> <span class="p">=&gt;</span> <span class="n">WellKnownFixAllProviders</span><span class="p">.</span><span class="n">BatchFixer</span><span class="p">;</span>

    <span class="k">public</span> <span class="k">sealed</span> <span class="k">override</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">RegisterCodeFixesAsync</span><span class="p">(</span><span class="n">CodeFixContext</span> <span class="n">context</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">root</span> <span class="p">=</span> <span class="k">await</span> <span class="n">context</span><span class="p">.</span><span class="n">Document</span><span class="p">.</span><span class="nf">GetSyntaxRootAsync</span><span class="p">(</span><span class="n">context</span><span class="p">.</span><span class="n">CancellationToken</span><span class="p">).</span><span class="nf">ConfigureAwait</span><span class="p">(</span><span class="k">false</span><span class="p">);</span>
        <span class="kt">var</span> <span class="n">diagnostic</span> <span class="p">=</span> <span class="n">context</span><span class="p">.</span><span class="n">Diagnostics</span><span class="p">.</span><span class="nf">First</span><span class="p">();</span>
        <span class="kt">var</span> <span class="n">declaration</span> <span class="p">=</span> <span class="p">(</span><span class="n">PropertyDeclarationSyntax</span><span class="p">)</span><span class="n">root</span><span class="p">.</span><span class="nf">FindNode</span><span class="p">(</span><span class="n">diagnostic</span><span class="p">.</span><span class="n">Location</span><span class="p">.</span><span class="n">SourceSpan</span><span class="p">);</span>

        <span class="n">context</span><span class="p">.</span><span class="nf">RegisterCodeFix</span><span class="p">(</span>
            <span class="n">CodeAction</span><span class="p">.</span><span class="nf">Create</span><span class="p">(</span>
                <span class="n">title</span><span class="p">:</span> <span class="n">_title</span><span class="p">,</span>
                <span class="n">createChangedSolution</span><span class="p">:</span> <span class="n">ct</span> <span class="p">=&gt;</span> <span class="nf">ConvertToNotificationProperty</span><span class="p">(</span><span class="n">context</span><span class="p">.</span><span class="n">Document</span><span class="p">,</span> <span class="n">declaration</span><span class="p">,</span> <span class="n">ct</span><span class="p">),</span>
                <span class="n">equivalenceKey</span><span class="p">:</span> <span class="n">_title</span><span class="p">),</span>
            <span class="n">diagnostic</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">Solution</span><span class="p">&gt;</span> <span class="nf">ConvertToNotificationProperty</span><span class="p">(</span><span class="n">Document</span> <span class="n">document</span><span class="p">,</span>
        <span class="n">PropertyDeclarationSyntax</span> <span class="n">propertyDeclarationSyntax</span><span class="p">,</span> <span class="n">CancellationToken</span> <span class="n">cancellationToken</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// 获取文档根语法节点。</span>
        <span class="kt">var</span> <span class="n">root</span> <span class="p">=</span> <span class="k">await</span> <span class="n">document</span><span class="p">.</span><span class="nf">GetSyntaxRootAsync</span><span class="p">(</span><span class="n">cancellationToken</span><span class="p">).</span><span class="nf">ConfigureAwait</span><span class="p">(</span><span class="k">false</span><span class="p">);</span>

        <span class="c1">// 生成可通知属性的语法节点集合。</span>
        <span class="kt">var</span> <span class="n">type</span> <span class="p">=</span> <span class="n">propertyDeclarationSyntax</span><span class="p">.</span><span class="n">Type</span><span class="p">;</span>
        <span class="kt">var</span> <span class="n">propertyName</span> <span class="p">=</span> <span class="n">propertyDeclarationSyntax</span><span class="p">.</span><span class="n">Identifier</span><span class="p">.</span><span class="n">ValueText</span><span class="p">;</span>
        <span class="kt">var</span> <span class="n">fieldName</span> <span class="p">=</span> <span class="s">$"_</span><span class="p">{</span><span class="kt">char</span><span class="p">.</span><span class="nf">ToLower</span><span class="p">(</span><span class="n">propertyName</span><span class="p">[</span><span class="m">0</span><span class="p">])}{</span><span class="n">propertyName</span><span class="p">.</span><span class="nf">Substring</span><span class="p">(</span><span class="m">1</span><span class="p">)}</span><span class="s">"</span><span class="p">;</span>
        <span class="kt">var</span> <span class="n">newNodes</span> <span class="p">=</span> <span class="nf">CreateNotificationProperty</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">propertyName</span><span class="p">,</span> <span class="n">fieldName</span><span class="p">);</span>

        <span class="c1">// 将可通知属性的语法节点插入到原文档中形成一份中间文档。</span>
        <span class="kt">var</span> <span class="n">intermediateRoot</span> <span class="p">=</span> <span class="n">root</span>
            <span class="p">.</span><span class="nf">InsertNodesAfter</span><span class="p">(</span>
                <span class="n">root</span><span class="p">.</span><span class="nf">FindNode</span><span class="p">(</span><span class="n">propertyDeclarationSyntax</span><span class="p">.</span><span class="n">Span</span><span class="p">),</span>
                <span class="n">newNodes</span><span class="p">);</span>

        <span class="c1">// 将中间文档中的自动属性移除形成一份最终文档。</span>
        <span class="kt">var</span> <span class="n">newRoot</span> <span class="p">=</span> <span class="n">intermediateRoot</span>
            <span class="p">.</span><span class="nf">RemoveNode</span><span class="p">(</span><span class="n">intermediateRoot</span><span class="p">.</span><span class="nf">FindNode</span><span class="p">(</span><span class="n">propertyDeclarationSyntax</span><span class="p">.</span><span class="n">Span</span><span class="p">),</span> <span class="n">SyntaxRemoveOptions</span><span class="p">.</span><span class="n">KeepNoTrivia</span><span class="p">);</span>

        <span class="c1">// 将原来解决方案中的此份文档换成新文档以形成新的解决方案。</span>
        <span class="k">return</span> <span class="n">document</span><span class="p">.</span><span class="n">Project</span><span class="p">.</span><span class="n">Solution</span><span class="p">.</span><span class="nf">WithDocumentSyntaxRoot</span><span class="p">(</span><span class="n">document</span><span class="p">.</span><span class="n">Id</span><span class="p">,</span> <span class="n">newRoot</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">Solution</span><span class="p">&gt;</span> <span class="nf">ConvertToNotificationProperty</span><span class="p">(</span><span class="n">Document</span> <span class="n">document</span><span class="p">,</span>
        <span class="n">PropertyDeclarationSyntax</span> <span class="n">propertyDeclarationSyntax</span><span class="p">,</span> <span class="n">CancellationToken</span> <span class="n">cancellationToken</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// 这个类型暂时留空，因为这是真正的使用 Roslyn 生成语法节点的代码，虽然只会写一句话，但相当长。</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>还记得我们在前面解读 <code class="language-plaintext highlighter-rouge">WalterlvDemoAnalyzersCodeFixProvider</code> 类型时的那些描述吗？我们现在为一个诊断 <code class="language-plaintext highlighter-rouge">Diagnostic</code> 注册了一个代码修改（CodeFix），并且其回调函数是 <code class="language-plaintext highlighter-rouge">ConvertToNotificationProperty</code>。这是我们自己编写的一个方法。</p><p>我在这个方法里面写的代码并不复杂，是获取原来的属性里的类型信息和属性名，然后修改文档，将新的文档返回。</p><p>其中，我留了一个 <code class="language-plaintext highlighter-rouge">CreateNotificationProperty</code> 方法为空，因为这是真正的使用 Roslyn 生成语法节点的代码，虽然只会写一句话，但相当长。</p><p>于是我将这个方法单独写在了下面。将这两个部分拼起来（用下面方法替换上面同名的方法），你就能得到一个完整的 <code class="language-plaintext highlighter-rouge">WalterlvDemoAnalyzersCodeFixProvider</code> 类的代码了。</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
</pre><td class="rouge-code"><pre><span class="k">private</span> <span class="n">SyntaxNode</span><span class="p">[]</span> <span class="nf">CreateNotificationProperty</span><span class="p">(</span><span class="n">TypeSyntax</span> <span class="n">type</span><span class="p">,</span> <span class="kt">string</span> <span class="n">propertyName</span><span class="p">,</span> <span class="kt">string</span> <span class="n">fieldName</span><span class="p">)</span>
    <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">SyntaxNode</span><span class="p">[]</span>
    <span class="p">{</span>
        <span class="n">SyntaxFactory</span><span class="p">.</span><span class="nf">FieldDeclaration</span><span class="p">(</span>
            <span class="k">new</span> <span class="n">SyntaxList</span><span class="p">&lt;</span><span class="n">AttributeListSyntax</span><span class="p">&gt;(),</span>
            <span class="k">new</span> <span class="nf">SyntaxTokenList</span><span class="p">(</span><span class="n">SyntaxFactory</span><span class="p">.</span><span class="nf">Token</span><span class="p">(</span><span class="n">SyntaxKind</span><span class="p">.</span><span class="n">PrivateKeyword</span><span class="p">)),</span>
            <span class="n">SyntaxFactory</span><span class="p">.</span><span class="nf">VariableDeclaration</span><span class="p">(</span>
                <span class="n">type</span><span class="p">,</span>
                <span class="n">SyntaxFactory</span><span class="p">.</span><span class="nf">SeparatedList</span><span class="p">(</span><span class="k">new</span> <span class="p">[]</span>
                <span class="p">{</span>
                    <span class="n">SyntaxFactory</span><span class="p">.</span><span class="nf">VariableDeclarator</span><span class="p">(</span>
                        <span class="n">SyntaxFactory</span><span class="p">.</span><span class="nf">Identifier</span><span class="p">(</span><span class="n">fieldName</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="p">})</span>
            <span class="p">),</span>
            <span class="n">SyntaxFactory</span><span class="p">.</span><span class="nf">Token</span><span class="p">(</span><span class="n">SyntaxKind</span><span class="p">.</span><span class="n">SemicolonToken</span><span class="p">)</span>
        <span class="p">),</span>
        <span class="n">SyntaxFactory</span><span class="p">.</span><span class="nf">PropertyDeclaration</span><span class="p">(</span>
            <span class="n">type</span><span class="p">,</span>
            <span class="n">SyntaxFactory</span><span class="p">.</span><span class="nf">Identifier</span><span class="p">(</span><span class="n">propertyName</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="p">.</span><span class="nf">AddModifiers</span><span class="p">(</span><span class="n">SyntaxFactory</span><span class="p">.</span><span class="nf">Token</span><span class="p">(</span><span class="n">SyntaxKind</span><span class="p">.</span><span class="n">PublicKeyword</span><span class="p">))</span>
        <span class="p">.</span><span class="nf">AddAccessorListAccessors</span><span class="p">(</span>
            <span class="n">SyntaxFactory</span><span class="p">.</span><span class="nf">AccessorDeclaration</span><span class="p">(</span>
                <span class="n">SyntaxKind</span><span class="p">.</span><span class="n">GetAccessorDeclaration</span>
            <span class="p">)</span>
            <span class="p">.</span><span class="nf">WithExpressionBody</span><span class="p">(</span>
                <span class="n">SyntaxFactory</span><span class="p">.</span><span class="nf">ArrowExpressionClause</span><span class="p">(</span>
                    <span class="n">SyntaxFactory</span><span class="p">.</span><span class="nf">Token</span><span class="p">(</span><span class="n">SyntaxKind</span><span class="p">.</span><span class="n">EqualsGreaterThanToken</span><span class="p">),</span>
                    <span class="n">SyntaxFactory</span><span class="p">.</span><span class="nf">IdentifierName</span><span class="p">(</span><span class="n">fieldName</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="p">.</span><span class="nf">WithSemicolonToken</span><span class="p">(</span><span class="n">SyntaxFactory</span><span class="p">.</span><span class="nf">Token</span><span class="p">(</span><span class="n">SyntaxKind</span><span class="p">.</span><span class="n">SemicolonToken</span><span class="p">)),</span>
            <span class="n">SyntaxFactory</span><span class="p">.</span><span class="nf">AccessorDeclaration</span><span class="p">(</span>
                <span class="n">SyntaxKind</span><span class="p">.</span><span class="n">SetAccessorDeclaration</span>
            <span class="p">)</span>
            <span class="p">.</span><span class="nf">WithExpressionBody</span><span class="p">(</span>
                <span class="n">SyntaxFactory</span><span class="p">.</span><span class="nf">ArrowExpressionClause</span><span class="p">(</span>
                    <span class="n">SyntaxFactory</span><span class="p">.</span><span class="nf">Token</span><span class="p">(</span><span class="n">SyntaxKind</span><span class="p">.</span><span class="n">EqualsGreaterThanToken</span><span class="p">),</span>
                    <span class="n">SyntaxFactory</span><span class="p">.</span><span class="nf">InvocationExpression</span><span class="p">(</span>
                        <span class="n">SyntaxFactory</span><span class="p">.</span><span class="nf">IdentifierName</span><span class="p">(</span><span class="s">"SetValue"</span><span class="p">),</span>
                        <span class="n">SyntaxFactory</span><span class="p">.</span><span class="nf">ArgumentList</span><span class="p">(</span>
                            <span class="n">SyntaxFactory</span><span class="p">.</span><span class="nf">Token</span><span class="p">(</span><span class="n">SyntaxKind</span><span class="p">.</span><span class="n">OpenParenToken</span><span class="p">),</span>
                            <span class="n">SyntaxFactory</span><span class="p">.</span><span class="nf">SeparatedList</span><span class="p">(</span><span class="k">new</span> <span class="p">[]</span>
                            <span class="p">{</span>
                                <span class="n">SyntaxFactory</span><span class="p">.</span><span class="nf">Argument</span><span class="p">(</span>
                                    <span class="n">SyntaxFactory</span><span class="p">.</span><span class="nf">IdentifierName</span><span class="p">(</span><span class="n">fieldName</span><span class="p">)</span>
                                <span class="p">)</span>
                                <span class="p">.</span><span class="nf">WithRefKindKeyword</span><span class="p">(</span>
                                    <span class="n">SyntaxFactory</span><span class="p">.</span><span class="nf">Token</span><span class="p">(</span><span class="n">SyntaxKind</span><span class="p">.</span><span class="n">RefKeyword</span><span class="p">)</span>
                                <span class="p">),</span>
                                <span class="n">SyntaxFactory</span><span class="p">.</span><span class="nf">Argument</span><span class="p">(</span>
                                    <span class="n">SyntaxFactory</span><span class="p">.</span><span class="nf">IdentifierName</span><span class="p">(</span><span class="s">"value"</span><span class="p">)</span>
                                <span class="p">),</span>
                            <span class="p">}),</span>
                            <span class="n">SyntaxFactory</span><span class="p">.</span><span class="nf">Token</span><span class="p">(</span><span class="n">SyntaxKind</span><span class="p">.</span><span class="n">CloseParenToken</span><span class="p">)</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="p">.</span><span class="nf">WithSemicolonToken</span><span class="p">(</span><span class="n">SyntaxFactory</span><span class="p">.</span><span class="nf">Token</span><span class="p">(</span><span class="n">SyntaxKind</span><span class="p">.</span><span class="n">SemicolonToken</span><span class="p">))</span>
        <span class="p">),</span>
    <span class="p">};</span>
</pre></table></code></div></div><p>以上这段代码写起来非常不直观，如果你也觉得麻烦，可以使用<a href="https://blog.csdn.net/jevonsflash/article/details/124798973">使用 林晓lx 的 RoslynSyntaxTool 工具互相转换 C# 代码与语法树代码</a>。</p><p>实际上本文并不会重点介绍如何使用 Roslyn 生成新的语法节点，因此我不会解释上面我是如何写出这样的语法节点来的，但如果你对照着语法可视化窗格（Syntax Visualizer）来看的话，也是不难理解为什么我会这么写的。</p><p>在此类型完善之后，我们再 F5 启动调试，可以发现我们已经可以完成一个自动属性的修改了，可以按照预期改成一个可通知属性。</p><p>你可以再看看下面的动图：</p><p><img data-proofer-ignore data-src="/static/posts/2019-07-06-preview-of-roslyn-code-fix.gif" alt="可以修改属性" /></p><h3 id="发布">发布<a href="#发布"><i class="fas fa-hashtag"></i></a></h3></h3><h3 id="发布成-nuget-包">发布成 NuGet 包<a href="#发布成-nuget-包"><i class="fas fa-hashtag"></i></a></h3></h3><p>前往我们分析器主项目 Walterlv.Demo.Analyzers 项目的输出目录，因为本文没有改输出路径，所以在项目的 <code class="language-plaintext highlighter-rouge">bin\Debug</code> 文件夹下。我们可以找到每次编译产生的 NuGet 包。</p><p><img data-proofer-ignore data-src="/static/posts/2019-07-06-09-08-43.png" alt="已经打出来的 NuGet 包" /></p><p>如果你不知道如何将此 NuGet 包发布到 <a href="https://www.nuget.org/">nuget.org</a>，请在文本中回复，也许我需要再写一篇博客讲解如何推送。</p><h3 id="发布到-visual-studio-插件商店">发布到 Visual Studio 插件商店<a href="#发布到-visual-studio-插件商店"><i class="fas fa-hashtag"></i></a></h3></h3><p>前往我们分析器的 Visual Studio 插件项目 Walterlv.Demo.Analyzers.Vsix 项目的输出目录，因为本文没有改输出路径，所以在项目的 <code class="language-plaintext highlighter-rouge">bin\Debug</code> 文件夹下。我们可以找到每次编译产生的 Visual Studio 插件安装包。</p><p><img data-proofer-ignore data-src="/static/posts/2019-07-06-09-10-26.png" alt="已经打出来的 Visual Studio 插件" /></p><p>如果你不知道如何将此 Visual Studio 插件发布到 <a href="https://marketplace.visualstudio.com/">Visual Studio Marketplace</a>，请在文本中回复，也许我需要再写一篇博客讲解如何推送。</p><h2 id="一些补充">一些补充<a href="#一些补充"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="辅助源代码">辅助源代码<a href="#辅助源代码"><i class="fas fa-hashtag"></i></a></h3></h3><p>前面我们提到了 <code class="language-plaintext highlighter-rouge">SetValue</code> 这个方法，这是为了写一个可通知对象。为了拥有这个方法，请在我们的测试项目中添加下面这两个文件：</p><p>一个可通知类文件 NotificationObject.cs：</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="k">using</span> <span class="nn">System.ComponentModel</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Runtime.CompilerServices</span><span class="p">;</span>

<span class="k">namespace</span> <span class="nn">Walterlv.TestForAnalyzer</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">class</span> <span class="nc">NotificationObject</span> <span class="p">:</span> <span class="n">INotifyPropertyChanged</span>
    <span class="p">{</span>
        <span class="k">protected</span> <span class="kt">bool</span> <span class="n">SetValue</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="k">ref</span> <span class="n">T</span> <span class="n">field</span><span class="p">,</span> <span class="n">T</span> <span class="k">value</span><span class="p">,</span> <span class="p">[</span><span class="n">CallerMemberName</span><span class="p">]</span> <span class="kt">string</span> <span class="n">propertyName</span> <span class="p">=</span> <span class="k">null</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nf">Equals</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="k">value</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="k">false</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">field</span> <span class="p">=</span> <span class="k">value</span><span class="p">;</span>
            <span class="n">PropertyChanged</span><span class="p">?.</span><span class="nf">Invoke</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="k">new</span> <span class="nf">PropertyChangedEventArgs</span><span class="p">(</span><span class="n">propertyName</span><span class="p">));</span>
            <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="k">event</span> <span class="n">PropertyChangedEventHandler</span> <span class="n">PropertyChanged</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>一个用于分析器测试的类 Demo.cs：</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">namespace</span> <span class="nn">Walterlv.TestForAnalyzer</span>
<span class="p">{</span>
    <span class="k">class</span> <span class="nc">Demo</span> <span class="p">:</span> <span class="n">NotificationObject</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="kt">string</span> <span class="n">Foo</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="示例代码仓库">示例代码仓库<a href="#示例代码仓库"><i class="fas fa-hashtag"></i></a></h3></h3><p>代码仓库在我的 Demo 项目中，注意协议是 <a href="https://github.com/996icu/996.ICU/blob/master/LICENSE">996.ICU</a> 哟！</p><ul><li><a href="https://github.com/walterlv/walterlv.demo/tree/master/Walterlv.Demo.Analyzers">walterlv.demo/Walterlv.Demo.Analyzers at master · walterlv/walterlv.demo</a></ul><h3 id="别忘了单元测试">别忘了单元测试<a href="#别忘了单元测试"><i class="fas fa-hashtag"></i></a></h3></h3><p>别忘了我们一开始创建仓库的时候有一个单元测试项目，而我们全文都没有讨论如何充分利用其中的单元测试。我将在其他的博客中说明如何编写和使用分析器项目的单元测试。</p><hr /><p><strong>参考资料</strong></p><ul><li><a href="https://www.meziantou.net/writing-a-roslyn-analyzer.htm">Writing a Roslyn analyzer - Meziantou’s blog</a><li><a href="https://dogschasingsquirrels.com/2014/08/04/code-generation-with-roslyn-fields-and-properties/">Code Generation with Roslyn – Fields and Properties - Dogs Chasing Squirrels</a></ul><p> 本文会经常更新，请阅读原文： <a href="/post/develop-a-code-analyzer-for-both-nuget-and-visual-studio-extension.html">https://blog.walterlv.com/post/develop-a-code-analyzer-for-both-nuget-and-visual-studio-extension.html</a> ，以避免陈旧错误知识的误导，同时有更好的阅读体验。</p><p> <a rel="知识共享许可协议" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"> <img alt="知识共享许可协议" src="https://blog.walterlv.com/assets/img/by-nc-sa.svg" /> </a></p><p> 本作品采用 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a> 进行许可。欢迎转载、使用、重新发布，但务必保留文章署名 吕毅 （包含链接： <a href="https://blog.walterlv.com">https://blog.walterlv.com</a> ），不得用于商业目的，基于本文修改后的作品务必以相同的许可发布。如有任何疑问，请 <a href="mailto:walter.lv@qq.com">与我联系 (walter.lv@qq.com)</a> 。</p></div><div class="post-tail-wrapper text-muted"><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="comments-wrapper"> 登录 GitHub 账号进行评论</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=基于 Roslyn 同时为 Visual Studio 插件和 NuGet 包开发 .NET/C# 源代码分析器 Analyzer 和修改器 CodeFixProvider - walterlv&url=https://blog.walterlv.com/post/develop-a-code-analyzer-for-both-nuget-and-visual-studio-extension.html" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=基于 Roslyn 同时为 Visual Studio 插件和 NuGet 包开发 .NET/C# 源代码分析器 Analyzer 和修改器 CodeFixProvider - walterlv&u=https://blog.walterlv.com/post/develop-a-code-analyzer-for-both-nuget-and-visual-studio-extension.html" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=基于 Roslyn 同时为 Visual Studio 插件和 NuGet 包开发 .NET/C# 源代码分析器 Analyzer 和修改器 CodeFixProvider - walterlv&url=https://blog.walterlv.com/post/develop-a-code-analyzer-for-both-nuget-and-visual-studio-extension.html" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">最近更新</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/post/monitor-foreground-window-on-windows">如何在控制台程序中监听 Windows 前台窗口的变化</a><li><a href="/post/how-to-start-a-process-with-environment-variables-without-code">在 Windows 上如何在启动程序时单独为这个程序指定环境变量，而不需要编写任何代码或脚本</a><li><a href="/post/wpf-draw-a-hsl-hsb-palette-using-hlsl">WPF 像素着色器进阶：使用 HLSL 编写一个高性能的实时变化的 HSL/HSV/HSB 调色盘</a><li><a href="/post/create-wpf-pixel-shader-effects-using-shazzam-shader-editor.html">WPF 像素着色器入门：使用 Shazzam Shader Editor 编写 HLSL 像素着色器代码</a><li><a href="/post/where-is-the-windows-10-native-icons.html">Windows 10 自带那么多图标，去哪里找呢？</a></ul></div><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/dotnet/">dotnet</a> <a class="post-tag" href="/tags/csharp/">csharp</a> <a class="post-tag" href="/tags/windows/">windows</a> <a class="post-tag" href="/tags/wpf/">wpf</a> <a class="post-tag" href="/tags/visualstudio/">visualstudio</a> <a class="post-tag" href="/tags/msbuild/">msbuild</a> <a class="post-tag" href="/tags/uwp/">uwp</a> <a class="post-tag" href="/tags/nuget/">nuget</a> <a class="post-tag" href="/tags/git/">git</a> <a class="post-tag" href="/tags/roslyn/">roslyn</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><section class="comments"> <script src="https://utteranc.es/client.js" repo="walterlv/BlogComments" issue-term="pathname" theme="preferred-color-scheme" crossorigin="anonymous" async> </script></section></div></div></div><footer class="d-flex flex-column w-100 justify-content-center"><div id="analytics-box"> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-108101550-1"></script> <script> document.addEventListener("DOMContentLoaded", function (event) { window.dataLayer = window.dataLayer || []; function gtag() { dataLayer.push(arguments); } gtag('js', new Date()); gtag('config', 'UA-108101550-1'); }); </script> <script async type="text/javascript">document.write(unescape("%3Cspan id='cnzz_stat_icon_1264408226'%3E%3C/span%3E%3Cscript src='//s22.cnzz.com/z_stat.php%3Fid%3D1264408226%26online%3D1%26show%3Dline' type='text/javascript'%3E%3C/script%3E"));</script></div><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2014-2024 <a href="https://github.com/walterlv">walterlv</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由吕毅按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0"> 本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，基于 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题修改。</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/dotnet/">dotnet</a> <a class="post-tag" href="/tags/csharp/">csharp</a> <a class="post-tag" href="/tags/windows/">windows</a> <a class="post-tag" href="/tags/wpf/">wpf</a> <a class="post-tag" href="/tags/visualstudio/">visualstudio</a> <a class="post-tag" href="/tags/msbuild/">msbuild</a> <a class="post-tag" href="/tags/uwp/">uwp</a> <a class="post-tag" href="/tags/nuget/">nuget</a> <a class="post-tag" href="/tags/git/">git</a> <a class="post-tag" href="/tags/roslyn/">roslyn</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script>
