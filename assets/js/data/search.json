[ { "title": "如何在控制台程序中监听 Windows 前台窗口的变化", "url": "/post/monitor-foreground-window-on-windows", "categories": "dotnet, csharp, windows", "tags": "", "date": "2023-08-03 11:50:23 +0800", "snippet": "前一段时间总会时不时发现当前正在打字的窗口突然失去了焦点，于是很希望有个工具能实时监听前台窗口的变化，并实时输出出来。本文会介绍两类知识，一类是如何在 .NET/C# 程序中方便地调用 Win32 API，另一类是在控制台程序中开启 Windows 消息循环。思路获取当前前台窗口的本质 API 调用是 GetForegroundWindow。在拿到前台窗口的句柄后，进而获取到例如窗口标题、类名等信息。var hWnd = GetForegroundWindow();// 随后获取窗口标题、类名等……接下来，就是什么时机去调用这个 API 了。虽然我第一时间想到了延时轮询的方式，并且好久以前也确实是这么写的。但其实有更好的方法来解决这个问题，而且 Lsj 的 Window Debugger 也正计划实现这个功能，对此也有更多的了解。是的，我们有 SetWinEventHook 这个 Win32 API，如果参数传入 EVENT_SYSTEM_FOREGROUND 就可以实现监听前台窗口的变化。实施基本框架代码于是，我们控制台程序中最关键的框架代码如下：// 监听系统的前台窗口变化。SetWinEventHook( EVENT_SYSTEM_FOREGROUND, EVENT_SYSTEM_FOREGROUND, HMODULE.Null, WinEventProc, 0, 0, WINEVENT_OUTOFCONTEXT | WINEVENT_SKIPOWNPROCESS);// 开启消息循环，以便 WinEventProc 能够被调用。if (GetMessage(out var lpMsg, default, default, default)){ TranslateMessage(in lpMsg); DispatchMessage(in lpMsg);}// 当前前台窗口变化时，输出新的前台窗口信息。void WinEventProc(HWINEVENTHOOK hWinEventHook, uint @event, HWND hwnd, int idObject, int idChild, uint idEventThread, uint dwmsEventTime){ var current = GetForegroundWindow(); // 随后获取窗口标题、类名等……}解释： 调用 SetWinEventHook 时，前两个参数都传入 EVENT_SYSTEM_FOREGROUND 第一个参数是最小事件值，第二个参数是最大事件值，这里我们只监听前台窗口变化，所以两个参数都传入 EVENT_SYSTEM_FOREGROUND 由于我们是控制台程序，没有窗口，所以第三个参数传入 HMODULE.Null，第 5、6 个参数传入 0 最后一个参数，我们传入了 WINEVENT_OUTOFCONTEXT | WINEVENT_SKIPOWNPROCESS WINEVENT_OUTOFCONTEXT 表示事件函数将在其他进程的上下文中执行，这意味着该事件钩子函数可以捕获其他进程中发生的事件 WINEVENT_SKIPOWNPROCESS 表示忽略进程自身发生的事件（当然，我们是控制台程序，没有窗口，所以这个传不传没有区别） 随后，我们开启了消息循环，以便 WinEventProc 能够被调用 GetMessage 会阻塞当前线程，直到有消息到达 DispatchMessage 会将消息传递给 WinEventProc，这样 WinEventProc 才会被调用 P/Invoke这里，我使用的是 microsoft/CsWin32，因为我只会用到少数几个 Win32 函数，不希望引入庞大的 P/Invoke 相关的库。首先安装 Microsoft.Windows.CsWin32 NuGet 包：&amp;lt;ItemGroup&amp;gt; &amp;lt;PackageReference Include=&quot;Microsoft.Windows.CsWin32&quot; Version=&quot;0.3.18-beta&quot; PrivateAssets=&quot;all&quot; /&amp;gt;&amp;lt;/ItemGroup&amp;gt;随后，在项目中添加文件 NativeMethods.txt，内容如下。这些是我们刚刚已经用的以及即将使用的 Win32 函数和常量。DispatchMessageGetClassNameGetForegroundWindowGetMessageGetProcessImageFileNameGetWindowTextGetWindowThreadProcessIdSetWinEventHookTranslateMessageEVENT_SYSTEM_FOREGROUNDWINEVENT_OUTOFCONTEXTWINEVENT_SKIPOWNPROCESS随后，在 Program.cs 的开头添加几个 using：using Windows.Win32.Foundation;using Windows.Win32.UI.Accessibility;using static Windows.Win32.PInvoke;这样，前面我们的框架代码便能正常编译和使用了。获取窗口的各种信息为了让 Program.cs 中的代码更简洁一些，我们创建一个 Win32Window 类，用来辅助我们获取特定窗口的各种信息。using System.Buffers;using System.Diagnostics;using Windows.Win32.Foundation;using static Windows.Win32.PInvoke;namespace Walterlv.ForegroundWindowMonitor;public class Win32Window{ private readonly HWND _hWnd; private string? _className; private string? _title; private string? _processName; private uint _pid; internal Win32Window(nint handle) { _hWnd = (HWND)handle; } public nint Handle =&amp;gt; _hWnd; public string ClassName =&amp;gt; _className ??= CallWin32ToGetPWSTR(512, (p, l) =&amp;gt; GetClassName(_hWnd, p, l)); public string Title =&amp;gt; _title ??= CallWin32ToGetPWSTR(512, (p, l) =&amp;gt; GetWindowText(_hWnd, p, l)); public uint ProcessId =&amp;gt; _pid is 0 ? (_pid = GetProcessIdCore()) : _pid; public string ProcessName =&amp;gt; _processName ??= Process.GetProcessById((int)ProcessId).ProcessName; private unsafe uint GetProcessIdCore() { uint pid = 0; GetWindowThreadProcessId(_hWnd, &amp;amp;pid); return pid; } private unsafe string CallWin32ToGetPWSTR(int bufferLength, Func&amp;lt;PWSTR, int, int&amp;gt; getter) { var buffer = ArrayPool&amp;lt;char&amp;gt;.Shared.Rent(bufferLength); try { fixed (char* ptr = buffer) { getter(ptr, bufferLength); return new string(ptr); } } finally { ArrayPool&amp;lt;char&amp;gt;.Shared.Return(buffer); } }}于是，回到 Program.cs 中的 WinEventProc 方法内部，我们就可以输出窗口的各种信息了：void WinEventProc(HWINEVENTHOOK hWinEventHook, uint @event, HWND hwnd, int idObject, int idChild, uint idEventThread, uint dwmsEventTime){ var current = GetForegroundWindow(); var w = new Win32Window(current); // 你也可以获得更多你想获得的信息，这里我只是举例输出了几个而已。 var rowText = $&quot;[{w.Handle}] {w.Title} - {w.ProcessName}&quot;; Console.WriteLine(rowText);}完整代码Program.cs 的完整代码如下：using Windows.Win32.Foundation;using Windows.Win32.UI.Accessibility;using static Windows.Win32.PInvoke;// 监听系统的前台窗口变化。SetWinEventHook( EVENT_SYSTEM_FOREGROUND, EVENT_SYSTEM_FOREGROUND, HMODULE.Null, WinEventProc, 0, 0, WINEVENT_OUTOFCONTEXT | WINEVENT_SKIPOWNPROCESS);// 开启消息循环，以便 WinEventProc 能够被调用。if (GetMessage(out var lpMsg, default, default, default)){ TranslateMessage(in lpMsg); DispatchMessage(in lpMsg);}// 当前前台窗口变化时，输出新的前台窗口信息。void WinEventProc(HWINEVENTHOOK hWinEventHook, uint @event, HWND hwnd, int idObject, int idChild, uint idEventThread, uint dwmsEventTime){ var current = GetForegroundWindow(); var w = new Win32Window(current); // 你也可以获得更多你想获得的信息，这里我只是举例输出了几个而已。 var rowText = $&quot;[{w.Handle}] {w.Title} - {w.ProcessName}&quot;; Console.WriteLine(rowText);}如果更多地优化一下输出的格式，那么就可以得到下面的效果：关于如何在控制台中输出表格（并实现中英文字符对齐显示），可以阅读我的另一篇博客。 .NET/C# 程序如何在控制台/终端中以字符表格的形式输出数据 - walterlv开源项目本文的代码已经开源在 GitHub 上，感兴趣可以去项目中阅读更新的代码： https://github.com/walterlv/Walterlv.ForegroundWindowMonitor参考资料 dotnet 使用 CsWin32 库简化 Win32 函数调用逻辑 GetForegroundWindow function (winuser.h) - Win32 apps - Microsoft Learn microsoft/CsWin32: A source generator to add a user-defined set of Win32 P/Invoke methods and supporting types to a C# project." }, { "title": ".NET/C# 程序如何在控制台/终端中以字符表格的形式输出数据", "url": "/post/format-data-as-a-table-in-console", "categories": "dotnet, csharp", "tags": "", "date": "2023-08-03 11:49:03 +0800", "snippet": "在一篇在控制台窗口中监听前台窗口的博客中，我在控制台里以表格的形式输出了每一个前台窗口的信息。在控制台里编写一个字符表格其实并不难，毕竟 ASCII 中就已经提供了制表符。不过要在合适的位置输出合适的制表符，要写一些打杂式的代码了；另外，如果还要考虑表格列的宽度自适应，再考虑中英文在控制台中的对齐，还要考虑文字超出单元格时是裁剪/省略/换行。当把所有这些麻烦加到一起之后，写一个这样的辅助类来顶替那些麻烦事儿还是很有必要的。效果预览以下是我在前台窗口监视程序中的运行效果：代码组织我写了三个类来完成这样的事情： ConsoleTableBuilder&amp;lt;T&amp;gt; 用于构建表格 ConsoleTableColumnDefinition&amp;lt;T&amp;gt; 用于定义表格的列 ConsoleStringExtensions 由于在控制台中做中英文对齐不能使用 string 原有的与长度相关的方法，所以我们需要一个静态类来扩展 string 对控制台的特殊处理详细的代码，可以在我的 GitHub 仓库中找到： https://github.com/walterlv/Walterlv.Packages/tree/master/src/Utils/Walterlv.Console其中，ConsoleStringExtensions 类的设计，我参考了 D 的个人博客，不过原文的一部分关键实现其实是不正确的，有一些本不必要的循环浪费性能，还有不能直观看出含义的缩写命名，所以这个类的实际代码是我完全重写之后，请 GPT-4 帮我润色，以及请 GitHub Copilot 帮我写完注释之后的版本。开源这个类库我已经开源到我的 GitHub 仓库中，并可直接以 NuGet 形式引用。项目地址： https://github.com/walterlv/Walterlv.Packages/tree/master/src/Utils/Walterlv.ConsoleNuGet 包： https://www.nuget.org/packages/Walterlv.Console用法如下，我们获取控制台的字符宽度，然后 -1 后作为表格的宽度，随后定义每一列，这就完成了表格的初始化：var consoleWidth = Console.WindowWidth;var table = new ConsoleTableBuilder&amp;lt;Win32Window&amp;gt;(consoleWidth - 1, new ConsoleTableColumnDefinition&amp;lt;Win32Window&amp;gt;[]{ (8, &quot;time&quot;, _ =&amp;gt; $&quot;{DateTime.Now:hh:mm:ss}&quot;), (8, &quot;hwnd&quot;, w =&amp;gt; $&quot;{w.Handle:X8}&quot;), (0.5, &quot;title&quot;, w =&amp;gt; w.Title), (0.25, &quot;class name&quot;, w =&amp;gt; w.ClassName), (6, &quot;pid&quot;, w =&amp;gt; $&quot;{w.ProcessId}&quot;), (0.25, &quot;process name&quot;, w =&amp;gt; $&quot;{w.ProcessName}&quot;),});Console.WriteLine(table.BuildHeaderRows()); 需要 -1 是因为大多数情况下，输出的行都刚好能在控制台中排得下，但有小部分控制台会在输出完后额外换一行，于是会看到每输出一行都有一个空白行出现（虽然我现在仍不知道原因） 定义列时，每个参数都是一个 ConsoleTableColumnDefinition&amp;lt;Win32Window&amp;gt; 的实例，为了方便，我允许隐式从元组转换 整数列宽的元组，定义的是这一列可用的字符数 小数列的元组，是将整数列宽和表格划线用的字符除外后，剩余总列宽的百分比 元组的第二项是表头中的列名 元组的第三项是这一列的值的获取和格式化方法 接下来，在每一次有新数据需要输出时，都可以通过 BuildRow 方法，传入数据实例和字符串换行方法，得到一行的字符串。// 当前前台窗口变化时，输出新的前台窗口信息。void WinEventProc(HWINEVENTHOOK hWinEventHook, uint @event, HWND hwnd, int idObject, int idChild, uint idEventThread, uint dwmsEventTime){ var current = GetForegroundWindow(); var w = new Win32Window(current); var rowText = table.BuildRow(w, StringDisplayMode.Wrap); Console.WriteLine(rowText);} StringDisplayMode 是一个枚举，指定当字符串超过指定长度时，应如何处理此字符串： Truncate 截断字符串 TruncateWithEllipsis 截断字符串，并在末尾添加省略号 Wrap 将字符串换行 注意，当选择 Wrap 换行时，通过 BuildRow 方法得到的字符串其实是多行的（可以看本文开头的效果图了解）。关于表格输出类的完整使用示例，可参考我监听前台窗口的博客，或直接查看我的 GitHub 仓库中的示例代码。 如何在控制台程序中监听 Windows 前台窗口的变化 - walterlv Walterlv.Packages/src/Utils/Walterlv.Console参考资料 D 的个人博客" }, { "title": "在 Windows 上如何在启动程序时单独为这个程序指定环境变量，而不需要编写任何代码或脚本", "url": "/post/how-to-start-a-process-with-environment-variables-without-code", "categories": "windows", "tags": "", "date": "2023-08-01 16:50:35 +0800", "snippet": "有些程序没有内置提供代理的功能，但遵循环境变量中设置的代理。如果我们能有办法仅为这个特定的程序设置环境变量，那么我们就可以在不开启全局代理的情况下单独为这样的程序开启代理。设置环境变量开启代理比如，Unity Hub 就是这样的一个程序。为了让它开启代理，我们可以在命令行中用这样的三句命令启动它：&amp;gt; cd &quot;C:\\Program Files\\Unity Hub&quot;&amp;gt; set HTTP_PROXY=http://127.0.0.1:7778&amp;gt; set HTTPS_PROXY=http://127.0.0.1:7778&amp;gt; &quot;Unity Hub.exe&quot;单独为程序设置环境变量的方法如果，我们能用一句话就完成上面的三句命令，那么就可以直接在快捷方式中设置这个程序的代理了，不需要单独写一个脚本。在这个问答中 Launch Windows program with custom environment variable - Super User，我获得了启发，用 CMD 代理启动。不过原回答中只设置了一条环境变量，我们需要稍作修改以设置两条环境变量。一句命令C:\\Windows\\System32\\cmd.exe /c &quot;set HTTP_PROXY=http://127.0.0.1:7778 &amp;amp;&amp;amp; set HTTPS_PROXY=http://127.0.0.1:7778 &amp;amp;&amp;amp; start &quot;Unity Hub Launcher&quot; &quot;C:\\Program Files\\Unity Hub\\Unity Hub.exe&quot;&quot; 这里的外层引号 &quot; 是为了让整个后面的字符串不会被空格分隔 这里的内层引号则是为了让 cmd 代理执行的命令部分的每个参数不会被空格分隔 在 cmd 中，&amp;amp;&amp;amp; 用来连接两个命令快捷方式如果平时是通过快捷方式来启动程序的，那么只需要编辑此快捷方式的属性，将目标改为上面的命令即可。这样，整个程序的使用体验基本跟平时没有什么区别，但已经成功为它设置了代理。参考资料 Launch Windows program with custom environment variable - Super User" }, { "title": "如何正确调教 Visual Studio 自带的拼写检查功能", "url": "/post/visual-studio-spell-checker-issue", "categories": "visualstudio", "tags": "", "date": "2023-07-19 16:11:24 +0800", "snippet": "Visual Studio 2022 (17.6 Preview 2) 带来了拼写检查功能，此功能一出大家纷纷吐槽各种问题。不过团队中确实时不时会出现单词拼写错误的情况，所以有时又觉得非常需要它。如果你打算在 Visual Studio 中好好使用这个自带的功能，那么可以阅读本文。对它有更多的了解之后，也许可以逐渐趋利避害。开启拼写检查功能目前，拼写检查器功能仍然是预览功能，所以需要在 Visual Studio 的“工具”-&amp;gt;“选项”菜单中找到“环境”-&amp;gt;“预览功能”选项卡，然后找到“拼写检查器”功能，把它打开。拼写检查和忽略单词开启了 Visual Studio 拼写检查器功能后，如果再在代码中写出了错误的单词，则会视时给出下划线提醒。不过注意，这个提醒只是 IDE 的提醒，不会出现在项目编译过程的警告或信息中。下图是对 embedding 单词的错误拼写进行了纠正。Visual Studio 的拼写检查器是基于字典的，这意味着必然存在一些专有/私有词汇会被误认为不正确。例如，我的名字“walterlv”。这时，我们应该忽略这个拼写。在单词旁边的小灯泡上点击（使用重构快捷键可打开），然后选择“拼写：忽略”walterlv””即可忽略这个单词的拼写。调教拼写检查器全局忽略文件Visual Studio 拼写检查器忽略功能的优点是，这个忽略是全局生效的，对所有已经打开的项目和未来打开的项目都生效；而缺点也同样是这个。（我其实比较期待有个全局忽略列表的前提下，可以在项目内增加一个项目特定的忽略列表。）这个全局的忽略列表存在这个地方：%LocalAppData%\\Microsoft\\VisualStudio\\17.0_14b1edd8\\exclusion.dic如果你打开这个文件会发现很奇怪，每个单词的前面都有一个不可识别的字符。在 Visual Studio 和 Visual Studio Code 中打开这个文件可以发现这一点。具体这个字符是什么，我们可以使用十六进制查看工具查看：可以注意到这个文件的： 每个单词前都有一段 EF BB BF，而这个是 UTF-8 的 BOM 头 每个单词后都有一个 0D 0A，而这个是 Windows 的换行符，对应 \\r\\n 文件的开头有两个 UTF-8 BOM 头这几乎可以肯定是 Visual Studio 拼写检查器的 bug！！！在这个功能刚发布的时候，忽略单词并不会生效，可能与这个 bug 有关，不过好在后面即使有不符合预期的 BOM 头出现，也不会导致忽略单词不生效。如果你是一个强迫症，那么可以把这个词典文件删除，新的 Visual Studio 生成的忽略文件已经不会再有 UTF-8 BOM 头了（包括文件开头的 BOM 头）。如果这个文件一直保留，那么新的 Visual Studio 写新的忽略单词也会包含这个 BOM 头。如果你不想删除，那么可以使用 Visual Studio Code 编辑手动去掉这些 BOM 头之后，保存为无 BOM 的 UTF-8 文件即可。参考资料 Improving the Spell Checker - Visual Studio Blog Learn about the Spell Checker - Visual Studio (Windows) - Microsoft Learn" }, { "title": "WPF 像素着色器进阶：使用 HLSL 编写一个高性能的实时变化的 HSL/HSV/HSB 调色盘", "url": "/post/wpf-draw-a-hsl-hsb-palette-using-hlsl", "categories": "wpf, dotnet, windows", "tags": "", "date": "2023-05-25 16:33:06 +0800", "snippet": "要在代码里画一个 HSL/HSV/HSB 调色盘非常容易，不过如果这个调色盘需要实时变化，那么频繁绘制需要在 CPU 上大量创建或者修改位图，性能不太好。本文将使用 HLSL 来完成这一任务。HLSL 入门如果你对 WPF 使用像素着色器还不太了解，那么可以阅读入门文章： WPF 像素着色器入门：使用 Shazzam Shader Editor 编写 HLSL 像素着色器代码HSL/HSV/HSB为了让后面的代码容易看懂，我们需要先简单了解一下 HSL/HSV/HSB。 HSL：hue 色相, saturation 饱和度, lightness 亮度 HSV/HSB：hue 色相, saturation 饱和度, value/brighness 明度这是两个不同但类似的，符合人眼感知的颜色表示方法，其中后两者只是名称不同，实际上是完全相同的意思。关于 HSL 和 HSV/HSB 的更多资料，可以参考 HSL and HSV - Wikipedia▲ HSL▲ HSVHSL 和 HSV/HSB 的 HLSL 代码版本一：初步实现由于 HSL 和 HSV/HSB 到 RGB 的转换是非常广泛被使用的，所以网上的代码非常丰富，我们只需要让 GPT-4 帮我们生成一个就可以了：这是 HSL 调色盘的代码：sampler2D input : register(s0);/// &amp;lt;summary&amp;gt;Background Color outside of the Circle&amp;lt;/summary&amp;gt;/// &amp;lt;type&amp;gt;Color&amp;lt;/type&amp;gt;/// &amp;lt;minValue&amp;gt;0,0,0,1&amp;lt;/minValue&amp;gt;/// &amp;lt;maxValue&amp;gt;1,1,1,1&amp;lt;/maxValue&amp;gt;/// &amp;lt;defaultValue&amp;gt;1,1,1,1&amp;lt;/defaultValue&amp;gt;float4 BackColor : register(C0);/// &amp;lt;summary&amp;gt;Hue Initial Angle&amp;lt;/summary&amp;gt;/// &amp;lt;minValue&amp;gt;0&amp;lt;/minValue&amp;gt;/// &amp;lt;maxValue&amp;gt;360&amp;lt;/maxValue&amp;gt;/// &amp;lt;defaultValue&amp;gt;0&amp;lt;/defaultValue&amp;gt;float HueInitialAngle : register(C1);/// &amp;lt;summary&amp;gt;Lightness&amp;lt;/summary&amp;gt;/// &amp;lt;minValue&amp;gt;0&amp;lt;/minValue&amp;gt;/// &amp;lt;maxValue&amp;gt;1&amp;lt;/maxValue&amp;gt;/// &amp;lt;defaultValue&amp;gt;0.5&amp;lt;/defaultValue&amp;gt;float Lightness : register(C2);float3 HSLtoRGB(float H, float S, float L){ float C = (1.0f - abs(2.0f * L - 1.0f)) * S; float X = C * (1.0f - abs(fmod(H / 60.0f, 2.0f) - 1.0f)); float m = L - C / 2.0f; float3 RGB; if (0 &amp;lt;= H &amp;amp;&amp;amp; H &amp;lt; 60) RGB = float3(C, X, 0); else if (60 &amp;lt;= H &amp;amp;&amp;amp; H &amp;lt; 120) RGB = float3(X, C, 0); else if (120 &amp;lt;= H &amp;amp;&amp;amp; H &amp;lt; 180) RGB = float3(0, C, X); else if (180 &amp;lt;= H &amp;amp;&amp;amp; H &amp;lt; 240) RGB = float3(0, X, C); else if (240 &amp;lt;= H &amp;amp;&amp;amp; H &amp;lt; 300) RGB = float3(X, 0, C); else RGB = float3(C, 0, X); return RGB + m;}float4 main(float2 uv : TEXCOORD) : COLOR{ float2 pos = uv * 2.0f - 1.0f; float dist = length(pos); if(dist &amp;gt; 1.0f) return BackColor; float h = atan2(pos.y, pos.x) * (180.0f / 3.1415926f) + HueInitialAngle; if(h &amp;lt; 0) h += 360; else if(h &amp;gt; 360) h -= 360; float s = dist; float l = Lightness; float3 color = HSLtoRGB(h, s, l); return float4(color, 1.0f);}这是 HSB 调色盘的代码：﻿sampler2D input : register(s0);/// &amp;lt;summary&amp;gt;Background Color outside of the Circle&amp;lt;/summary&amp;gt;/// &amp;lt;type&amp;gt;Color&amp;lt;/type&amp;gt;/// &amp;lt;minValue&amp;gt;0,0,0,1&amp;lt;/minValue&amp;gt;/// &amp;lt;maxValue&amp;gt;1,1,1,1&amp;lt;/maxValue&amp;gt;/// &amp;lt;defaultValue&amp;gt;1,1,1,1&amp;lt;/defaultValue&amp;gt;float4 BackColor : register(C0);/// &amp;lt;summary&amp;gt;Hue Initial Angle&amp;lt;/summary&amp;gt;/// &amp;lt;minValue&amp;gt;0&amp;lt;/minValue&amp;gt;/// &amp;lt;maxValue&amp;gt;360&amp;lt;/maxValue&amp;gt;/// &amp;lt;defaultValue&amp;gt;0&amp;lt;/defaultValue&amp;gt;float HueInitialAngle : register(C1);/// &amp;lt;summary&amp;gt;Brightness&amp;lt;/summary&amp;gt;/// &amp;lt;minValue&amp;gt;0&amp;lt;/minValue&amp;gt;/// &amp;lt;maxValue&amp;gt;1&amp;lt;/maxValue&amp;gt;/// &amp;lt;defaultValue&amp;gt;1&amp;lt;/defaultValue&amp;gt;float Brightness : register(C2);float3 HSBtoRGB(float H, float S, float B){ float C = B * S; float X = C * (1.0f - abs(fmod(H / 60.0f, 2.0f) - 1.0f)); float m = B - C; float3 RGB; if (0 &amp;lt;= H &amp;amp;&amp;amp; H &amp;lt; 60) RGB = float3(C, X, 0); else if (60 &amp;lt;= H &amp;amp;&amp;amp; H &amp;lt; 120) RGB = float3(X, C, 0); else if (120 &amp;lt;= H &amp;amp;&amp;amp; H &amp;lt; 180) RGB = float3(0, C, X); else if (180 &amp;lt;= H &amp;amp;&amp;amp; H &amp;lt; 240) RGB = float3(0, X, C); else if (240 &amp;lt;= H &amp;amp;&amp;amp; H &amp;lt; 300) RGB = float3(X, 0, C); else RGB = float3(C, 0, X); return RGB + m;}float4 main(float2 uv : TEXCOORD) : COLOR{ float2 pos = uv * 2.0f - 1.0f; float dist = length(pos); if(dist &amp;gt; 1.0f) return BackColor; float h = atan2(pos.y, pos.x) * (180.0f / 3.1415926f) + HueInitialAngle; if (h &amp;lt; 0) h += 360; else if (h &amp;gt; 360) h -= 360; float s = dist; float b = Brightness; float3 color = HSBtoRGB(h, s, b); return float4(color, 1.0f);}这两个调色盘都支持三个参数： 背景色，用于指定显示圆盘外面显示什么颜色 色相旋转角度，用于按照你的需要将起始的色相转到对应的位置（右、上等） 亮度或明度，当指定这个值时，整个调色盘的最大亮度或明度就被限制到了这个值通常，1 和 2 直接在代码中设好就可以了，3 则通常是在界面中额外显示一个滑块了整体调节。版本二：精简指令需要注意的是，上述代码都是超过了 PS_2 的最大 64 条指令的，也就是说只能以 PS_3 作为目标框架。不过，PS_3 不支持部分显卡（例如 Windows 远程桌面 RDP 所虚拟的显卡）。所以，如果你希望上述像素着色器能够在这样的情况下工作，则需要放弃 PS_3 转而使用 PS_2，或者在不满足要求的情况下自己用其他方式进行软渲染。那么，上述代码能将指令数优化到 64 以内吗？我们去问问 GPT-4。被 GPT-4 精简后的代码如下，现在已经可以完全在 PS_2 的目标框架下完成编译并使用了。sampler2D input : register(s0);/// &amp;lt;summary&amp;gt;Hue Initial Angle&amp;lt;/summary&amp;gt;/// &amp;lt;minValue&amp;gt;0&amp;lt;/minValue&amp;gt;/// &amp;lt;maxValue&amp;gt;360&amp;lt;/maxValue&amp;gt;/// &amp;lt;defaultValue&amp;gt;0&amp;lt;/defaultValue&amp;gt;float HueInitialAngle : register(C0);/// &amp;lt;summary&amp;gt;Brightness&amp;lt;/summary&amp;gt;/// &amp;lt;minValue&amp;gt;0&amp;lt;/minValue&amp;gt;/// &amp;lt;maxValue&amp;gt;1&amp;lt;/maxValue&amp;gt;/// &amp;lt;defaultValue&amp;gt;1&amp;lt;/defaultValue&amp;gt;float Brightness : register(C1);float3 HSBToRGB(float3 hsb){ float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0); float3 p = abs(frac(hsb.xxx + K.xyz) * 6.0 - K.www); return hsb.z * lerp(K.xxx, clamp(p - K.xxx, 0.0, 1.0), hsb.y);}float4 main(float2 uv : TEXCOORD) : COLOR{ float2 pos = uv * 2.0f - 1.0f; float dist = length(pos); float h = (atan2(pos.y, pos.x) / (2.0f * 3.1415926f) + HueInitialAngle / 360.0f) % 1.0f; float s = dist; float b = Brightness; float3 hsb = float3(h, s, b); float3 color = HSBToRGB(hsb); return float4(color, 1.0f);}版本三：带有完整功能的精简指令既然可以把指令精简到如此程度，那么我们把前面删除的 BackColor 功能加回来能否继续保证在 64 指令数以内呢？既然 GPT-4 那么强大，那么就劳烦一下它吧，经过反复询问以及我的调试下，HSL 调色盘和 HSV/HSB 调色盘的精简指令全功能版本就出来啦，代码如下，大家可复制参考。至于全功能是哪写全功能呢？ 支持使用 HueInitialAngle 参数控制色相的旋转角度 支持设置 HSL 中的 L（Lightness）或 HSV/HSB 中的 B（Brighness） 支持 Gamma 校正（设置为 1.0 则不校正，如果希望用户看起来更自然一些，可以设置为 2.2） 支持 OutsideColor 参数设置调色盘圆外的颜色，且支持设置半透明色如下图是这四个参数的设置效果，其中圆外设置成了半透明黑色。▲ 全功能的 HSB 调色盘HSL 调色盘：sampler2D input : register(s0);/// &amp;lt;summary&amp;gt;Hue Initial Angle&amp;lt;/summary&amp;gt;/// &amp;lt;type&amp;gt;Single&amp;lt;/type&amp;gt;/// &amp;lt;minValue&amp;gt;0&amp;lt;/minValue&amp;gt;/// &amp;lt;maxValue&amp;gt;360&amp;lt;/maxValue&amp;gt;/// &amp;lt;defaultValue&amp;gt;0&amp;lt;/defaultValue&amp;gt;float HueInitialAngle : register(C1);/// &amp;lt;summary&amp;gt;Lightness&amp;lt;/summary&amp;gt;/// &amp;lt;type&amp;gt;Single&amp;lt;/type&amp;gt;/// &amp;lt;minValue&amp;gt;0&amp;lt;/minValue&amp;gt;/// &amp;lt;maxValue&amp;gt;1&amp;lt;/maxValue&amp;gt;/// &amp;lt;defaultValue&amp;gt;0.5&amp;lt;/defaultValue&amp;gt;float Lightness : register(C2);/// &amp;lt;summary&amp;gt;Gamma Correction&amp;lt;/summary&amp;gt;/// &amp;lt;type&amp;gt;Single&amp;lt;/type&amp;gt;/// &amp;lt;minValue&amp;gt;1.0&amp;lt;/minValue&amp;gt;/// &amp;lt;maxValue&amp;gt;2.4&amp;lt;/maxValue&amp;gt;/// &amp;lt;defaultValue&amp;gt;1.0&amp;lt;/defaultValue&amp;gt;float Gamma : register(C3);/// &amp;lt;summary&amp;gt;Background Color outside of the Circle&amp;lt;/summary&amp;gt;/// &amp;lt;type&amp;gt;Color&amp;lt;/type&amp;gt;/// &amp;lt;minValue&amp;gt;0,0,0,1&amp;lt;/minValue&amp;gt;/// &amp;lt;maxValue&amp;gt;1,1,1,1&amp;lt;/maxValue&amp;gt;/// &amp;lt;defaultValue&amp;gt;1,1,1,1&amp;lt;/defaultValue&amp;gt;float4 OutsideColor : register(C4);float3 HUEtoRGB(float H){ float R = abs(H * 6 - 3) - 1; float G = 2 - abs(H * 6 - 2); float B = 2 - abs(H * 6 - 4); return saturate(float3(R,G,B));}float3 HSLtoRGB(in float3 HSL){ float3 RGB = HUEtoRGB(HSL.x); float C = (1 - abs(2 * HSL.z - 1)) * HSL.y; return (RGB - 0.5) * C + HSL.z;}float4 main(float2 uv : TEXCOORD) : COLOR{ float2 pos = uv * 2.0f - 1.0f; float dist = length(pos); dist = pow(dist, Gamma); float h = (atan2(pos.y, pos.x) / (2.0f * 3.1415926f) + 1.0f + HueInitialAngle / 360.0f) % 1.0f; float s = dist; float l = Lightness; float3 hsl = float3(h, s, l); float3 color = HSLtoRGB(hsl); float4 finalColor = float4(color, 1.0f); if(dist &amp;gt; 1.0f) finalColor = float4(OutsideColor.rgb, 1.0f) * OutsideColor.a + finalColor * (1 - OutsideColor.a); return finalColor;}HSV/HSB 调色盘：sampler2D input : register(s0);/// &amp;lt;summary&amp;gt;Hue Initial Angle&amp;lt;/summary&amp;gt;/// &amp;lt;type&amp;gt;Single&amp;lt;/type&amp;gt;/// &amp;lt;minValue&amp;gt;0&amp;lt;/minValue&amp;gt;/// &amp;lt;maxValue&amp;gt;360&amp;lt;/maxValue&amp;gt;/// &amp;lt;defaultValue&amp;gt;0&amp;lt;/defaultValue&amp;gt;float HueInitialAngle : register(C0);/// &amp;lt;summary&amp;gt;Brightness&amp;lt;/summary&amp;gt;/// &amp;lt;type&amp;gt;Single&amp;lt;/type&amp;gt;/// &amp;lt;minValue&amp;gt;0&amp;lt;/minValue&amp;gt;/// &amp;lt;maxValue&amp;gt;1&amp;lt;/maxValue&amp;gt;/// &amp;lt;defaultValue&amp;gt;1&amp;lt;/defaultValue&amp;gt;float Brightness : register(C1);/// &amp;lt;summary&amp;gt;Gamma Correction&amp;lt;/summary&amp;gt;/// &amp;lt;type&amp;gt;Single&amp;lt;/type&amp;gt;/// &amp;lt;minValue&amp;gt;1.0&amp;lt;/minValue&amp;gt;/// &amp;lt;maxValue&amp;gt;2.4&amp;lt;/maxValue&amp;gt;/// &amp;lt;defaultValue&amp;gt;2.2&amp;lt;/defaultValue&amp;gt;float Gamma : register(C2);/// &amp;lt;summary&amp;gt;Color outside of the Circle&amp;lt;/summary&amp;gt;/// &amp;lt;type&amp;gt;Color&amp;lt;/type&amp;gt;/// &amp;lt;minValue&amp;gt;0,0,0,1&amp;lt;/minValue&amp;gt;/// &amp;lt;maxValue&amp;gt;1,1,1,1&amp;lt;/maxValue&amp;gt;/// &amp;lt;defaultValue&amp;gt;1,1,1,1&amp;lt;/defaultValue&amp;gt;float4 OutsideColor : register(C3);float3 HSBToRGB(float3 hsb){ float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0); float3 p = abs(frac(hsb.xxx + K.xyz) * 6.0 - K.www); return hsb.z * lerp(K.xxx, clamp(p - K.xxx, 0.0, 1.0), hsb.y);}float4 main(float2 uv : TEXCOORD) : COLOR{ float2 pos = uv * 2.0f - 1.0f; float dist = length(pos); dist = pow(dist, Gamma); float h = (atan2(pos.y, pos.x) / (2.0f * 3.1415926f) + HueInitialAngle / 360.0f) % 1.0f; float s = dist; float b = Brightness; float3 hsb = float3(h, s, b); float3 color = HSBToRGB(hsb); float4 finalColor = float4(color, 1.0f); if(dist &amp;gt; 1.0f) finalColor = float4(OutsideColor.rgb, 1.0f) * OutsideColor.a + finalColor * (1 - OutsideColor.a); return finalColor;}附：GPT-4 提示词考虑到有些小伙伴可能对我的 GPT-4 提示词感兴趣，那么我就把我的询问过程贴出来。参考资料 HSL and HSV - Wikipedia" }, { "title": "WPF 像素着色器入门：使用 Shazzam Shader Editor 编写 HLSL 像素着色器代码", "url": "/post/create-wpf-pixel-shader-effects-using-shazzam-shader-editor.html", "categories": "", "tags": "dotnet, csharp, wpf, directx", "date": "2023-05-22 22:06:04 +0800", "snippet": "HLSL，High Level Shader Language，高级着色器语言，是 Direct3D 着色器模型所必须的语言。WPF 支持 Direct3D 9，也支持使用 HLSL 来编写着色器。你可以使用任何一款编辑器来编写 HLSL，但 Shazzam Shader Editor 则是专门为 WPF 实现像素着色器而设计的一款编辑器，使用它来编写像素着色器，可以省去像素着色器接入到 WPF 所需的各种手工操作。本文是 WPF 编写 HLSL 的入门文章，带大家使用 Shazzam Shader Editor 来编写最简单的像素着色器代码。下载安装实际上 Shazzam Shader Editor 有一段时间没有维护了，不过在 WPF 下依然是一个不错的编写 HLSL 的工具。 于是去我的镜像地址下载：https://github.com/walterlv/download/raw/master/Shazzam/Shazzam_v1.5.Setup.exe 已经没有官网了：shazzam-tool.com下载完成之后安装到你的电脑上即可。Shazzam 是开源的，但是官方开源在 CodePlex 上，https://archive.codeplex.com/?p=shazzam，而 CodePlex 已经关闭。JohanLarsson 将其 Fork 到了 GitHub 上，https://github.com/JohanLarsson/Shazzam，不过几乎只有代码查看功能而不提供维护。Shazzam Shader Editor主界面打开 Shazzam，左侧会默认选中 Sample Shaders 即着色器示例，对于不了解像素着色器能够做到什么效果的小伙伴来说，仅浏览这里面的特效就能够学到很多好玩的东西。旁边是 Tutorial 教程，这里的教程是配合 HLSL and Pixel Shaders for XAML Developers 这本书来食用的，所以如果希望能够系统地学习 HLSL，那么读一读这本书跟着学习里面的代码吧！左边的另一个标签是 Your Folder，可以放平时学习 HLSL 时的各种代码，也可以是你的项目代码，这里会过滤出 .fx 文件用于编写 HLSL 代码。如果你打开关于界面，你可以看到这款软件很用心地在关于窗口背后使用了 TelescopicBlur 特效，这是一个 PS_3 特效，后面会解释其含义。公共设置依然在左侧，可以选择 Settings 设置。目标框架 Target FrameworkWPF 自 .NET Framework 4.0 开始支持 PS_3，当然也包括现在的 .NET Core 3.x 和后续的全版本 .NET。PS_3 带来了比 PS_2 更多的功能，但需要注意，不是所有的显卡设备都支持 PS_3，这其中就包括了至今仍在广泛使用的 Windows 远程桌面（RDP）。所以，如果希望让你的着色器代码能在目前所有设备上正常运行，建议使用 PS_2；如果不在乎这一点，或者你有其他低性能的方法（例如用 CPU 画位图）来替代 PS_3，那么还是可以继续用的。如果你正在写的 HLSL 代码指令数刚好超过 PS_2 的限制（64 条指令）不太多，可以参考我在另一篇博客中的优化方式：关于 PS_3 相比于此前带来的更新可以查看微软的官方文档了解：ps_3_0 - Windows applications - Microsoft Docs。生成的命名空间 Generated Namespace默认是 Shazzam，实际上在接入到你的项目的时候，这个命名空间肯定是要改的，所以建议改成你项目中需要使用到的命名空间。比如我的是 Walterlv.Effects。改好之后，如果你编译你的 .fx 文件，也就是编写了 HLSL 代码的文件，那么顺便也会生成一份使用 Walterlv.Effects 命名空间的 C# 代码便于你将此特效接入到你的 WPF 应用程序中。缩进 Indentation默认的缩进是 Tab，非常不清真，建议改成四个空格。默认动画时长 Default Animation Length如果你的特效是为了制作动画（实际上在 Shazzam 中编写的 HLSL，任何一个寄存器（变量）都可以拿来做动画），那么此值将给动画设置一个默认的时长。相比于前面的所有设置，这个设置不会影响到你的任何代码，只是决定你预览动画效果时的时长，所以设置多少都没有影响。编写 HLSL 代码HLSL 代码窗格实际上本文不会教你编写任何 HLSL 代码，也不会进行任何语法入门之类的，我们只需要了解 Shazzam 是如何帮助我们为 WPF 程序编写像素着色器代码的。将你的视线移至下方富含代码的窗格，这里标记着 XXX.fx 的标签就是 HLSL 代码了。大致浏览一下，你会觉得这风格就是 C 系列的语言风格，所以从学校里出来的各位应该很有亲切感，上手难度不高。按下 F5，即可立即编译你的 HLSL 代码，并在界面上方看到预览效果。别说你没有 HLSL 代码，前面我们可是打开了那么多个示例教程呀。预览调节窗格确保你刚刚使用 F5 编译了你的 HLSL 代码。这样，你就能在这个窗格看到各种预览调节选项。你可以直接拉动拉杆调节参数范围，也可以直接开启一个动画预览各种值的连续变化效果。生成的 C# 代码继续切换一个标签，你可以看到 Shazzam 为你生成的 C# 代码。实际上稍后你就可以直接使用这份代码驱动起你刚刚编写的特效。代码风格使用了我们刚刚设置的一些全局参数。将像素着色器放到 WPF 项目中将像素着色器放到 WPF 项目中需要经过两个步骤： 找到生成的像素着色器文件，并放入 WPF 工程中； 修改像素着色器的生成方式。将特效放入到你的 WPF 项目中我们需要将两个文件加入到你的 WPF 程序中： 一个 .ps 文件，即刚刚的 .fx 文件编译后的像素着色器文件； 一份用于驱动此像素着色器的 C# 代码。这些文件都可以使用以下方法找到： 请前往 %LocalAppData%\\Shazzam\\GeneratedShaders 文件夹； 根据名称变化规则找到对应的文件夹： 注意命名，如果你的 .fx 文件命名为 walterlv.fx，那么生成的文件就会在 WalterlvEffect 文件夹下 进入刚刚找到的 XxxEffect 文件夹，里面有你需要的所有文件： 一个 .ps 文件 一个 C# 文件（以及 VB 文件） 随后，将这两份文件一并加入到你的 WPF 项目工程文件中。但是，请特别注意路径！留意你的 C# 代码，里面是编写了像素着色器的路径的： 如果你的程序集名称是其他名称，需要修改下面 Walterlv.Effects 的部分改成你的程序集名称； 如果你放到了其他的子文件夹中，你也需要在下面 /WalterlvEffect.ps 的前面加上子文件夹。// 记得修改程序集名称，以及 .ps 文件所在的文件夹路径！切记！pixelShader.UriSource = new Uri(&quot;/Walterlv.Effects;component/WalterlvEffect.ps&quot;, UriKind.Relative);修改像素着色器的生成方式需要使用 Resource 方式编译此 .ps 文件到 WPF 项目中。如果你使用的是旧的项目格式，则右键此 .ps 文件的时候选择属性，你可以在 Visual Studio 的属性窗格的生成操作中将其设置为 Resource。如果你使用的是 Sdk 风格的新项目格式，则在属性窗格中无法将其设置为 Resource，这个时候请直接修改 .csproj 文件，加上下面一行：&amp;lt;Resource Include=&quot;**\\*.ps&quot; /&amp;gt;如果不知道怎么放，我可以多贴一些 csproj 的代码，用于指示其位置：&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk.WindowsDesktop&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;OutputType&amp;gt;WinExe&amp;lt;/OutputType&amp;gt; &amp;lt;TargetFramework&amp;gt;netcoreapp3.0&amp;lt;/TargetFramework&amp;gt; &amp;lt;UseWPF&amp;gt;true&amp;lt;/UseWPF&amp;gt; &amp;lt;AssemblyName&amp;gt;Walterlv.Demo&amp;lt;/AssemblyName&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;Resource Include=&quot;**\\*.ps&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt;&amp;lt;/Project&amp;gt;在 WPF 程序中使用这个特效要在 WPF 程序中使用这个特效，则设置控件的 Effect 属性，将我们刚刚生成的像素着色器对应 C# 代码的类名写进去即可。当然，需要在前面引入 XAML 命名空间。&amp;lt;Window x:Class=&quot;Walterlv.CloudTyping.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:effects=&quot;clr-namespace:Walterlv.Effects&quot; Title=&quot;walterlv&quot;&amp;gt; &amp;lt;Grid&amp;gt; &amp;lt;Grid.Effect&amp;gt; &amp;lt;effects:WalterlvEffect /&amp;gt; &amp;lt;/Grid.Effect&amp;gt; &amp;lt;!-- 省略了界面上的各种代码 --&amp;gt; &amp;lt;/Grid&amp;gt;&amp;lt;/Window&amp;gt;下面是我将 Underwater 特效加入到我的云键盘窗口中，给整个窗口带来的视觉效果。入门总结本文毕竟是一篇入门文章，没有涉及到任何的技术细节。你可以按照以下问题检查是否入门成功： 你能否成功安装并打开 Shazzam Shader Editor 软件？ 你能否找到并打开一个示例像素着色器代码，并完成编译预览效果？ 知道如何设置像素着色器使用 PS_3 版本吗？ 尝试将一个示例像素着色器编译完并放入到你的 WPF 项目中。 尝试将特效应用到你的一个 WPF 控件中查看其效果。参考资料 shazzam-tool.com Shazzam Shader Editor - CodePlex Archive JohanLarsson/Shazzam: A fork of https://shazzam.codeplex.com/ Shazzam - A Tool for Creating WPF Pixel Shader Effects - The Continuum Show - Channel 9 ps_3_0 - Windows applications - Microsoft Docs ps_3_0 Registers - Windows applications - Microsoft Docs WPF Custom Effect disappears when using Remote Desktop - Stack Overflow" }, { "title": "Windows 10 自带那么多图标，去哪里找呢？", "url": "/post/where-is-the-windows-10-native-icons.html", "categories": "", "tags": "windows, personalize", "date": "2023-05-19 19:48:24 +0800", "snippet": "无意间发现我的 D 盘根目录中大部分的文件夹都是系统专用文件夹，有自己的独特图标，偶有一两个开发用的文件夹是默认图标。于是想把它们改成独特样式，而且是 Windows 10 那些新图标样式！这是我的文件夹，我希望把最上面几个文件夹的图标改成下面那些风格。大家都知道在文件夹上右键，选择 属性 → 自定义 → 更改图标，这里可以选择很多图标，但用了很多年看腻了，Windows 10 中还自带有那么多，它们又在哪里呢？Windows 10 自带的图标几乎都在 %systemroot%\\system32\\*.dll 中，主要是这些： Windows 10 风格 %systemroot%\\system32\\ddores.dll %systemroot%\\system32\\dmdskres.dll %systemroot%\\system32\\imageres.dll %systemroot%\\system32\\mmres.dll %systemroot%\\system32\\networkexplorer.dll %systemroot%\\system32\\pnidui.dll %systemroot%\\system32\\sensorscpl.dll %systemroot%\\system32\\setupapi.dll %systemroot%\\system32\\shell32.dll %systemroot%\\system32\\wmploc.dll %systemroot%\\system32\\wpdshext.dll Windows 7 风格 %systemroot%\\system32\\accessibilitycpl.dll %systemroot%\\system32\\dsuiext.dll %systemroot%\\system32\\gameux.dll %systemroot%\\system32\\ieframe.dll %systemroot%\\system32\\mstscax.dll %systemroot%\\system32\\netcenter.dll Windows 早期风格 %systemroot%\\system32\\compstui.dll %systemroot%\\system32\\mmcndmgr.dll %systemroot%\\system32\\moricons.dll %systemroot%\\system32\\pifmgr.dll 我们一起来看看它们都是什么样的吧！Windows 10 风格▲ ddores.dll 包含各种硬件图标▲ dmdskres.dll 磁盘管理所用图标▲ imageres.dll 各种各样 Windows 10 风格的图标，涵盖各种用途▲ mmres.dll 音频设备图标▲ networkexplorer.dll 网络和共享中心图标▲ pnidui.dll 不要被这些空白迷惑了，这都是白色的网络指示图标（有线、无线、飞行模式等）▲ sensorscpl.dll 各种传感器图标（如温度、亮度、声音、指纹、地理位置等）▲ setupapi.dll 为各种硬件安装程序提供的图标▲ shell32.dll 这个是点开“更改图标”按钮后查看的默认图标库，也包含各种各样 Windows 10 风格的图标，涵盖各种用途▲ wmploc.dll 各种媒体设备、媒体文件、媒体文件夹▲ wpdshext.dllWindows 7/Vista 风格▲ accessibilitycpl.dll 辅助功能图标▲ dsuiext.dll 服务器或网络服务所用图标▲ gameux.dll 游戏图标▲ ieframe.dll IE 所用的图标（部分图标其实已经更新成 Windows 10 风格，给 Edge 用）▲ mstscax.dll 远程桌面连接所用图标（部分图标其实已经更新成 Windows 10 风格）▲ netcenter.dll Windows 7 风格的网络和共享中心所用图标Windows XP/2000/9X/3.X 风格▲ compstui.dll▲ mmcndmgr.dll 古老的图标▲ moricons.dll 古老的图标▲ netshell.dll 古老的网络连接图标▲ pifmgr.dll Windows 95 时代古老的图标▲ wiashext.dll 各种图片、照片和媒体设备图标一个说明：你会发现有些图标是空白的，这个不是 BUG，是微软的无奈……因为有些古老的不负责任的程序会依赖于这些老旧的被微软淘汰的图标，如果微软删掉了这些图标，那么这些程序会崩溃。哎……" }, { "title": "如何更精准地设置 C# / .NET Core 项目的输出路径？（包括添加和删除各种前后缀）", "url": "/post/the-properties-that-affetcs-project-output-path.html", "categories": "", "tags": "dotnet, csharp, visualstudio, msbuild", "date": "2023-04-18 08:54:42 +0800", "snippet": "我们都知道可以通过在 Visual Studio 中设置输出路径（OutputPath）来更改项目输出文件所在的位置。对于 .NET Core 所使用的 Sdk 风格的 csproj 格式来说，你可能会发现实际生成路径中带了 netcoreapp3.0 或者 net472 这样的子文件夹。然而有时我们并不允许生成这样的子文件夹。本文将介绍可能影响实际输出路径的各种设置。项目和输出路径对于这样的一个简单的项目文件，这个项目的实际输出路径可能是像下图那样的。&amp;lt;Project&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;TargetFramework&amp;gt;netcoreapp3.0&amp;lt;/TargetFramework&amp;gt; &amp;lt;OutputPath&amp;gt;bin\\$(Configuration)&amp;lt;/OutputPath&amp;gt; &amp;lt;/PropertyGroup&amp;gt;&amp;lt;/Project&amp;gt;有没有办法可以不要生成这样的子文件夹呢？答案是可以的。我在 解读 Microsoft.NET.Sdk 的源码，你能定制各种奇怪而富有创意的编译过程 一文中有说到如何解读 Microsoft.NET.Sdk，而我们的答案就是从解读这个 Sdk 而来。影响输出路径的属性OutputPath 属性由这些部分组成：$(BaseOutputPath)\\$(PlatformName)\\$(Configuration)\\$(RuntimeIdentifier)\\$(TargetFramework.ToLowerInvariant())\\如果以上所有属性都有值，那么生成的路径可能就像下面这样：bin\\x64\\Debug\\win7-x64\\netcoreapp3.0具体的，这些属性以及其相关的设置有： $(BaseOutputPath) 默认值 bin\\，你也可以修改。 $(PlatformName) 默认值是 $(Platform)，而 $(Platform) 的默认值是 AnyCPU；当这个值等于 AnyCPU 的时候，这个值就不会出现在路径中。 $(Configuration) 默认值是 Debug。 $(RuntimeIdentifier) 这个值和 $(PlatformTarget) 互为默认值，任何一个先设置都会影响另一个；此值即 x86、x64 等标识符。可以通过 $(AppendRuntimeIdentifierToOutputPath) 属性指定是否将此加入到输出路径中。 $(TargetFramework) 这是在 csproj 文件中强制要求指定的，如果不设置的话项目是无法编译的；可以通过 $(AppendTargetFrameworkToOutputPath) 属性指定是否将此加入到输出路径中。 现在，你应该可以更轻松地设置你的输出路径，而不用担心总会出现各种意料之外的子文件夹了吧！" }, { "title": "如何利用 Win32 API 设置两个窗口的所有者（Owner）关系", "url": "/post/set-owner-window-using-win32-api", "categories": "windows, csharp, dotnet", "tags": "", "date": "2023-03-01 15:37:01 +0800", "snippet": "设置两个窗口的父子关系非常简单，只需要调用 SetParent 函数即可。然而设置两个窗口的所有者（Owner）关系却没有一个简单直观的 API。那么本文介绍一下如何设置两个窗口的 Owner 关系。设置所有者（Owner）由于方法非常简单，所以我直接贴出 MainWindow 中的完整代码：public partial class MainWindow : Window{ public MainWindow() { InitializeComponent(); SourceInitialized += OnSourceInitialized; } private void OnSourceInitialized(object? sender, EventArgs e) { var ownerHwnd = User32.GetForegroundWindow(); var hwnd = new WindowInteropHelper(this).Handle; User32.SetWindowLong(hwnd, GetWindowLongIndexes.GWL_HWNDPARENT, (nint)ownerHwnd); }}在这里，我准备好了两个窗口句柄，一个是 ownerHwnd，我随便取了当前窗口的；另一个是 hwnd 即自己的句柄。这样，程序启动的时候，便会把自己窗口的所有者设置为启动前最后一个前台窗口。接下来是关键代码 SetWindowLong，传入三个参数： 自己窗口的句柄 hwnd GWL_HWNDPARENT 即指定所有者（在官方文档中，依然将其描述为 parent`） 所有者窗口的句柄 ownerHwnd所需 API在 C# 中，以上 API 函数需要定义。为了方便，你可以直接安装库 Lsj.Util.Win32 以省去所有的定义工作。如果你不想引入库，可以用下面我准备好的定义（摘自 Lsj.Util.Win32 并简化）：public static nint SetWindowLong([In] nint hWnd, [In] GetWindowLongIndexes nIndex, [In] nint dwNewLong) =&amp;gt; nint.Size &amp;gt; 4 ? SetWindowLongPtrImp(hWnd, nIndex, dwNewLong) : SetWindowLongImp(hWnd, nIndex, dwNewLong.ToInt32());[DllImport(&quot;user32.dll&quot;, CharSet = CharSet.Unicode, EntryPoint = &quot;SetWindowLongW&quot;, ExactSpelling = true, SetLastError = true)]private static extern int SetWindowLongImp(nint hWnd, GetWindowLongIndexes nIndex, int dwNewLong);[DllImport(&quot;user32.dll&quot;, CharSet = CharSet.Unicode, EntryPoint = &quot;SetWindowLongPtrW&quot;, ExactSpelling = true, SetLastError = true)]private static extern nint SetWindowLongPtrImp(nint hWnd, GetWindowLongIndexes nIndex, nint dwNewLong);public enum GetWindowLongIndexes{ GWL_HWNDPARENT = -8,}后续需求出于兼容性考虑，即便设置为了所有者关系，Windows 系统也不会强制修改窗口的样式（例如从任务栏中去掉）。你可以考虑将窗口的 WindowStylesEx 属性中的 WS_EX_APPWINDOW 部分去掉来实现这样的效果。var style = style &amp;amp; ~WindowStylesEx.WS_EX_APPWINDOW;至于具体如何使用 GetWindowLong 和 SetWindowLong 来实现以上目的，本文就不赘述了。参考资料 SetParent function (winuser.h) - Win32 apps - Microsoft Learn GetWindowLongA function (winuser.h) - Win32 apps - Microsoft Learn winapi - How to change a Window Owner using its handle - Stack Overflow" }, { "title": "WPF 的 Dispatcher 为什么要创建一个隐藏窗口？", "url": "/post/why-dispatcher-creates-a-hidden-message-only-window", "categories": "wpf, windows", "tags": "", "date": "2023-02-28 10:18:05 +0800", "snippet": "在深入了解 WPF Dispatcher 的工作原理（Invoke/InvokeAsync 部分）中，我提到 Dispatcher 在构造函数中创建了一个隐藏窗口专门用来接收消息，以处理通过 Invoke 系列方法调用的那些操作。然而 C 不满足于只看到这个结论，他更期望知道为什么 WPF 一定要创建这个隐藏的窗口。其实对这个问题我也不知道答案，但在和他深入的探讨以及不断寻找资料的过程中，我们逐渐得知了缘由。本文记录了这一次探讨，给希望了解 Windows、WPF 底层机制的人一些可供参考的思路和结论。当然，要特别感谢 C 提出了这个问题，并在讨论过程中给出了关键性的推理。隐藏窗口的疑问先来回顾一下 Dispatcher 构造函数中与创建窗口相关的部分：// Create the message-only window we use to receive messages// that tell us to process the queue.MessageOnlyHwndWrapper window = new MessageOnlyHwndWrapper();_window = new SecurityCriticalData&amp;lt;MessageOnlyHwndWrapper&amp;gt;( window );_hook = new HwndWrapperHook(WndProcHook);_window.Value.AddHook(_hook);它创建了一个 Message-Only 窗口，专门监听此窗口收到的消息。然而，试问这个问题： 一定需要此隐藏窗口吗？ 消息循环不一定需要窗口来参与啊！没有窗口，消息循环依旧能持续进行并处理消息。所需知识的梳理为了能让阅读这篇博客的所有人都能理解这个问题，我们需要简单了解一下 Windows 消息循环机制。从本质上说，消息循环就是在某个线程上执行了以下代码：while( (bRet = GetMessage( &amp;amp;msg, NULL, 0, 0 )) != 0){ if (bRet == -1) { // handle the error and possibly exit } else { TranslateMessage(&amp;amp;msg); DispatchMessage(&amp;amp;msg); }}在这段代码里，GetMessage 是从此线程的消息队列中取得消息，TranslateMessage 将按键消息转换为字符消息并重新发送到此消息队列，DispatchMessage 则将消息调度到窗口过程。可以发现，全程是不需要任何窗口参与的。我们已经在这个循环中拿到了发往此线程的所有的消息，一个都没有漏掉。既然如此，Invoke 相关的自定义消息也可以发给这个线程的消息队列（而不是发给特定的窗口），这样也不会漏掉任何消息。也就是说，不需要创建任何窗口也能收到并处理所需的任何消息。对于没有接触过 Windows 消息机制的 WPF 开发者来说，可能会认为上面那段代码是 Windows 系统提供的某种机制，是自己不能控制和扩展的代码。其实不是这样的，这段代码是需要由开发者开发的应用程序中手动处理的。WPF 框架只是帮助我们处理好了这件琐事而已。既然 WPF 框架已经处理了这件琐事，那就意味着同在框架内的 Invoke 的那些操作也能放到这里一并处理了，并不需要创建一个隐藏消息窗口（Hidden Message-Only Window）来绕着圈子处理。再大不了觉得这样在消息循环中耦合了 Dispatcher 内的机制的话，可以利用一下“依赖倒置”原则将这种依赖抽象一下，在解决代码可维护性的问题的同时，依然能可以避免额外创建一个窗口。所以综合来看，似乎创建隐藏消息窗口真的显得没有必要。可供参考的资料在我和 C 探讨的过程中，我找到了一些对此问题有帮助的资料： Message-Only Window Window Features - Win32 apps - Microsoft Learn 发送消息到窗口 SendMessageA function (winuser.h) - Win32 apps - Microsoft Learn PostMessageA function (winuser.h) - Win32 apps - Microsoft Learn 发送消息到线程 PostThreadMessageA function (winuser.h) - Win32 apps - Microsoft Learn 其中 1、2 可以帮助对 Windows 消息循环机制不太熟悉的小伙伴了解更多解答此问题的背景知识： 从第一篇资料中我们可知，Message-Only Window 是 Windows 中一项很重要的机制，甚至专门为开发者创建此窗口准备了一个常量 ` HWND_MESSAGE`。虽然不能正面证明前面 WPF 创建隐藏消息窗口的必要性，但可以知道这至少是一个常用做法。既然常用，那一定有其存在的必要性。 从第二篇资料中我们可知，在 SendMessage 函数中将窗口句柄参数传入 NULL 将会失败，而在 PostMessage 函数中将窗口句柄参数传入 NULL 的效果将和 PostThreadMessage 的效果完全相同。而 PostThreadMessage 则一样会正常将消息加入到此线程的消息队列中。而当我们仔细再去阅读 PostThreadMessage 文档中的注解部分时，就会注意到下面这段话： Messages sent by PostThreadMessage are not associated with a window. As a general rule, messages that are not associated with a window cannot be dispatched by the DispatchMessage function. Therefore, if the recipient thread is in a modal loop (as used by MessageBox or DialogBox), the messages will be lost. To intercept thread messages while in a modal loop, use a thread-specific hook. PostThreadMessage 发送的消息与窗口不关联。作为一般规则，与窗口不关联的消息不能由 DispatchMessage 函数调度。 因此，如果收件人线程处于模式循环中， (MessageBox 或 DialogBox) ，则消息将丢失。 若要在模式循环中截获线程消息，请使用特定于线程的挂钩。按文中的说法，如果我们使用 PostThreadMessage 来发送消息给这个线程的消息队列，那么当此线程处于模态时，消息将丢失，除非使用特定于线程的挂钩。看起来这是在描述一个现象：如果我们不使用隐藏的消息窗口而是直接将消息发给线程，那么此消息将在线程处于模态时丢失。可是，为什么会丢失呢？隐藏窗口的解答我和 C 的探讨差点在上述阶段终止时，C 猛然意识到了上述现象的本质原因。是的，这就是本文疑问的最本质解答！// 消息循环while( (bRet = GetMessage( &amp;amp;msg, NULL, 0, 0 )) != 0){ if (bRet == -1) { // handle the error and possibly exit } else { TranslateMessage(&amp;amp;msg); DispatchMessage(&amp;amp;msg); }} DispatchMessage 的作用就是将消息循环中窗口相关的消息转发给对应的窗口进行调度。 如果使用 Message-Only 窗口，那么无论谁来写消息循环，只要写消息循环的这名开发者在消息处理中调用了 DispatchMessage 函数，那么窗口就可以正常处理消息。 然而，如果 WPF 的 Invoke 机制没有使用 Message-Only 窗口，那么 DispatchMessage 的转发将没有其他途径可以调用到 Invoke 中的那些操作；唯一能处理 Invoke 那些操作的地方就是正在处理消息循环的这个循环本环里！ 设想，有一个开发者在处理某条消息的时候自己创建了一个新的消息循环（即嵌套的消息循环），那么那个开发者必须在自己的消息循环里调用一下 Invoke 中的那些操作，否则那些操作将没有任何机会被执行！ 而开发者们为什么要自己去开消息循环呢？这不就是众所周知的“模态”吗？？？弹模态对话框的本质就是开了一个新的消息循环处理消息的同时，阻塞原来的消息循环。另外，拖拽文件、拖拽窗口，本质上都是开了一个新的消息循环处理消息。 由于内外层的消息循环都是调用的 GetMessage 函数取得消息，内层的消息循环退出后，对于外层消息循环来说消息已经被消费了，再也回不来了，这不就是丢失了吗？！ 综上所述，WPF 在 Dispatcher 的机制里创建隐藏的消息窗口，其目的就是为了解决消息循环嵌套问题，只要所有实现了消息循环的开发者能记得调用 DispatchMessage 函数，Dispatcher 就能完成 Invoke 那些操作的处理，而开发者们绝对不会忘了调用这个函数（否则你的程序根本无法工作）。反之，如果 Dispatcher 直接使用线程本身的消息循环，那么就必须指望所有消息循环的开发者主动来调用 Dispatcher 提供的某种方法，这显然是不利于代码的高质量维护的。实际上在我们分析完原因后，会发现 Windows 本身提供的 Message-Only Window 机制的出现也是为了解决相同的问题。这也是本文贴出的代码是 C++ 代码，而非 WPF 源码的原因。探讨结束了，特别感谢 C 在这个过程中提出的关键的分析逻辑。参考资料 Using Messages and Message Queues - Win32 apps - Microsoft Learn TranslateMessage function (winuser.h) - Win32 apps - Microsoft Learn DispatchMessage function (winuser.h) - Win32 apps - Microsoft Learn Window Features - Win32 apps - Microsoft Learn SendMessageA function (winuser.h) - Win32 apps - Microsoft Learn PostMessageA function (winuser.h) - Win32 apps - Microsoft Learn PostThreadMessageA function (winuser.h) - Win32 apps - Microsoft Learn" }, { "title": "Directory.GetFiles 中传入搜索字符串（Search Pattern）的神奇规则", "url": "/post/search-pattern-of-dotnet-directory-getfiles", "categories": "dotnet, windows", "tags": "", "date": "2022-11-08 16:50:08 +0800", "snippet": "众所周知，文件名的匹配规则里同配符 ? 代表单个字符，通配符 * 代表多个字符。然而，具体到 Directory.GetFiles(string path, string searchPattern) 方法调用时，却又有一些大家不一定知道的细节。不信？我出一道题大家试试！一道测试题假设在调用 Directory.GetFiles(string path, string searchPattern) 时，searchPattern 传入下表左侧的字符串；请在同一行的两个文件里，能匹配上的打个勾，不能匹配的打个叉。 搜索字符串 文件 1 文件 2 *.xls book.xls bool.xlsx *.ai file.ai file.aif file?.txt file1.txt file1.txtother file*.txt file1.txt file1.txtother *1*.txt file1.txt thisisastrangefile.txt 5 秒后给出答案。54321答案为： 行 匹配字符串 文件 1 文件 2 1 *.xls ✔️ book.xls ✔️ bool.xlsx 2 *.ai ✔️ file.ai ❌ file.aif 3 file?.txt ✔️ file1.txt ❌ file1.txtother 4 file*.txt ✔️ file1.txt ✔️ file1.txtother 5 *1*.txt ✔️ file1.txt ✔️ thisisastrangefile.txt 如果你觉得奇怪，那就不奇怪了。因为这 5 个搜索案例均来自于微软官方文档，而微软花了很大篇幅来解释为什么是这样的行为。解答第 1、2 行，不一样的地方是扩展名长度。 如果搜索字符串扩展名长度为 3，那么文件名里扩展名前 3 位为此扩展名的文件都将匹配上 如果搜索字符串扩展名长度不是 3，那么扩展名必须严格匹配第 3、4 行，不一样 的地方是 ? 和 *。 如果使用 ? 匹配文件，那么文件扩展名必须完全相同才能匹配上 如果使用 * 匹配文件，那么文件扩展名以此开头的都能匹配上第 5 行，为什么明明文件名里没有 1 却也能匹配上呢？这需要简单说一下 8.3 文件名。 8.3文件名一种文件名规范，它主要运用于FAT文件系统中。其后继者NTFS文件系统也支持8.3文件名。这种规范之所以被称为“8.3”，是因为其文件名的特殊格式：文件名的主体部分最多只能包含8个字符，而文件扩展名最多只能包含3个字符。二者之间用“.”相连。8.3文件名的目录和文件名都仅使用大写字母，但DOS和命令提示符都不大小写敏感（当然，如果使用UNIX或类Unix等一般大小写敏感的操作系统，则应注意）。 8.3文件名必须包含主体文件名，但不必须包含扩展名，二者之间用“.”相连。但是如果输入“.”后没有输入扩展名，则“.”没有意义，会被忽略。比如12345678.会被系统保存为12345678。为了兼容老程序，Windows 会有一个算法让 8.3 文件名与长文件名对应，具体对应方法可以参考维基百科：8.3文件名 - 维基百科，自由的百科全书。前面的“thisisastrangefile.txt”对应的 8.3 文件名为“THISIS~1.TXT”，而 Directory.GetFiles 会同时匹配长文件名和 8.3 文件名，所以，“thisisastrangefile.txt”就神奇般地被匹配上了。以下是实测结果。图片的上方是我创建的被测文件名，下方是调用 Directory.GetFiles 来验证搜索结果。其他说明需要注意的是，这个匹配规则只适用于 Windows 下的 API 调用，不适用于用户在文件资源管理器中的搜索操作。搜索操作里没有这么奇怪的规则，单单就是字符串包含以及通配符而已。参考资料 Directory.GetFiles Method (System.IO) - Microsoft Learn 8.3文件名 - 维基百科，自由的百科全书" }, { "title": "CS8350：不允许使用“Foo(ref x, ref y)”的这种参数组合，因为它可能会在其声明范围之外公开由参数 x 引用的变量", "url": "/post/cs8350-ref-arguments-combination-is-disallowed", "categories": "csharp, dotnet", "tags": "", "date": "2022-09-28 12:40:45 +0800", "snippet": "标题所述的是一个 .NET/C# 程序的编译错误。这个编译错误是 C#7.2 时就引入的，但更新到 Visual Studio 2022（17.4） 后，有更多的情况会被判定为发生了此错误。本文会解释这个错误的原因和解决办法。新引入的 CS8350 编译错误以下这段代码，在 Visual Studio 2022（17.4）版本中会出现编译错误 CS8350，但在低版本的 Visual Studio 中则可以正常编译通过。var i = 0;var b = new Bar();Foo(ref i, ref b);static void Foo(ref int i, ref Bar bar){}public ref struct Bar{}错误为： CS8350：不允许使用“Foo(ref a, ref b)”的这种参数组合，因为它可能会在其声明范围之外公开由参数 a 引用的变量CS8350: This combination of arguments to is disallowed because it may expose variables referenced by parameter outside of their declaration scope.如果单看以上示例看不出这个报错的原因的话，我们可以去看看 CS8350 官方报错的典型情况。CS8350 错误的典型情况实际上，在 C# 7.2 刚引入时，这个编译错误就已经存在了。比如以下代码就会报 CS8350 错误：// 此代码示例来自于微软官方 C#7.2 对 CS8350 的解释文档：// https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.2/span-safety.md#method-arguments-must-matchvoid M1(ref Span&amp;lt;int&amp;gt; s1){ Span&amp;lt;int&amp;gt; s2 = stackalloc int[1]; Swap(ref s1, ref s2);}void Swap(ref Span&amp;lt;int&amp;gt; x, ref Span&amp;lt;int&amp;gt; y){ // 经过以下赋值后，M1 方法内定义的 s2 变量将在 M1 方法出栈后仍被引用。 // 用官方的说法，仅在 M1 方法内定义的局部变量 s2 将逃逸到 M1 方法外部。 ref x = ref y;}在以上代码中，M1 方法接受传入的局部引用变量 s1，并在方法内部创建一个新的局部引用变量 s2。在 M1 方法中随后调用了 Swap 方法，而 Swap 方法将 s1 的引用换成了 s2 的引用。于是 s1 现在将引用 M1 方法内的一个局部变量。然而，当 M1 方法返回后，s1 却不会出栈（因为它不是 M1 中定义的局部变量）。所以调用 M1 方法的另一个方法将获取一个已被出栈的方法内的局部变量，换句话说，局部引用变量 s2 逃逸到了 M1 方法的外部。这在 C# 的安全代码块中显然是不被允许的。ref struct S{ public Span&amp;lt;int&amp;gt; Span; public void Set(Span&amp;lt;int&amp;gt; span) { Span = span; }}void Broken(ref S s){ Span&amp;lt;int&amp;gt; span = stackalloc int[1]; // 这会将此方法内定义的局部变量 span 被 S 的实例引用。 // 于是，当此方法执行完成并出栈后，方法内的局部变量仍然被引用。 s.Set(span); }在以上方法中，Broken 方法接受传入的局部引用变量 s，并在方法内部创建一个新的局部变量 span。在 Broken 方法调用了 s.Set(span) 后，局部变量 span 的引用将被储存到 s 的内部。当 Broken 方法退出后，局部变量 span 已被出栈却仍能被 s 调用。这会出现明显的安全漏洞。要解决这个问题，应该把 S 设计成 readonly 的（如 readonly ref struct S），把 Broken 的 ref 改为 in；这样，s 将无法储存可能被出栈的变量。总结一下 CS8350 的产生原因： 两个栈中的引用变量有不同的生命周期； 这两个不同生命周期的变量以引用的方式传给同一个方法。回到 Visual Studio 2022（17.4）现在，我们重新审视本文开头引入的那段代码：var i = 0;var b = new Bar();Foo(ref i, ref b);static void Foo(ref int i, ref Bar bar){}public ref struct Bar{}按照我们总结的原因，这段代码其实并不会产生安全问题，因此本不应该会报 CS8350 错误。但是，我们忽略了另一个问题——目前所有变量的生命周期都是从声明中推断出来的。仅凭目前的语法功能集，C# 无法完全推断所有变量的生命周期。按照 C# 官方开发人员的说法，要做到完全推断，需要扩展 C# 的功能，例如声明一个参数不允许逃逸出这个方法。关于这个问题的具体描述，可以在此问题的官方 GitHub Issue 页面看到相关人员的讨论： https://github.com/dotnet/roslyn/issues/43591因此，目前来说，我们只能接受这种情况下报告的 CS8350 编译错误，并调整我们的代码。例如，将上述的 Bar 的 ref 去掉，或者修改代码实现，避免同时传入两个局部变量的引用。参考资料 csharplang/span-safety.md at main · dotnet/csharplang Relax CS8350 when passed ref-parameter are created in the same stack frame · Issue #43591 · dotnet/roslyn Need a general way to declare ref and ref-like locals bound to current scope. · Discussion #1130 · dotnet/csharplang" }, { "title": "使用 AutoMapper 自动映射模型时，处理不同模型属性缺失的问题", "url": "/post/convert-models-using-auto-mapper-with-property-missing", "categories": "dotnet, csharp", "tags": "", "date": "2022-09-20 20:30:02 +0800", "snippet": "使用 AutoMapper 可以很方便地在不同的模型之间进行转换而减少编写太多的转换代码。不过，如果各个模型之间存在一些差异的话（比如多出或缺少一些属性），简单的配置便不太行。本文帮助你解决这个问题。关于 AutoMapper 的系列文章： 使用 AutoMapper 自动在多个数据模型间进行转换 使用 AutoMapper 自动映射模型时，处理不同模型属性缺失的问题属性增加或减少前面我们所有的例子都是在处理要映射的类型其属性都一一对应的情况。然而，如果所有的属性都是一样的，那我们为什么还要定义多个属性类型呢（Attribute 不一样除外）。正常的开发情况下这些实体类型都会是大部分相同，但也有些许差异的情况。现在，我们稍微改动一下我们的数据模型，给其中一个增加一个新属性 Description：public class Walterlv1Dao{ public string? Id { get; set; } public string? Name { get; set; } public string? Description { get; set; } public List&amp;lt;FriendDao&amp;gt;? Friend { get; set; }}public class Walterlv1Vo{ public string? Id { get; set; } public string? Name { get; set; } public List&amp;lt;FriendVo&amp;gt;? Friend { get; set; }}如果使用一下代码对上述两个模型进行映射，非常需要注意映射方向：static IMapper InitializeMapper(){ var configuration = new MapperConfiguration(cfg =&amp;gt; { cfg.CreateMap&amp;lt;Walterlv1Dao, Walterlv1Vo&amp;gt;(); });#if DEBUG configuration.AssertConfigurationIsValid();#endif var mapper = configuration.CreateMapper(); return mapper;}这里，我们设定从 Walterlv1Dao 映射到 Walterlv1Vo 是正常的，因为前者比后者多出了一些属性。但反过来却不行，如果反过来写，我们将收到一个异常 AutoMapper.AutoMapperConfigurationException：cfg.CreateMap&amp;lt;Walterlv1Vo, Walterlv1Dao&amp;gt;();Unmapped members were found. Review the types and members below.Add a custom mapping expression, ignore, add a custom resolver, or modify the source/destination typeFor no matching constructor, add a no-arg ctor, add optional arguments, or map all of the constructor parameters==============================================================================================Walterlv1Vo -&amp;gt; Walterlv1Dao (Destination member list)Walterlv.Demo.AutoMapping.Models.Walterlv1Vo -&amp;gt; Walterlv.Demo.AutoMapping.Models.Walterlv1Dao (Destination member list)Unmapped properties:Description如果确实希望反过来映射，那么应该使用正向映射之后，再将其反向：cfg.CreateMap&amp;lt;Walterlv1Dao, Walterlv1Vo&amp;gt;().ReverseMap();参考资料 AutoMapper/AutoMapper: A convention-based object-object mapper in .NET." }, { "title": "使用 AutoMapper 自动在多个数据模型间进行转换", "url": "/post/convert-models-using-auto-mapper", "categories": "dotnet, csharp", "tags": "", "date": "2022-09-20 20:06:02 +0800", "snippet": "访问数据库、IPC 通信、业务模型、视图模型……对于同一个业务的同一种数据，经常会使用多种数据模型工作在不同的代码模块中。这时它们之间的互相转换便是大量的重复代码了。使用 AutoMapper 便可以很方便地在不同的模型之间进行转换而减少编写太多的转换代码（如果这一处的代码对性能不太敏感的话）。关于 AutoMapper 的系列文章： 使用 AutoMapper 自动在多个数据模型间进行转换 使用 AutoMapper 自动映射模型时，处理不同模型属性缺失的问题安装 AutoMapper 库这是 AutoMapper 的官方 GitHub 仓库： AutoMapper/AutoMapper: A convention-based object-object mapper in .NET.安装 AutoMapper 的 NuGet 包即可在项目中使用 AutoMapper。入门以下是一个最简单的控制台演示程序的代码。// Program.csvar mapper = InitializeMapper();var dao = new Walterlv1Dao{ Id = &quot;2ed3558ac938438fb2c1d2de71d7bb90&quot;, Name = &quot;walterlv&quot;, Text = &quot;blog.walterlv.com&quot;,};var vo = mapper.Map&amp;lt;Walterlv1Vo&amp;gt;(dao);Console.WriteLine($&quot;Name = {vo.Name}, Text = {vo.Text}&quot;);static IMapper InitializeMapper(){ var configuration = new MapperConfiguration(cfg =&amp;gt; { cfg.CreateMap&amp;lt;Walterlv1Dao, Walterlv1Vo&amp;gt;(); });#if DEBUG configuration.AssertConfigurationIsValid();#endif var mapper = configuration.CreateMapper(); return mapper;}在这段代码中： 我们定义了一个方法 InitializeMapper，在里面初始化 IMapper 的新实例。 初始化 MapperConfiguration，定义类型的映射关系 在 DEBUG 下验证 MapperConfiguration 的映射是否正确 创建一个 IMapper 的映射器，用于后续映射使用 我们初始化了一个 Walterlv1Dao 类的实例 我们调用 mapper.Map 将其映射到 Walterlv1Vo 类型这两个类型的定义如下（虽然无关紧要）。public class Walterlv1Dao{ public string? Id { get; set; } public string? Name { get; set; } public string? Text { get; set; }}public class Walterlv1Vo{ public string? Id { get; set; } public string? Name { get; set; } public string? Text { get; set; }}如果你的应用程序中会使用到依赖注入，那么只需要把拿到的 IMapper 加入即可。如果希望两个类型之间能够双向映射，那么在初始化 IMapper 的时候也应该再额外调用一下 ReverseMap 方法，否则就会抛出异常 AutoMapper.AutoMapperMappingException:“Missing type map configuration or unsupported mapping.”。cfg.CreateMap&amp;lt;Walterlv1Dao, Walterlv1Vo&amp;gt;().ReverseMap();复杂类型和集合现在，我们让模型稍复杂一些：public class Walterlv1Dao{ public string? Id { get; set; } public string? Name { get; set; } public FriendDao? Friend { get; set; }}public class FriendDao{ public string? Id { get; set; } public string? Name { get; set; }}public class Walterlv1Vo{ public string? Id { get; set; } public string? Name { get; set; } public FriendVo? Friend { get; set; }}public class FriendVo{ public string? Id { get; set; } public string? Name { get; set; }}AutoMapper 能处理这样的属性嵌套情况，只需要设置嵌套类型也能映射即可：cfg.CreateMap&amp;lt;Walterlv1Dao, Walterlv1Vo&amp;gt;().ReverseMap();cfg.CreateMap&amp;lt;FriendDao, FriendVo&amp;gt;().ReverseMap();如果两个模型中子模型的类型是一样的，那么只会进行简单的赋值，而不会创建新的对象。例如上面例子里，如果 FriendDao 和 FriendVo 合并成 Friend 类型，两个类型都使用这个合并的类型，那么映射之后，Friend 将是同一个对象。除了复杂类型，列表也是可以的：public class Walterlv1Dao{ public string? Id { get; set; } public string? Name { get; set; } public List&amp;lt;FriendDao&amp;gt;? Friend { get; set; }}public class Walterlv1Vo{ public string? Id { get; set; } public string? Name { get; set; } public List&amp;lt;FriendVo&amp;gt;? Friend { get; set; }}参考资料 AutoMapper/AutoMapper: A convention-based object-object mapper in .NET." }, { "title": "解决 WPF 分组的 ItemsControl 内部控件无法被 UI 自动化识别的问题", "url": "/post/wpf-items-control-supports-ui-automation", "categories": "wpf, dotnet, windows", "tags": "", "date": "2022-09-20 11:17:10 +0800", "snippet": "如果你试图给 WPF 的 ItemsControl 加入自动化识别，或者支持无障碍使用，会发现 ItemsControl 内的元素如果进行了分组，则只能识别到组而不能识别到元素本身。如果你正试图解决这个问题，那么本文正好能给你答案。现象现在，我们在 ItemsControl 的内部放几个按钮并进行分组。用自动化软件去捕获它，会发现整个 ItemsControl 会被视为一个控件（如下图上方），而我们期望的是像下图下方那样可识别到内部的每一个按钮。这个例子的最简示例我已经开源到 GitHub 上了，感兴趣可以自行去看看： https://github.com/walterlv/Walterlv.WpfIssues.ItemsControlAutomationIssue官方推荐的解决方法（但有 bug，无效）官方其实有一个开关 Switch.System.Windows.Controls.ItemsControlDoesNotSupportAutomation 解决这个问题。但是自 .NET Framework 4.7 开始直到 .NET 6 正式版，这个开关实际上一直都不会生效。关于如何打开这个开关，可以查看林德熙的博客：https://blog.lindexi.com/post/WPF-Application-Compatibility-switches-list.html#switchsystemwindowscontrolsitemscontroldoesnotsupportautomation关于这个 bug，我已经向微软官方 GitHub 仓库提了： https://github.com/dotnet/wpf/issues/6861后面我会解释原因。但是现在我们需要换一个新的方法来解决它。临时解决方案（在官方 bug 修掉之前是最好方案）在你的项目中增加一个自己实现的 ItemsControl，源码如下：namespace Walterlv.Windows.Controls;// The fixed version of the ItemsControl.public class FixedItemsControl : ItemsControl{ protected override AutomationPeer OnCreateAutomationPeer() { return new ItemsControlWrapperAutomationPeer(this); } private sealed class ItemsControlWrapperAutomationPeer : ItemsControlAutomationPeer { public ItemsControlWrapperAutomationPeer(ItemsControl owner) : base(owner) { } protected override ItemAutomationPeer CreateItemAutomationPeer(object item) { return new ItemsControlItemAutomationPeer(item, this); } protected override string GetClassNameCore() { return &quot;ItemsControl&quot;; } protected override AutomationControlType GetAutomationControlTypeCore() { return AutomationControlType.List; } } private class ItemsControlItemAutomationPeer : ItemAutomationPeer { public ItemsControlItemAutomationPeer(object item, ItemsControlWrapperAutomationPeer parent) : base(item, parent) { } protected override AutomationControlType GetAutomationControlTypeCore() { return AutomationControlType.DataItem; } protected override string GetClassNameCore() { return &quot;ItemsControlItem&quot;; } }}在你项目里原本需要使用到 ItemsControl 的地方，都换成以上这个修复版的 FixedItemsControl 就可以解决问题。官方开关不生效的原因会出现这个原因，是因为 ItemsControl 内部元素分组后，元素会在 GroupItem 中，GroupItem 重写了 OnCreateAutomationPeer 方法并返回了 GroupItemAutomationPeer 的实例。在其 GetChhildrenCore 方法中会试图从 ItemsControl 中获取它的 ItemsControlAutomationPeer 以返回子节点。然而在这段代码中，itemsControl.CreateAutomationPeer() 始终返回 null，所以永远没有子节点。// GroupItemAutomationPeer.csprotected override List&amp;lt;AutomationPeer&amp;gt; GetChildrenCore(){ GroupItem owner = (GroupItem)Owner; ItemsControl itemsControl = ItemsControl.ItemsControlFromItemContainer(Owner); if (itemsControl != null) { ItemsControlAutomationPeer itemsControlAP = itemsControl.CreateAutomationPeer() as ItemsControlAutomationPeer; if (itemsControlAP != null) { List&amp;lt;AutomationPeer&amp;gt; children = new List&amp;lt;AutomationPeer&amp;gt;(); // Ignore this code because in this case it will not be executed. return children; } } return null;}那 ItemsControl 的 CreateAutomationPeer 是怎么实现的呢？直接靠 UIElement 基类来实现。可以发现，它单独对 ItemsControl 判断了我们本文一开始所说的开关。按名称进行推测，ItemsControlDoesNotSupportAutomation 指“ItemsControl 不支持自动化”，也就是说我们需要将其设置为 false 才是让它支持自动化。但实际上这个值无论设置为 true 还是 false 都不会让自动化生效。// UIElement.csprotected virtual AutomationPeer OnCreateAutomationPeer(){ if (!AccessibilitySwitches.ItemsControlDoesNotSupportAutomation) { AutomationNotSupportedByDefaultField.SetValue(this, true); } return null;}假设设置为 true，那么上述方法直接返回 null 即不会生成自动化节点。显然不能解决问题。假设设置为 false，那么会设置一个标识位 AutomationNotSupportedByDefaultField 为 true。现在我们继续看与之相关的代码，即 UIElement 的 CreateAutomationPeer 方法。// UIElement.cs// Method: CreateAutomationPeerif (!AccessibilitySwitches.ItemsControlDoesNotSupportAutomation){ // work around (ItemsControl.GroupStyle doesn&#39;t show items in groups in the UIAutomation tree) AutomationNotSupportedByDefaultField.ClearValue(this); ap = OnCreateAutomationPeer(); // if this element returns an explicit peer (even null), use // it. But if it returns null by reaching the default method // above, give it a second chance to create a peer. // [This whole dance, including the UncommonField, would be // unnecessary once ItemsControl implements its own override // of OnCreateAutomationPeer.] if (ap == null &amp;amp;&amp;amp; !AutomationNotSupportedByDefaultField.GetValue(this)) { ap = OnCreateAutomationPeerInternal(); }}else{ ap = OnCreateAutomationPeer();}当 ItemsControlDoesNotSupportAutomation 标识设为 false 时，第一个 if 将进入，OnCreateAutomationPeer 将执行，然后将按前面的代码将 AutomationNotSupportedByDefaultField 标识设置为 true。这会导致第二个 if 不满足条件而退出，从而整个方法执行完毕——没有产生任何自动化节点。而就算将 ItemsControlDoesNotSupportAutomation 标识设为 true，进入了 else，OnCreateAutomationPeer 内部也不会返回自动化节点。于是，这个开关完全没有生效！官方正在解决在我查出以上原因之后，给官方提了此问题的修复方案，可以让这个开关正常工作。 https://github.com/dotnet/wpf/pull/6862目前这个方案正在审查中。但在官方合并之前，可以使用我在本文第二小节中提到的方案临时解决问题。" }, { "title": "如何让 WPF 程序更好地适配 UI 自动化", "url": "/post/wpf-app-supports-ui-automation-better", "categories": "wpf, dotnet, windows", "tags": "", "date": "2022-07-12 15:52:53 +0800", "snippet": "Windows 中很早就内置了 UI 自动化机制（UIAutomation 从 Windows XP SP3 就开始提供了），WPF 第一个版本开始也提供了 UI 自动化的支持。所以按道理说如果你使用了 WPF，那么你的 UI 做准备好了随时可被自动化的准备。虽说 WPF 支持不错，但我还是有几点需要说明一下： 这里我说的是“UI 自动化”，而不是“UI 自动化测试”；前者比后者范围更广泛，因为前者除了能用来做 UI 自动化测试之外，还能同时应用于读屏软件，为残障人士提供方便。 WPF 从机制层面提供了 UI 自动化的支持，但架不住很多不了解相关机制的人意外改坏，所以本文还是很有必要说一说的。接下来，我会从下面几个方面来说，只谈及使用层面，不深入到原理层面。WPF 自带的 UI 自动化为了方便演示，我使用 Visual Studio 自带的模板创建一个默认的 WPF 应用程序，我会不断修改这个程序，然后用我自己写的 UI 自动化测试软件来验证它的自动化适配效果。哪些控件自带完整的 UI 自动化Windows 上 UIAutomation 控件名 对应的 WPF 控件名 翻译 button Button 按钮 calendar Calendar 日历 checkbox CheckBox 检查框 combobox ComboBox 组合框 custom UserControl 自定义控件 datagrid DataGrid 数据表 dataitem DataItem 数据表项 document   文档 edit TextBox 文本框 group   组合 header   标题 headeritem   标题项 hyperlink   超链接 image Image 图像 list ListBox 列表 listitem ListBoxItem 列表项 menu Menu 菜单 menuitem MenuItem 菜单项 menubar   菜单栏 pane   容器 progressbar ProgressBar 进度条 radiobutton RadioButton 单选框 scrollbar ScrollBar 滚动调 separator Separator 分隔符 slider Slider 滑块 spinner   旋转器 splitbutton   拆分按钮 statusbar StatusBar 状态栏 tab TabControl 选项卡 tabitem TabItem 选项卡项 table   表格 text TextBlock 文本 thumb Thumb   titlebar   标题栏 toolbar ToolBar 工具栏 tooltip ToolTip 工具提示 tree TreeView 树视图 treeitem TreeViewItem 树视图项 window Window 窗口 额外的，在新的 Windows 系统（或者 UWP/WinUI 程序里）还存在另外两种支持 UI 自动化的全新控件类型： UIAutomation 控件名 对应的 WPF 控件名 翻译 semanticzoom SemanticZoom   appbar AppBar   不过从实际测试情况来看，微软自家都已经不用这两种特殊控件了，而是使用前面那些常用控件的组合来替代这两个特殊的控件。WPF 自带控件的支持情况为了直观地看到 WPF 每个自带控件对 UI 自动化的支持情况，我给刚刚创建的 WPF 程序添加了各种常见控件，然后用自己写的 UI 自动化测试软件捕获一下这个窗口。可以发现，WPF 自带控件给 UI 自动化正确暴露了各种需要的控件。至少，给盲人用的读屏软件能准确读出所有控件的文字描述。下面是这个直观的捕获视频：具体来说，WPF 默认情况下有这些特点： 所有可交互的控件，其整体可被捕获，而且各个可被交互的部分也可以分别被捕获（例如日历和内部按钮，树和内部的项，滚动条和内部按钮等）。 控件中变化的文字部分，也正确暴露给了 UI 自动化（例如按钮内的文本，列表项文本，菜单项等）。 容器与布局类的控件并没有暴露给 UI 自动化（例如 Grid、StackPanel、Border 等，并没有出现在自动化测试中）。 用户控件（UserControl）暴露给了 UI 自动化。默认情况下 WPF 属性与 UI 自动化属性的对应关系也许有人知道，WPF 有自动化相关的一套 API 用来适配 UI 自动化的。是一套附加属性，UIAutomationProperties.Xxx 这样的。比如： AutomationProperties.AutomationId AutomationProperties.Name 还有更多……但我们在编写控件的时候，其实并不需要主动、直接地去设置这些属性。虽然没有为这些附加属性设置值，但在暴露相关属性给 UI 自动化时，已经暴露了其他有用的属性。比如： 如果你设置了控件的名称 x:Name=&quot;WalterlvDemoButton&quot;，那么 UI 自动化在捕获到此控件后，其自动化 Id 就是 WalterlvDemoButton 了。 如果你设置了控件的内容（例如按钮/复选框/单选框/列表项的 Content，例如菜单项/选项卡的 Header），那么 UI 自动化在捕获到此控件后，其自动化 Name 就是对应指定的这些属性。 而且即使你没有任何设置，自动化 Class 名称就是控件的类名，IsEnabled 就对应了控件自身的 IsEnabled，IsVisible 也对应了控件自身的 IsVisible。在有了以上那么多特点作为保底的情况下，好好善用这些自带控件，做控件布局以及调整样式的时候正确按照控件原有的属性含义来做，是不需要专门针对 UI 自动化做任何适配的。然而，实际情况却并不是这样……哪些情况会破坏 WPF 的 UI 自动化很多时候，我们在写代码时，可能太过于关注最终做成了什么样子，而忽略了控件原本的层次结构和属性含义，这就可能导致我们的程序暴露给 UI 自动化测试的控件和层次结构十分诡异，甚至不可读。下面，我列举几个例子： 本来给按钮（Button）设置文本属性用的是 Content 属性，但某天想做很特别的样式，单独在模板（Template）里面写死了文本，而没有直接设置按钮的 Content 属性。这样 UI 自动化软件抓取此按钮的时候，就不知道这个按钮到底是做什么功能的按钮了，会抓到一个没有文本描述的按钮。 列表或树绑定了一个源（ItemsSource），而这个源集合中的每一个项都是 ViewModel 中的一项（例如 Walterlv.Demo.DemoItem 类型），这个类型没有重写 ToString 方法，于是列表项暴露给 UI 自动化的名称将是重复的毫无意义的字符串（例如都是 Walterlv.Demo.DemoItem）。 有些按钮或列表项没有任何文字描述，它们是完全由图像构成的控件。如果这个按钮还没有指定名称的话，那就跟任何其他同类按钮没有区分度了；而列表类控件在这种情况下基本无法暴露任何有用的信息。 有些控件明明是想做成可交互的，却偏偏用 Grid、Border 这种布局或装饰控件来做样式，最后用 MouseDown 这样的通用事件来做交互。这基本上等同于放弃了自带控件的所有 UI 自动化的支持。 自己做非常复杂的可交互控件（例如自己做一个画布），它继承自非常底层的 FrameworkElement。虽然这个控件指定了控件样式和模板，但它已经没有对 UI 自动化暴露任何有用的信息了。后面的 4 和 5 两种，UI 自动化甚至都无法捕获到这样的控件。毕竟 WPF 默认也不太好将全部控件暴露给 UI 自动化，否则对 UI 自动化测试软件或读屏软件来说，将面临着如 WPF 可视化树般复杂和庞大的 UI 自动化树。WPF 适配 UI 自动化的最佳实践在了解到 WPF UI 自动化的已有特点后，我们将以上的坑点一个个击破，就是我们推荐的最佳实践。 尽量保留 WPF 自带的 UI 自动化机制，避免对样式和模板做过于复杂的定制，如果要做，则尽可能使用现成常用的属性，而不是自己定义新属性（例如用好 Content 而不是定义一个新的 TitleText 之类的）。 如果某个 ViewModel 集合会被绑定到 UI 列表或树中，这个 ViewModel 应该重写 ToString() 方法，返回对用户可读的有用的信息（不要像控制台输出一样一股脑把所有属性打印出来）。 如果某个按钮或图像没有任何文本描述，请为其设置 x:Name 属性以增加一个唯一的 Id；更好地，可以设置 AutomationProperties.Name 附加属性指定一个友好的名称供视觉障碍人士阅读。 如果没有文字描述的按钮或图像在列表中，请为其设置 AutomationProperties.Id 属性绑定一个能区分彼此的信息作为唯一 Id，然后设置 AutomationProperties.Name 附加属性指定一个友好的名称供视觉障碍人士阅读。 尽量使用通用控件来做控件对应的交互（例如像一个按钮那就用按钮，像一个组合框那就用组合框），而不是使用 Grid、Border 等用来布局或装饰的控件来随意处理。 如果一定要做特别的控件交互（没有任何现有控件可以代表这个交互方式），那么充分利用用户控件（UserControl）会自动暴露给 UI 自动化的特点，做一个用户控件。相反地，如果你用用户控件仅仅只是为了拆分代码，就应该为此控件重写 OnCreateAutomationPeer 方法，返回 null 避免这个控件出现在 UI 自动化层级当中。 如果还希望特别交互的控件被复用（不适合用 UserControl），那么你需要为这个控件重写 OnCreateAutomationPeer 方法，返回一个合适的 AutomationPeer 的实例。// 对于上述第 6 点，应该为用户控件重写此方法。protected override AutomationPeer? OnCreateAutomationPeer(){ return null;}public class WalterlvDemoControl : FrameworkElement{ // 对于上述第 7 点，应该为用户控件重写此方法。 protected override AutomationPeer? OnCreateAutomationPeer() { return new WalterlvDemoAutomationPeer(this); }}// 自定义的 AutomationPeer。只需要继承自 FrameworkElementAutomationPeer 就可自动拥有大量现成自动化属性的支持。public class WalterlvDemoAutomationPeer : FrameworkElementAutomationPeer{ public WalterlvDemoAutomationPeer(WalterlvDemoControl demo) : base(demo) { } // 在 AutomationControlType 里找一个最能反应你所写控件交互类型的类型， // 准确返回类型可以让 UI 自动化软件针对性地做一些自动化操作（例如按钮的点击）， // 如果找不到类似的就说明是全新种类的控件，应返回 Custom。 protected override AutomationControlType GetAutomationControlTypeCore() { return AutomationControlType.Custom; } // 针对上面返回的类型，这里给一个本地化的控件类型名。 protected override string GetLocalizedControlTypeCore() { return &quot;吕毅的示例控件&quot;; } // 这里的文字就类似于按钮的 Content 属性一样，是给用户“看”的，可被读屏软件读出。 // 你可以考虑返回你某个自定义属性的值或某些自定义属性组合的值，而这个值最能向用户反映此控件当前的状态。 protected override string GetNameCore() { return &quot;吕毅在 https://blog.walterlv.com 中展示的博客文本。&quot;; }}给一个几乎都是图像组成的 ListBox 的 UI 自动化适配例子。在下面动图中，如果完全没有适配，那么捕获的时候只会得到完全没有区分度的 ViewModel 的名称，也是就 ToString 默认生成的类名 Walterlv.Demo.ThemeItem。参考资料 UI Automation - Win32 apps - Microsoft Docs UI Automation Overview - .NET Framework - Microsoft Docs" }, { "title": "最简单的代码，让 WPF 支持响应式布局", "url": "/post/wpf-adaptive-ui-in-simplest-way.html", "categories": "", "tags": "wpf, dotnet", "date": "2022-07-11 09:49:42 +0800", "snippet": "响应式布局在各种现代的 UI 框架中不是什么新鲜的概念，基本都是内置支持。然而在古老的 WPF 框架中却并没有原生支持，后来虽然通过 Blend 自带的 Interactions 库实现了响应式布局，但生成的代码量太大了，而且需要引入额外的库。如果只是希望临时局部地方使用响应式布局，那么其实可以直接使用 WPF 内置的绑定机制来完成响应式布局。本文介绍如何使用。思路是在控件尺寸发生变更的时候更新控件的样式。而能容易实现这个的只有 Trigger 和 Setter 那一套。直接在控件上使用的 Trigger 只能使用 EventTrigger，因此我们需要编写能写更多种类 Trigger 的 Style。&amp;lt;Style x:Key=&quot;Style.Foo.WalterlvDemo&quot;&amp;gt; &amp;lt;Setter Property=&quot;Grid.Row&quot; Value=&quot;0&quot; /&amp;gt; &amp;lt;Setter Property=&quot;Grid.Column&quot; Value=&quot;0&quot; /&amp;gt; &amp;lt;Style.Triggers&amp;gt; &amp;lt;DataTrigger Value=&quot;True&quot; Binding=&quot;{Binding ActualHeight, ElementName=DemoWindow, Converter={StaticResource GreaterOrEqualsConverter}, ConverterParameter=640}&quot;&amp;gt; &amp;lt;Setter Property=&quot;Grid.Row&quot; Value=&quot;1&quot; /&amp;gt; &amp;lt;Setter Property=&quot;Grid.Column&quot; Value=&quot;1&quot; /&amp;gt; &amp;lt;/DataTrigger&amp;gt; &amp;lt;/Style.Triggers&amp;gt;&amp;lt;/Style&amp;gt;定义了一个样式，默认情况下，行列是 (0, 0)，当窗口宽度大于或等于 640 之后，行列换到 (1, 1)。这里我们需要一个大于或等于，以及小于的转换器。using System;using System.Collections.Generic;using System.Globalization;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Windows.Data;namespace Walterlv.Styles.Converters{ public class GreaterOrEqualsConverter : IValueConverter { public double Than { get; set; } public object Convert(object value, Type targetType, object parameter, CultureInfo culture) { if (value is double d) { return d &amp;gt;= Than; } else if (value is float f) { return f &amp;gt;= Than; } else if (value is ulong ul) { return ul &amp;gt;= Than; } else if (value is long l) { return l &amp;gt;= Than; } else if (value is uint ui) { return ui &amp;gt;= Than; } else if (value is int i) { return i &amp;gt;= Than; } else if (value is ushort us) { return us &amp;gt;= Than; } else if (value is short s) { return s &amp;gt;= Than; } else { return false; } } public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture) { throw new NotSupportedException(); } } public class LessConverter : IValueConverter { public double Than { get; set; } public object Convert(object value, Type targetType, object parameter, CultureInfo culture) { if (value is double d) { return d &amp;lt; Than; } else if (value is float f) { return f &amp;lt; Than; } else if (value is ulong ul) { return ul &amp;lt; Than; } else if (value is long l) { return l &amp;lt; Than; } else if (value is uint ui) { return ui &amp;lt; Than; } else if (value is int i) { return i &amp;lt; Than; } else if (value is ushort us) { return us &amp;lt; Than; } else if (value is short s) { return s &amp;lt; Than; } else { return false; } } public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture) { throw new NotSupportedException(); } }}如果你本身是写的基础控件的样式，那么绑定当然就跟本文一开始说的写法非常类似了。如果你需要写的是一般控件，可以考虑直接在控件里写 &amp;lt;Framework.Style /&amp;gt; 把样式内联进去。如果你写的是 DataTemplate，也一样是使用 DataTrigger 绑定。你也可以不绑定到窗口上，而绑定到控件本身上，使用 TemplatedParent 作为绑定的源即可。&amp;lt;DataTemplate&amp;gt; &amp;lt;DataTemplate.Resources&amp;gt; &amp;lt;local:LessConverter x:Key=&quot;LessThan60&quot; Than=&quot;60&quot; /&amp;gt; &amp;lt;/DataTemplate.Resources&amp;gt; &amp;lt;Grid&amp;gt; &amp;lt;Image x:Name=&quot;Icon&quot; /&amp;gt; &amp;lt;Rectangle x:Name=&quot;Mask&quot; Fill=&quot;Red&quot; /&amp;gt; &amp;lt;/Grid&amp;gt; &amp;lt;DataTemplate.Triggers&amp;gt; &amp;lt;DataTrigger Binding=&quot;{Binding ActualWidth, RelativeSource={RelativeSource TemplatedParent}, Converter={StaticResource LessThan60}}&quot; Value=&quot;True&quot;&amp;gt; &amp;lt;Setter TargetName=&quot;Icon&quot; Property=&quot;Grid.ColumnSpan&quot; Value=&quot;3&quot; /&amp;gt; &amp;lt;Setter TargetName=&quot;Mask&quot; Property=&quot;Visibility&quot; Value=&quot;Collapsed&quot; /&amp;gt; &amp;lt;/DataTrigger&amp;gt;&amp;lt;/DataTemplate&amp;gt;" }, { "title": "MSBuild/Roslyn 和 NuGet 的 100 个坑", "url": "/post/problems-of-msbuild-and-nuget.html", "categories": "", "tags": "msbuild, nuget, visualstudio, dotnet", "date": "2022-07-11 09:49:23 +0800", "snippet": "MSBuild 不愧是强大的编译器，它提供的扩展机制让你几乎可以编译任何类型的文件或项目；Roslyn 是全新编写的一套编译器，不过它保留了 MSBuild 的大部分机制；NuGet 是 .NET 生态系统中的包管理机制，被原生集成在新的 Microsoft.NET.Sdk 中。不过，他们的坑还是挺多的；本文就是他们 100 个坑的集合。系列博客这是兄弟篇中的一篇，关于 MSBuild/Roslyn 和 NuGet 的 100 个坑： MSBuild/Roslyn 和 NuGet 的 100 个坑由于这篇博客是大量坑的记录，所以是它建立在你已经对 MSBuild/Roslyn 和 NuGet 有一些了解的基础之上的。我摘取了一些入门系列文章，也许你可以通过阅读这些来了解下： 理解 C# 项目 csproj 文件格式的本质和编译流程 迁移 csproj 文件到基于 Microsoft.NET.Sdk 创建基于 MSBuild Task 的跨平台的 NuGet 工具包 创建基于命令行工具的跨平台的 NuGet 工具包当然还有更多，可以访问 https://walterlv.github.io/categories#nuget。100 个坑不可用的源NuGet 可以指定多个包源。既可以在 Visual Studio 中配置，也可以在配置文件中配置。&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;configuration&amp;gt; &amp;lt;packageSources&amp;gt; &amp;lt;add key=&quot;nuget.org&quot; value=&quot;https://api.nuget.org/v3/index.json&quot; protocolVersion=&quot;3&quot; /&amp;gt; &amp;lt;add key=&quot;Debug&quot; value=&quot;C:\\Users\\lvyi\\Desktop\\TroukawDerjalyem\\DejaiJacir\\bin&quot; /&amp;gt; &amp;lt;/packageSources&amp;gt; &amp;lt;disabledPackageSources&amp;gt; &amp;lt;add key=&quot;Microsoft Visual Studio Offline Packages&quot; value=&quot;true&quot; /&amp;gt; &amp;lt;/disabledPackageSources&amp;gt;&amp;lt;/configuration&amp;gt;不过，只要有任何一个源不可用，那么你任何一个项目都别想再成功还原（restore）包了。比如： 某个国外的源因为某些不可描述的原因无法连通 某个源暂时挂掉了，服务不可用 某个本地的源，文件夹不存在了是的，不管还有多少个或者，只要死了一个，还原都没有用了。这种情况，唯一的办法就是把那个不再可用的源从配置中删除，或者临时禁用掉出问题的源。不存在的版本（新版本已修复）如果某个包的特定版本在所有源中不存在，那么安装此包的项目再也无法更新或者卸载此包了（也就别想再编译通过了）。不过目前这种问题只存在于旧的 packages.config 形式的 NuGet 包管理系统中。如果已经升级成 PackageReference，那么就没有这个问题了。编译不通过后无法安装和更新 NuGet 包有些情况下，会因为项目没有办法完成编译导致无法安装和更新某些 NuGet 包；但编译不通过其实就是这个 NuGet 包导致的（比如某个测试包）。大面积注释确保编译通过虽然说是一种可以尝试的手段，但毕竟还是太低效了。这时，通过手工修改项目文件来实现手工更新 NuGet 包不失为一种尝试手段。项目文件 Sdk 的来回切换MSBuild 15.0 为项目文件的根节点 Project 带来了 Sdk 属性，也就是说 Visual Studio 2017 开始支持。将 WPF、UWP 以及其他各种类型的旧 csproj 迁移成 Sdk 风格的 csproj 一文讲述了如何为项目文件添加 Sdk 属性，以便项目能够体验到最新的 Microsoft.NET.Sdk 编译体验。其中的 NuGet 原生支持是非常清爽的。升级时很清爽，降级就不爽了！这种情况会发生在新分支中进行了项目文件升级，随后切换回之前的分支；这时相当于在降级。但是，降级时会编译不通过，并提示： Your project.json doesn’t have a runtimes section. You should add ‘“runtimes”: { “win”: { } }’ to your project.json and then re-run NuGet restore.其实这是只有新的项目文件才会出现的编译错误，而错误原因是 NuGet 的缓存文件中与包引用相关的信息已经不正确了，需要运行 nuget restore 或者 dotnet restore 重新更新此文件才行。但是，只有使用了 Sdk 风格的 csproj 文件才会在执行了此命令后重新生成正确的包引用缓存文件；原来的格式并不会生成此文件，也就是说，无法修复。唯一的解决办法就是清除项目中的所有 NuGet 缓存，使用 git clean -xdf。依赖的项目会自动转为依赖的 NuGet 包如果你给一个项目 A 打 NuGet 包，但这个项目引用此解决方案中的另一个项目 B。那么这时打包，NuGet 会认为 A 包依赖于 B 包。事实上，B 包极有可能是不存在的，也就是说，你打的 A 包并没有办法给大家正常使用。.nuget.g.props 和 .nuget.g.targets使用 Microsoft.NET.Sdk 作为 Sdk 的项目文件会自动在 obj 文件夹下生成 project.assets.json、$(ProjectName).csproj.nuget.cache、$(ProjectName).csproj.nuget.g.props 和 $(ProjectName).csproj.nuget.g.targets 文件；其中 .nuget.g.props 和 .nuget.g.targets 中生成了 Import 包中编译相关文件的代码。例如：&amp;lt;Project ToolsVersion=&quot;14.0&quot; xmlns=&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;&amp;gt; &amp;lt;ImportGroup Condition=&quot; &#39;$(ExcludeRestorePackageImports)&#39; != &#39;true&#39; &quot;&amp;gt; &amp;lt;Import Project=&quot;$(NuGetPackageRoot)walterlv.demo.tools\\3.0.27-alpha\\build\\Walterlv.Demo.Tools.targets&quot; Condition=&quot;Exists(&#39;$(NuGetPackageRoot)walterlv.demo.tools\\3.0.27-alpha\\build\\Walterlv.Demo.Tools.targets&#39;)&quot; /&amp;gt; &amp;lt;/ImportGroup&amp;gt;&amp;lt;/Project&amp;gt;然而，有时会出现包中的文件并没有 Import 成功的情况，或者已经 Import，但却不明原因的无法完成编译。（我的 Visual Studio 版本 2017.7.4，Microsoft.NET.Sdk 版本 2.1.300。）这时，把这两个文件重新在 csproj 中 Import 一次却能正常。具体来说是这样（Walterlv.Demo 是项目名称）：&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;Import Condition=&quot; Exists(&#39;obj\\Walterlv.Demo.csproj.nuget.g.props&#39;) &quot; Project=&quot;obj\\Walterlv.Demo.csproj.nuget.g.props&quot; /&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;TargetFramework&amp;gt;net45&amp;lt;/TargetFramework&amp;gt; &amp;lt;LanguageTargets&amp;gt;$(MSBuildToolsPath)\\Microsoft.CSharp.targets&amp;lt;/LanguageTargets&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;Import Condition=&quot; Exists(&#39;obj\\Walterlv.Demo.csproj.nuget.g.targets&#39;) &quot; Project=&quot;obj\\Walterlv.Demo.csproj.nuget.g.targets&quot; /&amp;gt;&amp;lt;/Project&amp;gt;这里我们不通过直接修改 obj\\Walterlv.Demo.csproj.nuget.g.props 和 obj\\Walterlv.Demo.csproj.nuget.g.targets 文件是因为这两个文件不在版本管理中；而且如果执行 nuget restore 或者 dotnet restore 后会重新生成。" }, { "title": "git subtree 不断增加的推送时间，解不玩的冲突！这篇文章应该能救你", "url": "/post/performance-of-git-subtree.html", "categories": "", "tags": "git", "date": "2022-07-11 09:49:07 +0800", "snippet": "原生 git 对于公共组件那种类型的子仓库的支持并不怎么好，就是那种某个子文件夹是一个另外的 git 仓库，并被多个 git 父仓库使用的形式。实际使用的感受甚至是“糟糕透了”。这种并不友好的子仓库支持可能与 git 的设计理念有关，不过，git 的开发者始终在打补丁以稍微优化这样的体验。不断增加的推送时间如果你曾经在大仓库试过 git subtree push，你一定为下面这张图感到抓狂：▲ 不断增加的推送时间注意到总提交数了吗？注意到正在计算的提交数的变化了吗？你估算一下全部推送完毕需要多久？2~3 小时是跑不了的了。最令人心痛的是，等待了 2~3 个小时之后，还有机会因为 Non-Fast-Forward 而遭受拒绝。walterlv@LVYI MINGW64 /c/Users/OpenSource/Walterlv.Demo (temp/migrate)$ git subtree push --prefix=SubFolder/Walterlv/ demo temp/from-maingit push using: demo temp/from-mainfatal: ambiguous argument &#39;cb0580bb6ee76fa96f5bc3c7095303f9a33f5834^0&#39;: unknown revision or path not in the working tree.Use &#39;--&#39; to separate paths from revisions, like this:&#39;git &amp;lt;command&amp;gt; [&amp;lt;revision&amp;gt;...] -- [&amp;lt;file&amp;gt;...]&#39;could not rev-parse split hash cb0580bb6ee76fa96f5bc3c7095303f9a33f5834 from commit 691c5a1531ff38d02cb62fa34c99231dbde050b3To gitlab.walterlv:cbb/walterlv.demo.git ! [rejected] 1d3913a2e0ec6e4c507dbe2baabae18ef4b8fab9 -&amp;gt; temp/from-main (non-fast-forward)error: failed to push some refs to &#39;git@gitlab.walterlv.com:cbb/walterlv.demo.git&#39;hint: Updates were rejected because a pushed branch tip is behind its remotehint: counterpart. Check out this branch and integrate the remote changeshint: (e.g. &#39;git pull ...&#39;) before pushing again.hint: See the &#39;Note about fast-forwards&#39; in &#39;git push --help&#39; for details.永远也解不完的冲突在下次执行 git subtree pull 的时候，不管两个仓库有什么样的新变化，只要两边的代码不一样——就是冲突。原因每次执行 subtree 的 push 命令的时候，总会重新为子目录生成新的提交。然而这造成了一些很麻烦的问题： 每个提交都需要重新计算，因此每次推送都需要把主仓库所有的提交计算一遍，非常耗时； 每次 push 都是重新计算的，因此本地和远端新仓库的提交总是不一样的，关键还没有共同的父级，这导致 git 无法自动为我们解决冲突。解决git subtree 提供了 split 命令，官方对此的描述是： Extract a new, synthetic project history from the history of the subtree. The new history includes only the commits (including merges) that affected , and each of those commits now has the contents of at the root of the project instead of in a subdirectory. Thus, the newly created history is suitable for export as a separate git repository. After splitting successfully, a single commit id is printed to stdout. This corresponds to the HEAD of the newly created tree, which you can manipulate however you want. Repeated splits of exactly the same history are guaranteed to be identical (ie. to produce the same commit ids). Because of this, if you add new commits and then re-split, the new commits will be attached as commits on top of the history you generated last time, so ‘git merge’ and friends will work as expected. Note that if you use ‘–squash’ when you merge, you should usually not just ‘–rejoin’ when you split.意思是说，当使用了 split 命令后，git subtree 将确保对于相同历史的分割始终是相同的提交号。于是，当需要 push 的时候，git 将只计算 split 之后的新提交；并且下次 split 的时候，以前相同的历史纪录将得到相同的 git 提交号。$ git subtree split --rejoin --prefix=SubDir/ HEAD参考资料 git-subtree pull merge conflict - Stack Overflow git - Reduce increasing time to push a subtree - Stack Overflow git-subtree/git-subtree.txt at master · apenwarr/git-subtree" }, { "title": "git fetch 失败，因为 unable to resolve reference &#39;refs/remotes/origin/xxx&#39;: reference broken", "url": "/post/git-fetch-failed-for-reference-broken.html", "categories": "", "tags": "git", "date": "2022-05-30 09:07:35 +0800", "snippet": "我在使用 git fetch 命令的时候，发现竟然会失败，提示错误 error: cannot lock ref &#39;refs/remotes/origin/xxx&#39;: unable to resolve reference &#39;refs/remotes/origin/xxx&#39;: reference broken。本文介绍如何修复这样的错误，并探索此错误产生的原因。错误在使用 git fetch 命令之后，发现竟然出现了错误，错误输出如下：$ git fetch --all --pruneFetching originerror: cannot lock ref &#39;refs/remotes/origin/next/release&#39;: unable to resolve reference &#39;refs/remotes/origin/next/release&#39;: reference brokenFrom git***.***.com:walterlv/demo-project ! [new branch] next/release -&amp;gt; origin/next/release (unable to update local ref)error: cannot lock ref &#39;refs/remotes/origin/feature/ai&#39;: unable to resolve reference &#39;refs/remotes/origin/feature/ai&#39;: reference broken ! [new branch] feature/ai -&amp;gt; origin/feature/ai (unable to update local ref)error: cannot lock ref &#39;refs/remotes/origin/release&#39;: unable to resolve reference &#39;refs/remotes/origin/release&#39;: reference broken ! [new branch] release -&amp;gt; origin/release (unable to update local ref)error: Could not fetch origin修复前往仓库路径，然后删除这些分支对应的文件。 前往仓库所在的本地文件夹； 进入子目录 .git\\refs\\remotes； 一个个对着上面失败的分支，将其删除。比如在我的错误例子中，要删除的文件分别是： .git\\refs\\remotes\\origin\\next\\release .git\\refs\\remotes\\origin\\feature\\ai .git\\refs\\remotes\\origin\\release随后，重新尝试 git fetch，git 会重新生成这些分支文件，因此不用担心会删出问题：$ git fetch --all --pruneFetching originFrom gitlab.walterlv.com:t/app/demo a1fd2551f7..cfb662e870 next/release -&amp;gt; origin/next/release * [new branch] feature/ai -&amp;gt; origin/feature/ai 97d72dfc8f..ceb346c8e2 release -&amp;gt; origin/release" }, { "title": "使用 Roslyn 分析代码注释，给 TODO 类型的注释添加负责人、截止日期和 issue 链接跟踪", "url": "/post/comment-analyzer-and-code-fix-using-roslyn.html", "categories": "", "tags": "roslyn, visualstudio, nuget, dotnet, csharp", "date": "2022-05-17 17:35:43 +0800", "snippet": "如果某天改了一点代码但是没有完成，我们可能会在注释里面加上 // TODO。如果某个版本为了控制影响范围临时使用不太合适的方法解了 Bug，我们可能也会在注释里面加上 // TODO。但是，对于团队项目来说，一个人写的 TODO 可能过了一段时间就淹没在大量的 TODO 堆里面了。如果能够强制要求所有的 TODO 被跟踪，那么代码里面就比较容易能够控制住 TODO 的影响了。本文将基于 Roslyn 开发代码分析器，要求所有的 TODO 注释具有可被跟踪的负责人等信息。预备知识如果你对基于 Roslyn 编写分析器和代码修改器不了解，建议先阅读我的一篇入门教程： 基于 Roslyn 同时为 Visual Studio 插件和 NuGet 包开发 .NET/C# 源代码分析器 Analyzer 和修改器 CodeFixProvider - walterlv分析器我们先准备一些公共的信息：namespace Walterlv.Demo{ internal static class DiagnosticIds { /// &amp;lt;summary&amp;gt; /// 标记了待办事项的代码必须被追踪。WAL 是我名字（walterlv）的前三个字母。 /// &amp;lt;/summary&amp;gt; public const string TodoMustBeTracked = &quot;WAL302&quot;; }}在后面的代码分析器和修改器中，我们将都使用此公共的字符串常量来作为诊断 Id。我们先添加分析器（TodoMustBeTrackedAnalyzer）最基础的代码：[DiagnosticAnalyzer(LanguageNames.CSharp)]public class TodoMustBeTrackedAnalyzer : DiagnosticAnalyzer{ private static readonly DiagnosticDescriptor Rule = new DiagnosticDescriptor( DiagnosticIds.TodoMustBeTracked, &quot;任务必须被追踪&quot;, &quot;未完成的任务缺少负责人和完成截止日期：{0}&quot;, &quot;Maintainability&quot;, DiagnosticSeverity.Error, isEnabledByDefault: true, description: &quot;未完成的任务必须有对应的负责人和截止日期（// TODO @lvyi 2019-08-01），最好有任务追踪系统（如 JIRA）跟踪。&quot;); public override ImmutableArray&amp;lt;DiagnosticDescriptor&amp;gt; SupportedDiagnostics =&amp;gt; ImmutableArray.Create(Rule); public override void Initialize(AnalysisContext context) =&amp;gt; context.RegisterSyntaxTreeAction(AnalyzeSingleLineComment); private void AnalyzeSingleLineComment(SyntaxTreeAnalysisContext context) { // 这里将是我们分析器的主要代码。 }}接下来我们则是要完善语法分析的部分，我们需要找到单行注释和多行注释。注释在语法节点中不影响代码含义，这些不影响代码含义的语法部件被称作 Trivia（闲杂部件）。这跟我前面入门教程部分说的语法节点不同，其 API 会少一些，但也更加简单。我们从语法树的 DescendantTrivia 方法中可以拿到文档中的所有的 Trivia 然后过滤掉获得其中的注释部分。比如，我们要分析下面的这个注释：// TODO 林德熙在这个版本写的逗比代码，下个版本要改掉。在语法节点中判断注释的袋子性，然后使用正则表达式匹配 TODO、负责人以及截止日期即可。private static readonly Regex TodoRegex = new Regex(@&quot;//\\s*todo&quot;, RegexOptions.Compiled | RegexOptions.IgnoreCase);private static readonly Regex AssigneeRegex = new Regex(@&quot;@\\w+&quot;, RegexOptions.Compiled);private static readonly Regex DateRegex = new Regex(@&quot;[\\d]{4}\\s?[年\\-\\.]\\s?[01]?[\\d]\\s?[月\\-\\.]\\s?[0123]?[\\d]\\s?日?&quot;, RegexOptions.Compiled);private void AnalyzeSingleLineComment(SyntaxTreeAnalysisContext context){ var root = context.Tree.GetRoot(); foreach (var comment in root.DescendantTrivia() .Where(x =&amp;gt; x.IsKind(SyntaxKind.SingleLineCommentTrivia) || x.IsKind(SyntaxKind.MultiLineCommentTrivia))) { var value = comment.ToString(); var todoMatch = TodoRegex.Match(value); if (todoMatch.Success) { var assigneeMatch = AssigneeRegex.Match(value); var dateMatch = DateRegex.Match(value); if (!assigneeMatch.Success || !dateMatch.Success) { var diagnostic = Diagnostic.Create(Rule, comment.GetLocation(), value); context.ReportDiagnostic(diagnostic); } } }}将上面的类组装起来运行 Visual Studio 调试即可看到效果。没有负责人和截止日期的 TODO 注释将报告编译错误。TodoMustBeTrackedAnalyzer 类型的完整代码如下：using System;using System.Collections.Immutable;using System.Linq;using System.Text.RegularExpressions;using Walterlv.Demo;using Microsoft.CodeAnalysis;using Microsoft.CodeAnalysis.CSharp;using Microsoft.CodeAnalysis.CSharp.Syntax;using Microsoft.CodeAnalysis.Diagnostics;namespace Walterlv.Analyzers.Maintainability{ [DiagnosticAnalyzer(LanguageNames.CSharp)] public class TodoMustBeTrackedAnalyzer : DiagnosticAnalyzer { private static readonly LocalizableString Title = &quot;任务必须被追踪&quot;; private static readonly LocalizableString MessageFormat = &quot;未完成的任务缺少负责人和完成截止日期：{0}&quot;; private static readonly LocalizableString Description = &quot;未完成的任务必须有对应的负责人和截止日期（// TODO @lvyi 2019-08-01），最好有任务追踪系统（如 JIRA）跟踪。&quot;; private static readonly Regex TodoRegex = new Regex(@&quot;//\\s*todo&quot;, RegexOptions.Compiled | RegexOptions.IgnoreCase); private static readonly Regex AssigneeRegex = new Regex(@&quot;@\\w+&quot;, RegexOptions.Compiled); private static readonly Regex DateRegex = new Regex(@&quot;[\\d]{4}\\s?[年\\-\\.]\\s?[01]?[\\d]\\s?[月\\-\\.]\\s?[0123]?[\\d]\\s?日?&quot;, RegexOptions.Compiled); private static readonly DiagnosticDescriptor Rule = new DiagnosticDescriptor( DiagnosticIds.TodoMustBeTracked, Title, MessageFormat, Categories.Maintainability, DiagnosticSeverity.Error, isEnabledByDefault: true, description: Description); public override ImmutableArray&amp;lt;DiagnosticDescriptor&amp;gt; SupportedDiagnostics =&amp;gt; ImmutableArray.Create(Rule); public override void Initialize(AnalysisContext context) { context.EnableConcurrentExecution(); context.ConfigureGeneratedCodeAnalysis(GeneratedCodeAnalysisFlags.Analyze | GeneratedCodeAnalysisFlags.ReportDiagnostics); context.RegisterSyntaxTreeAction(AnalyzeSingleLineComment); } private void AnalyzeSingleLineComment(SyntaxTreeAnalysisContext context) { var root = context.Tree.GetRoot(); foreach (var comment in root.DescendantTrivia() .Where(x =&amp;gt; x.IsKind(SyntaxKind.SingleLineCommentTrivia) || x.IsKind(SyntaxKind.MultiLineCommentTrivia))) { var value = comment.ToString(); var todoMatch = TodoRegex.Match(value); if (todoMatch.Success) { var assigneeMatch = AssigneeRegex.Match(value); var dateMatch = DateRegex.Match(value); if (!assigneeMatch.Success || !dateMatch.Success) { var diagnostic = Diagnostic.Create(Rule, comment.GetLocation(), value); context.ReportDiagnostic(diagnostic); } } } } }}代码修改器只是报错的话，开发者看到错误可能会一脸懵逼，因为从未见过注释还会报告编译错误的，不知道怎么改。于是我们需要编写一个代码修改器以便自动完成注释的修改，添加负责人和截止日期。我这里代码修改器修改后的结果就像下面这样：生成一个新的注释字符串然后替换即可：using System;using System.Collections.Immutable;using System.Composition;using System.Linq;using System.Text.RegularExpressions;using System.Threading;using System.Threading.Tasks;using Walterlv.Demo;using Microsoft.CodeAnalysis;using Microsoft.CodeAnalysis.CodeActions;using Microsoft.CodeAnalysis.CodeFixes;using Microsoft.CodeAnalysis.CSharp;namespace Walterlv.Analyzers.Maintainability{ [ExportCodeFixProvider(LanguageNames.CSharp, Name = nameof(TodoMustBeTrackedCodeFixProvider)), Shared] public class TodoMustBeTrackedCodeFixProvider : CodeFixProvider { private const string Title = &quot;添加任务负责人 / 完成日期 / JIRA Id 追踪&quot;; private static readonly Regex AssigneeRegex = new Regex(@&quot;@\\w+&quot;, RegexOptions.Compiled); private static readonly Regex DateRegex = new Regex(@&quot;[\\d]{4}\\s?[年\\-\\.]\\s?[01]?[\\d]\\s?[月\\-\\.]\\s?[0123]?[\\d]\\s?日?&quot;, RegexOptions.Compiled); public sealed override ImmutableArray&amp;lt;string&amp;gt; FixableDiagnosticIds =&amp;gt; ImmutableArray.Create(DiagnosticIds.TodoMustBeTracked); public sealed override FixAllProvider GetFixAllProvider() =&amp;gt; WellKnownFixAllProviders.BatchFixer; public sealed override Task RegisterCodeFixesAsync(CodeFixContext context) { var diagnostic = context.Diagnostics.First(); context.RegisterCodeFix(CodeAction.Create( Title, c =&amp;gt; FormatTrackableTodoAsync(context.Document, diagnostic, c), nameof(TodoMustBeTrackedCodeFixProvider)), diagnostic); return Task.CompletedTask; } private async Task&amp;lt;Document&amp;gt; FormatTrackableTodoAsync( Document document, Diagnostic diagnostic, CancellationToken cancellationToken) { var root = await document.GetSyntaxRootAsync(cancellationToken).ConfigureAwait(false); var oldTrivia = root.FindTrivia(diagnostic.Location.SourceSpan.Start); var oldComment = oldTrivia.ToString(); if (oldComment.Length &amp;gt; 3) { oldComment = oldComment.Substring(2).Trim(); if (oldComment.StartsWith(&quot;todo&quot;, StringComparison.CurrentCultureIgnoreCase)) { oldComment = oldComment.Substring(4).Trim(); } } var comment = $&quot;// TODO @{Environment.UserName} {DateTime.Now:yyyy年M月d日} {oldComment}&quot;; var newTrivia = SyntaxFactory.ParseTrailingTrivia(comment); var newRoot = root.ReplaceTrivia(oldTrivia, newTrivia); return document.WithSyntaxRoot(newRoot); } }}如果你觉得编写生成代码的语法树很麻烦，可以使用使用 林晓lx 的 RoslynSyntaxTool 工具互相转换 C# 代码与语法树代码。" }, { "title": "基于 Roslyn 同时为 Visual Studio 插件和 NuGet 包开发 .NET/C# 源代码分析器 Analyzer 和修改器 CodeFixProvider", "url": "/post/develop-a-code-analyzer-for-both-nuget-and-visual-studio-extension.html", "categories": "", "tags": "roslyn, visualstudio, nuget, dotnet, csharp", "date": "2022-05-17 17:35:16 +0800", "snippet": "Roslyn 是 .NET 平台下十分强大的编译器，其提供的 API 也非常丰富好用。本文将基于 Roslyn 开发一个 C# 代码分析器，你不止可以将分析器作为 Visual Studio 代码分析和重构插件发布，还可以作为 NuGet 包发布。不管哪一种，都可以让我们编写的 C# 代码分析器工作起来并真正起到代码建议和重构的作用。本文将教大家如何从零开始开发一个基于 Roslyn 的 C# 源代码分析器 Analyzer 和修改器 CodeFixProvider。可以作为 Visual Studio 插件安装和使用，也可以作为 NuGet 包安装到项目中使用（无需安装插件）。无论哪一种，你都可以在支持 Roslyn 分析器扩展的 IDE（如 Visual Studio）中获得如下面动图所展示的效果。开发准备安装 Visual Studio 扩展开发工作负载你需要先安装 Visual Studio 的扩展开发工作负载，如果你还没有安装，那么请先阅读以下博客安装： 如何安装和准备 Visual Studio 扩展/插件开发环境创建一个分析器项目启动 Visual Studio，新建项目，然后在项目模板中找到 “Analyzer with Code Fix (.NET Standard)”，下一步。随后，取好项目名字之后，点击“创建”，你将来到 Visual Studio 的主界面。我为项目取的名称是 Walterlv.Demo.Analyzers，接下来都将以此名称作为示例。你如果使用了别的名称，建议你自己找到名称的对应关系。在创建完项目之后，你可选可以更新一下项目的 .NET Standard 版本（默认是 1.3，建议更新为 2.0）以及几个 NuGet 包。首次调试如果你现在按下 F5，那么将会启动一个 Visual Studio 的实验实例用于调试。由于我们是一个分析器项目，所以我们需要在第一次启动实验实例的时候新建一个专门用来测试的小型项目。简单起见，我新建一个 .NET Core 控制台项目。新建的项目如下：我们目前只是基于模板创建了一个分析器，而模板中自带的分析器功能是 “只要类型名称中有任何一个字符是小写的，就给出建议将其改为全部大写”。于是我们看到 Program 类名底下标了绿色的波浪线，我们将光标定位到 Program 类名上，可以看到出现了一个 “小灯泡” 提示。按下重构快捷键（默认是 Ctrl + .）后可以发现，我们的分析器项目提供的 “Make uppercase” 建议显示了出来。于是我们可以快速地将类名修改为全部大写。因为我们在前面安装了 Visual Studio 扩展开发的工作负载，所以可以在 “视图”-&amp;gt;“其他窗口” 中找到并打开 Syntax Visualizer 窗格。现在，请将它打开，因为接下来我们的代码分析会用得到这个窗格。如果体验完毕，可以关闭 Visual Studio；当然也可以在我们的分析器项目中 Shift + F5 强制结束调试。下次调试的时候，我们不需要再次新建项目了，因为我们刚刚新建的项目还在我们新建的文件夹下。下次调试只要像下面那样再次打开这个项目测试就好了。解读模板自带的分析器项目项目和解决方案在创建完项目之后，你会发现解决方案中有三个项目： Walterlv.Demo.Analyzers 分析器主项目，我们接下来分析器的主要逻辑代码都在这个项目中 这个项目在编译成功之后会生成一个 NuGet 包，安装了此包的项目将会运行我们的分析器 Walterlv.Demo.Analyzers.Vsix Visual Studio 扩展项目，我们会在这里 Visual Studio 插件相关的信息 这个项目在便已成功之后会生成一个 Visual Studio 插件安装包，Visual Studio 安装了此插件后将会对所有正在编辑的项目运行我们的分析器 这个项目在默认情况下是启动项目（按下 F5 会启动这个项目调试），调试时会启动一个 Visual Studio 的实验实例 Walterlv.Demo.Analyzers.Test 单元测试项目 模板为我们生成了比较多的辅助代码帮助我们快速编写用于测试我们分析器可用性的单元测试，我们接下来的代码质量也靠这个来保证 在项目内部： WalterlvDemoAnalyzersAnalyzer.cs 模板中自带的分析器（Analyzer）的主要代码 我们什么都还没有写的时候，里面已经包含一份示例用的分析器，其功能是找到包含小写的类名。 WalterlvDemoAnalyzersCodeFixProvider.cs 模板中自带的代码修改器（CodeFixProvider）的主要代码 我们什么都还没有写的时候，里面已经包含一份示例用的代码修改器，根据前面分析器中找到的诊断信息，给出修改建议，即只要类型名称中有任何一个字符是小写的，就给出建议将其改为全部大写 Resources.resx 这里包含分析器建议使用的多语言信息 分析器代码（Analyzer）别看我们分析器文件中的代码很长，但实际上关键的信息并不多。我们现在还没有自行修改 WalterlvDemoAnalyzersAnalyzer 类中的任何内容，而到目前位置这个类里面包含的最关键代码我提取出来之后是下面这些。为了避免你吐槽这些代码编译不通过，我将一部分的实现替换成了 NotImplementedException。[DiagnosticAnalyzer(LanguageNames.CSharp)]public class WalterlvDemoAnalyzersAnalyzer : DiagnosticAnalyzer{ public override ImmutableArray&amp;lt;DiagnosticDescriptor&amp;gt; SupportedDiagnostics =&amp;gt; throw new NotImplementedException(); public override void Initialize(AnalysisContext context) =&amp;gt; throw new NotImplementedException();}最关键的点： [DiagnosticAnalyzer(LanguageNames.CSharp)] 为 C# 语言提供诊断分析器 override SupportedDiagnostics 返回此分析器支持的诊断规则 override Initialize 在此分析器初始化的时候执行某些代码 现在我们分别细化这些关键代码。为了简化理解，我将多语言全部替换成了实际的字符串值。重写 SupportedDiagnostics 的部分，创建并返回了一个 DiagnosticDescriptor 类型的只读集合。目前只有一个 DiagnosticDescriptor，名字是 Rule，构造它的时候传入了一大堆字符串，包括分析器 Id、标题、消息提示、类型、级别、默认开启、描述信息。可以很容易看出，如果我们这个分析器带有多个诊断建议，那么在只读集合中返回多个 DiagnosticDescriptor 的实例。public const string DiagnosticId = &quot;WalterlvDemoAnalyzers&quot;;private static readonly LocalizableString Title = &quot;Type name contains lowercase letters&quot;;private static readonly LocalizableString MessageFormat = &quot;Type name &#39;{0}&#39; contains lowercase letters&quot;;private static readonly LocalizableString Description = &quot;Type names should be all uppercase.&quot;;private const string Category = &quot;Naming&quot;;private static DiagnosticDescriptor Rule = new DiagnosticDescriptor(DiagnosticId, Title, MessageFormat, Category, DiagnosticSeverity.Warning, isEnabledByDefault: true, description: Description);public override ImmutableArray&amp;lt;DiagnosticDescriptor&amp;gt; SupportedDiagnostics =&amp;gt; ImmutableArray.Create(Rule);重写 Initialize 的部分，模板中注册了一个类名分析器，其实就是下面那个静态方法 AnalyzeSymbol。public override void Initialize(AnalysisContext context){ context.RegisterSymbolAction(AnalyzeSymbol, SymbolKind.NamedType);}private static void AnalyzeSymbol(SymbolAnalysisContext context){ // 省略实现。 // 在模板自带的实现中，这里判断类名是否包含小写字母，如果包含则创建一个新的诊断建议以改为大写字母。}代码修改器（CodeFixProvider）代码修改器文件中的代码更长，但关键信息也没有增加多少。我们现在也没有自行修改 WalterlvDemoAnalyzersCodeFixProvider 类中的任何内容，而到目前位置这个类里面包含的最关键代码我提取出来之后是下面这些。为了避免你吐槽这些代码编译不通过，我将一部分的实现替换成了 NotImplementedException。[ExportCodeFixProvider(LanguageNames.CSharp, Name = nameof(WalterlvDemoAnalyzersCodeFixProvider)), Shared]public class WalterlvDemoAnalyzersCodeFixProvider : CodeFixProvider{ public sealed override ImmutableArray&amp;lt;string&amp;gt; FixableDiagnosticIds =&amp;gt; throw new NotImplementedException(); public sealed override FixAllProvider GetFixAllProvider() =&amp;gt; WellKnownFixAllProviders.BatchFixer; public sealed override async Task RegisterCodeFixesAsync(CodeFixContext context) =&amp;gt; throw new NotImplementedException();}最关键的点： [ExportCodeFixProvider(LanguageNames.CSharp, Name = nameof(WalterlvDemoAnalyzersCodeFixProvider)), Shared] 为 C# 语言提供代码修改器 override FixableDiagnosticIds 注意到前面 WalterlvDemoAnalyzersAnalyzer 类型中有一个公共字段 DiagnosticId 吗？在这里返回，可以为那里分析器找到的代码提供修改建议 override GetFixAllProvider 在最简单的示例中，我们将仅仅返回 BatchFixer，其他种类的 FixAllProvider 我将通过其他博客进行说明 override RegisterCodeFixesAsync 在 FixableDiagnosticIds 属性中我们返回的那些诊断建议这个方法中可以拿到，于是为每一个返回的诊断建议注册一个代码修改器（CodeFix） 在这个模板提供的例子中，FixableDiagnosticIds 返回了 WalterlvDemoAnalyzersAnalyzer 类中的公共字段 DiagnosticId：public sealed override ImmutableArray&amp;lt;string&amp;gt; FixableDiagnosticIds =&amp;gt; ImmutableArray.Create(WalterlvDemoAnalyzersAnalyzer.DiagnosticId);RegisterCodeFixesAsync 中找到我们在 WalterlvDemoAnalyzersAnalyzer 类中找到的一个 Diagnostic，然后对这个 Diagnostic 注册一个代码修改（CodeFix）。public sealed override async Task RegisterCodeFixesAsync(CodeFixContext context){ var root = await context.Document.GetSyntaxRootAsync(context.CancellationToken).ConfigureAwait(false); // TODO: Replace the following code with your own analysis, generating a CodeAction for each fix to suggest var diagnostic = context.Diagnostics.First(); var diagnosticSpan = diagnostic.Location.SourceSpan; // Find the type declaration identified by the diagnostic. var declaration = root.FindToken(diagnosticSpan.Start).Parent.AncestorsAndSelf().OfType&amp;lt;TypeDeclarationSyntax&amp;gt;().First(); // Register a code action that will invoke the fix. context.RegisterCodeFix( CodeAction.Create( title: title, createChangedSolution: c =&amp;gt; MakeUppercaseAsync(context.Document, declaration, c), equivalenceKey: title), diagnostic);}private async Task&amp;lt;Solution&amp;gt; MakeUppercaseAsync(Document document, TypeDeclarationSyntax typeDecl, CancellationToken cancellationToken){ // 省略实现。 // 将类名改为全大写，然后返回解决方案。}开发自己的分析器（Analyzer）一个简单的目标作为示例，我们写一个属性转换分析器，将自动属性转换为可通知属性。就是像以下上面的一种属性转换成下面的一种：public string Foo { get; set; }private string _foo;public string Foo{ get =&amp;gt; _foo; set =&amp;gt; SetValue(ref _foo, value);}这里我们写了一个 SetValue 方法，有没有这个 SetValue 方法存在对我们后面写的分析器其实没有任何影响。不过你如果强迫症，可以看本文最后的“一些补充”章节，把 SetValue 方法加进来。开始添加最基础的代码于是，我们将 Initialize 方法中的内容改成我们期望的分析自动属性的语法节点分析。public override void Initialize(AnalysisContext context) =&amp;gt; context.RegisterSyntaxNodeAction(AnalyzeAutoProperty, SyntaxKind.PropertyDeclaration);private void AnalyzeAutoProperty(SyntaxNodeAnalysisContext context){ // 你可以在这一行打上一个断点，这样你可以观察 `context` 参数。}上面的 AnalyzeAutoProperty 只是我们随便取的名字，而 SyntaxKind.PropertyDeclaration 是靠智能感知提示帮我找到的。现在我们来试着分析一个自动属性。按下 F5 调试，在新的调试的 Visual Studio 实验实例中，我们将鼠标光标放在 public string Foo { get; set; } 行上。如果我们提前在 AnalyzeAutoProperty 方法中打了断点，那么我们可以在此时观察到 context 参数。 CancellationToken 指示当前是否已取消分析 Node 语法节点 SemanticModel ContainingSymbol 语义分析节点 Compilation Options其中，Node.KindText 属性的值为 PropertyDeclaration。还记得前面让你先提前打开 Syntax Visualizer 窗格吗？是的，我们可以在这个窗格中找到 PropertyDeclaration 节点。我们可以借助这个语法可视化窗格，找到 PropertyDeclaration 的子节点。当我们一级一级分析其子节点的语法的时候，便可以取得这个语法节点的全部所需信息（可见性、属性类型、属性名称），也就是具备生成可通知属性的全部信息了。添加分析自动属性的代码由于我们在前面 Initialize 方法中注册了仅在属性声明语法节点的时候才会执行 AnalyzeAutoProperty 方法，所以我们在这里可以简单的开始报告一个代码分析 Diagnostic：var propertyNode = (PropertyDeclarationSyntax)context.Node;var diagnostic = Diagnostic.Create(_rule, propertyNode.GetLocation());context.ReportDiagnostic(diagnostic);现在，WalterlvDemoAnalyzersAnalyzer 类的完整代码如下：[DiagnosticAnalyzer(LanguageNames.CSharp)]public class WalterlvDemoAnalyzersAnalyzer : DiagnosticAnalyzer{ public const string DiagnosticId = &quot;WalterlvDemoAnalyzers&quot;; private static readonly LocalizableString _title = &quot;自动属性&quot;; private static readonly LocalizableString _messageFormat = &quot;这是一个自动属性&quot;; private static readonly LocalizableString _description = &quot;可以转换为可通知属性。&quot;; private const string _category = &quot;Usage&quot;; private static readonly DiagnosticDescriptor _rule = new DiagnosticDescriptor( DiagnosticId, _title, _messageFormat, _category, DiagnosticSeverity.Info, isEnabledByDefault: true, description: _description); public override ImmutableArray&amp;lt;DiagnosticDescriptor&amp;gt; SupportedDiagnostics =&amp;gt; ImmutableArray.Create(_rule); public override void Initialize(AnalysisContext context) =&amp;gt; context.RegisterSyntaxNodeAction(AnalyzeAutoProperty, SyntaxKind.PropertyDeclaration); private void AnalyzeAutoProperty(SyntaxNodeAnalysisContext context) { var propertyNode = (PropertyDeclarationSyntax)context.Node; var diagnostic = Diagnostic.Create(_rule, propertyNode.GetLocation()); context.ReportDiagnostic(diagnostic); }}可以发现代码并不多，现在运行，可以在光标落在属性声明的行时看到修改建议。如下图所示：你可能会觉得有些不满，看起来似乎只有我们写的那些标题和描述在工作。但实际上你还应该注意到这些： DiagnosticId、_messageFormat、_description 已经工作起来了； 只有光标在属性声明的语句块时，这个提示才会出现，因此说明我们的已经找到了正确的代码块了； 不要忘了我们还有个 CodeFixProvider 没有写呢，你现在看到的依然还在修改大小写的部分代码是那个类（WalterlvDemoAnalyzersCodeFixProvider）里的。开发自己的代码修改器（CodeFixProvider）现在，我们开始进行代码修改，将 WalterlvDemoAnalyzersCodeFixProvider 类改成我们希望的将属性修改为可通知属性的代码。[ExportCodeFixProvider(LanguageNames.CSharp, Name = nameof(WalterlvDemoAnalyzersCodeFixProvider)), Shared]public class WalterlvDemoAnalyzersCodeFixProvider : CodeFixProvider{ private const string _title = &quot;转换为可通知属性&quot;; public sealed override ImmutableArray&amp;lt;string&amp;gt; FixableDiagnosticIds =&amp;gt; ImmutableArray.Create(WalterlvDemoAnalyzersAnalyzer.DiagnosticId); public sealed override FixAllProvider GetFixAllProvider() =&amp;gt; WellKnownFixAllProviders.BatchFixer; public sealed override async Task RegisterCodeFixesAsync(CodeFixContext context) { var root = await context.Document.GetSyntaxRootAsync(context.CancellationToken).ConfigureAwait(false); var diagnostic = context.Diagnostics.First(); var declaration = (PropertyDeclarationSyntax)root.FindNode(diagnostic.Location.SourceSpan); context.RegisterCodeFix( CodeAction.Create( title: _title, createChangedSolution: ct =&amp;gt; ConvertToNotificationProperty(context.Document, declaration, ct), equivalenceKey: _title), diagnostic); } private async Task&amp;lt;Solution&amp;gt; ConvertToNotificationProperty(Document document, PropertyDeclarationSyntax propertyDeclarationSyntax, CancellationToken cancellationToken) { // 获取文档根语法节点。 var root = await document.GetSyntaxRootAsync(cancellationToken).ConfigureAwait(false); // 生成可通知属性的语法节点集合。 var type = propertyDeclarationSyntax.Type; var propertyName = propertyDeclarationSyntax.Identifier.ValueText; var fieldName = $&quot;_{char.ToLower(propertyName[0])}{propertyName.Substring(1)}&quot;; var newNodes = CreateNotificationProperty(type, propertyName, fieldName); // 将可通知属性的语法节点插入到原文档中形成一份中间文档。 var intermediateRoot = root .InsertNodesAfter( root.FindNode(propertyDeclarationSyntax.Span), newNodes); // 将中间文档中的自动属性移除形成一份最终文档。 var newRoot = intermediateRoot .RemoveNode(intermediateRoot.FindNode(propertyDeclarationSyntax.Span), SyntaxRemoveOptions.KeepNoTrivia); // 将原来解决方案中的此份文档换成新文档以形成新的解决方案。 return document.Project.Solution.WithDocumentSyntaxRoot(document.Id, newRoot); } private async Task&amp;lt;Solution&amp;gt; ConvertToNotificationProperty(Document document, PropertyDeclarationSyntax propertyDeclarationSyntax, CancellationToken cancellationToken) { // 这个类型暂时留空，因为这是真正的使用 Roslyn 生成语法节点的代码，虽然只会写一句话，但相当长。 }}还记得我们在前面解读 WalterlvDemoAnalyzersCodeFixProvider 类型时的那些描述吗？我们现在为一个诊断 Diagnostic 注册了一个代码修改（CodeFix），并且其回调函数是 ConvertToNotificationProperty。这是我们自己编写的一个方法。我在这个方法里面写的代码并不复杂，是获取原来的属性里的类型信息和属性名，然后修改文档，将新的文档返回。其中，我留了一个 CreateNotificationProperty 方法为空，因为这是真正的使用 Roslyn 生成语法节点的代码，虽然只会写一句话，但相当长。于是我将这个方法单独写在了下面。将这两个部分拼起来（用下面方法替换上面同名的方法），你就能得到一个完整的 WalterlvDemoAnalyzersCodeFixProvider 类的代码了。private SyntaxNode[] CreateNotificationProperty(TypeSyntax type, string propertyName, string fieldName) =&amp;gt; new SyntaxNode[] { SyntaxFactory.FieldDeclaration( new SyntaxList&amp;lt;AttributeListSyntax&amp;gt;(), new SyntaxTokenList(SyntaxFactory.Token(SyntaxKind.PrivateKeyword)), SyntaxFactory.VariableDeclaration( type, SyntaxFactory.SeparatedList(new [] { SyntaxFactory.VariableDeclarator( SyntaxFactory.Identifier(fieldName) ) }) ), SyntaxFactory.Token(SyntaxKind.SemicolonToken) ), SyntaxFactory.PropertyDeclaration( type, SyntaxFactory.Identifier(propertyName) ) .AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword)) .AddAccessorListAccessors( SyntaxFactory.AccessorDeclaration( SyntaxKind.GetAccessorDeclaration ) .WithExpressionBody( SyntaxFactory.ArrowExpressionClause( SyntaxFactory.Token(SyntaxKind.EqualsGreaterThanToken), SyntaxFactory.IdentifierName(fieldName) ) ) .WithSemicolonToken(SyntaxFactory.Token(SyntaxKind.SemicolonToken)), SyntaxFactory.AccessorDeclaration( SyntaxKind.SetAccessorDeclaration ) .WithExpressionBody( SyntaxFactory.ArrowExpressionClause( SyntaxFactory.Token(SyntaxKind.EqualsGreaterThanToken), SyntaxFactory.InvocationExpression( SyntaxFactory.IdentifierName(&quot;SetValue&quot;), SyntaxFactory.ArgumentList( SyntaxFactory.Token(SyntaxKind.OpenParenToken), SyntaxFactory.SeparatedList(new [] { SyntaxFactory.Argument( SyntaxFactory.IdentifierName(fieldName) ) .WithRefKindKeyword( SyntaxFactory.Token(SyntaxKind.RefKeyword) ), SyntaxFactory.Argument( SyntaxFactory.IdentifierName(&quot;value&quot;) ), }), SyntaxFactory.Token(SyntaxKind.CloseParenToken) ) ) ) ) .WithSemicolonToken(SyntaxFactory.Token(SyntaxKind.SemicolonToken)) ), };以上这段代码写起来非常不直观，如果你也觉得麻烦，可以使用使用 林晓lx 的 RoslynSyntaxTool 工具互相转换 C# 代码与语法树代码。实际上本文并不会重点介绍如何使用 Roslyn 生成新的语法节点，因此我不会解释上面我是如何写出这样的语法节点来的，但如果你对照着语法可视化窗格（Syntax Visualizer）来看的话，也是不难理解为什么我会这么写的。在此类型完善之后，我们再 F5 启动调试，可以发现我们已经可以完成一个自动属性的修改了，可以按照预期改成一个可通知属性。你可以再看看下面的动图：发布发布成 NuGet 包前往我们分析器主项目 Walterlv.Demo.Analyzers 项目的输出目录，因为本文没有改输出路径，所以在项目的 bin\\Debug 文件夹下。我们可以找到每次编译产生的 NuGet 包。如果你不知道如何将此 NuGet 包发布到 nuget.org，请在文本中回复，也许我需要再写一篇博客讲解如何推送。发布到 Visual Studio 插件商店前往我们分析器的 Visual Studio 插件项目 Walterlv.Demo.Analyzers.Vsix 项目的输出目录，因为本文没有改输出路径，所以在项目的 bin\\Debug 文件夹下。我们可以找到每次编译产生的 Visual Studio 插件安装包。如果你不知道如何将此 Visual Studio 插件发布到 Visual Studio Marketplace，请在文本中回复，也许我需要再写一篇博客讲解如何推送。一些补充辅助源代码前面我们提到了 SetValue 这个方法，这是为了写一个可通知对象。为了拥有这个方法，请在我们的测试项目中添加下面这两个文件：一个可通知类文件 NotificationObject.cs：using System.ComponentModel;using System.Runtime.CompilerServices;namespace Walterlv.TestForAnalyzer{ public class NotificationObject : INotifyPropertyChanged { protected bool SetValue&amp;lt;T&amp;gt;(ref T field, T value, [CallerMemberName] string propertyName = null) { if (Equals(field, value)) { return false; } field = value; PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName)); return true; } public event PropertyChangedEventHandler PropertyChanged; }}一个用于分析器测试的类 Demo.cs：namespace Walterlv.TestForAnalyzer{ class Demo : NotificationObject { public string Foo { get; set; } }}示例代码仓库代码仓库在我的 Demo 项目中，注意协议是 996.ICU 哟！ walterlv.demo/Walterlv.Demo.Analyzers at master · walterlv/walterlv.demo别忘了单元测试别忘了我们一开始创建仓库的时候有一个单元测试项目，而我们全文都没有讨论如何充分利用其中的单元测试。我将在其他的博客中说明如何编写和使用分析器项目的单元测试。参考资料 Writing a Roslyn analyzer - Meziantou’s blog Code Generation with Roslyn – Fields and Properties - Dogs Chasing Squirrels" }, { "title": "Roslyn 入门：使用 Roslyn 静态分析现有项目中的代码（语法分析）", "url": "/post/analysis-code-of-existed-projects-using-roslyn.html", "categories": "", "tags": "visualstudio, dotnet, csharp, roslyn", "date": "2022-05-17 17:34:26 +0800", "snippet": "Roslyn 是微软为 C# 设计的一套分析器，它具有很强的扩展性。以至于我们只需要编写很少量的代码便能够分析我们的项目文件。作为 Roslyn 入门篇文章，你将可以通过本文学习如何开始编写一个 Roslyn 扩展项目，如何开始分析一个解决方案（.sln）中项目（.csproj）的代码文件（.cs）。本文是 Roslyn 入门系列之一： Roslyn 入门：使用 Visual Studio 的语法可视化（Syntax Visualizer）窗格查看和了解代码的语法树 Roslyn 入门：使用 .NET Core 版本的 Roslyn 编译并执行跨平台的静态的源码 Roslyn 入门：使用 Roslyn 静态分析现有项目中的代码（本文）如果你希望真实地静态分析一个实际项目，并且理解这样的分析过程是如何进行的（而不只是写个 demo），那么本文的所有内容都将是必要的。准备工作为了能够进行后面关键的操作，我们需要先有一个能跑起来的项目。▲ 在 Visual Studio 新建项目，选择“控制台程序(.NET Framework)”在目前（2022-05-17 17:34），如果我们需要像本文一样分析现有的解决方案和项目，那么 .NET Framework 是必须的；如果只是分析单个文件，那么也可以选择 .NET Core，参见 Roslyn 入门：使用 .NET Core 版本的 Roslyn 编译并执行跨平台的静态的源码。当然，如果你有一个现成的 .NET Core 项目，可以通过修改 .csproj 文件改成 .NET Framework 的：&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;OutputType&amp;gt;Exe&amp;lt;/OutputType&amp;gt; &amp;lt;!-- 从 netcoreapp2.0 改成 net471，因为 NuGet 包中的 ValueTuple 与 net47 不兼容，所以只能选择 net471 或以上 --&amp;gt; &amp;lt;TargetFramework&amp;gt;net471&amp;lt;/TargetFramework&amp;gt; &amp;lt;/PropertyGroup&amp;gt;&amp;lt;/Project&amp;gt;现在，我们有了一个可以开始写代码的 Program.cs 文件，接下来就可以正式开始入门了。安装必要的 NuGet 包在 NuGet 包管理器中搜索并安装 Microsoft.CodeAnalysis 包 —— 这是一个包含 Roslyn 所有 API 的各种 NuGet 包的合集。当然，如果你只是做一些特定的事情，当然不需要安装这么全的 NuGet 包，像 Roslyn 静态分析 - 林德熙 的 demo 和 Roslyn 编译与执行 - 吕毅 中的教程就不需要安装所有 NuGet 包。特别注意！！！如果前面你是通过 .NET Core 项目改过来的，那么还需要额外安装以下三个 NuGet 包，否则运行时会无法打开解决方案和项目。 Microsoft.Build Microsoft.Build.Tasks.Core System.Threading.Tasks.Dataflow打开一个解决方案/项目和其中的文件现在，我们使用这些代码打开解决方案。我以 MSTestEnhancer 为例：// 打开 MSTestEnhancer(https://github.com/dotnet-campus/MSTestEnhancer/) 解决方案文件。// 注意这里的 MSBuildWorkspace.Create() 会返回 WorkSpace 的实例。// 虽然 WorkSpace 是跨平台的，但是 MSBuildWorkspace 仅在 Windows 下可用。var solution = await MSBuildWorkspace.Create().OpenSolutionAsync( @&quot;D:\\Developments\\Open\\MSTestEnhancer\\MSTest.Extensions.sln&quot;); // 从解决方案中选出 MSTest.Extensions 项目。var project = solution.Projects.First(x =&amp;gt; x.Name == &quot;MSTest.Extensions&quot;);// 从 MSTest.Extensions 项目中选出我们要分析的 ContractTestContext.cs 文件。// 这里只是一个示例，所以我们只分析一个文件。你可以从 Documents 集合中找出这个项目的所有文件进行分析。var document = project.Documents.First(x =&amp;gt; x.Name.Equals(&quot;ContractTestContext.cs&quot;, StringComparison.InvariantCultureIgnoreCase));分析代码我们要分析的代码大致是这样的：// 这里是 using，省略。// 这里是命名空间，省略。public class ContractTestContext&amp;lt;T&amp;gt;{ // 这是代码的细节，省略。}现在，我们开始使用 Roslyn API 找出里面的泛型 T。这里，我们必须引入一个概念 —— Syntax Rewriter。语法重写——Syntax RewriterRoslyn 对 C# 代码进行分析的一个非常关键的 API 是 CSharpSyntaxRewriter——这是一个专门用来给你继承的类。CSharpSyntaxRewriter 是访问者模式中访问者的一个实现，如果你不了解访问者模式，推荐阅读 23种设计模式（9）：访问者模式 - CSDN博客 进行了解，否则我们后面的代码你将只能跟着我写，而不能明白其中的含义。当你阅读到这里时，我开始假设你已经了解了访问者模式了。我们每个人都可能会写出不同的基于 Roslyn 的分析器，这些分析器通常都会对不同文件的 C# 语法树进行不同的操作；于是，我们通过重写 CSharpSyntaxRewriter 可以实现各种各样不同的操作。在访问者模式中，由于 C# 的语法在一个 C# 版本发布之后就会确定，其中各种各样类型的语法对应访问者模式中的各种不同类型的数据，Roslyn 为我们构建的语法树对应访问者模式中需要访问的庞大的数据结构。由于 Roslyn 的语法树是非常庞大的，以至于对其进行遍历也是一个非常复杂的操作；所以 Roslyn 通过访问者模式为我们封装了这种复杂的遍历过程，我们只需要重写 CSharpSyntaxRewriter 就可以实现对某种特定语法节点的操作。现在，我们编写一个用于找出泛型参数 T 的 Syntax Rewriter。class TypeParameterVisitor : CSharpSyntaxRewriter{ public override SyntaxNode VisitTypeParameterList(TypeParameterListSyntax node) { var lessThanToken = this.VisitToken(node.LessThanToken); var parameters = this.VisitList(node.Parameters); var greaterThanToken = this.VisitToken(node.GreaterThanToken); return node.Update(lessThanToken, parameters, greaterThanToken); }}其实这段代码就是 CSharpSyntaxRewriter 基类中的代码，我把它贴出来可以帮助我们理解它。你也依然需要将他放入到我们的项目中，因为我们接下来的代码就开始要使用它了。如果你想了解更多语法节点，推荐另一篇入门文章：Roslyn 入门：使用 Visual Studio 的语法可视化（Syntax Visualizer）窗格查看和了解代码的语法树。访问泛型参数现在，我们继续在之前打开解决方案和项目文件的代码后面增添代码：// 从我们一开始打开的项目文件中获取语法树。var tree = await document.GetSyntaxTreeAsync();var syntax = tree.GetCompilationUnitRoot();// 使用我们刚刚重写 CSharpSyntaxRewriter 的类来访问语法树。var visitor = new TypeParameterVisitor();var node = visitor.Visit(syntax);// 得到的 node 是新的语法树节点，// 如果我们在 `TypeParameterVisitor` 中修改了语法树，// 那么这里就会得到修改后的 node 节点。// 我们可以通过这个 node 节点做各种后续的操作。如果我们使用 node 的方式是修改代码，那么可以使用 var text = node.GetText(); 来得到新的语法树生成的代码，使用这段文本替换之前的文本可以达到修改代码的目的。不过，这不是本文的重点，本文的重点依然在入门。现在，整合以上的三大段代码，你的项目应该能够完整地跑起来了。哪三段？1. 打开项目文件；2. TypeParameterVisitor；3. 访问泛型参数。其中 1 和 3 写在一个方法中，2 是一个新类。分析这个泛型参数直到现在，我们所写的任何代码都还只是为了使使用 Roslyn API 的代码能够跑起来，没有进行任何实质上的分析。接下来，我们会修改 CSharpSyntaxRewriter 以进行真正的分析。不过在此之前，我假设上面的代码你是能正常跑起来而且没有错误的。（如果不行，就在下面留言吧！留言有邮件通知的，我会在第一时间回复你。）如果你不了解 Roslyn，强烈建议去 VisitTypeParameterList 重写方法中打一个断点观察 lessThanToken parameters greaterThanToken 这几个实例的含义。lessThanToken 就是 &amp;lt;，greaterThanToken 就是 &amp;gt;；而 parameters 是一个泛型参数列表，在这里，是一个 T。现在，我们构造一个自己的泛型参数列表试试，名字不是 T 了，而是 TParameter。var parameters = new SeparatedSyntaxList&amp;lt;TypeParameterSyntax&amp;gt;();parameters = parameters.Add(SyntaxFactory.TypeParameter(&quot;TParameter&quot;));特别注意：SeparatedSyntaxList 的 Add 操作不会修改原集合，而是会返回一个新的集合！所以上面 Add 之后的赋值语句不能少！这样的设计应该是为了避免遍历语法树的时候语法树被修改导致遍历不可控。于是，我们的 TypeParameterVisitor 变成了这样：class TypeParameterVisitor : CSharpSyntaxRewriter{ public override SyntaxNode VisitTypeParameterList(TypeParameterListSyntax node) { // 构造一个自己的泛型列表，名字改为了 TParameter。 var parameters = new SeparatedSyntaxList&amp;lt;TypeParameterSyntax&amp;gt;(); parameters = parameters.Add(SyntaxFactory.TypeParameter(&quot;TParameter&quot;)); // 依然保留之前的更新语法节点的方法。 // 这样，我们将会在语法树访问结束后得到新的语法树。 var lessThanToken = this.VisitToken(node.LessThanToken); var greaterThanToken = this.VisitToken(node.GreaterThanToken); return node.Update(lessThanToken, parameters, greaterThanToken); }}如果你觉得编写生成代码的语法树很麻烦，可以使用使用 林晓lx 的 RoslynSyntaxTool 工具互相转换 C# 代码与语法树代码。总结我们总共编写了两个关键类： Program Main（用于打开项目和文件，并调用 TypeParameterVisitor 遍历语法树） 需要注意，Main 函数只有 C#7.2 及以上才支持 async，如果没有这么高，需要再编写一个新函数，然后在 Main 里面调用它。 TypeParameterVisitor VisitTypeParameterList（用于遍历和修改语法树中的泛型参数列表） 以上便是分析和修改 Roslyn 语法树的简单实例了，我将整个 Program.cs 文件贴在下面，以便整体查看。using System;using System.IO;using System.Linq;using System.Threading.Tasks;using Microsoft.CodeAnalysis;using Microsoft.CodeAnalysis.CSharp;using Microsoft.CodeAnalysis.CSharp.Syntax;using Microsoft.CodeAnalysis.MSBuild;namespace Walterlv.Demo.Roslyn{ class Program { static void Main(string[] args) { RunAsync().Wait(); } private static async Task RunAsync() { var solution = await MSBuildWorkspace.Create().OpenSolutionAsync( @&quot;D:\\Developments\\Open\\MSTestEnhancer\\MSTest.Extensions.sln&quot;); var project = solution.Projects.First(x =&amp;gt; x.Name == &quot;MSTest.Extensions&quot;); var document = project.Documents.First(x =&amp;gt; x.Name.Equals(&quot;ContractTestContext.cs&quot;, StringComparison.InvariantCultureIgnoreCase)); var tree = await document.GetSyntaxTreeAsync(); var syntax = tree.GetCompilationUnitRoot(); var visitor = new TypeParameterVisitor(); var node = visitor.Visit(syntax); var text = node.GetText(); File.WriteAllText(document.FilePath, text.ToString()); } } class TypeParameterVisitor : CSharpSyntaxRewriter { public override SyntaxNode VisitTypeParameterList(TypeParameterListSyntax node) { var syntaxList = new SeparatedSyntaxList&amp;lt;TypeParameterSyntax&amp;gt;(); syntaxList = syntaxList.Add(SyntaxFactory.TypeParameter(&quot;TParameter&quot;)); var lessThanToken = this.VisitToken(node.LessThanToken); var greaterThanToken = this.VisitToken(node.GreaterThanToken); return node.Update(lessThanToken, syntaxList, greaterThanToken); } }}参考资料 23种设计模式（9）：访问者模式 - CSDN博客 John Koerner - Using a CSharp Syntax Rewriter Learn Roslyn Now: Part 5 CSharpSyntaxRewriter – Shotgun Debugging Code Generation with Roslyn: a Skeleton Class from UML - Federico Tomassetti - Software Architect" }, { "title": "WPF 窗口在 Visual Studio 调试的时候会被一个莫名其妙的调试层覆盖住", "url": "/post/visual-studio-add-a-window-covering-my-whole-wpf-window", "categories": "wpf, dotnet, visualstudio", "tags": "", "date": "2022-03-05 10:13:01 +0800", "snippet": "同样的程序，在使用 Visual Studio 调试的时候和直接运行的时候相比，总会有一些细微之处是不同的。大多数时候这些不同可以忽略，但是一旦这些不同是我们产品需求的一部分的时候，你可能就会发现调试和非调试状态下的行为不同却找不到原因，非常抓狂！本文记录我遇到的一个 WPF 窗口调试的案例。看完后大家至少知道 Visual Studio 调试时的一个小坑，更进一步则可以在出现奇妙问题的时候打开一个新的思路。UI 自动化微软有一款自动化办公软件 Power Automate Desktop，它可以录制你对某软件的操作，以便在后续自动化进行这些操作。一天，我正用它来自动化操作我正在开发中的一款小工具软件（WPF 框架），但发现它竟然无法识别我界面中的任何控件，无论怎么识别，都是一整个窗口。这导致 Power Automate Desktop 的自动化操作对我正开发的软件毫无作用，这怎么能忍！▲ 正常情况（能识别到窗口内的控件）▲ 异常情况（只能识别到一整个窗口）Visual Studio 干了啥！我用 snoop 查看了一下我软件界面里的控件，发现没有什么异常。不过，意外发现有一个名为“AdornerWindow”的窗口引起了我的注意，直接在 snoop 里将其设为隐藏后，Power Automate Desktop 瞬间即可正常识别我软件里面的各种控件了。▲ 引起注意的“AdornerWindow”窗口然而，我不能每次自动化之前先用 snoop 隐藏一下这个窗口吧，所以就打算在我窗口的 ContentRendered 事件里把它干掉。这就有了下面这段代码：public MainWindow(){ InitializeComponent(); ContentRendered += RecordingCaptureWindow_ContentRendered;}private void RecordingCaptureWindow_ContentRendered(object? sender, EventArgs e){ HandleVisualStudioHacking();}/// &amp;lt;summary&amp;gt;/// 因为 Visual Studio 会在调试状态下向此窗口添加一个全覆盖窗口，导致我们无法捕获到下方控件。所以我们需要将此窗口移除。/// &amp;lt;/summary&amp;gt;[Conditional(&quot;DEBUG&quot;)]private void HandleVisualStudioHacking(){ var windows = Application.Current.Windows.OfType&amp;lt;Window&amp;gt;().ToList(); var thisWindowIndex = windows.IndexOf(this); var suspiciousWindowIndex = thisWindowIndex + 1; if (suspiciousWindowIndex &amp;lt; windows.Count &amp;amp;&amp;amp; windows[suspiciousWindowIndex] is { } suspiciousWindow &amp;amp;&amp;amp; suspiciousWindow.GetType().FullName == &quot;Microsoft.VisualStudio.DesignTools.WpfTap.WpfVisualTreeService.Adorners.AdornerWindow&quot;) { suspiciousWindow.Close(); }}因为发现每一个 WPF 窗口上面都会覆盖这样一个透明窗口，所以我拿到主线程所有窗口的列表，找到当前窗口的下一个（因为假想 Visual Studio 总会在我们创建完一个窗口后立即创建覆盖窗口），然后把它关掉。" }, { "title": "使用 ImageMagick 轻松制作带有多种尺寸的 ico 图标文件", "url": "/post/convert-to-ico-icon-using-image-magick", "categories": "windows", "tags": "", "date": "2022-02-16 10:05:35 +0800", "snippet": "ico 图标格式是一种包含多种尺寸位图的容器格式，Windows 用这种格式来作为图标是为了能让文件图标在各种不同显示尺寸下都能看起来清晰可辨。可是，相当多的平面设计软件都没有内嵌 ico 格式的支持（尤其是 macOS 版的），导致设计师很难直接输出 ico 格式的图标。另外，有些自称能 png 转 ico 格式的图片转换器虽然能生成 ico 格式，但这种 ico 格式内只包含一种位图尺寸，导致在很小或很大时图标显示非常模糊。那么，本文推荐 ImageMagick 这款强大的命令行工具，帮助我们一条命令完成多尺寸 png 图到 ico 格式的转换。虽是牛刀杀鸡，但奈何确实简单方便。ImageMagick 下载安装WinGet 安装（推荐）一句命令完成：winget install ImageMagick装完后你将自动拥有其对应的命令行工具，可随时在各个终端输入命令。scoop 安装如果你使用 scoop 来管理软件包，那么只需输入：scoop install imagemagick与 WinGet 相同，随后即可拥有工具。直接下载 官方网站：ImageMagick – Convert, Edit, or Compose Digital Images 官方仓库：ImageMagick/LICENSE at main · ImageMagick/ImageMagick 下载地址：ImageMagick – Download官方下载地址里，Windows 的下载在最后一项——“Windows Binary Release”。介绍文字很多，如果看不下去的话，直接选 Windows 章节下第一个表格里第一个版本下载即可，这是 64 位系统下的 ImageMagick 安装包，下载完点击安装后即可拥有其完整的命令行工具。软件基于 Apache 2.0 协议，如果你只是使用它生成的二进制文件，那么可免费用于个人、公司内部或商业用途。ImageMagick 使用本来 ImageMagick 转图片用的是 convert 命令，但 Windows 下 convert 命令转的是磁盘格式（详见在 Windows 安装期间将 MBR 磁盘转换为 GPT 磁盘），所以我们只能通过 magick convert 命令来替代它。多尺寸 png 转 ico 格式前往包含多尺寸 png 的文件夹中，执行如下命令，将其转为多位图尺寸 ico 格式。magick convert 16.png 24.png 32.png 48.png 256.png walterlv.ico前面的所有参数都是 png 图片，最后一个参数是 ico 输出文件名。ImageMagick 会自动识别 png 的尺寸并设置到 ico 中。" }, { "title": "在多个可执行程序（exe）之间共享同一个私有部署的 .NET 运行时", "url": "/post/share-self-deployed-dotnet-runtime-among-multiple-exes", "categories": "dotnet", "tags": "", "date": "2022-02-16 09:59:05 +0800", "snippet": "从 .NET Core 3 开始，.NET 应用就支持独立部署自己的 .NET 运行时。可以不受系统全局安装的 .NET 运行时影响，特别适合国内这种爱优化精简系统的情况……鬼知道哪天就被优化精简了一个什么重要 .NET 运行时组件呢！然而，如果你的项目会生成多个 exe 程序，那么他们每个独立发布时，互相之间的运行时根本不互通。即便编译时使用完全相同的 .NET 框架（例如都设为 net6.0），最终也无法共用运行时文件。那么，还有没有方法能在多个 exe 之间共享运行时而又不受制于系统安装的版本呢？有！问题例如，你要部署的应用程序文件夹结构是这样的（只看 exe 和文件夹，不看其他文件）：- Walterlv.Demo.exe- Walterlv.Updater.exe+ 1.2.1 - Walterlv.SubProcess.exe那么，以上这些 exe 是应该发布成“依赖框架”（Framework Dependent）还是“独立”（Self Contained）呢？如果是“依赖框架”，那么发布完后，需要目标系统先安装有 .NET 运行时，而这个系统全局的 .NET 运行时会被各个不同的应用影响，谁知道会不会被精简或被魔改呢！如果是“独立”，那么这几个 exe 之间的运行时不会共享，每个都占用了大量的存储空间，用来放一模一样的 .NET 运行时和库文件，而且如果放一起的话还跑不起来——就算后续修复了跑不起来的 bug，上面那个多级文件夹之间共享这些 .NET 运行时文件也是一个令人头疼的事情。官方解决方案GitHub 上其实也有人在讨论如何共享运行时的问题： Support deploying multiple exes as a single self-contained set · Issue #53834 · dotnet/runtime How to share self contained runtime? · Issue #52974 · dotnet/runtime官方给出了一个解决方案： 设置 DOTNET_ROOT 环境变量那么，我们把 runtime 文件夹放到以上根目录，然后设一下 DOTNET_ROOT 就可以让这些 .NET 的 exe 脱离系统安装的 .NET 运行了。等等！是不是有什么问题？ 这个 DOTNET_ROOT 环境变量怎么设？安装软件的时候安装包去系统里设一下吗？这一设不就跟在系统全局安装一个意思吗？ 这个环境变量能设相对路径吗？肯定不行，因为不同文件夹下的 exe 如果希望共享同一个独立部署的运行时，那么相对路径肯定不同。 如果每个 exe 设自己的 DOTNET_ROOT 环境变量呢？那谁来设呢？难不成还要专门为每一个 exe 写一个非托管的启动器用来设环境变量吗？真是杀鸡用牛刀啊！我们的解决方案鉴于官方目前仍没有比较省心的共享独立部署 .NET 运行时的方案，我们就不得不自己操刀来干这件事情。为此，我们开发了一个 dotnetCampus.AppHost 库，其原理是允许你单独修改每个 exe 所查找的 .NET 运行时路径。dotnetCampus.AppHost 库 你可以在 NuGet 上拿到此库：dotnetCampus.AppHost。 项目在 GitHub 上开源：dotnet-campus/dotnetCampus.AppHost使用方法第一步：在 exe 入口项目上安装 NuGet 包：dotnetCampus.AppHost。第二步：修改项目，加入一行设置将来运行时要用的 .NET 运行时路径。 &amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;OutputType&amp;gt;Exe&amp;lt;/OutputType&amp;gt; &amp;lt;TargetFramework&amp;gt;net6.0&amp;lt;/TargetFramework&amp;gt;++ &amp;lt;!-- 可以是相对路径，也可以是绝对路径。但既然要私有部署，当然选相对路径更好。这里瞎写一个 runtime\\6.0.1 --&amp;gt;++ &amp;lt;AppHostDotNetRoot&amp;gt;runtime\\6.0.1&amp;lt;/AppHostDotNetRoot&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;PackageReference Include=&quot;dotnetCampus.AppHost&quot; Version=&quot;1.0.0-alpha04&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;/Project&amp;gt;第三步：在编译（dotnet build）完你的项目后，记得把 .NET 运行时的整个文件夹打包到你项目对应的文件夹下。例如，对于本文一开始举例的项目，就可以指定成自己设的文件夹：+ runtime + 6.0.1 - dotnet.exe + host + shared + swidtag- Walterlv.Demo.exe- Walterlv.Updater.exe+ 1.2.1 - Walterlv.SubProcess.exe这样，为 Walterlv.Demo 和 Walterlv.Updater 项目设置 AppHostDotNetRoot 为 runtime\\6.0.1；为 Walterlv.SubProcess 项目设置 AppHostDotNetRoot 为 ..\\runtime\\6.0.1，他们就可以共用一个私有部署的运行时了。那，这个 .NET 运行时文件夹哪里来呢？当然是官网下啦： https://dotnet.microsoft.com/en-us/download/dotnet/6.0/runtime下载完安装后，可以在以下文件夹提取到： C:\\Program Files\\dotnet C:\\Program Files(x86)\\dotnet其中，前者适用于编译成 x64 的应用程序（例如设置 PlatformTarget 为 x64 或设置 RuntimeIdentifier 为 win-x64 的程序），后者适用于编译成 x86 的应用程序（例如设置 PlatformTarget 为 x86 或设置 RuntimeIdentifier 为 win-x86 的程序）。适用目前，dotnetCampus.AppHost 支持的框架与平台如下，还在继续添加其他框架和平台的支持： net6.0 win-x64 win-x86 win-arm win-arm64 net5.0 win-x64 win-x86 win-arm win-arm64 netcoreapp3.1 win-x64 win-x86 win-arm win-arm64 netcoreapp3.0 win-x64 win-x86 win-arm win-arm64 对于多框架项目，可以放心安装而不需要做框架判断。只有在需要生成 AppHost 的时候才会设置 .NET 运行时，不需要生成时不会报错，需要生成而无法生成时才会报错。原理挖个坑，稍后填。参考资料 dotnet core 应用是如何跑起来的 通过AppHost理解运行过程 dotnet 桌面端基于 AppHost 的配置式自动切换更新后的应用程序路径 Support deploying multiple exes as a single self-contained set · Issue #53834 · dotnet/runtime How to share self contained runtime? · Issue #52974 · dotnet/runtime DOTNET_ROOT does not work as the doc says. · Issue #64244 · dotnet/runtime .NET environment variables - .NET CLI - Microsoft Docs Write a custom .NET runtime host - .NET - Microsoft Docs runtime/fxr_resolver.cpp at v6.0.1 · dotnet/runtime runtime/native-hosting.md at main · dotnet/runtime samples/core/hosting at main · dotnet/samples c# - While a self-contained .NetCore app is running, what’s the best way to start another .NetCore app sharing the same runtime? - Stack Overflow" }, { "title": "如何检测当前操作系统是否支持运行 .NET Core 3 / .NET 5 / .NET 6 应用？", "url": "/post/how-to-detect-system-supports-dotnet", "categories": "dotnet, windows", "tags": "", "date": "2022-01-28 19:31:41 +0800", "snippet": "虽然微软官方声称 .NET Core 3 / .NET 5 / .NET 6 应用支持在 Windows 7 及以上运行，但你不应该轻信。因为微软还在某个隐秘的角落里说明还应安装一枚 KB2533623 补丁。直接判断补丁肯定是不靠谱的，因为还有其他几枚补丁（KB3063858、KB4457144）包含了这枚补丁。所以有没有什么靠谱写的判断方法呢？本文就来说说。Windows 7 支持情况KB2533623 补丁.NET Core 程序在 Windows 7 上需要 KB2533623 补丁才能运行本质上是需要它提供的这三个 Win32 函数： SetDefaultDllDirectories AddDllDirectory RemoveDllDirectory而我们可以通过 GetProcAddress 来判断这这些函数是否存在。由于这三个函数是一起添加到 kernel32.dll 里的，所以只需判断一个即可。更多内容可参考林德熙的博客：探索 dotnet core 为何在 Windows7 系统需要补丁的原因。国内设备支持情况根据本文即所述的判断方法，目前（2022年春节）国内环境对于 .NET Core 的支持情况如下：▲ 国内 Windows 7 以上系统对 .NET Core 支持情况统计（数据已脱敏，因此只提供百分比）其中，各系统支持情况为： 系统 支持率 Windows 7 32.9% Windows 7 SP1 97.1% Windows 8/8.1/10/11 100% 微软这些年一直在故意模糊 Windows 7 和 Windows 7 SP1 的界限，试图让不带 SP1 的 Windows 7 完全消失在任何微软的文档当中。然而，现实中的 Windows 7 可不会随着微软文档中相关文字的消失而消失。通过上表数据可以发现，不带 SP1 的 Windows 7 支持率低得可怜。好在 Windows 7（无 SP1）的设备数占所有 Windows 7 设备总数的 1.8%，不多也不少……还处于需要支持的数量级……C# 版判断方法判断所需的 Win32 函数：[DllImport(&quot;kernel32.dll&quot;, CharSet = CharSet.Unicode, EntryPoint = &quot;GetModuleHandleW&quot;, ExactSpelling = true, SetLastError = true)]public static extern HMODULE GetModuleHandle([In][MarshalAs(UnmanagedType.LPWStr)] string lpModuleName);[DllImport(&quot;kernel32.dll&quot;, CharSet = CharSet.Ansi, ExactSpelling = true, SetLastError = true, ThrowOnUnmappableChar = true)]public static extern FARPROC GetProcAddress([In] HMODULE hModule, [In][MarshalAs(UnmanagedType.LPStr)] string lpProcName);封装一个 C# 的调用，方便大家参考：/// &amp;lt;summary&amp;gt;/// 检查当前操作系统是否支持 .NET Core 运行时。/// &amp;lt;/summary&amp;gt;/// &amp;lt;returns&amp;gt;支持则返回 true；否则返回 false。&amp;lt;/returns&amp;gt;public static bool CheckOSIsNetCoreSupported(){ var kernel32ModuleHandle = Win32.Kernel32.GetModuleHandle(&quot;kernel32&quot;); if (kernel32ModuleHandle != IntPtr.Zero) { // .NET Core 程序运行必要，但缺补丁的系统没有的三个函数： // - SetDefaultDllDirectories // - AddDllDirectory // - RemoveDllDirectory var setDefaultDllDirectoriesProcAddress = Win32.Kernel32.GetProcAddress(kernel32ModuleHandle, &quot;SetDefaultDllDirectories&quot;); return setDefaultDllDirectoriesProcAddress != IntPtr.Zero; } else { throw new InvalidOperationException(&quot;因为调用错误，无法获取 kernel32 的 ModuleName。&quot;); }}C++ 版判断方法挖个坑，明天更新……参考资料 探索 dotnet core 为何在 Windows7 系统需要补丁的原因 Microsoft Security Advisory: Insecure library loading could allow remote code execution Microsoft 安全公告：不安全的库加载可能允许远程执行代码" }, { "title": "如何让 .NET 程序脱离系统安装的 .NET 运行时独立运行？除了 Self-Contained 之外还有更好方法！谈 dotnetCampus.AppHost 的工作原理", "url": "/post/how-does-the-dotnet-campus-apphost-work", "categories": "dotnet, nuget", "tags": "", "date": "2022-01-27 18:37:55 +0800", "snippet": "从 .NET Core 3 开始，.NET 应用就支持独立部署自己的 .NET 运行时。可以不受系统全局安装的 .NET 运行时影响，特别适合国内这种爱优化精简系统的情况……鬼知道哪天就被优化精简了一个什么重要 .NET 运行时组件呢！然而，如果你的项目会生成多个 exe 程序，那么他们每个独立发布时，互相之间的运行时根本不互通。即便编译时使用完全相同的 .NET 框架（例如都设为 net6.0），最终也无法共用运行时文件。而 dotnetCampus.AppHost 就可以帮助你完成多个 exe 共享独立部署的 .NET 环境的功能。其原理是允许你单独修改每个 exe 所查找的 .NET 运行时路径。那么本文带你详细了解其原理和实现。原代码解读首先记得先把仓库拉下来： dotnet/runtime: .NET is a cross-platform runtime for cloud, mobile, desktop, and IoT apps.如果有产品化需求，记得切到对应的 Tag（例如 v6.0.1 等）。.NET 的 AppHost 负责查找 .NET 运行时并将其运行起来，而 AppHost 相关的代码在 src\\native\\corehost 文件夹中。这些文件夹中的代码是以 CMakeList 方式管理的零散 C++ 文件（和头文件），可以使用 CMake 里的 cmake-gui 工具来打开、管理和编译。不过我依然更喜欢使用 Visual Studio 来打开和编辑这些文件。Visual Studio 支持 CMake 工作区，详见 CMake projects in Visual Studio。不过这些 CMakeList.txt 并没有针对 Visual Studio 做较好的适配，所以实际上个人认为最好的视图方式是 Visual Studio 的文件夹视图，或者 Visual Studio Code。通过阅读 corehost 文件夹内各个 C++ 源代码文件，我们可以找到运行时寻找 .NET 运行时路径的功能在 fxr_resolver.cpp 文件中实现，具体是 fxr_resolver::try_get_path 函数。关键代码如下：// For apphost and libhost, root_path is expected to be a directory.// For libhost, it may be empty if app-local search is not desired (e.g. com/ijw/winrt hosts, nethost when no assembly path is specified)// If a hostfxr exists in root_path, then assume self-contained.if (root_path.length() &amp;gt; 0 &amp;amp;&amp;amp; library_exists_in_dir(root_path, LIBFXR_NAME, out_fxr_path)){ trace::info(_X(&quot;Resolved fxr [%s]...&quot;), out_fxr_path-&amp;gt;c_str()); out_dotnet_root-&amp;gt;assign(root_path); return true;}// For framework-dependent apps, use DOTNET_ROOT_&amp;lt;ARCH&amp;gt;pal::string_t default_install_location;pal::string_t dotnet_root_env_var_name;if (get_dotnet_root_from_env(&amp;amp;dotnet_root_env_var_name, out_dotnet_root)){ trace::info(_X(&quot;Using environment variable %s=[%s] as runtime location.&quot;), dotnet_root_env_var_name.c_str(), out_dotnet_root-&amp;gt;c_str());}else{ if (pal::get_dotnet_self_registered_dir(&amp;amp;default_install_location) || pal::get_default_installation_dir(&amp;amp;default_install_location)) { trace::info(_X(&quot;Using global installation location [%s] as runtime location.&quot;), default_install_location.c_str()); out_dotnet_root-&amp;gt;assign(default_install_location); } else { trace::error(_X(&quot;A fatal error occurred, the default install location cannot be obtained.&quot;)); return false; }}解读： root_path 参数的含义为 .NET 程序的入口 dll 所在路径。一开始先判断一下 .NET 程序入口 dll 所在文件夹内有没有一个名为 hostfxr.dll 的文件，如果存在那么直接返回找到，就在应用程序所在文件夹；如果没有找到，就继续后续执行。 试图从环境变量中找一个名为 DOTNET_ROOT 的变量并取得其值，然后将其转换为绝对路径。如果找到了这个变量并且路径存在，则使用此文件夹；如果没有定义或文件夹不存在，则继续后续执行。 试图从全局安装的路径（C:\\Program Files\\dotnet 或 C:\\Program Files(x86)\\dotnet 路径下找 .NET 运行时，如果找到则使用此文件夹；如果没有找到，则返回错误，要求用户下载 .NET 运行时。新代码修改那么，我们的改动便可以从这里开始。-- // For framework-dependent apps, use DOTNET_ROOT_&amp;lt;ARCH&amp;gt; pal::string_t default_install_location; pal::string_t dotnet_root_env_var_name;++ if (is_dotnet_root_enabled_for_execution(out_dotnet_root))++ {++ // For apps that using dotnetCampus.AppHost, use the EMBED_DOTNET_ROOT placeholder.++ trace::info(_X(&quot;Using embedded dotnet_root [%s] as runtime location.&quot;), out_dotnet_root-&amp;gt;c_str());++ }-- if (get_dotnet_root_from_env(&amp;amp;dotnet_root_env_var_name, out_dotnet_root))++ else if (get_dotnet_root_from_env(&amp;amp;dotnet_root_env_var_name, out_dotnet_root)) {++ // For framework-dependent apps, use DOTNET_ROOT_&amp;lt;ARCH&amp;gt; trace::info(_X(&quot;Using environment variable %s=[%s] as runtime location.&quot;), dotnet_root_env_var_name.c_str(), out_dotnet_root-&amp;gt;c_str()); } else { if (pal::get_dotnet_self_registered_dir(&amp;amp;default_install_location) || pal::get_default_installation_dir(&amp;amp;default_install_location)) { trace::info(_X(&quot;Using global installation location [%s] as runtime location.&quot;), default_install_location.c_str()); out_dotnet_root-&amp;gt;assign(default_install_location); } else { trace::error(_X(&quot;A fatal error occurred, the default install location cannot be obtained.&quot;)); return false; } }解读： 我添加了一个名为 is_dotnet_root_enabled_for_execution 的函数调用，试图找一下编译时确定的 .NET 运行时路径。如果发现编译时设过此路径，并且此文件夹在运行时存在，那么将此文件夹改为绝对路径后继续后续执行；如果没设过或路径不存在，则使用其他的方式来确定 .NET 运行时的路径。而这个 is_dotnet_root_enabled_for_execution 函数，我的实现如下：#if defined(FEATURE_APPHOST) || defined(FEATURE_LIBHOST)#define EMBED_DOTNET_ROOT_HI_PART_UTF8 &quot;622e5d2d0f48bd3448f713291ed3f86d&quot; // SHA-256 of &quot;DOTNET_ROOT&quot; in UTF-8#define EMBED_DOTNET_ROOT_LO_PART_UTF8 &quot;f2f05ca222e95084f222207c5c348eea&quot;#define EMBED_DOTNET_ROOT_FULL_UTF8 (EMBED_DOTNET_ROOT_HI_PART_UTF8 EMBED_DOTNET_ROOT_LO_PART_UTF8) // NUL terminatedbool is_dotnet_root_enabled_for_execution(pal::string_t* dotnet_root){ constexpr int EMBED_SZ = sizeof(EMBED_DOTNET_ROOT_FULL_UTF8) / sizeof(EMBED_DOTNET_ROOT_FULL_UTF8[0]); constexpr int EMBED_MAX = (EMBED_SZ &amp;gt; 1025 ? EMBED_SZ : 1025); // 1024 DLL name length, 1 NUL // Contains the EMBED_DOTNET_ROOT_FULL_UTF8 value at compile time or the managed DLL name replaced by &quot;dotnet build&quot;. // Must not be &#39;const&#39; because std::string(&amp;amp;embed[0]) below would bind to a const string ctor plus length // where length is determined at compile time (=64) instead of the actual length of the string at runtime. static char embed[EMBED_MAX] = EMBED_DOTNET_ROOT_FULL_UTF8; // series of NULs followed by embed hash string static const char hi_part[] = EMBED_DOTNET_ROOT_HI_PART_UTF8; static const char lo_part[] = EMBED_DOTNET_ROOT_LO_PART_UTF8; if (!pal::clr_palstring(embed, dotnet_root)) { trace::error(_X(&quot;The dotnet_root value could not be retrieved from the executable image.&quot;)); return false; } // Since the single static string is replaced by editing the executable, a reference string is needed to do the compare. // So use two parts of the string that will be unaffected by the edit. size_t hi_len = (sizeof(hi_part) / sizeof(hi_part[0])) - 1; size_t lo_len = (sizeof(lo_part) / sizeof(lo_part[0])) - 1; std::string binding(&amp;amp;embed[0]); if ((binding.size() &amp;gt;= (hi_len + lo_len)) &amp;amp;&amp;amp; binding.compare(0, hi_len, &amp;amp;hi_part[0]) == 0 &amp;amp;&amp;amp; binding.compare(hi_len, lo_len, &amp;amp;lo_part[0]) == 0) { trace::info(_X(&quot;This executable does not binding to dotnet_root yet. The binding value is: &#39;%s&#39;&quot;), dotnet_root-&amp;gt;c_str()); return false; } trace::info(_X(&quot;The dotnet_root binding to this executable is: &#39;%s&#39;&quot;), dotnet_root-&amp;gt;c_str()); if (pal::realpath(dotnet_root)) { return true; } trace::info(_X(&quot;Did not find binded dotnet_root directory: &#39;%s&#39;&quot;), dotnet_root-&amp;gt;c_str()); return false;}#endif // FEATURE_APPHOST解读： 随便生成了一段字符串 622e5d2d0f48bd3448f713291ed3f86df2f05ca222e95084f222207c5c348eea，然后定义三个宏，一个是前一半，一个是后一半，一个是整个字符串。 这个字符串是一个占位符，将来在编译最终 exe 时，会在 exe 的二进制文件中搜索这一字符串，将其替换为我们需要的 .NET 运行时路径（如在这篇文章中我们设置成的 runtime\\6.0.1）。 这是一段随便生成的字符串，是通过将字符串 DOTNET_ROOT 进行 UTF-8 编码后 SHA-256 哈希得到的，你也可以用其他任何方法得到，只要避免整个 exe 不会碰巧遇到一模一样的字节序列就好。 我们分成了前一半后一半和整条，是因为我们未来编译时只替换整条的，一半的不会被替换。于是可以通过在运行时比较整条的是否刚好等于两个半条的拼接来判定是否在编译时设置过 .NET 运行时路径。 我们使用 pal::clr_palstring 将被替换的字符串进行 UTF-8 到 Unicode 的转码，这样就可以在运行时直接使用了。 随后，我们比较一下前面第 1 条所说的是否设置过 .NET 运行时路径，只有设置过才会用，否则使用默认的运行时查找逻辑。 最后，检查一下路径是否存在，将相对路径转换为绝对路径。（这个步骤是通过实测发现有问题才加的，如果只是相对路径，会有一部分逻辑正常执行另一部分挂掉）。改完后，整个项目编译一下，以得到我们想要的 apphost.exe 和 singleapphost.exe。参考： 如何编译、修改和调试 dotnet runtime 仓库中的 apphost nethost comhost ijwhost - walterlv配合 NuGet 包编译前面的修改，只是为了得到 apphost.exe，我们还没有让这个 apphost.exe 工作起来呢。为了能工作起来，我们需要做一个像下面这样的 NuGet 包：其中： build 这个是预定义的文件夹，必须使用此名称。 用来修改编译过程（这是 NuGet 包里用来编译的入口点），以便能将 AppHost 的修改加入到编译环节。 template 这个名字是随便取的，会在 build 里用到。 替换占位符时会替换这里的 apphost.exe 文件。 tools 这个名字是随便取的，会在 build 里用到（虽然 tools 本来也是有特殊用途，不过我们没用到）。 用来替换占位符的可执行程序就在这里。 而为了得到这样的 NuGet 包，我们这样来设计项目：其中： Assets 文件夹里的内容会近似原封不动地放到目标 NuGet 包里（唯一变化的，就是在放进 NuGet 包之前会自动把 Build.props 和 Build.targets 的名字改一下）。 Patches 文件夹里存放的是对 dotnet/runtime: .NET is a cross-platform runtime for cloud, mobile, desktop, and IoT apps. 项目的修改补丁，以便后续修改 dotnet runtime 仓库时能随时使用这里的补丁继续。 SourceProject 文件夹无需关心，是安装的源码包引来的。 其他所有文件都是用来编译生成替换占位符程序的。为了能让这样的项目结构生成前面所述的 NuGet 包，我们需要修改项目的 csproj 文件：&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;OutputType&amp;gt;WinExe&amp;lt;/OutputType&amp;gt; &amp;lt;TargetFrameworks&amp;gt;net6.0;net5.0;net45&amp;lt;/TargetFrameworks&amp;gt; &amp;lt;GeneratePackageOnBuild&amp;gt;true&amp;lt;/GeneratePackageOnBuild&amp;gt; &amp;lt;GenerateDocumentationFile&amp;gt;true&amp;lt;/GenerateDocumentationFile&amp;gt; &amp;lt;RootNamespace&amp;gt;dotnetCampus.AppHosting&amp;lt;/RootNamespace&amp;gt; &amp;lt;IncludeBuildOutput&amp;gt;false&amp;lt;/IncludeBuildOutput&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;ItemGroup Condition=&quot;&#39;$(TargetFramework)&#39; == &#39;net6.0&#39;&quot;&amp;gt; &amp;lt;PackageReference Include=&quot;dotnetCampus.CommandLine.Source&quot; Version=&quot;3.3.0&quot; PrivateAssets=&quot;All&quot; /&amp;gt; &amp;lt;PackageReference Include=&quot;dotnetCampus.MSBuildUtils.Source&quot; Version=&quot;1.1.0&quot; PrivateAssets=&quot;All&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;ItemGroup Condition=&quot;&#39;$(TargetFramework)&#39; != &#39;net6.0&#39;&quot;&amp;gt; &amp;lt;Compile Remove=&quot;**\\*.cs&quot; /&amp;gt; &amp;lt;Compile Include=&quot;Program.cs&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;!-- 引入包文件用于打包。 --&amp;gt; &amp;lt;Target Name=&quot;_IncludeAllDependencies&quot; BeforeTargets=&quot;_GetPackageFiles&quot;&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;None Include=&quot;Assets\\build\\Build.props&quot; Pack=&quot;True&quot; PackagePath=&quot;build\\$(PackageId).props&quot; /&amp;gt; &amp;lt;None Include=&quot;Assets\\build\\Build.targets&quot; Pack=&quot;True&quot; PackagePath=&quot;build\\$(PackageId).targets&quot; /&amp;gt; &amp;lt;None Include=&quot;Assets\\template\\**&quot; Pack=&quot;True&quot; PackagePath=&quot;template&quot; /&amp;gt; &amp;lt;None Include=&quot;$(OutputPath)net6.0\\**&quot; Pack=&quot;True&quot; PackagePath=&quot;tools&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;/Target&amp;gt;&amp;lt;/Project&amp;gt;其中，重要的部分为： TargetFrameworks：虽然我们只生成 net6.0 框架的替换 AppHost 占位符程序，但为了能让 NuGet 包能装在多框架项目中，我们需要添加其他框架的支持（虽然这些框架可能甚至都没有 AppHost 机制）。 为此，我们需要在依赖其他 NuGet 包时使用 Condition=&quot;&#39;$(TargetFramework)&#39; == &#39;net6.0&#39;&quot; 判断，只在 net6.0 项目中用包。同时，还需要在非 net6.0 项目中移除几乎所有的源代码，避免其他框架限制我们的代码编写（例如 net45 框架会限制我们使用 .NET 6 的新 API）。 GeneratePackageOnBuild 设为 true 以生成 NuGet 包；IncludeBuildOutput 以避免将生成的文件输出到 NuGet 包中（因为我们有多个框架，而且除了 net6.0 都是垃圾文件，所以要避免默认生成进去；我们随后手工放入到 NuGet 包中）。 通过名为 _IncludeAllDependencie 的 Target，我们将 Assets 文件夹中的所有文件打入 NuGet 包中，同时改一下 Build.props 和 Build.targets 文件的名字。然后把前面忽略的输出文件，将其 net6.0 框架部分手工打入 NuGet 包中。那么剩下的，就是 Build.props / Build.targets 和占位符替换程序的部分了。源码在这里：dotnet-campus/dotnetCampus.AppHost。Build.props 和 Build.targets 部分如果有问题，可以留言或者私信沟通；而占位符替换程序的本质就是读取文件并替换其一部分二进制序列，会比较简单。参考资料 dotnet core 应用是如何跑起来的 通过AppHost理解运行过程 dotnet 桌面端基于 AppHost 的配置式自动切换更新后的应用程序路径 Support deploying multiple exes as a single self-contained set · Issue #53834 · dotnet/runtime How to share self contained runtime? · Issue #52974 · dotnet/runtime DOTNET_ROOT does not work as the doc says. · Issue #64244 · dotnet/runtime .NET environment variables - .NET CLI - Microsoft Docs Write a custom .NET runtime host - .NET - Microsoft Docs runtime/fxr_resolver.cpp at v6.0.1 · dotnet/runtime runtime/native-hosting.md at main · dotnet/runtime samples/core/hosting at main · dotnet/samples c# - While a self-contained .NetCore app is running, what’s the best way to start another .NetCore app sharing the same runtime? - Stack Overflow" }, { "title": "如何编译、修改和调试 dotnet runtime 仓库中的 apphost nethost comhost ijwhost", "url": "/post/how-to-modify-compile-and-debug-dotnet-apphost", "categories": "dotnet", "tags": "", "date": "2022-01-27 17:06:47 +0800", "snippet": ".NET 以 MIT 协议开源，于是任何人都可以尝试对其进行一丢丢的修改以实现一些原本很难实现的功能，例如在多个可执行程序（exe）之间共享同一个私有部署的 .NET 运行时。在这个例子中，我们修改了 AppHost 添加了一个可以定制 .NET 运行时路径的功能，这就需要我们能编译、修改和调试 dotnet/runtime 仓库里的 apphost 部分。本文将以 dotnetCampus.AppHost 库的原理为例，介绍 dotnet/runtime 仓库里 corehost 部分的编译、修改和调试。仓库和代码首先记得先把仓库拉下来： dotnet/runtime: .NET is a cross-platform runtime for cloud, mobile, desktop, and IoT apps.如果有产品化需求，记得切到对应的 Tag（例如 v6.0.1 等）。CoreHost 相关的代码在 src\\native\\corehost 文件夹中。文件夹中的代码是以 CMakeList 方式管理的零散 C++ 文件（和头文件），可以使用 CMake 里的 cmake-gui 工具来打开、管理和编译。不过我依然更喜欢使用 Visual Studio 来打开和编辑这些文件。Visual Studio 支持 CMake 工作区，详见 CMake projects in Visual Studio。不过这些 CMakeList.txt 并没有针对 Visual Studio 做较好的适配，所以实际上个人认为最好的视图方式是 Visual Studio 的文件夹视图，或者 Visual Studio Code。编译差量编译整个 dotnet/runtime 仓库大约需要 15 分钟，但是前 2 分钟就可以完成 CoreHost 部分的编译。也就是说，你可以直接考虑按照我在另一篇文章里描述的那样直接编整个 dotnet/runtime；如果不想等太久，大可在输出路径里等着，生成了就可以 Ctrl+C 取消后续编译。所以，大可以考虑直接用如下方法编译： 修改 .NET 运行时、框架和库，从编译 dotnet runtime 仓库开始 - walterlv# 例如：.\\build.cmd -a x64 -c Release编译好的 CoreHost 相关文件可以在这个文件夹里找到： x64: .\\artifacts\\bin\\win-x64.Release\\corehost x86: .\\artifacts\\bin\\win-x86.Release\\corehost arm: .\\artifacts\\bin\\win-arm.Release\\corehost arm64: .\\artifacts\\bin\\win-arm64.Release\\corehost修改在 dotnet-campus/dotnetCampus.AppHost 项目中，我们试图让一个本来不支持在编译时定制的“.NET 运行时路径”变成可以在编译时定制。关于这个库的功能和用法可以参考： 在多个可执行程序（exe）之间共享同一个私有部署的 .NET 运行时 - walterlv所以，到底如何才能支持多个可执行程序共享同一个私有部署的 .NET 运行时呢？这部分内容较多，会打断大家的全局思路，所以我单独将其写到了另一篇： 谈 dotnetCampus.AppHost 的工作原理 - walterlv调试在阅读了 谈 dotnetCampus.AppHost 的工作原理 - walterlv 之后，你可以了解到我实现编译时设置 .NET 运行时路径的原理是在编译目标 exe 时替换了一个“占位符”。那么，我们需要把目标 exe 编出来才能调试真实场景下的 AppHost 工作过程。 首先设置环境变量 set COREHOST_TRACE=1 以开启 AppHost 的日志追踪。 其次设置环境变量 set COREHOST_TRACEFILE=host.txt 在目标 exe 运行时将追踪的日志存放到工作目录的 host.txt 文件中。 运行目标 exe，到你差不多希望执行到的地方后，查看 host.txt 文件的内容。（注意，此文件的写入方式是追加，所以多次运行 exe 时并不会覆盖之前调试所产生的日志，要记得删除文件哦！）这里的日志还是非常详细的，基本上 AppHost 执行过程中的每一个分支都能检查到。例如，我截取一下使用 dotnetCampus.AppHost 库编译出来的某示例 exe 的日志文件的前几行：所以，在你修改 CoreHost 的代码时，记得加上充足的追踪日志，以方便后续的调试。参考资料 CMake projects in Visual Studio - Microsoft Docs" }, { "title": "修改 .NET 运行时、框架和库，从编译 dotnet runtime 仓库开始", "url": "/post/how-to-compile-dotnet-runtime", "categories": "dotnet", "tags": "", "date": "2022-01-27 15:43:53 +0800", "snippet": ".NET 以 MIT 协议开源，于是任何人都可以尝试对其进行一丢丢的修改以实现一些原本很难实现的功能，例如在多个可执行程序（exe）之间共享同一个私有部署的 .NET 运行时。然而，对其的修改得能够编译生成期望的文件才行。本文介绍一下如何编译 dotnet/runtime 仓库，日常使用非常简单，所以如果只是轻微修改的话，本文大概就够了。首先记得先把仓库拉下来： dotnet/runtime: .NET is a cross-platform runtime for cloud, mobile, desktop, and IoT apps.如果有产品化需求，记得切到对应的 Tag（例如 v6.0.1 等）。编译命令在 Windows 系统上，编译入口在 build.cmd 文件中。如果想简单调试用，那么直接双击或在终端中执行一下它就够了。不过，以下命令可能更常用些：# 编译 win-x64 Release 版本（实际系统为你编译所用的系统）.\\build.cmd -a x64 -c Release# 编译 win-x86 Release 版本（实际系统为你编译所用的系统）.\\build.cmd -a x86 -c Release首次编译会慢一些，需要拉一些包以及下载一些工具，如果有些工具一直无法下载的话，可能需要考虑一下魔法上网。如果没有改动代码的话，不需要做其他额外设置即可完成编译。在首次编译完成后，后续差量编译大约 15 分钟能完成。等全部编译完成后，你可以在 artifacts 路径中找到所有输出的文件，按需取用即可。更详细的命令在仓库的 eng\\build.ps1 文件里，有一个 Get-Help 函数，可以输出帮助信息。你也可以直接通过此命令得到完全的帮助信息输出：.\\build.cmd -h帮助信息输出如下：Common settings: -arch (-a) Target platform: x86, x64, arm, arm64, or wasm. Pass a comma-separated list to build for multiple architectures. [Default: Your machine&#39;s architecture.] -binaryLog (-bl) Output binary log. -configuration (-c) Build configuration: Debug, Release or Checked. Checked is exclusive to the CLR subset. It is the same as Debug, except code is compiled with optimizations enabled. Pass a comma-separated list to build for multiple configurations. [Default: Debug] -help (-h) Print help and exit. -librariesConfiguration (-lc) Libraries build configuration: Debug or Release. [Default: Debug] -os Target operating system: windows, Linux, OSX, Android or Browser. [Default: Your machine&#39;s OS.] -runtimeConfiguration (-rc) Runtime build configuration: Debug, Release or Checked. Checked is exclusive to the CLR runtime. It is the same as Debug, except code is compiled with optimizations enabled. [Default: Debug] -runtimeFlavor (-rf) Runtime flavor: CoreCLR or Mono. [Default: CoreCLR] -subset (-s) Build a subset, print available subsets with -subset help. &#39;-subset&#39; can be omitted if the subset is given as the first argument. [Default: Builds the entire repo.] -verbosity (-v) MSBuild verbosity: q[uiet], m[inimal], n[ormal], d[etailed], and diag[nostic]. [Default: Minimal] -vs Open the solution with Visual Studio using the locally acquired SDK. Path or any project or solution name is accepted. (Example: -vs Microsoft.CSharp or -vs CoreCLR.sln)Actions (defaults to -restore -build): -build (-b) Build all source projects. This assumes -restore has been run already. -clean Clean the solution. -pack Package build outputs into NuGet packages. -publish Publish artifacts (e.g. symbols). This assumes -build has been run already. -rebuild Rebuild all source projects. -restore Restore dependencies. -sign Sign build outputs. -test (-t) Incrementally builds and runs tests. Use in conjuction with -testnobuild to only run tests.Libraries settings: -allconfigurations Build packages for all build configurations. -coverage Collect code coverage when testing. -framework (-f) Build framework: net6.0 or net48. [Default: net6.0] -testnobuild Skip building tests when invoking -test. -testscope Scope tests, allowed values: innerloop, outerloop, all.Native build settings: -cmakeargs User-settable additional arguments passed to CMake. -ninja Use Ninja to drive the native build. (default) -msbuild Use MSBuild to drive the native build. This is a no-op for Mono. -pgoinstrument Build the CLR with PGO instrumentation.Command-line arguments not listed above are passed through to MSBuild.The above arguments can be shortened as much as to be unambiguous.(Example: -con for configuration, -t for test, etc.).Here are some quick examples. These assume you are on a Windows x64 machine:* Build CoreCLR for Windows x64 on Release configuration:.\\build.cmd clr -c release* Cross-compile CoreCLR runtime for Windows ARM64 on Release configuration..\\build.cmd clr.runtime -arch arm64 -c release* Build Debug libraries with a Release runtime for Windows x64..\\build.cmd clr+libs -rc release* Build Release libraries and their tests with a Checked runtime for Windows x64, and run the tests..\\build.cmd clr+libs+libs.tests -rc checked -lc release -test* Build Mono runtime for Windows x64 on Release configuration..\\build.cmd mono -c release* Build Release coreclr corelib, crossgen corelib and update Debug libraries testhost to run test on an updated corelib..\\build.cmd clr.corelib+clr.nativecorelib+libs.pretest -rc release* Build Debug mono corelib and update Release libraries testhost to run test on an updated corelib..\\build.cmd mono.corelib+libs.pretest -rc debug -c releaseFor more information, check out https://github.com/dotnet/runtime/blob/main/docs/workflow/README.md" }, { "title": "一文看懂 .NET 的异常处理机制、原则以及最佳实践", "url": "/post/dotnet-exception.html", "categories": "", "tags": "dotnet, csharp", "date": "2022-01-27 15:08:22 +0800", "snippet": "什么时候该抛出异常，抛出什么异常？什么时候该捕获异常，捕获之后怎么处理异常？你可能已经使用异常一段时间了，但对 .NET/C# 的异常机制依然有一些疑惑。那么，可以阅读本文。本文适用于已经入门 .NET/C# 开发，已经开始在实践中抛出和捕获异常，但是对 .NET 异常机制的用法以及原则比较模糊的小伙伴。通过阅读本文，小伙伴们可以迅速在项目中使用比较推荐的异常处理原则来处理异常。快速了解 .NET 的异常机制Exception 类我们大多数小伙伴可能更多的使用 Exception 的类型、Message 属性、StackTrace 以及内部异常来定位问题，但其实 Exception 类型还有更多的信息可以用于辅助定位问题。 Message 用来描述异常原因的详细信息 如果你捕捉到了异常，一般使用这段描述能知道发生的大致原因。 如果你准备抛出异常，在这个信息里面记录能帮助调试问题的详细文字信息。 StackTrace 包含用来确定错误位置的堆栈跟踪（当有调试信息如 PDB 时，这里就会包含源代码文件名和源代码行号） InnerException 包含内部异常信息 Source 这个属性包含导致错误的应用程序或对象的名称 Data 这是一个字典，可以存放基于键值的任意数据，帮助在异常信息中获得更多可以用于调试的数据 HelpLink 这是一个 url，这个 url 里可以提供大量用于说明此异常原因的信息如果你自己写一个自定义异常类，那么你可以在自定义的异常类中记录更多的信息。然而大多数情况下我们都考虑使用 .NET 中自带的异常类，因此可以充分利用 Exception 类中的已有属性在特殊情况下报告更详细的利于调试的异常信息。捕捉异常捕捉异常的基本语法是：try{ // 可能引发异常的代码。}catch (FileNotFoundException ex){ // 处理一种类型的异常。}catch (IOException ex){ // 处理另一种类的异常。}除此之外，还有 when 关键字用于筛选异常：try{ // 可能引发异常的代码。}catch (FileNotFoundException ex) when (Path.GetExtension(ex.FileName) is &quot;.png&quot;){ // 处理一种类型的异常，并且此文件扩展名为 .png。}catch (FileNotFoundException ex){ // 处理一种类型的异常。}无论是否有带 when 关键字，都是前面的 catch 块匹配的时候执行匹配的 catch 块而无视后面可能也匹配的 catch 块。如果 when 块中抛出异常，那么此异常将被忽略，when 中的表达式值视为 false。有个但是，请看：.NET Framework 的 bug？try-catch-when 中如果 when 语句抛出异常，程序将彻底崩溃 - walterlv。引发异常引发异常使用 throw 关键字。只是注意如果要重新抛出异常，请使用 throw; 语句或者将原有异常作为内部异常。创建自定义异常如果你只是随便在业务上创建一个异常，那么写一个类继承自 Exception 即可：public class MyCustomException : Exception{ public string MyCustomProperty { get; } public MyCustomException(string customProperty) =&amp;gt; MyCustomProperty = customProperty;}不过，如果你需要写一些比较通用抽象的异常（用于被继承），或者在底层组件代码中写自定义异常，那么就建议考虑写全异常的所有构造函数，并且加上可序列化：[Serializable]public class InvalidDepartmentException : Exception{ public InvalidDepartmentException() : base() { } public InvalidDepartmentException(string message) : base(message) { } public InvalidDepartmentException(string message, Exception innerException) : base(message, innerException) { } // 如果异常需要跨应用程序域、跨进程或者跨计算机抛出，就需要能被序列化。 protected InvalidDepartmentException(SerializationInfo info, StreamingContext context) : base(info, context) { }}在创建自定义异常的时候，建议： 名称以 Exception 结尾 Message 属性的值是一个句子，用于描述异常发生的原因。 提供帮助诊断错误的属性。 尽量写全四个构造函数，前三个方便使用，最后一个用于序列化异常（新的异常类应可序列化）。finally异常堆栈跟踪堆栈跟踪从引发异常的语句开始，到捕获异常的 catch 语句结束。利用这一点，你可以迅速找到引发异常的那个方法，也能找到是哪个方法中的 catch 捕捉到的这个异常。异常处理原则try-catch-finally我们第一个要了解的异常处理原则是——明确 try catch finally 的用途！try 块中，编写可能会发生异常的代码。最好的情况是，你只将可能会发生异常的代码放到 try 块中，当然实际应用的时候可能会需要额外放入一些相关代码。但是如果你将多个可能发生异常的代码放到一个 try 块中，那么将来定位问题的时候你就会很抓狂（尤其是多个异常还是一个类别的时候）。catch 块的作用是用来 “恢复错误” 的，是用来 “恢复错误” 的，是用来 “恢复错误” 的。如果你在 try 块中先更改了类的状态，随后出了异常，那么最好能将状态改回来——这可以避免这个类型或者应用程序的其他状态出现不一致——这很容易造成应用程序“雪崩”。举一个例子：我们写一个程序有简洁模式和专业模式，在从简洁模式切换到专业模式的时候，我们设置 IsProfessionalMode 为 true，但随后出现了异常导致没有成功切换为专业模式；然而接下来所有的代码在执行时都判断 IsProfessionalMode 为 true 状态不正确，于是执行了一些非预期的操作，甚至可能用到了很多专业模式中才会初始化的类型实例（然而没有完成初始化），产生大量的额外异常；我们说程序雪崩了，多数功能再也无法正常使用了。当然如果任务已全部完成，仅仅在对外通知的时候出现了异常，那么这个时候不需要恢复状态，因为实际上已经完成了任务。你可能会有些担心如果我没有任何手段可以恢复错误怎么办？那这个时候就不要处理异常！——如果不知道如何恢复错误，请不要处理异常！让异常交给更上一层的模块处理，或者交给整个应用程序全局异常处理模块进行统一处理（这个后面会讲到）。另外，异常不能用于在正常执行过程中更改程序的流程。异常只能用于报告和处理错误条件。finally 块的作用是清理资源。虽然 .NET 的垃圾回收机制可以在回收类型实例的时候帮助我们回收托管资源（例如 FileStream 类打开的文件），但那个时机不可控。因此我们需要在 finally 块中确保资源可被回收，这样当重新使用这个文件的时候能够立刻使用而不会被占用。一段异常处理代码中可能没有 catch 块而有 finally 块，这个时候的重点是清理资源，通常也不知道如何正确处理这个错误。一段异常处理代码中也可能 try 块留空，而只在 finally 里面写代码，这是为了“线程终止”安全考虑。在 .NET Core 中由于不支持线程终止因此可以不用这么写。详情可以参考：.NET/C# 异常处理：写一个空的 try 块代码，而把重要代码写到 finally 中（Constrained Execution Regions） - walterlv。该不该引发异常？什么情况下该引发异常？答案是——这真的是一个异常情况！于是，我们可能需要知道什么是“异常情况”。一个可以参考的判断方法是——判断这件事发生的频率： 如果这件事并不常见，当它发生时确实代表发生了一个错误，那么这件事情就可以认为是异常。 如果这件事经常发生，代码中正常情况就应该处理这件事情，那么这件事情就不应该被认为是异常（而是正常流程的一部分）。例如这些情况都应该认为是异常： 方法中某个参数不应该传入 null 时但传入了 null 这是开发者使用这个方法时没有遵循此方法的契约导致的，让开发者改变调用此方法的代码就可以完全避免这件事情发生 而下面这些情况则不应该认为是异常： 用户输入了一串字符，你需要将这串字符转换为数字 用户输入的内容本身就千奇百怪，出现非数字的输入再正常不过了，对非数字的处理本就应该成为正常流程的一部分 对于这些不应该认为是异常的情况，编写的代码就应该尽可能避免异常。有两种方法来避免异常： 先判断再使用。 例如读取文件之前，先判断文件是否存在；例如读取文件流时先判断是否已到达文件末尾。 如果提前判断的成本过高，可采用 TryDo 模式来完成，例如字符串转数字中的 TryParse 方法，字典中的 TryGetValue 方法。 对极为常见的错误案例返回 null（或默认值），而不是引发异常。极其常见的错误案例可被视为常规控制流。通过在这些情况下返回 NULL（或默认值），可最大程度地减小对应用的性能产生的影响。（后面会专门说 null）而当存在下列一种或多种情况时，应引发异常： 方法无法完成其定义的功能。 根据对象的状态，对某个对象进行不适当的调用。请勿有意从自己的源代码中引发 System.Exception、System.SystemException、System.NullReferenceException 或 System.IndexOutOfRangeException。该不该捕获异常？在前面 try-catch-finally 小节中，我们提到了 catch 块中应该写哪些代码，那里其实已经说明了哪些情况下应该处理异常，哪些情况下不应该处理异常。一句总结性的话是——如果知道如何从错误中恢复，那么就捕获并处理异常，否则交给更上层的业务去捕获异常；如果所有层都不知道如何处理异常，就交给全局异常处理模块进行处理。应用程序全局处理异常对于 .NET 程序，无论是 .NET Framework 还是 .NET Core，都有下面这三个可以全局处理的异常。这三个都是事件，可以自行监听。 AppDomain.UnhandledException 应用程序域未处理的异常，任何线程中未处理掉的异常都会进入此事件中 当这里能够收到事件，意味着应用程序现在频临崩溃的边缘（从设计上讲，都到这里了，也再没有任何代码能够使得程序从错误中恢复了） 不过也可以配置 legacyUnhandledExceptionPolicy 防止后台线程抛出的异常让程序崩溃退出 建议在这个事件中记录崩溃日志，然后对应用程序进行最后的拯救恢复操作（例如保存用户的文档数据） AppDomain.FirstChanceException 应用程序域中的第一次机会异常 我们前面说过，一个异常被捕获时，其堆栈信息将包含从 throw 块到 catch 块之间的所有帧，而在第一次机会异常事件中，只是刚刚 throw 出来，还没有被任何 catch 块捕捉，因此在这个事件中堆栈信息永远只会包含一帧（不过可以稍微变通一下在第一次机会异常 FirstChanceException 中获取比较完整的异常堆栈） 注意第一次机会异常事件即便异常会被 catch 也会引发，因为它引发在 catch 之前 不要认为异常已经被 catch 就万事大吉可以无视这个事件了。前面我们说过异常仅在真的是异常的情况才应该引发，因此如果这个事件中引发了异常，通常也真的意味着发生了错误（差别只是我们能否从错误中恢复而已）。如果你经常在正常的操作中发现可以通过此事件监听到第一次机会异常，那么一定是应用程序或框架中的异常设计出了问题（可能把正常应该处理的流程当作了异常，可能内部实现代码错误，可能出现了使用错误），这种情况一定是要改代码修 Bug 的。而一些被认为是异常的情况下收到此事件则是正常的。 TaskScheduler.UnobservedTaskException 在使用 async / await 关键字编写异步代码的时候，如果一直有 await 传递，那么异常始终可以被处理到；但中间有异步任务没有 await 导致异常没有被传递的时候，就会引发此事件。 如果在此事件中监听到异常，通常意味着代码中出现了不正确的 async / await 的使用（要么应该修改实现避免异常，要么应该正确处理异常并从中恢复错误） 对于 GUI 应用程序，还可以监听 UI 线程上专属的全局异常： WPF：Application.DispatcherUnhandledException 或者 Dispatcher.UnhandledException Windows Forms：Application.ThreadException关于这些全局异常的处理方式和示例代码，可以参阅博客： WPF UnhandledException - Iron 的博客 - CSDN博客抛出哪些异常？任何情况下都不应该抛出这些异常： 过于抽象，以至于无法表明其含义 Exception 这可是顶级基类，这都抛出来了，使用者再也无法正确地处理此异常了 SystemException 这是各种异常的基类，本身并没有明确的意义 ApplicationException 这是各种异常的基类，本身并没有明确的意义 由 CLR 引发的异常 NullReferenceException 试图在空引用上执行某些方法，除了告诉实现者出现了意料之外的 null 之外，没有什么其它价值了 IndexOutOfRangeException 使用索引的时候超出了边界 InvalidCastException 表示试图对某个类型进行强转但类型不匹配 StackOverflow 表示栈溢出，这通常说明实现代码的时候写了不正确的显式或隐式的递归 OutOfMemoryException 表示托管堆中已无法分出期望的内存空间，或程序已经没有更多内存可用了 AccessViolationException 这说明使用非托管内存时发生了错误 BadImageFormatException 这说明了加载的 dll 并不是期望中的托管 dll TypeLoadException 表示类型初始化的时候发生了错误 .NET 设计失误 FormatException 因为当它抛出来时无法准确描述到底什么错了 首先是你自己不应该抛出这样的异常。其次，你如果在运行中捕获到了上面这些异常，那么代码一定是写得有问题。如果是捕获到了上面 CLR 的异常，那么有两种可能： 你的代码编写错误（例如本该判空的代码没有判空，又如索引数组超出界限） 你使用到的别人写的代码编写错误（那你就需要找到它改正，或者如果开源就去开源社区中修复吧）而一旦捕获到了上面其他种类的异常，那就找到抛这个异常的人，然后对它一阵狂扁即可。其他的异常则是可以抛出的，只要你可以准确地表明错误原因。另外，尽量不要考虑抛出聚合异常 AggregateException，而是优先使用 ExceptionDispatchInfo 抛出其内部异常。详见：使用 ExceptionDispatchInfo 捕捉并重新抛出异常 - walterlv。异常的分类在 该不该引发异常 小节中我们说到一个异常会被引发，是因为某个方法声称的任务没有成功完成（失败），而失败的原因有四种： 方法的使用者用错了（没有按照方法的契约使用） 方法的执行代码写错了 方法执行时所在的环境不符合预期简单说来，就是：使用错误，实现错误、环境错误。使用错误： ArgumentException 表示参数使用错了 ArgumentNullException 表示参数不应该传入 null ArgumentOutOfRangeException 表示参数中的序号超出了范围 InvalidEnumArgumentException 表示参数中的枚举值不正确 InvalidOperationException 表示当前状态下不允许进行此操作（也就是说存在着允许进行此操作的另一种状态） ObjectDisposedException 表示对象已经 Dispose 过了，不能再使用了 NotSupportedException 表示不支持进行此操作（这是在说不要再试图对这种类型的对象调用此方法了，不支持） PlatformNotSupportedException 表示在此平台下不支持（如果程序跨平台的话） NotImplementedException 表示此功能尚在开发中，暂时请勿使用实现错误：前面由 CLR 抛出的异常代码主要都是实现错误 NullReferenceException 试图在空引用上执行某些方法，除了告诉实现者出现了意料之外的 null 之外，没有什么其它价值了 IndexOutOfRangeException 使用索引的时候超出了边界 InvalidCastException 表示试图对某个类型进行强转但类型不匹配 StackOverflowException 表示栈溢出，这通常说明实现代码的时候写了不正确的显式或隐式的递归 OutOfMemoryException 表示托管堆中已无法分出期望的内存空间，或程序已经没有更多内存可用了 AccessViolationException 这说明使用非托管内存时发生了错误 BadImageFormatException 这说明了加载的 dll 并不是期望中的托管 dll TypeLoadException 表示类型初始化的时候发生了错误环境错误： IOException 下的各种子类 Win32Exception 下的各种子类 ……另外，还剩下一些不应该抛出的异常，例如过于抽象的异常和已经过时的异常，这在前面一小结中有说明。其他一些常见异常的原因和解决方法在平时的开发当中，你可能会遇到这样一些异常，它不像是自己代码中抛出的那些常见的异常，但也不包含我们自己的异常堆栈。这里介绍一些常见这些异常的原因和解决办法。AccessViolationException当出现此异常时，说明非托管内存中发生了错误。如果要解决问题，需要从非托管代码中着手调查。这个异常是访问了不允许的内存时引发的。在原因上会类似于托管中的 NullReferenceException。FileNotFoundException捕捉非 CLS 异常参考资料 Handling and throwing exceptions in .NET - Microsoft Docs Exceptions and Exception Handling - C# Programming Guide - Microsoft Docs Design Guidelines for Exceptions - Microsoft Docs" }, { "title": "在 Windows 系统上降低 UAC 权限运行程序（从管理员权限降权到普通用户权限）", "url": "/post/start-process-with-lowered-uac-privileges.html", "categories": "", "tags": "windows, dotnet, csharp", "date": "2022-01-27 12:50:19 +0800", "snippet": "在 Windows 系统中，管理员权限和非管理员权限运行的程序之间不能使用 Windows 提供的通信机制进行通信。对于部分文件夹（ProgramData），管理员权限创建的文件是不能以非管理员权限修改和删除的。然而，一个进程运行之后启动的子进程，会继承当前进程的 UAC 权限；于是有时我们会有降权运行的需要。本文将介绍 Windows 系统上降权运行的几种方法。本文的降权运行指的是： 有一个 A 程序是以管理员权限运行的（典型的，如安装包）； 有一个 B 程序会被 A 启动（我们期望降权运行的 B 程序）。如何判断当前进程的 UAC 权限通过下面的代码，可以获得当前进程的 UAC 权限。var identity = WindowsIdentity.GetCurrent();var principal = new WindowsPrincipal(identity);而如果要判断是否是管理员权限，则使用：if (principal.IsInRole(WindowsBuiltInRole.Administrator)){ // 当前正在以管理员权限运行。}此代码如果在 .NET Core 中编写，需要额外安装 Windows 兼容包：Microsoft.Windows.Compatibility。方法一：使用 runas 命令来运行程序（推荐）使用 runas 命令来运行，可以指定一个权限级别：&amp;gt; runas /trustlevel:0x20000 &quot;C:\\Users\\walterlv\\Desktop\\walterlv.exe&quot;var subProcessFileName = @&quot;C:\\Users\\walterlv\\Desktop\\walterlv.exe&quot;;Process.Start(&quot;runas.exe&quot;, $&quot;/trustlevel:0x20000 {subProcessFileName}&quot;);关于 runas 的更多细节，可以参考我的另一篇博客： Windows 下使用 runas 命令以指定的权限启动一个进程（非管理员、管理员） - 吕毅方法二：使用 explorer.exe 代理运行程序请特别注意，使用 explorer.exe 代理运行程序的时候，是不能带参数的，否则 explorer.exe 将不会启动你的程序。因为绝大多数用户启动系统的时候，explorer.exe 进程都是处于运行状态，而如果启动一个新的 explorer.exe，都会自动激活当前正在运行的进程而不会启动新的。于是我们可以委托默认以普通权限运行的 explorer.exe 来代理启动我们需要启动的子进程，这时启动的子进程便是与 explorer.exe 相同权限的。var subProcessFileName = &quot;C:\\Users\\walterlv\\Desktop\\walterlv.exe&quot;;Process.Start(&quot;explorer.exe&quot;, subProcessFileName);如果用户计算机上的 UAC 是打开的，那么 explorer.exe 默认就会以标准用户权限运行。通过以上代码，walterlv.exe 就会以与 explorer.exe 相同权限运行，也就是降权运行了。不过值得注意的是，Windows 7 上控制面板的 UAC 设置拉倒最低就是关掉 UAC 了；Windows 8 开始拉倒最底 UAC 还是打开的，只是不会提示 UAC 弹窗而已。也就是说，拉倒最底的话，Windows 7 的 UAC 就会关闭，explorer.exe 就会以管理员权限启动。下面的代码，如果发现自己是以管理员权限运行的，那么就降权重新运行自己，然后自己退出。（当然在关闭 UAC 的电脑上是无效的。）var identity = WindowsIdentity.GetCurrent();var principal = new WindowsPrincipal(identity);if (principal.IsInRole(WindowsBuiltInRole.Administrator)){ // 检测到当前进程是以管理员权限运行的，于是降权启动自己之后，把自己关掉。 Process.Start(&quot;explorer.exe&quot;, Assembly.GetEntryAssembly().Location); Shutdown(); return;}请再次特别注意，使用 explorer.exe 代理运行程序的时候，是不能带参数的，否则 explorer.exe 将不会启动你的程序。方法三：在启动进程时传入用户名和密码ProcessStartInfo 中有 UserName 和 Password 属性，设置此属性可以以此计算机上的另一个用户身份启动此进程。如果这个用户是普通用户，那么就会以普通权限运行此进程。var processInfo = new ProcessStartInfo{ Verb = &quot;runas&quot;, FileName = &quot;walterlv.exe&quot;, UserName = &quot;walterlv&quot;, Password = ReadPassword(), UseShellExecute = false, LoadUserProfile = true};Process.Start(processInfo);上面的 ReadPassword 函数来自我的另一篇博客：如何让 .NET Core 命令行程序接受密码的输入而不显示密码明文 - walterlv。然而，此方法最大的问题在于——产品级的程序，不可能也不应该知道用户的密码！所以实际上这样的方法并不实用。方法四：使用 Shell 进程的 Access Token 来启动进程此方法需要较多的 Windows API 调用，我没有尝试过这种方法，但是你可以自行尝试下面的链接： c# - How do you de-elevate privileges for a child process - Stack Overflow参考资料 c# starting process with lowered privileges from UAC admin level process - Stack Overflow c# - How do you de-elevate privileges for a child process - Stack Overflow c# - How do you de-elevate privileges for a child process - Stack Overflow windows - Force a program to run without administrator privileges or UAC? - Super User High elevation can be bad for your application: How to start a non-elevated process at the end of the installation - CodeProject How to Enable Drag and Drop for an Elevated MFC Application on Vista/Windows 7 • Helge Klein" }, { "title": "使用 Source Generator 在编译你的 .NET 项目时自动生成代码", "url": "/post/generate-csharp-source-using-roslyn-source-generator", "categories": "dotnet, csharp, roslyn", "tags": "", "date": "2021-12-29 14:07:43 +0800", "snippet": "本文将带你为你的某个库添加自动生成代码的逻辑。本文以 dotnetCampus.Ipc 项目为例，来说明如何为一个现成的 .NET 类库添加自动生成代码的功能。这是一个在本机内进行进程间通信的库，在你拥有一个 IPC 接口和对应的实现之后，本库还会自动帮你生成通过 IPC 代理访问的代码。由于项目加了 Roslyn 的 SourceGenerator 功能，所以当你安装了 dotnetCampus.Ipc NuGet 包 后，这些代码将自动生成，省去了手工编写的费神。dotnetCampus.Ipc 简介例如你有一个接口 IWalterlv 和其对应的实现 WalterlvImpl：public interface IWalterlv{ Task&amp;lt;string&amp;gt; GetUrlAsync();}public class WalterlvImpl : IWalterlv{ public Task&amp;lt;string&amp;gt; GetUrlAsync() { return Task.FromResult(&quot;https://blog.walterlv.com&quot;); }}那么只需要在 WalterlvImpl 上标记这是一个 IPC 对象即可：++ [IpcPublic(typeof(IWalterlv))] public class WalterlvImpl : IWalterlv这时，编译这个项目，将会自动生成这样的两个类： WalterlvIpcProxy：负责代理访问 IPC 对方 WalterlvIpcJoint：负责接收对方的 IPC 访问，然后对接到本地真实实例那么本文就以它为例子说明如何编写一个代码生成器： 开始编写一个基本的代码生成器 使用代码生成器生成需要的代码 将代码生成器加入到现有的 NuGet 包中 调试代码生成器一个基本的代码生成器创建一个项目，例如 dotnetCampus.Ipc.Analyzers，然后编辑其项目文件（csproj）。至少要包含以下内容： TargetFramework 必须是 netstandard2.0，目前（Visual Studio 2022 和 MSBuild 17）不支持其他任何框架。 引用 Microsoft.CodeAnalysis.Analyzers 和 Microsoft.CodeAnalysis.CSharp 并且不对外传递他们的依赖。&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;TargetFramework&amp;gt;netstandard2.0&amp;lt;/TargetFramework&amp;gt; &amp;lt;AppendTargetFrameworkToOutputPath&amp;gt;false&amp;lt;/AppendTargetFrameworkToOutputPath&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;PackageReference Include=&quot;Microsoft.CodeAnalysis.Analyzers&quot; Version=&quot;3.3.3&quot; PrivateAssets=&quot;all&quot; /&amp;gt; &amp;lt;PackageReference Include=&quot;Microsoft.CodeAnalysis.CSharp&quot; Version=&quot;4.0.1&quot; PrivateAssets=&quot;all&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt;&amp;lt;/Project&amp;gt;这里的 AppendTargetFrameworkToOutputPath 是可选的，目的是去掉生成路径下的 netstandard2.0 文件夹。接着创建一个代码生成器类：[Generator]public class ProxyJointGenerator : ISourceGenerator{ public void Initialize(GeneratorInitializationContext context) { } public void Execute(GeneratorExecutionContext context) { }}这样，你就写好了一个基本的生成器的代码框架了，剩下的就是往里面填内容了。生成代码Initialize 方法可进行一些初始化，你可以在这里订阅代码的变更通知，可以要求监听某些 C# 甚至是非代码文件的修改。本文是入门向，所以不涉及到这个方法。接下来我们大部分的代码都将从那个 Execute 方法开始。例如，我们可以随便写一个：// 这段代码来自 https://docs.microsoft.com/zh-cn/dotnet/csharp/roslyn-sdk/source-generators-overviewpublic void Execute(GeneratorExecutionContext context){ // find the main method var mainMethod = context.Compilation.GetEntryPoint(context.CancellationToken); // build up the source code string source = $@&quot;using System;namespace {mainMethod.ContainingNamespace.ToDisplayString()}{{ public static partial class {mainMethod.ContainingType.Name} {{ static partial void HelloFrom(string name) {{ Console.WriteLine($&quot;&quot;Generator says: Hi from &#39;{{name}}&#39;&quot;&quot;); }} }}}}&quot;; // add the source code to the compilation context.AddSource(&quot;generatedSource&quot;, source);}这里的 AddSource 就是将代码添加到你的项目中了。而我在 dotnetCampus.Ipc 库中编写的生成代码会稍微复杂一点，会根据项目中标记了 IpcPublic 的类的代码动态生成对这个类的代理访问和对接代码，使用的是 Roslyn 进行语义分析。可参见：使用 Roslyn 对 C# 代码进行语义分析 - walterlv。public void Execute(GeneratorExecutionContext context){ foreach (var ipcObjectType in FindIpcPublicObjects(context.Compilation)) { try { var contractType = ipcObjectType.ContractType; var proxySource = GenerateProxySource(ipcObjectType); var jointSource = GenerateJointSource(ipcObjectType); var assemblySource = GenerateAssemblyInfoSource(ipcObjectType); context.AddSource($&quot;{contractType.Name}.proxy&quot;, SourceText.From(proxySource, Encoding.UTF8)); context.AddSource($&quot;{contractType.Name}.joint&quot;, SourceText.From(jointSource, Encoding.UTF8)); context.AddSource($&quot;{contractType.Name}.assembly&quot;, SourceText.From(assemblySource, Encoding.UTF8)); } catch (DiagnosticException ex) { context.ReportDiagnostic(ex.ToDiagnostic()); } catch (Exception ex) { context.ReportDiagnostic(Diagnostic.Create(DIPC001_UnknownError, null, ex)); } }}这段代码的含义为： 通过自己写的 FindIpcPublicObjects 方法找到目前项目里所有的标记了 IpcPublic 特性的类； 为这个类生成代理类（Proxy）； 为这个类生成对接类（Joint）； 为这些类生成关系（AssemblyInfo）； 将这些新生成的代码都加入到项目中进行编译； 如果中间出现了未知异常，则用自己编写的 DiagnosticException 异常类辅助报告编译错误。这里只介绍创建代码分析器的一般方法，更多生成器代码可以前往仓库浏览：dotnetCampus.Ipc 项目。为 NuGet 包添加生成代码的功能现在，我们要将这个生成代码的功能添加到 NuGet 包中。最终打出的 NuGet 包会是下面这样：为了生成这样的包，我们需要： 添加解决方案依赖，确保编译 dotnetCampus.Ipc 之前，dotnetCampus.Ipc.Analyzers 项目已完成编译； 将 dotnetCampus.Ipc.Analyzers.dll 加入到 NuGet 包中。对于 1，在解决方案上右键-&amp;gt;“项目依赖项”，然后在 dotnetCampus.Ipc 项目上把 dotnetCampus.Ipc.Analyzers 勾上。对于 2，我们需要修改真正打包的那个项目，也就是 dotnetCampus.Ipc 项目，在其 csproj 文件的末尾添加：&amp;lt;Target Name=&quot;_IncludeAllDependencies&quot; BeforeTargets=&quot;_GetPackageFiles&quot;&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;None Include=&quot;..\\dotnetCampus.Ipc.Analyzers\\bin\\$(Configuration)\\**\\*.dll&quot; Pack=&quot;True&quot; PackagePath=&quot;analyzers\\dotnet\\cs&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt;&amp;lt;/Target&amp;gt;这样便能生成我们期望的 NuGet 包了。等打包发布后，就能出现本文一开始说的能生成代码的效果了。调试代码生成器代码生成器编写更复杂的时候，调试就成了一个问题。接下来我们说说如何调试代码生成器。这种代码的调试，大家可能很容易就想到了用 Debugger.Launch() 来调试，就像这样： public void Initialize(GeneratorInitializationContext context) {++ System.Diagnostics.Debugger.Launch(); }但是，用什么项目的编译来触发这个调试呢？总不可能在某个项目上安装上这个 NuGet 包吧……那样效率太低了。我们再建一个 dotnetCampus.Ipc.Test 项目，在其 csproj 文件上加上这么一行：&amp;lt;ItemGroup&amp;gt; &amp;lt;ProjectReference Include=&quot;..\\..\\src\\dotnetCampus.Ipc.Analyzers\\dotnetCampus.Ipc.Analyzers.csproj&quot; OutputItemType=&quot;Analyzer&quot; ReferenceOutputAssembly=&quot;false&quot; /&amp;gt;&amp;lt;/ItemGroup&amp;gt;OutputItemType=&quot;Analyzer&quot; 表示将项目添加为分析器，ReferenceOutputAssembly=&quot;false&quot; 表示此项目无需引用分析器项目的程序集。这样，编译此 dotnetCampus.Ipc.Test 项目时，就会触发选择调试器的界面，你就能调试你的代码生成器了。使用这种方式引用，相比于 NuGet 包引用来说，项目的分析器列表里无法看到生成的代码。如果需要在这种情况下看到代码，你可能需要在 context.AddSource 那里打上一个断点，来看生成的代码是什么样的。当然，除了用项目引用的方式，你还能直接引用最终的 dll：&amp;lt;ItemGroup&amp;gt; &amp;lt;Analyzer Include=&quot;..\\..\\src\\dotnetCampus.Ipc.Analyzers\\bin\\$(Configuration)\\dotnetCampus.Ipc.Analyzers.dll&quot; OutputItemType=&quot;Analyzer&quot; ReferenceOutputAssembly=&quot;false&quot; /&amp;gt;&amp;lt;/ItemGroup&amp;gt;参考资料 源生成器 - Microsoft Docs roslyn/source-generators.md at main · dotnet/roslyn roslyn/source-generators.cookbook.md at main · dotnet/roslyn" }, { "title": "使用 Roslyn 对 C# 代码进行语义分析", "url": "/post/roslyn-semantic-analysis-starter", "categories": "dotnet, roslyn, csharp", "tags": "", "date": "2021-12-29 08:47:18 +0800", "snippet": "Roslyn 是微软为 C# 设计的一套分析器，它具有很强的扩展性。以至于我们只需要编写很少量的代码便能够分析我们的源代码。之前我写过一些使用 Roslyn 进行语法分析的文章。使用语法分析，可以轻松为代码编写提供各种错误报告以及修改代码（见这里）。而使用语义分析，你可以像在运行时使用反射一样，在编译时访问源代码中的各种类型、属性、方法等，特别适合用来分析引用、生成代码等。当然，实际项目里面将两者结合起来可以做到更多的效果。本文将以 dotnetCampus.Ipc 项目里的自动生成 IPC 代理类型作为示例，来介绍如何使用 Roslyn 进行语法分析。本文会更偏碎片化。第一步：找到编译信息和语法树在开始后面的实际语义分析之前，你需要先拿到以下对象的实例： Microsoft.CodeAnalysis.SyntaxTree：包含单个文件里所有语法节点的语法树 Microsoft.CodeAnalysis.Compilation: 包含整个编译项目的编译信息你有以下方法可以拿到这些对象。如果你正在编写代码分析器（Analyzer）和修改器（CodeFix）代码分析器和修改器的入口方法可以得到一个 SyntaxNodeAnalysisContext 类型的参数，这个参数里面就可以拿到 Compilation 的实例。同时，在这个入口方法中，你也很容易就得到一个语法节点“SyntaxNode”的实例，而每一个语法节点都有 SyntaxTree 属性可以拿到语法树。关于代码分析器（Analyzer）和修改器（CodeFix）可以参考我之前的这些博客： 可参考：基于 Roslyn 同时为 Visual Studio 插件和 NuGet 包开发 .NET/C# 源代码分析器 Analyzer 和修改器 CodeFixProvider - walterlv 可参考：使用基于 Roslyn 的 Microsoft.CodeAnalysis.PublicApiAnalyzers 来追踪项目的 API 改动，帮助保持库的 API 兼容性 - walterlv 可参考：使用 Roslyn 分析代码注释，给 TODO 类型的注释添加负责人、截止日期和 issue 链接跟踪 - walterlv如果你正在编写代码生成器（Generator）代码生成器的入口方法带有一个 GeneratorExecutionContext 类型的参数，而它直接就有我们需要的两种对象。 GeneratorExecutionContext.Compilation 即整个项目的编译信息； GeneratorExecutionContext.Compilation.SyntaxTrees 包含整个项目正在参与编译的所有非生成器生成的代码的语法树。第二步：获取语义模型和语义符号使用这句，可以拿到一个语法树的语义模型：var semanticModel = compilation.GetSemanticModel(syntaxTree);通过这个语义模型，你可以找到每一个语法节点所对应的语义符号到底是什么。接下来的部分，你需要先拥有 Roslyn 语法分析的基本能力才能完成，因为要拿到一个语义符号，你需要先拿到其对应的语法节点（至少是第一个节点）。例如，拿到一个语法树（SyntaxTree）中的类型定义，可以用下面的方法：// 遍历语法树中的所有节点，找到所有类型定义的节点。var classDeclarationSyntaxes = from node in syntaxTree.GetRoot().DescendantNodes() where node.IsKind(SyntaxKind.ClassDeclaration) select (ClassDeclarationSyntax) node;这样，针对这个语法树里面的每一个类型定义，我们都可以拿到其对应的语义了：foreach (var classDeclarationSyntax in classDeclarationSyntaxes){ if (semanticModel.GetDeclaredSymbol(classDeclarationSyntax) is { } classDeclarationSymbol) { // 在这里使用你的类型定义语义符号。 }}第三步：使用语义模型经过了前两个步骤，Roslyn 语义分析最难的部分就结束了（没错，两句代码就结束了）。接下来对语义符号的使用你可以简单想象成就是在使用反射功能的编译形式而已。你可以简单地获得类型的命名空间，获得类型的特性（Attribute）；获得类型的成员，成员的特性……// 获取类型的命名空间。var namespace = classDeclarationSymbol.ContainingNamespace;// 获得基类，获得接口。var baseType = classDeclarationSymbol.BaseType;var interfaces = classDeclarationSymbol.Interfaces;// 获取类型的成员。var members = classDeclarationSymbol.GetMembers();// 获取成员的类型，然后忽略掉属性里面的方法。foreach (var member in members){ if (member is IMethodSymbol method &amp;amp;&amp;amp; method.MethodKind is MethodKind.PropertyGet or MethodKind.PropertySet) { continue; } // 其他成员。}// 获得方法的形参数列表。var parameters = method.Parameters;// 获得方法的返回值类型。var returnType = method.ReturnType;还有更多。由于使用起来非常地直观而简单，所以就自己探索吧！参考资料 roslyn/source-generators.md at main · dotnet/roslyn roslyn/source-generators.cookbook.md at main · dotnet/roslyn" }, { "title": "将 Windows Terminal 作为外部工具集成到其他工具/程序/代码中", "url": "/post/add-windows-terminal-external-starting-support-with-working-directory.html", "categories": "", "tags": "windows, dotnet", "date": "2021-12-22 13:30:18 +0800", "snippet": "Windows Terminal 在 Windows 上是一款 UWP 应用，然而其依然具有良好的与外部工具的集成特性，你可以在其他各种工具中配置使用 Windows Terminal 打开。本文介绍如何配置使用 Windows Terminal 打开。命令行调用在应用商店可以下载到 Windows Terminal (Preview)，下载安装后，你就可以开始使用 wt 命令了，这可以用来启动 Windows Terminal。（这里要说明一下，虽然你可以找到应用程序在 C:\\Program Files\\WindowsApps\\Microsoft.WindowsTerminal_0.9.433.0_x64__8wekyb3d8bbwe\\WindowsTerminal.exe 下，但是你并没有权限直接去运行 UWP 应用的 exe 入口。因此，你在任意的命令行工具，甚至是 Win+R 运行窗口，或者开始菜单的搜索中输入 wt 回车就可以运行 Windows Terminal 了。增加的命令实际上来自于 C:\\Users\\lvyi\\AppData\\Local\\Microsoft\\WindowsApps 目录。你可以进入这个目录找到商店应用增加的所有的命令。默认情况下直接打开会进入用户文件夹下。如果需要在特定的工作目录下打开，则需要修改配置。请点击设置按钮打开配置文件，然后修改默认终端的 startingDirectory 属性，从 %USERPROFILE% 修改到其他路径：如果需要使用“当前工作路径”，则将 startingDirectory 修改为 %__CD__%。注意，CD 两边分别是两个下划线。 { …… &quot;snapOnInput&quot;: true,-- &quot;startingDirectory&quot;: &quot;%USERPROFILE%&quot;,++ &quot;startingDirectory&quot;: &quot;%__CD__%&quot;, &quot;useAcrylic&quot;: true },在修改成 %__CD__% 之后，如果通过快捷方式直接启动 Windows Terminal，则会看到路径被切换到了 C:\\Windows\\System32。不过这不重要，因为即便是选择了用户路径，每次启动也都是要切走的。工具集成在了解了以上命令行调用后，工具集成就简单多了，只需要设置好启动 wt 命令，以及设置好工作路径即可。设置工作路径的方法为为：wt -d .其中后面的 . 是当前路径，你也可以换成你需要的路径。如下图是我在 Directory Opus 中设置的 Windows Terminal 的一键打开按钮：关于 Directory Opus 集成工具可以参见我的其他博客： 在 Directory Opus 中添加自定义的工具栏按钮提升效率 - walterlv Directory Opus 使用命令编辑器添加 PowerShell / CMD / Bash 等多种终端到自定义菜单 - walterlvC# 代码调用使用 C# 代码启动的方法也非常常规，直接 Process.Start 然后设置工作路径即可。var info = new ProcessStartInfo(&quot;wt.exe&quot;, @&quot;-d D:\\walterlv&quot;){ UseShellExecute = false,};Process.Start(info);参考资料 Windows Terminal command line arguments - Microsoft Docs Programmatically Opening Windows Terminal in a Specific Folder - Rick Strahl’s Web Log" }, { "title": "WHAT DID DELL DO? All WPF apps are rendered in a mess!", "url": "/post/wpf-renders-wrong-because-of-nahimicosd-en.html", "categories": "", "tags": "wpf", "date": "2021-12-21 16:27:11 +0800", "snippet": "Recently, we have received many feedbacks from users, saying that our software interface is a mess, and there is no way to find any button locations. That’s really difficult to resolve because we do nothing extra about the rendering part of our software.This article will first give a conclusion to help you solve the problem and then show our investigation process.This post is written in multiple languages. Please select yours: 中文 English What happenedYes, all the buttons are displayed everywhere, and covered across each other, and be positioned here and there. You can’t even read any UI texts. The UI elements change and flash after your mouse move.The bugUnder normal circumstances, there are indeed many reasons for WPF rendering to blow up, but most of them are just broken in a single computer. But this blog talks about some widespread rendering problems that many computers are suffering from. And this time, DELL make this happen.Now please check the NahimicOSD.dll file which is the critical key point of this rendering issue. It may be in these locations: C:\\ProgramData\\A-Volute\\DellInc.AlienwareSoundCenter\\Modules\\ScheduledModules\\NahimicOSD.dll C:\\ProgramData\\AWHeadset\\DellInc.AlienwareSoundCenter\\Modules\\ScheduledModules\\NahimicOSD.dll C:\\ProgramData\\A-Volute\\A-Volute.28054DF1F58B4\\Modules\\ScheduledModules\\NahimicOSD.dll C:\\ProgramData\\A-Volute\\A-Volute.Nahimic\\Modules\\Scheduled\\NahimicOSD.dll C:\\ProgramData\\A-Volute\\Modules\\ScheduledModules\\NahimicOSD.dllAll of the paths above are from DELL Alienware. Also, there are some other paths but I’m not sure whether it breaks the WPF rendering. C:\\Program Files\\Nahimic\\Nahimic2\\UserInterface\\Nahimic2OSD.dllNahimicOSD is an on-screen display library that displays something on any software using DirectX as its rendering engine. Unfortunately, the additional rendering blooms the rendering of WPF apps (DirectX 9 application precisely).SolutionsSolution for UsersIf you’re not a developer or you just want to solve it for yourself, try these: Renaming the NahimicOSD.dll (because it cannot be deleted in case of being occupied) Restart your computer (Then it will not be injected into any programs) Lose your temper at this fileI’ve posted the issue on the DELL Alienware community and waiting for their reply and new driver update. You can see my discussions there: Solved: Area-51m R2, blurred text and images in some apps - Dell Community m17 R2, WPF apps distorted, disappearing window contents - Dell Community The WPF UI is blurring and broken while the Alienware NahimicOSD.dll injects · Issue #5708 · dotnet/wpfSolution for DevelopersIf you’re a developer and want to solve this issue for your software users, you can view these two methods.Method 1: Software Only RenderingWrite this code below before any WPF window shown:System.Windows.Media.RenderOptions.ProcessRenderMode = System.Windows.Interop.RenderMode.SoftwareOnly;And your windows will render in software mode and the NahimicOSD will not break your app.Method 2: Blacklist (Administrator Privilege Required)Open this file C:\\ProgramData\\A-Volute\\DellInc.AlienwareSoundCenter\\Modules\\ScheduledModules\\Configurator\\BlackApps.dat and append your process name at the end of it and then your process will not be injected by the NahimicOSD.dll.This is totally a text file so it’s easy to edit.How did we find the reason and solutions?Some of our software users gave feedback to us with the messing UI as attachments. Most of them were DELL devices with a 10th CPU and two graphics cards which confuses us. We tried to switch the default graphics card and tried to upgrade the graphics drivers but nothing helped.What made changes was a special user which was using a LENOVO device. We find that the DELL Alienware Sound Center was installed on his/her computer. It seems that the DELL Alienware Sound Center is the criminal. So we dumped our software and get the proves that the NahimicOSD.dll in DELL’s path was injected into our software. We deleted the NahimicOSD.dll file and everything go back to fine.Other discussionsThis GitHub issue made me surprised because this was the right topic to talk about the same issue which I was concerned about. What made me surprised more is that I was one of the talkers of them two years ago but I remember nothing.References Button renders wrong after mouse leave · Issue #707 · dotnet/wpf Solved: Area-51m R2, blurred text and images in some apps - Dell Community m17 R2, WPF apps distorted, disappearing window contents - Dell Community" }, { "title": "所有 WPF 程序的界面渲染完全糊掉，竟是戴尔电脑惹的锅？", "url": "/post/wpf-renders-wrong-because-of-nahimicosd.html", "categories": "", "tags": "wpf", "date": "2021-12-21 16:18:51 +0800", "snippet": "近期收到了多起来自用户的反馈，说我们软件界面糊成一团，完全没办法看到按钮在哪里。我一看，这可棘手了，完全不是我们软件能渲染出来的样子啊！本文将先给出结论帮助大家解决问题，随后再展示我们的调查过程。This post is written in multiple languages. Please select yours: 中文 English 现象大家看看下面的界面： 不同的界面元素大小不一，参差不齐地随处摆放 鼠标划过界面各部分时，划过的矩形区域会闪烁，闪成不同的模样 虽然渲染杂乱无章，但功能依旧还在，你能在界面本来应该在的部位点击获得本该有的正常的界面功能很明显，这是渲染炸掉了。我们软件的各处逻辑功能什么的都非常正常。另外，评论区有童鞋反馈搜不到这篇答案，所以我多贴一些关键字在这里：WPF花屏Blend界面花屏WPF控件错乱wpf模糊wpf控件显示异常wpf重影wpf按钮异常显示wpf异常放大wpf渲染问题wpf渲染错误wpf render abnormal原因正常情况下造成 WPF 渲染炸掉的原因其实有很多，但大多数只破坏一台计算机。而真正让产品在全球大范围炸掉的，只有近期戴尔外星人推送的一枚新的更新。因此，本博客只说戴尔外星人造成的问题。至于其他原因，你可以从本原因中获得灵感自行查找。请检查一下出问题的电脑上是否有 NahimicOSD.dll 这个文件，如果这是一台戴尔电脑，那么它最有可能出现在下面这个路径下： C:\\ProgramData\\A-Volute\\DellInc.AlienwareSoundCenter\\Modules\\ScheduledModules\\NahimicOSD.dll如果这是其他品牌的电脑，那么他很有可能出现在下面这个路径下（因为插上了外星人耳机，自动安装了驱动）： C:\\ProgramData\\AWHeadset\\DellInc.AlienwareSoundCenter\\Modules\\ScheduledModules\\NahimicOSD.dll当然，也有其他反馈说在别的路径下的： C:\\ProgramData\\A-Volute\\A-Volute.28054DF1F58B4\\Modules\\ScheduledModules\\NahimicOSD.dll C:\\ProgramData\\A-Volute\\A-Volute.Nahimic\\Modules\\Scheduled\\NahimicOSD.dll C:\\ProgramData\\A-Volute\\Modules\\ScheduledModules\\NahimicOSD.dll同时也存在非戴尔设备的情况： C:\\Program Files\\Nahimic\\Nahimic2\\UserInterface\\Nahimic2OSD.dllNahimicOSD 是一个用于在应用程序最终渲染结果上叠加另一个显示层的库，这个库会在应用程序运行时注入进程，并在目标进程调用 DirectX 渲染时将叠加层加入渲染。解决方法用户端解决方法（你自己遇到问题时使用）由于这个文件已经注入到了很多应用中，所以解决方法是将 NahimicOSD.dll 文件重命名（因为你直接删删不掉）。等重启电脑后，这个文件也就不会注入到任何程序里去了，这时你想怎么处置都可以。另外，这个文件可能有 x86 和 x64 两个版本；可能都需要处理，适用于不同架构的进程。已知有问题的应用： dnSpy (x64, .NET) WPF Performance Suite (x64/x86, .NET Framework)我们已经尝试了各种方式与外星人技术人员取得联系，但是都失败了。现在相关的问题戴尔技术论坛上也有人在讨论，不过官方技术人员目前还没有任何处理。现在有两个帖子在讨论，我在后面有回复： Solved: Area-51m R2, blurred text and images in some apps - Dell Community m17 R2, WPF apps distorted, disappearing window contents - Dell Community也写了一篇无奈的吐槽： The WPF UI is blurring and broken while the Alienware NahimicOSD.dll injects · Issue #5708 · dotnet/wpf开发端解决方法（修改你的程序以应对这种情况）方法一：软渲染（无奈之举）如果你的程序足够简单，那么采用软渲染来规避这个问题也未尝不可。方法是在你第一个窗口显示出来之前，调用一下下面这句话：System.Windows.Media.RenderOptions.ProcessRenderMode = System.Windows.Interop.RenderMode.SoftwareOnly;如果想避免影响范围太大，还可以判断一下是否存在这个文件：bool hasInjected = Process.GetCurrentProcess().Modules.OfType&amp;lt;ProcessModule&amp;gt;().Any(x =&amp;gt;{ return x.FileName.Equals(@&quot;C:\\ProgramData\\A-Volute\\DellInc.AlienwareSoundCenter\\Modules\\ScheduledModules\\NahimicOSD.dll&quot;, StringComparison.OrdinalIgnoreCase) || x.FileName.Equals(@&quot;C:\\ProgramData\\AWHeadset\\DellInc.AlienwareSoundCenter\\Modules\\ScheduledModules\\NahimicOSD.dll&quot;, StringComparison.OrdinalIgnoreCase);});if (hasInjected){ RenderOptions.ProcessRenderMode = RenderMode.SoftwareOnly;}方法二：黑名单（需要管理员权限）NahimicOSD 有一个黑名单文件 BlackApps.dat，在列表里的程序将不会注入破坏其渲染。路径在：C:\\ProgramData\\A-Volute\\DellInc.AlienwareSoundCenter\\Modules\\ScheduledModules\\Configurator\\BlackApps.dat虽然扩展名是 dat 但这是一个标准的文本文件，截取开头的一部分如下：firefox.exechrome.exeiexplore.exeopera.exesteam.exegameoverlayui.exevlc.exeskype.exeSkypeApp.exeRzSynapse.exeMovieMaker.exePhotoshop.exeblender.exegoogleearth.exeXBMC.exeBOXEE.exe你的程序可以用管理员权限修改这个文件，在末尾把你的进程名加上。顺便吐槽一下，这个文件截至目前已有 398 行了，包含了大量常用软件。所以既然开发商早已知道问题这么多，竟然还不修机制，而是通过黑名单来避免冲突，也是扯！调查过程实际上找到这个原因并没有花太多时间，但多少有些机缘巧合。 一开始，我们查看了用户电脑的型号、CPU/GPU 型号（都是戴尔，十代 CPU） 一开始怀疑的，必然是显卡驱动之类。但反馈此问题的用户中，有一部分是双显卡，换 Intel 的换 NVidia 的都不能修掉此问题，重新去官网下载安装最新版本的驱动亦不能解决掉该问题。所以直接排除此原因。 随后，我们将一些其他的 WPF 程序放到用户的电脑上运行（比如 dnSpy、WPF Performance Suite），结果都会糊掉。 随后，我们又将一个 DirectX 9 Demo 放到用户电脑上运行，然而 Demo 画面一直在动，我们又是远程调查的，所以难以判定这种糊到底是因为远程软件导致还是确实已经糊了，所以此步骤没有收获。在我们即将放弃之时，又一个新用户反馈了问题，与之前多个用户反馈不同的是，这是一台联想的电脑，八代 CPU，这样看来似乎又没有什么共性。林德熙提醒我可能跟 Button renders wrong after mouse leave · Issue #707 · dotnet/wpf 问题有关。于是我们立刻拿下 DUMP 文件，果然发现了可疑文件：一台联想的电脑上出现戴尔的模块，并且注入到了进程里面，实在是另人怀疑。并且 OSD 全称为 on-screen display，即屏幕叠加显示，更加值得怀疑。所以我们就在用户电脑上删除了 NahimicOSD 文件，重启程序，果然一切恢复正常。再联系用户，才发现原来用户近期插了一部外星人耳机，于是自动安装上了驱动。其他讨论在看到这篇讨论（Button renders wrong after mouse leave · Issue #707 · dotnet/wpf）后我惊呆了，因为我两年前其实也参加了讨论，但是竟然一点印象都没有，还在这里调查了这么久。如果大家有其他需要讨论的地方，也可以去那里讨论。参考资料 Button renders wrong after mouse leave · Issue #707 · dotnet/wpf" }, { "title": "删删删！快速将旧版 .NET Framework 的 WPF / Windows Forms 项目格式(csproj) 迁移成新版 SDK 风格的项目格式", "url": "/post/introduce-new-style-csproj-into-net-framework.html", "categories": "", "tags": "visualstudio, msbuild", "date": "2021-12-21 12:03:14 +0800", "snippet": "现在再使用 Visual Studio 创建新的 WPF 项目时，将默认引诱你使用 .NET 6（或者 5、.NET Core 3.1）框架和配套的新的 SDK 风格的项目文件（csproj）。新项目格式的人类可读性比旧项目要高出不少，而且新的 Visual Studio 也为它增加了非常多好用的显示效果和功能。但如果你手头有一个旧的 WPF 项目，要怎么才能使用到新项目格式带来的各种好处呢？本问将带你快速完成迁移，一路删删删。实际上，本文最早发布的时候 WPF on .NET Core 还没有发布，所以步骤会非常繁琐而且改完还有很多的 bug 要修。后来 WPF 和 Visual Studio 经过不断完善，现在再做迁移已经十分简单了。而本文将直接基于 Visual Studio 2022 来讲述（也适用于 VS2019），已经比当初修改要简单上太多了！准备工作为了方便讲述操作，我这里先着手准备一份旧格式的 WPF 项目。在创建项目时选“WPF 应用(.NET Framework)”就会使用旧的格式。下面我给两张新旧功能和 csproj 文件内容的比较，让你直观感受到升级项目到 SDK 风格后的好处。▲ (旧项目支持) 左 | 右 (新项目支持)▲ (旧项目格式) 左 | 右 (新项目格式)可以很明显发现，新格式文件内容很简单易读，而且 Visual Studio 也针对新格式给出分类的引用。当然，新格式还有更多好处，比如多框架，比如开可空引用类型等。开始迁移第一步：写个基本框架右键项目，选“卸载项目”；再右键项目，选“编辑项目文件”。请复制以下整块代码，然后粘贴替换掉你原来项目文件里的所有内容：&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk.WindowsDesktop&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;TargetFramework&amp;gt;net48&amp;lt;/TargetFramework&amp;gt; &amp;lt;UseWPF&amp;gt;true&amp;lt;/UseWPF&amp;gt; &amp;lt;/PropertyGroup&amp;gt;&amp;lt;/Project&amp;gt;如果是 Windows Forms 项目，则将其中的 &amp;lt;UseWPF&amp;gt;true&amp;lt;/UseWPF&amp;gt; 换成 &amp;lt;UseWindowsForms&amp;gt;true&amp;lt;/UseWindowsForms&amp;gt;；如果同时用到了 WPF 和 Windows Forms，则这两句都需要加上。额外的，根据你项目的实际情况稍作调整： 如果期望其他的 .NET Framework 版本，则把 net48 改为其他版本（如 net45、net462 等） 如果期望同时拥有 .NET 6 和 .NET Framework 版本，则把 TargetFramework 变复数，然后在里面加多个框架（如 &amp;lt;TargetFrameworks&amp;gt;net6.0-windows;net48&amp;lt;/TargetFrameworks&amp;gt;）改完之后，右键项目，选“重新加载项目”。第二步：删除不再需要的文件如果你不知道或不记得曾改过以下这几个文件，那么就应该全删掉。（这些文件是自动生成的，换言之，如果你明确知道这几个文件你正在用，那么就不要删。） Properties\\Resources.resx Properties\\Resources.Designer.resx Properties\\Settings.resx Properties\\Settings.Designer.resx App.config packages.config打开 AssemblyInfo.cs，删掉除 ThemeInfo 以外的全部内容。（这些内容是自动生成的，换言之，如果你自己往里面新增了内容，也应保留。）删完后，应是下面这样：using System.Windows;[assembly: ThemeInfo( ResourceDictionaryLocation.None, //主题特定资源词典所处位置 //(未在页面中找到资源时使用， //或应用程序资源字典中找到时使用) ResourceDictionaryLocation.SourceAssembly //常规资源词典所处位置 //(未在页面中找到资源时使用， //、应用程序或任何主题专用资源字典中找到时使用))]Windows Forms 项目里面没有这个特性，所以整个文件都可以删除。第三步：加回以前的引用，改回以前的属性如果你以前装过一些 NuGet 包，那么重新装一下；如果你以前引用过一些项目，那么重新引用一下。如果以前设置了一些特殊属性，那么也右键项目，选“属性”，在新的属性面板里面一条条对着改就好： 输出类型（类库，还是应用程序） 平台目标（Any CPU，还是 x86） 其他参考资料因为本文最早发布的时候 WPF on .NET Core 还没有发布，所以这么简单的内容也参考了如下非常多的资料： XAML files are not supported · Issue #810 · dotnet/sdk XAML files are not supported · Issue #1467 · dotnet/project-system Old csproj to new csproj: Visual Studio 2017 upgrade guide Using the new .Csproj without .Net core · Issue #1688 · Microsoft/msbuild c# - WPF App Using new csproj format - Stack Overflow XAML files are not supported · Issue #1467 · dotnet/project-system XAML files are not supported · Issue #810 · dotnet/sdk c# - How-to migrate Wpf projects to the new VS2017 format - Stack Overflow project.json doesn’t have a runtimes section, add ‘“runtimes”: { “win”: { } }’ to project.json · Issue #5931 · Microsoft/vsts-tasks Ignore PROJECT.JSON when using .CSPROJ · Issue #394 · Microsoft/msbuild dotnet build fails when referencing a project converted to PackageReference · Issue #6294 · dotnet/cli Visual studio project.json does not have a runtime section - Stack Overflow" }, { "title": ".NET 中各种混淆（Obfuscation）的含义、原理、实际效果和不同级别的差异（使用 SmartAssembly）", "url": "/post/obfuscation-configurations-of-smart-assembly.html", "categories": "", "tags": "dotnet, csharp", "date": "2021-12-20 23:15:01 +0800", "snippet": "长文预警！！！UWP 程序有 .NET Native 可以将程序集编译为本机代码，逆向的难度会大很多；而基于 .NET Framework 和 .NET Core 的程序却没有 .NET Native 的支持。虽然有 Ngen.exe 可以编译为本机代码，但那只是在用户计算机上编译完后放入了缓存中，而不是在开发者端编译。于是有很多款混淆工具来帮助混淆基于 .NET 的程序集，使其稍微难以逆向。本文介绍 Smart Assembly 各项混淆参数的作用以及其实际对程序集的影响。本文不会讲 SmartAssembly 的用法，因为你只需打开它就能明白其基本的使用。感兴趣可以先下载：.NET Obfuscator, Error Reporting, DLL Merging - SmartAssembly。准备我们先需要准备程序集来进行混淆试验。这里，我使用 Whitman 来试验。它在 GitHub 上开源，并且有两个程序集可以试验它们之间的相互影响。额外想吐槽一下，SmartAssembly 的公司 Red Gate 一定不喜欢这款软件，因为界面做成下面这样竟然还长期不更新：而且，如果要成功编译，还得用上同为 Red Gate 家出品的 SQL Server，如果不装，软件到处弹窗报错。只是报告错误而已，干嘛还要开发者装一个那么重量级的 SQL Server 啊！详见：Why is SQL Server required — Redgate forums。SmartAssemblySmartAssembly 本质上是保护应用程序不被逆向或恶意篡改。目前我使用的版本是 6，它提供了对 .NET Framework 程序的多种保护方式： 强签名 Strong Name Signing 强签名可以确保程序之间的依赖关系是严格确定的，如果对其中的一个依赖进行篡改，将导致无法加载正确的程序集。 微软提供了强签名工具，所以可以无需使用 SmartAssembly 的： Sn.exe (Strong Name Tool) - Microsoft Docs How to: Sign an Assembly with a Strong Name - Microsoft Docs 自动错误上报 Automated Error Reporting SmartAssembly 会自动向 exe 程序注入异常捕获与上报的逻辑。 功能使用率上报 Feature Usage Reporting SmartAssembly 会修改每个方法，记录这些方法的调用次数并上报。 依赖合并 Dependencies Merging SmartAssembly 会将程序集中你勾选的的依赖与此程序集合并成一个整的程序集。 依赖嵌入 Dependencies Embedding SmartAssembly 会将依赖以加密并压缩的方式嵌入到程序集中，运行时进行解压缩与解密。 其实这只是方便了部署（一个 exe 就能发给别人），并不能真正保护程序集，因为实际运行时还是解压并解密出来了。 裁剪 Pruning SmartAssembly 会将没有用到的字段、属性、方法、事件等删除。它声称删除了这些就能让程序逆向后代码更难读懂。 名称混淆 Obfuscation 修改类型、字段、属性、方法等的名称。 流程混淆 Control Flow Obfuscation 修改方法内的执行逻辑，使其执行错综复杂。 动态代理 References Dynamic Proxy SmartAssembly 会将方法的调用转到动态代理上。 资源压缩加密 Resources Compression and Encryption SmartAssembly 会将资源以加密并压缩的方式嵌入到程序集中，运行时进行解压缩与解密。 字符串压缩加密 Strings Encoding SmartAssembly 会将字符串都进行加密，运行时自动对其进行解密。 防止 MSIL Disassembler 对其进行反编译 MSIL Disassembler Protection 在程序集中加一个 Attribute，这样 MSIL Disassembler 就不会反编译这个程序集。 密封类 如果 SmartAssembly 发现一个类可以被密封，就会把它密封，这样能获得一点点性能提升。 生成调试信息 Generate Debugging Information 可以生成混淆后的 pdb 文件 以上所有 SmartAssembly 对程序集的修改中，我标为 粗体 的是真的在做混淆，而标为 斜体 的是一些辅助功能。后面我只会说明其混淆功能。裁剪 Pruning我故意在 Whitman.Core 中写了一个没有被用到的 internal 类 UnusedClass，如果我们开启了裁剪，那么这个类将消失。▲ 没用到的类将消失特别注意，如果标记了 InternalsVisibleTo，尤其注意不要不小心被误删了。名称混淆 Obfuscation类/方法名与字段名的混淆名称混淆中，类名和方法名的混淆有三个不同级别： 等级 1 是使用 ASCII 字符集 等级 2 是使用不可见的 Unicode 字符集 等级 3 是使用高级重命名算法的不可见的 Unicode 字符集需要注意：对于部分程序集，类与方法名（NameMangling）的等级只能选为 3，否则混淆程序会无法完成编译。字段名的混淆有三个不同级别： 等级 1 是源码中字段名称和混淆后字段名称一一对应 等级 2 是在一个类中的不同字段使用不同名称即可（这不废话吗，不过 SmartAssembly 应该是为了强调与等级 1 和等级 3 的不同，必须写一个描述） 等级 3 是允许不同类中的字段使用相同的名字（这样能够更加让人难以理解）需要注意：对于部分程序集，字段名（FieldsNameMangling）的等级只能选为 2 或 3，否则混淆程序会无法完成编译。实际试验中，以上各种组合经常会出现无法编译的情况。下面是 Whitman 中 RandomIdentifier 类中的部分字段在混淆后的效果：// Token: 0x04000001 RID: 1[CompilerGenerated][DebuggerBrowsable(DebuggerBrowsableState.Never)]private int \\u0001;// Token: 0x04000002 RID: 2private readonly Random \\u0001 = new Random();// Token: 0x04000003 RID: 3private static readonly Dictionary&amp;lt;int, int&amp;gt; \\u0001 = new Dictionary&amp;lt;int, int&amp;gt;();这部分的原始代码可以在 冷算法：自动生成代码标识符（类名、方法名、变量名） 找到。如果你需要在混淆时使用名称混淆，你只需要在以上两者的组合中找到一个能够编译通过的组合即可，不需要特别在意等级 1~3 的区别，因为实际上都做了混淆，1~3 的差异对逆向来说难度差异非常小的。需要 特别小心如果有 InternalsVisibleTo 或者依据名称的反射调用，这种混淆下极有可能挂掉！！！请充分测试你的软件，切记！！！转移方法 ChangeMethodParent如果开启了 ChangeMethodParent，那么混淆可能会将一个类中的方法转移到另一个类中，这使得逆向时对类型含义的解读更加匪夷所思。排除特定的命名空间如果你的程序集中确实存在需要被按照名称反射调用的类型，或者有 internal 的类/方法需要被友元程序集调用，请排除这些命名空间。流程混淆 Control Flow Obfuscation列举我在 Whitman.Core 中的方法：public string Generate(bool pascal){ var builder = new StringBuilder(); var wordCount = WordCount &amp;lt;= 0 ? 4 - (int) Math.Sqrt(_random.Next(0, 9)) : WordCount; for (var i = 0; i &amp;lt; wordCount; i++) { var syllableCount = 4 - (int) Math.Sqrt(_random.Next(0, 16)); syllableCount = SyllableMapping[syllableCount]; for (var j = 0; j &amp;lt; syllableCount; j++) { var consonant = Consonants[_random.Next(Consonants.Count)]; var vowel = Vowels[_random.Next(Vowels.Count)]; if ((pascal || i != 0) &amp;amp;&amp;amp; j == 0) { consonant = CultureInfo.CurrentCulture.TextInfo.ToTitleCase(consonant); } builder.Append(consonant); builder.Append(vowel); } } return builder.ToString();}▲ 这个方法可以在 冷算法：自动生成代码标识符（类名、方法名、变量名） 找到。流程混淆修改方法内部的实现。为了了解各种不同的流程混淆级别对代码的影响，我为每一个混淆级别都进行反编译查看。▲ 没有混淆0 级流程混淆▲ 0 级流程混淆1 级流程混淆▲ 1 级流程混淆可以发现 0 和 1 其实完全一样。又被 SmartAssembly 耍了。2 级流程混淆2 级流程混淆代码很长，所以我没有贴图：// Token: 0x06000004 RID: 4 RVA: 0x00002070 File Offset: 0x00000270public string Generate(bool pascal){ StringBuilder stringBuilder = new StringBuilder(); StringBuilder stringBuilder2; if (-1 != 0) { stringBuilder2 = stringBuilder; } int num2; int num = num2 = this.WordCount; int num4; int num3 = num4 = 0; int num6; int num8; if (num3 == 0) { int num5 = (num &amp;lt;= num3) ? (4 - (int)Math.Sqrt((double)this._random.Next(0, 9))) : this.WordCount; if (true) { num6 = num5; } int num7 = 0; if (!false) { num8 = num7; } if (false) { goto IL_10E; } if (7 != 0) { goto IL_134; } goto IL_8E; } IL_6C: int num9 = num2 - num4; int num10; if (!false) { num10 = num9; } int num11 = RandomIdentifier.SyllableMapping[num10]; if (6 != 0) { num10 = num11; } IL_86: int num12 = 0; int num13; if (!false) { num13 = num12; } IL_8E: goto IL_11E; IL_10E: string value; stringBuilder2.Append(value); num13++; IL_11E: string text; bool flag; if (!false) { if (num13 &amp;gt;= num10) { num8++; goto IL_134; } text = RandomIdentifier.Consonants[this._random.Next(RandomIdentifier.Consonants.Count)]; value = RandomIdentifier.Vowels[this._random.Next(RandomIdentifier.Vowels.Count)]; flag = ((pascal || num8 != 0) &amp;amp;&amp;amp; num13 == 0); } if (flag) { text = CultureInfo.CurrentCulture.TextInfo.ToTitleCase(text); } if (!false) { stringBuilder2.Append(text); goto IL_10E; } goto IL_86; IL_134: if (num8 &amp;gt;= num6) { return stringBuilder2.ToString(); } num2 = 4; num4 = (int)Math.Sqrt((double)this._random.Next(0, 16)); goto IL_6C;}▲ 2 级流程混淆这时就发现代码的可读性降低了，需要耐心才能解读其含义。3 级流程混淆以下是 3 级流程混淆：// Token: 0x06000004 RID: 4 RVA: 0x0000207C File Offset: 0x0000027Cpublic string Generate(bool pascal){ StringBuilder stringBuilder = new StringBuilder(); int num2; int num = num2 = this.WordCount; int num4; int num3 = num4 = 0; int num7; int num8; string result; if (num3 == 0) { int num5; if (num &amp;gt; num3) { num5 = this.WordCount; } else { int num6 = num5 = 4; if (num6 != 0) { num5 = num6 - (int)Math.Sqrt((double)this._random.Next(0, 9)); } } num7 = num5; num8 = 0; if (false) { goto IL_104; } if (7 == 0) { goto IL_84; } if (!false) { goto IL_12A; } return result; } IL_73: int num9 = num2 - num4; num9 = RandomIdentifier.SyllableMapping[num9]; IL_81: int num10 = 0; IL_84: goto IL_114; IL_104: string value; stringBuilder.Append(value); num10++; IL_114: string text; bool flag; if (!false) { if (num10 &amp;gt;= num9) { num8++; goto IL_12A; } text = RandomIdentifier.Consonants[this._random.Next(RandomIdentifier.Consonants.Count)]; value = RandomIdentifier.Vowels[this._random.Next(RandomIdentifier.Vowels.Count)]; flag = ((pascal || num8 != 0) &amp;amp;&amp;amp; num10 == 0); } if (flag) { text = CultureInfo.CurrentCulture.TextInfo.ToTitleCase(text); } if (!false) { stringBuilder.Append(text); goto IL_104; } goto IL_81; IL_12A: if (num8 &amp;lt; num7) { num2 = 4; num4 = (int)Math.Sqrt((double)this._random.Next(0, 16)); goto IL_73; } result = stringBuilder.ToString(); return result;}▲ 3 级流程混淆3 级流程混淆并没有比 2 级高多少，可读性差不多。不过需要注意的是，这些差异并不是随机差异，因为重复生成得到的流程结果是相同的。4 级流程混淆以下是 4 级流程混淆：// Token: 0x06000004 RID: 4 RVA: 0x0000207C File Offset: 0x0000027Cpublic unsafe string Generate(bool pascal){ void* ptr = stackalloc byte[14]; StringBuilder stringBuilder = new StringBuilder(); StringBuilder stringBuilder2; if (!false) { stringBuilder2 = stringBuilder; } int num = (this.WordCount &amp;lt;= 0) ? (4 - (int)Math.Sqrt((double)this._random.Next(0, 9))) : this.WordCount; *(int*)ptr = 0; for (;;) { ((byte*)ptr)[13] = ((*(int*)ptr &amp;lt; num) ? 1 : 0); if (*(sbyte*)((byte*)ptr + 13) == 0) { break; } *(int*)((byte*)ptr + 4) = 4 - (int)Math.Sqrt((double)this._random.Next(0, 16)); *(int*)((byte*)ptr + 4) = RandomIdentifier.SyllableMapping[*(int*)((byte*)ptr + 4)]; *(int*)((byte*)ptr + 8) = 0; for (;;) { ((byte*)ptr)[12] = ((*(int*)((byte*)ptr + 8) &amp;lt; *(int*)((byte*)ptr + 4)) ? 1 : 0); if (*(sbyte*)((byte*)ptr + 12) == 0) { break; } string text = RandomIdentifier.Consonants[this._random.Next(RandomIdentifier.Consonants.Count)]; string value = RandomIdentifier.Vowels[this._random.Next(RandomIdentifier.Vowels.Count)]; bool flag = (pascal || *(int*)ptr != 0) &amp;amp;&amp;amp; *(int*)((byte*)ptr + 8) == 0; if (flag) { text = CultureInfo.CurrentCulture.TextInfo.ToTitleCase(text); } stringBuilder2.Append(text); stringBuilder2.Append(value); *(int*)((byte*)ptr + 8) = *(int*)((byte*)ptr + 8) + 1; } *(int*)ptr = *(int*)ptr + 1; } return stringBuilder2.ToString();}▲ 4 级流程混淆我们发现，4 级已经开始使用没有含义的指针来转换我们的内部实现了。这时除了外部调用以外，代码基本已无法解读其含义了。动态代理 References Dynamic Proxy还是以上一节中我们 Generate 方法作为示例，在开启了动态代理之后（仅开启动态代理，其他都关掉），方法变成了下面这样：// Token: 0x06000004 RID: 4 RVA: 0x0000206C File Offset: 0x0000026Cpublic string Generate(bool pascal){ StringBuilder stringBuilder = new StringBuilder(); int num = (this.WordCount &amp;lt;= 0) ? (4 - (int)\\u0002.\\u0002((double)\\u0001.~\\u0001(this._random, 0, 9))) : this.WordCount; for (int i = 0; i &amp;lt; num; i++) { int num2 = 4 - (int)\\u0002.\\u0002((double)\\u0001.~\\u0001(this._random, 0, 16)); num2 = RandomIdentifier.SyllableMapping[num2]; for (int j = 0; j &amp;lt; num2; j++) { string text = RandomIdentifier.Consonants[\\u0003.~\\u0003(this._random, RandomIdentifier.Consonants.Count)]; string text2 = RandomIdentifier.Vowels[\\u0003.~\\u0003(this._random, RandomIdentifier.Vowels.Count)]; bool flag = (pascal || i != 0) &amp;amp;&amp;amp; j == 0; if (flag) { text = \\u0006.~\\u0006(\\u0005.~\\u0005(\\u0004.\\u0004()), text); } \\u0007.~\\u0007(stringBuilder, text); \\u0007.~\\u0007(stringBuilder, text2); } } return \\u0008.~\\u0008(stringBuilder);}▲ 动态代理注意到 _random.Next(0, 9) 变成了 \\u0001.~\\u0001(this._random, 0, 9)，Math.Sqrt(num) 变成了 \\u0002.\\u0002(num)。也就是说，一些常规方法的调用被替换成了一个代理类的调用。那么代理类在哪里呢？▲ 生成的代理类生成的代理类都在根命名空间下。比如刚刚的 \\u0001.~\\u0001 调用，就是下面这个代理类：// Token: 0x0200001A RID: 26internal sealed class \\u0001 : MulticastDelegate{ // Token: 0x06000030 RID: 48 public extern \\u0001(object, IntPtr); // Token: 0x06000031 RID: 49 public extern int Invoke(object, int, int); // Token: 0x06000032 RID: 50 RVA: 0x000030A8 File Offset: 0x000012A8 static \\u0001() { MemberRefsProxy.CreateMemberRefsDelegates(25); } // Token: 0x04000016 RID: 22 internal static \\u0001 \\u0001; // Token: 0x04000017 RID: 23 internal static \\u0001 ~\\u0001;}字符串编码与加密 Strings Encoding字符串统一收集编码 Encode字符串编码将程序集中的字符串都统一收集起来，存为一个资源；然后提供一个辅助类统一获取这些字符串。比如 Whitman.Core 中的字符串现在被统一收集了：▲ 统一收集的字符串和解密辅助类在我的项目中，统一收集的字符串可以形成下面这份字符串（也即是上图中 Resources 文件夹中的那个文件内容）： cQ== dw== cg== dA== eQ== cA== cw== ZA== Zg== Zw== aA== ag== aw== bA== eg== eA== Yw== dg== Yg== bg== bQ== dHI= ZHI= Y2g= d2g= c3Q= YQ== ZQ== aQ== bw== dQ== YXI= YXM= YWk= YWly YXk= YWw= YWxs YXc= ZWU= ZWE= ZWFy ZW0= ZXI= ZWw= ZXJl aXM= aXI= b3U= b3I= b28= b3c= dXI= MjAxOC0wOC0yNlQxODoxMDo0Mw==`VGhpcyBhc3NlbWJseSBoYXMgYmVlbiBidWlsdCB3aXRoIFNtYXJ0QXNzZW1ibHkgezB9LCB3aGljaCBoYXMgZXhwaXJlZC4= RXZhbHVhdGlvbiBWZXJzaW9uxVGhpcyBhc3NlbWJseSBoYXMgYmVlbiBidWlsdCB3aXRoIFNtYXJ0QXNzZW1ibHkgezB9LCBhbmQgdGhlcmVmb3JlIGNhbm5vdCBiZSBkaXN0cmlidXRlZC4= IA== Ni4xMi41Ljc5OQ== U21hcnRBc3NlbWJseQ== UGF0aA== U29mdHdhcmVcUmVkIEdhdGVc(U29mdHdhcmVcV293NjQzMk5vZGVcUmVkIEdhdGVc由于这些不可见字符让我的博客挂掉了，所以我用图来补，上文就换成空格了……虽然字符串难以读懂，但其实我原本就是这么写的；给你看看我的原始代码就知道了（来自 冷算法：自动生成代码标识符（类名、方法名、变量名））：private static readonly List&amp;lt;string&amp;gt; Consonants = new List&amp;lt;string&amp;gt;{ &quot;q&quot;,&quot;w&quot;,&quot;r&quot;,&quot;t&quot;,&quot;y&quot;,&quot;p&quot;,&quot;s&quot;,&quot;d&quot;,&quot;f&quot;,&quot;g&quot;,&quot;h&quot;,&quot;j&quot;,&quot;k&quot;,&quot;l&quot;,&quot;z&quot;,&quot;x&quot;,&quot;c&quot;,&quot;v&quot;,&quot;b&quot;,&quot;n&quot;,&quot;m&quot;, &quot;w&quot;,&quot;r&quot;,&quot;t&quot;,&quot;p&quot;,&quot;s&quot;,&quot;d&quot;,&quot;f&quot;,&quot;g&quot;,&quot;h&quot;,&quot;j&quot;,&quot;k&quot;,&quot;l&quot;,&quot;c&quot;,&quot;b&quot;,&quot;n&quot;,&quot;m&quot;, &quot;r&quot;,&quot;t&quot;,&quot;p&quot;,&quot;s&quot;,&quot;d&quot;,&quot;h&quot;,&quot;j&quot;,&quot;k&quot;,&quot;l&quot;,&quot;c&quot;,&quot;b&quot;,&quot;n&quot;,&quot;m&quot;, &quot;r&quot;,&quot;t&quot;,&quot;s&quot;,&quot;j&quot;,&quot;c&quot;,&quot;n&quot;,&quot;m&quot;, &quot;tr&quot;,&quot;dr&quot;,&quot;ch&quot;,&quot;wh&quot;,&quot;st&quot;, &quot;s&quot;,&quot;s&quot;};生成的字符串获取辅助类就像下面这样不太容易读懂：// Token: 0x0200000A RID: 10public class Strings{ // Token: 0x0600001C RID: 28 RVA: 0x00002B94 File Offset: 0x00000D94 public static string Get(int stringID) { stringID -= Strings.offset; if (Strings.cacheStrings) { object obj = Strings.hashtableLock; lock (obj) { string text; Strings.hashtable.TryGetValue(stringID, out text); if (text != null) { return text; } } } int index = stringID; int num = (int)Strings.bytes[index++]; int num2; if ((num &amp;amp; 128) == 0) { num2 = num; if (num2 == 0) { return string.Empty; } } else if ((num &amp;amp; 64) == 0) { num2 = ((num &amp;amp; 63) &amp;lt;&amp;lt; 8) + (int)Strings.bytes[index++]; } else { num2 = ((num &amp;amp; 31) &amp;lt;&amp;lt; 24) + ((int)Strings.bytes[index++] &amp;lt;&amp;lt; 16) + ((int)Strings.bytes[index++] &amp;lt;&amp;lt; 8) + (int)Strings.bytes[index++]; } string result; try { byte[] array = Convert.FromBase64String(Encoding.UTF8.GetString(Strings.bytes, index, num2)); string text2 = string.Intern(Encoding.UTF8.GetString(array, 0, array.Length)); if (Strings.cacheStrings) { try { object obj = Strings.hashtableLock; lock (obj) { Strings.hashtable.Add(stringID, text2); } } catch { } } result = text2; } catch { result = null; } return result; } // Token: 0x0600001D RID: 29 RVA: 0x00002CF4 File Offset: 0x00000EF4 static Strings() { if (Strings.MustUseCache == &quot;1&quot;) { Strings.cacheStrings = true; Strings.hashtable = new Dictionary&amp;lt;int, string&amp;gt;(); } Strings.offset = Convert.ToInt32(Strings.OffsetValue); using (Stream manifestResourceStream = Assembly.GetExecutingAssembly().GetManifestResourceStream(&quot;{f6b5a51a-b2fb-4143-af01-e2295062799f}&quot;)) { int num = Convert.ToInt32(manifestResourceStream.Length); Strings.bytes = new byte[num]; manifestResourceStream.Read(Strings.bytes, 0, num); manifestResourceStream.Close(); } } // Token: 0x0400000C RID: 12 private static readonly string MustUseCache = &quot;0&quot;; // Token: 0x0400000D RID: 13 private static readonly string OffsetValue = &quot;203&quot;; // Token: 0x0400000E RID: 14 private static readonly byte[] bytes = null; // Token: 0x0400000F RID: 15 private static readonly Dictionary&amp;lt;int, string&amp;gt; hashtable; // Token: 0x04000010 RID: 16 private static readonly object hashtableLock = new object(); // Token: 0x04000011 RID: 17 private static readonly bool cacheStrings = false; // Token: 0x04000012 RID: 18 private static readonly int offset = 0;}生成字符串获取辅助类后，原本写着字符串的地方就会被替换为 Strings.Get(int) 方法的调用。字符串压缩加密 Compress前面那份统一收集的字符串依然还是明文存储为资源，但还可以进行压缩。这时，Resources 中的那份字符串资源现在是二进制文件（截取前 256 字节）：00000000: 7b7a 7d02 efbf bdef bfbd 4def bfbd efbf00000010: bd7e 6416 efbf bd6a efbf bd22 efbf bd0800000020: efbf bdef bfbd 4c42 7138 72ef bfbd efbf00000030: bd54 1337 efbf bd0e 22ef bfbd 69ef bfbd00000040: 613d efbf bd6e efbf bd35 efbf bd0a efbf00000050: bd33 6043 efbf bd26 59ef bfbd 5471 efbf00000060: bdef bfbd 2cef bfbd 18ef bfbd 6def bfbd00000070: efbf bdef bfbd 64ef bfbd c9af efbf bdef00000080: bfbd efbf bd4b efbf bdef bfbd 66ef bfbd00000090: 1e70 efbf bdef bfbd ce91 71ef bfbd 1d5e000000a0: 1863 efbf bd16 0473 25ef bfbd 2204 efbf000000b0: bdef bfbd 11ef bfbd 4fef bfbd 265a 375f000000c0: 7bef bfbd 19ef bfbd d5bd efbf bdef bfbd000000d0: efbf bd70 71ef bfbd efbf bd05 c789 efbf000000e0: bd51 eaae beef bfbd ee97 adef bfbd 0a33000000f0: d986 141c 2bef bfbd efbf bdef bfbd 1fef这份压缩的字符串在程序启动的时候会进行一次解压，随后就直接读取解压后的字符串了。所以会占用启动时间（虽然不长），但不会占用太多运行时时间。为了能够解压出这些压缩的字符串，Strings 类相比于之前会在读取后进行一次解压缩（解密）。可以看下面我额外标注出的 Strings 类新增的一行。 using (Stream manifestResourceStream = Assembly.GetExecutingAssembly().GetManifestResourceStream(&quot;{4f639d09-ce0f-4092-b0c7-b56c205d48fd}&quot;)) { int num = Convert.ToInt32(manifestResourceStream.Length); byte[] buffer = new byte[num]; manifestResourceStream.Read(buffer, 0, num);++ Strings.bytes = SimpleZip.Unzip(buffer); manifestResourceStream.Close(); }至于嵌入其中的解压与解密类 SimpleZip，我就不能贴出来了，因为反编译出来有 3000+ 行：字符串缓存 UseCache与其他的缓存策略一样，每次获取字符串都太消耗计算资源的话，就可以拿内存空间进行缓存。在实际混淆中，我发现无论我是否开启了字符串缓存，实际 Strings.Get 方法都会缓存字符串。你可以回到上面去重新阅读 Strings.Get 方法的代码，发现其本来就已带缓存。这可能是 SmartAssembly 的 Bug。使用类的内部委托获取字符串 UseImprovedEncoding之前的混淆都会在原来有字符串地方使用 Strings.Get 来获取字符串。而如果开启了这一选项，那么 Strings.Get 就不是全局调用的了，而是在类的内部调用一个委托字段。比如从 Strings.Get 调用修改为 \\u0010(),，而 \\u0010 是我们自己的类 RandomIdentifier 内部的被额外加进去的一个字段 internal static GetString \\u0010;。防止 MSIL Disassembler 对其进行反编译 MSIL Disassembler Protection这其实是个没啥用的选项，因为我们程序集只会多出一个全局的特性：[assembly: SuppressIldasm]只有 MSIL Disassembler 和基于 MSIL Disassembler 的工具认这个特性。真正想逆向程序集的，根本不会在乎 MSIL Disassembler 被禁掉。dnSpy 和 dotPeek 实际上都忽略了这个特性，依然能毫无障碍地反编译。dnSpy 可以做挺多事儿的，比如： 断点调试 Windows 源代码 - lindexi 神器如 dnSpy，无需源码也能修改 .NET 程序 - walterlv密封在 OtherOptimizations 选项中，有一项 SealClasses 可以将所有可以密封的类进行密封（当然，此操作不会修改 API）。在上面的例子中，由于 RandomIdentifier 是公有类，可能被继承，所以只有预先写的内部的 UnusedClass 被其标记为密封了。// Token: 0x02000003 RID: 3internal sealed class UnusedClass{ // Token: 0x06000007 RID: 7 RVA: 0x000026D0 File Offset: 0x000008D0 internal void Run() { } // Token: 0x06000008 RID: 8 RVA: 0x000026D4 File Offset: 0x000008D4 internal async Task RunAsync() { }}实际项目中，我该如何选择既然你希望选择“混淆”，那么你肯定是希望能进行最大程度的保护。在保证你没有额外产生 Bug，性能没有明显损失的情况下，能混淆得多厉害就混淆得多厉害。基于这一原则，我推荐的混淆方案有（按推荐顺序排序）： 流程混淆 建议必选 直接选用 4 级流程（不安全代码）混淆，如果出问题才换为 3 级（goto）混淆，理论上不需要使用更低级别 流程混淆对性能的影响是非常小的，因为多执行的代码都是有编译期级别优化的，没有太多性能开销的代码 流程混淆仅影响实现，不修改 API，所以基本不会影响其他程序各种对此程序集的调用 名称混淆 尽量选择 任意选择类/方法名和字段名的级别，只要能编译通过就行（因为无论选哪个，对程序的影响都一样，逆向的难度差异也较小） 名称混淆不影响程序执行性能，所以只要能打开，就尽量打开 如果有 InternalsVisibleTo 或者可能被其他程序集按名称反射调用，请： 关闭此混淆 使用 Exclude 排除特定命名空间，使此命名空间下的类/方法名不进行名称混淆 如果你能接受用 Attribute 标记某些类不应该混淆类名，也可以使用这些标记（只是我不推荐这么做，这让混淆污染了自己的代码） 动态代理 推荐选择 动态代理仅影响实现，不修改 API，所以基本不会影响其他程序各种对此程序集的调用 动态代理会生成新的类/委托来替换之前的方法调用，所以可能造成非常轻微的性能损失（一般可以忽略） 字符串压缩加密 可以选择 由于所有的字符串都被统一成一个资源，如果额外进行压缩加密，那么逆向时理解程序的含义将变得非常困难（没有可以参考的锚点） 会对启动时间有轻微的性能影响，如果额外压缩加密，那么会有更多性能影响；如果你对启动性能要求较高，还是不要选了 会轻微增加内存占用和读取字符串时的 CPU 占用，如果你对程序性能要求非常高，还是不要选了 以上四种混淆方式从四个不同的维度对你类与方法的实现进行了混淆，使得你写的类的任何地方都变得无法辨认。流程混淆修改方法内实现的逻辑，名称混淆修改类/属性/方法的名称，动态代理将方法内对其他方法的调用变得不再直接，字符串压缩加密将使得字符串不再具有可读的含义。对逆向阅读影响最大的就是以上 4 种混淆了，如果可能，建议都选择开启。如果你的程序中有需要保护的“嵌入的资源”，在没有自己的保护手段的情况下，可以使用“资源压缩加密”。不过，我更加推荐你自己进行加密。至于 SmartAssembly 推荐的其他选项，都是噱头重于实际效果： 裁剪 一般也不会有多少开发者会故意往程序集中写一些不会用到的类吧！ 依赖合并/依赖嵌入 并不会对逆向造成障碍，开不开启差别不大，反而降低了性能 防止 MSIL Disassembler 反编译 并不会对逆向造成障碍，防君子不防小人 密封类 声称可以提升性能，但这点性能提升微乎其微 SmartAssembly 的官方文档写得还是太简单了，很难得到每一个设置项的含义和实际效果。以上这些信息的得出，离不开 dnSpy 的反编译。参考资料 SmartAssembly 6 documentation - SmartAssembly 6 - Product Documentation Obfuscating code with name mangling - SmartAssembly 6 - Product Documentation" }, { "title": "为 .NET Core / Framework 程序开启大内存感知（LargeAddressAware），使 32 位程序支持最多 4GB 的用户空间内存", "url": "/post/how-to-enable-large-address-aware-for-net-apps.html", "categories": "", "tags": "dotnet, windows", "date": "2021-12-13 21:01:43 +0800", "snippet": "如果你不做特殊处理，把你的项目以 x86 的架构进行编译，那么你的应用程序在 Windows 上最多只能使用 2GB 的内存（地址空间）。如果你的项目使用 .NET Framework 框架，那么现行有很多简单的方法来帮你实现大内存感知，但 .NET Core 框架下却没有。所以我写了一个库 dotnetCampus.LargeAddressAware，帮助你轻松实现 32 位程序的大内存感知。dotnetCampus.LargeAddressAware 库无论你是 .NET Framework 程序还是 .NET Core 程序，只要在你的项目中安装 dotnetCampus.LargeAddressAware 即可立享最高可达 4GB 的用户空间内存。&amp;lt;ItemGroup&amp;gt; &amp;lt;PackageReference Include=&quot;dotnetCampus.LargeAddressAware&quot; Version=&quot;1.0.0&quot; /&amp;gt;&amp;lt;/ItemGroup&amp;gt;效果 应用程序 操作系统 是否开启大内存感知 最大可使用的用户空间内存 32-bit 32-bit ❌ 2GB 32-bit 64-bit ❌ 2GB 32-bit 32-bit ✔️ 3GB 32-bit 64-bit ✔️ 4GB 原理我在 2017 年写的一篇博客（使 32 位程序使用大于 2GB 的内存）中就已经介绍过 32 位程序开启大内存感知的原理和方法了，不过因为一开始我自己也懂得不多，所以写得比较简单。后来也根据自己新的理解也填充了不少内容，但是当初取的标题和内容真的很难被搜到，而且侧重点在方法上。所以现在重写了现在的这篇新的，侧重在让懒用户快速上手，让深度用户快速理解上。32 位寻址空间只有 4GB 大小，于是 32 位应用程序进程最大只能用到 4GB 的内存。然而，除了应用程序本身要用内存，操作系统内核也需要使用。应用程序使用的内存空间分为用户空间和内核空间，每个 32 位程序的用户空间可独享前 2GB 空间（指针值为正数），而内核空间为所有进程共享 2GB 空间（指针值为负数）。所以，32 位应用程序实际能够访问的内存地址空间最多只有 2GB。在应用程序的 PE 头上，有一个应用程序是否感知大内存的标记 LARGEADDRESSAWARE。当 32 位操作系统识别到此标记时，会为其提供 3GB 的用户空间；当 64 位操作系统识别到此标记时，会为其提供 4GB 的用户空间，即用户态完全用满 32 位的寻址空间。其他开启 LARGEADDRESSAWARE 的方法不推荐的方法：仅适用于 .NET Framework 的旧方法当时的那篇博客中，我提到过可通过编译成 AnyCPU (Prefer 32-bit) 来实现大内存感知，这也是最简单的方式，被 .NET Framework 自带。方法是修改 csproj 文件，加上这两句： &amp;lt;PropertyGroup&amp;gt;++ &amp;lt;!-- 此方法被废弃，因为不支持 .NET Core --&amp;gt;++ &amp;lt;PlatformTarget&amp;gt;AnyCPU&amp;lt;/PlatformTarget&amp;gt;++ &amp;lt;Prefer32Bit&amp;gt;true&amp;lt;/Prefer32Bit&amp;gt; &amp;lt;/PropertyGroup&amp;gt;可惜，此方法只适用于 .NET Framework 程序，不适用于 .NET Core 程序！因为 .NET Core 框架下编译时，是直接忽略 Prefer32Bit 的！.NET Core 下大内存感知确实是有了，但生成的却是 AMD64 程序，无法在 32 位系统下运行。不推荐的方法：使用 EditBin 的原始方法如果还想用自带的方法来完成大内存感知的开启的话，我们只能选用 Visual Studio 自带的 editbin 了。方法是打开 Visual Studio 自带的终端，然后在里面输入：editbin /largeaddressaware xxx.exe方法本身其实是非常好的，毕竟是 Visual Studio 自带的工具链。但需要手工执行就是一个大坑！你怎么能保证每次发布前要运行一下这个命令呢？检查是否已开启大内存感知我在之前的博客中提到可以使用 Visual Studio 自带的 dumpbin 工具来检查是否开启了大内存感知：dumpbin /headers xxx.exe | more但是，我们有更直观的 dnSpy 为什么还要用命令行来临时查看呢？相信你早就注意到前面我已经贴了一张 dnSpy 检查大内存感知的图了。参考资料 AnyCPU (32bit preferred) What is the purpose of the “Prefer 32-bit” setting in Visual Studio 2012 and how does it actually work? WPF 编译为 AnyCPU 和 x86 有什么区别 - 林德熙 IMAGE_FILE_LARGE_ADDRESS_AWARE Memory Limits for Windows and Windows Server Releases Getting 32-bit application to use more than 2GB on 64-bit Windows 7? /LARGEADDRESSAWARE (Handle Large Addresses) Why 2 GB memory limit when running in 64 bit Windows? Pushing the Limits of Windows: Paged and Nonpaged Pool Can a 32bit process access more memory on a 64bit windows OS? /3GB /3GB editbin/dumpbin editbin /largeaddressaware xxx.exe dumpbin /headers xxx.exe | more verify if largeAddressAware is in effect? LargeAddressAware Visual Studio 2015 C# " }, { "title": "C#/.NET 如何创建带有本机依赖的多框架多系统 NuGet 包", "url": "/post/create-a-nuget-package-with-native-dependencies.html", "categories": "", "tags": "dotnet, nuget, msbuild", "date": "2021-12-13 20:21:48 +0800", "snippet": "正常如果你想写一个 .NET 的 NuGet 包，直接打包就好了，你的引用程序集会出现在 NuGet 包内的 lib 文件夹内。然而，如果我们的 NuGet 包包含本机依赖的话怎么办呢？我们的项目需求假设我们要做一个 NuGet 包 Walterlv.MixPackage，包含以下内容： 一个要被引用的托管程序集 Walterlv.MixPackage.dll 一个封装了本机代码的 C++/CLI 程序集 Walterlv.NativeWrapper.dll 一个被封装的本机代码动态链接库 Walterlv.Interop.dll 其他本机依赖 Ijwhost.dll、concrt140.dll、msvcp140.dll、vcruntime140.dll、ucrtbase.dll 等其中 1 是完全使用 C# 编写的 .NET 程序集，2 是 C++/CLI 程序集。3 是团队内编写的实现功能的本机动态链接库。1 依赖 2，2 依赖 3，3 依赖 4。实际上 3 和 4 在打包方式上是完全一样的，所以我们后面会将其合并考虑。在你具体的项目中，可以只有 1、4 也可以只有 1、3、4 或者是 2、4 或者是 2、3、4。对于这些不同的组合，NuGet 包的制作会有一点点不一样，在这篇博客里面都会说应该怎么做。NuGet 相关文件夹解读我曾在这两篇博客里提到过 NuGet 文件夹，那里会更全一些但是不够细。而本文不会全面，却对本文所需的例子说明得更加详细。感兴趣也可以过去看看。 如何创建一个基于命令行工具的跨平台的 NuGet 工具包 如何创建一个基于 MSBuild Task 的跨平台的 NuGet 工具包我们会涉及到这些文件夹：+ buildTransive - 可选。包含构建时的一些自定义任务（如果有的化），可随着包依赖而传递执行。+ lib - 必须。放你最终被引用的托管程序集，将被引用。+ ref - 看情况，可能必须可能可选。如果你除了要引用托管程序集外，还要引用平台相关的程序集，那么这就是必须的。+ runtimes - 必须。用来放平台相关的动态链接库。其中，runtimes 文件夹的层次结构类似这样：+ runtimes + win - net46 - net451 - net461 - netcoreapp2.1 - netstandard1.3 - netstandard2.0 - uap10.0.16299 + unix - netcoreapp2.1 - netstandard1.3 - netstandard2.0 + osx - netcoreapp2.1 - netstandard1.3 - netstandard2.0当然如果你只跑在 Windows 系统上，也可以是这样（实际上是一样的，看你需求）：+ runtimes + win-x86 + lib - net45 - netcoreapp3.1 - net5.0 + win-x64 + lib - net45 - netcoreapp3.1 - net5.0其中，ref 文件夹内包含各个不同框架下要引用的程序集。+ ref - net45 - netcoreapp3.1 - net5.0最后那个 lib 文件夹应该不用多作解释了，一个普通的 .NET 程序集打出的 NuGet 包里带的就是这个文件夹，用来被引用。但需要特别说明的是： 【重要】如果你包含 lib 文件夹，那么你应该分拆成两个 NuGet 包！ 否则可能迫于 .NET Core 下我还没懂的 .deps 文件的引用机制，你将无法同时引用托管和 C++/CLI 程序集。制作这样的 NuGet 包如果你对 NuGet 打包比较熟，相信看到上面的文件夹结构就已经知道怎么打出这样的包了。不过如果不熟也没关系，我们继续阅读下文。打出什么样的包？对于本文前面说到的几种包，打的方式不太一样。总共 3 种不同的 dll（托管程序集、C++/CLI 程序集、本机动态链接库），因此我们能组合出 7 种不同的包结构。1/7 只含托管程序集太简单了，默认打包就是这样。本文不讲。2/7 只含本机动态链接库如果只含本机动态链接库，只需要做好 runtimes 文件夹就够了。制作方法见后文的“本机依赖包（单包）”。3/7 只含 C++/CLI 程序集如果只含C++/CLI 程序集和本机动态链接库，一样只需要做好 runtimes 文件夹就够了。制作方法见后文的“本机依赖包（单包）”。4/7 含 C++/CLI 程序集和本机动态链接库如果只含 C++/CLI 程序集和本机动态链接库，一样只需要做好 runtimes 文件夹就够了。制作方法见后文的“本机依赖包（单包）”。5/7 含托管程序集和本机动态链接库如果只含托管程序集和本机动态链接库，只需要做好 lib 和 runtimes 文件夹就够了。制作方法见后文的“本机依赖包（单包）”。6/7 托管程序集和 C++/CLI 程序集由于包含了托管程序集和 C++/CLI 程序集，这两种程序集同时被 .NET Core App / .NET 5/6 项目引用时会出现问题，分别引用则正常。所以制作方法见后文的“托管、C++/CLI 和本机依赖包（双包）”。但是，如果你的托管程序集完全封装好了 C++/CLI 程序集，使得后者完全不会被项目引用的话，你也可以把它视作本机动态链接库来做，即做成“本机依赖包（单包）”。7/7 含托管程序集、C++/CLI 程序集、本机动态链接库由于包含了托管程序集和 C++/CLI 程序集，这两种程序集同时被 .NET Core App / .NET 5/6 项目引用时会出现问题，分别引用则正常。所以制作方法见后文的“托管、C++/CLI 和本机依赖包（双包）”。但是，如果你的托管程序集完全封装好了 C++/CLI 程序集，使得后者完全不会被项目引用的话，你也可以把它视作本机动态链接库来做，即做成“本机依赖包（单包）”。包制作方法在前面的 7 种不同的组合中，我们最终会做出两种不同的包来： 只包含托管依赖或只包含本机依赖的“单包”，其特点为这些依赖只需拷贝到输出目录即可，项目本身不会直接依赖它们的类型（例如通过 P/Invoke 调用的那些 dll）。 同时包含托管依赖和 C++/CLI 依赖的“双包”，其特点为项目会直接使用 C++/CLI 程序集里的类型。分别介绍制作方法。本机依赖包（单包）单包特别好打。所以如果你不是有特别需要的话，最好还是选单包。第一步：创建一个普通的类库第二步：将本机依赖文件拷至对应文件夹下这里，我们建了一个“Assets”文件夹，用来放 NuGet 的零散文件。这个名字你可以随便取，反正也不会进到 NuGet 文件夹中。随后，我们依层级建好“runtimes”、“win-x86”、“lib”、“netcoreapp3.1”这样的文件夹一整组（见下图）。然后，把对应架构的 dll 分别拷至对应的目录下。图中出现的 Ijwhost.dll 是加载 C++/CLI 程序集必须的 .NET Core 运行时，在生成 C++/CLI 程序集时会出现在其输出目录里。第三步：将文件打入 NuGet 包中编辑刚刚项目的 csproj 文件，用 GeneratePackageOnBuild 标记要生成 NuGet 包；用 _GetPackageFiles 时机将 Assets\\runtimes 文件夹中的所有文件引入包中。另外，目标框架我们选了两个，与最终包含的本机依赖的框架种类对应，即分别允许高于 .NET Core App 3.1（含 .NET 5/6）和 .NET Framework 4.5.2 框架的程序集引用此项目。&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;TargetFrameworks&amp;gt;netcoreapp3.1;net452&amp;lt;/TargetFrameworks&amp;gt; &amp;lt;GeneratePackageOnBuild&amp;gt;true&amp;lt;/GeneratePackageOnBuild&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;Target Name=&quot;IncludeAllDependencies&quot; BeforeTargets=&quot;_GetPackageFiles&quot;&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;None Include=&quot;Assets\\runtimes\\**\\*.dll&quot; Pack=&quot;True&quot; PackagePath=&quot;runtimes&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;/Target&amp;gt;&amp;lt;/Project&amp;gt;特别的，如果你的这个项目仅供打 NuGet 包，最终生成的 dll 不被引用，那么额外标一个“IsTool”，这样生成的 dll 不被引用。当然，如果你这个 dll 要被引用就不应该加这句代码。 &amp;lt;PropertyGroup&amp;gt; &amp;lt;TargetFrameworks&amp;gt;netcoreapp3.1;net452&amp;lt;/TargetFrameworks&amp;gt; &amp;lt;GeneratePackageOnBuild&amp;gt;true&amp;lt;/GeneratePackageOnBuild&amp;gt;++ &amp;lt;!-- 仅当你的 dll 不需要被引用时 --&amp;gt;++ &amp;lt;IsTool&amp;gt;true&amp;lt;/IsTool&amp;gt; &amp;lt;/PropertyGroup&amp;gt;如果你不需要直接那个 C++/CLI 程序集，而只是需要它出现在输出目录，那么到目前为止就够了。但如果那个 C++/CLI 程序集需要被引用，你还需要额外加一点点。我们取 x86 下的这两个 dll，将其让入 NuGet 的 ref 文件夹中。 &amp;lt;Target Name=&quot;IncludeAllDependencies&quot; BeforeTargets=&quot;_GetPackageFiles&quot;&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;None Include=&quot;Assets\\runtimes\\**\\*.dll&quot; Pack=&quot;True&quot; PackagePath=&quot;runtimes&quot; /&amp;gt;++ &amp;lt;!-- 仅当你的 C++/CLI 也需要被引用时 --&amp;gt;++ &amp;lt;None Include=&quot;Assets\\runtimes\\win-x86\\lib\\net452\\Walterlv.Demo.Interop.dll&quot; Pack=&quot;True&quot; PackagePath=&quot;ref\\net452&quot; /&amp;gt;++ &amp;lt;None Include=&quot;Assets\\runtimes\\win-x86\\lib\\netcoreapp3.1\\Walterlv.Demo.Interop.dll&quot; Pack=&quot;True&quot; PackagePath=&quot;ref\\netcoreapp3.1&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;/Target&amp;gt;当然，如果你有专门生成引用程序集的方法，也可以在这里放专门的引用程序集，而不用像这样拿一个 x86 的程序集来无意义地增加 NuGet 包的大小。请特别注意：托管程序集和 C++/CLI 程序集不可在同一个 NuGet 包中被引用！这意味着，如果你己像引用 C++/CLI 又想引用此项目的 dll 时，请改用后面的“双包”方案。完成编译这个项目，你将在输出目录下得到一个 NuGet 包，它已经具有正确的文件结构了。托管、C++/CLI 和本机依赖包（双包）双包方案旨在解决托管程序集和 C++/CLI 程序集无法在同一个 NuGet 包中被引用的问题。（实际上是可以正常引用并编译通过的，但在 .NET Core 框架下无法运行。）第四步：再建一个普通的类库再建一个普通的类库，引用之前创建的项目。现在两个项目的职责分别为： 原来的类库：负责提供本机动态链接库和 C++/CLI 程序集 新的类库：负责提供托管程序集，并标记引用原来的包编辑新项目的 csproj 文件。目标框架需与原来一模一样；也要 GeneratePackageOnBuild 来标记生成 NuGet 包；使用 ProjectReference 引用原来的项目，这样可以在生成的 NuGet 包中自动标记原来的 NuGet 包是其中一个重要的依赖。最后，如果我们这个托管程序集需要引用那个 C++/CLI 程序集，那么就额外在下面写上一个 Reference 把原来的 dll 引用一下。&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;TargetFrameworks&amp;gt;netcoreapp3.1;net452&amp;lt;/TargetFrameworks&amp;gt; &amp;lt;GeneratePackageOnBuild&amp;gt;true&amp;lt;/GeneratePackageOnBuild&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;ProjectReference Include=&quot;..\\Walterlv.PackageDemo.Runtime\\Walterlv.PackageDemo.Runtime.csproj&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;Reference Include=&quot;Walterlv.Demo.Interop.dll&quot; HintPath=&quot;..\\Walterlv.PackageDemo.Runtime\\Assets\\runtimes\\win-x86\\lib\\$(TargetFramework)\\Walterlv.Demo.Interop.dll&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt;&amp;lt;/Project&amp;gt;完成再编译整个项目，你就可以得到两个 NuGet 包了： Walterlv.PackageDemo.Runtime：包含本机依赖和 C++/CLI 程序集 Walterlv.PackageDemo：包含托管程序集，同时依赖前者使用效果当你将两个 NuGet 包都推送到 NuGet 服务器上去之后，你就可以在你的业务中使用这两个 NuGet 包了： 如果你只做了一个单包，那么直接引用这个单包即可 如果你做的是双包，那么引用其中托管的那一个即可，本机依赖包会自动根据 NuGet 的依赖安装.NET Framework 项目对于 .NET Framework 项目，项目编译后，NuGet 会自动将本机依赖包里对应架构和框架的文件拷贝到输出目录中，于是你就能正常运行你的程序了。.NET Core App 项目对于 .NET Core App 项目，项目编译后，输出目录下会出现“runtimes”和“ref”两个文件夹，分别对应 NuGet 包里的同名文件夹，不过只包含业务项目需要的框架，而不含其他框架。如果你最终直接把此 .NET Core App 项目发布出去，则这两个文件夹配合“.deps”文件需要一并带上。如果你使用 .NET 的发布功能将其发布成框架独立的应用程序，那么编译器会自动将 runtimes 里面的对应架构和框架的文件拷贝至输出目录下，于是你就能正常运行你的程序了。" }, { "title": "将美化进行到底，使用 Oh My Posh 把 PowerShell 做成 oh-my-zsh 的样子", "url": "/post/beautify-powershell-like-zsh.html", "categories": "", "tags": "windows, powershell", "date": "2021-11-22 16:35:33 +0800", "snippet": "不知你有没有看过 Linux 上 oh-my-zsh 的样子？看过之后你一定会惊叹，原来命令行还能这么玩！然而 Windows 下能这么玩吗？答案是可行的，接下来就来看看怎么玩。Windows 下我们用 Oh My Posh 在 PowerShell 中实现这样的效果。先放一张我的美化效果图：接下来，我们用三个步骤完成这样的美化。第零步：挑选一个终端鉴于无论是 PowerShell (Windows) 还是 PowerShell (Core) 都无法直接获得本文所述的效果，所以强烈建议在开始之前准备一个专门的终端，比如： Windows Terminal (Windows 自带) Fluent Terminal (流畅设计的终端) ConEmu cmder - Console Emulator无论你选了哪一个，当你设置好后，会在所有终端中生效，包括 Visual Studio、Visual Studio Code 中内嵌的终端。另外，如果你从来没有在你的电脑上折腾过终端，那么可能还需要额外去应用商店安装一下 PowerShell 的 .NET 版本（不装的话，默认是 Windows PowerShell，版本会旧一些）：第一步：安装 Oh My Posh先启动你主用的终端（本文将以 Windows Terminal 为例），然后输入如下安装命令：Install-Module oh-my-posh -Scope CurrentUser如果中途提示是否允许安装，输入 Y 继续就好了。第二步：启用 Oh My Posh在安装完后，输入并执行 Get-PoshThemes 命令便可以浏览 Oh My Posh 自带的几十款主题（同时也能验证装好了）。只可惜你会发现主题里有大量的“□□”字，这个我们在第三步里会推荐一些字体供你挑选。还需要做一件重要的事情，我们要让每次新启动 PowerShell 时都自动启用此模组，否则等你下次打开终端时就没有任何效果了。输入 $PROFILE 查询你的 PowerShell Profile 文件位置：去对应的文件夹找一下这个文件（Microsoft.PowerShell_profile.ps1）。如果你没有这个文件，就新建一个，文件里面编写如下内容：Import-Module oh-my-poshSet-PoshPrompt agnoster这里的 agnoster 是刚刚 Get-PoshThemes 主题列表里的第一个。因为我们还没有装好字体，现在格式混乱，所以也很难挑选真正喜爱的主题。至此，Oh My Posh 模组已经可以在每次启动 PowerShell 时自动加载了。第三步：安装字体、挑选主题关于字体，小提一下：如果你直接使用 PowerShell 而不使用终端的话，字体的定制会非常麻烦，可参见 自定义 Windows PowerShell 和 cmd 的字体 感受一下。所以还是需要强调一下本文开头的部分，建议选一款终端操作以较少调试上的痛苦。字体可以在这些地方挑选： Nerd Fonts - Iconic font aggregator, glyphs/icons collection, &amp;amp; fonts patcher ▲ 推荐，支持 Oh My Posh 需要的各种图标 powerline/fonts: Patched fonts for Powerline users. ▲ 基本能呈现 PowerLine 效果，但图标较少，可选的主题较少对于 Nerd Fonts，去网站上挑选一款字体，点击“Download”下载、解压、右键全选安装即可，就像安装其他任何字体一样。对于 PowerLine Fonts，克隆仓库，找到 Install.ps1 文件并执行它即可安装。这里，我选了 Nerd Fonts 系的 Fira Code NF 字体，直接安装。接着，去终端里面为 PowerShell 选择刚安装好的字体，点击保存。（如果终端里看不到新安装的字体，请重启终端。）接下来就是见证奇迹的时刻——新启动一个终端：重新输入 Get-PoshThemes 再预览主题，然后挑选一个。挑好后，去修改 Microsoft.PowerShell_profile.ps1 文件内容，换主题名。这里，我选了 iterm2，于是就有了本文一开始的美化效果了。同样，在 Visual Studio Code 里设置一下终端字体也可以在 Visual Studio Code 里看到相同的效果：主题在这个文件夹下，可以自行编辑： ~\\Documents\\PowerShell\\Modules\\oh-my-posh\\&amp;lt;版本号&amp;gt;\\themes ▲ 如果你用的是 Windows PowerShell 而不是 PowerShell，可用 $PROFILE 查询一下跟目录S0cialEngineering - 灰色铅笔的彩色世界。 基于自带的 iterm2 魔改了一个 iterm3 主题，他授权我在这里分流提供给大家下载。我觉得非常好看，就白瞟了。 下载 iterm3.omp.json效果如下：参考资料 Nerd Fonts - Iconic font aggregator, glyphs/icons collection, &amp;amp; fonts patcher powerline/fonts: Patched fonts for Powerline users. Overview — Powerline beta documentation" }, { "title": "无需安装 VS2019，在 Visual Studio 2022 中编译 .NET Framework 4.5/4/3.5 这样的古老框架", "url": "/post/support-old-netfx-on-vs2022-or-later.html", "categories": "", "tags": "visualstudio, dotnet", "date": "2021-11-15 15:55:01 +0800", "snippet": "Visual Studio 2022 已正式发布！着急升级的小伙伴兴致勃勃地升级并卸载了原来的 Visual Studio 2019 后，发现自己的几个库项目竟然无法编译通过了。究其原因，是因为我的一些库依旧在支持古老的 .NET Framework 4.5 框架，而 Visual Studio 2022 不再附带如此古老的目标包了。我之前在 另一篇文章 中告诉大家通过将 Visual Studio 2019 装回来的方式解决这个问题，但是有小伙伴不想安装 Visual Studio 2019；所以本文用另外一种方法，无需安装 Visual Studio 2019，也无需单独安装 .NET Framework 目标包。无法编译 .NET Framework 4.5 项目为了更广泛的适用于各种项目，我的一些库兼容的框架版本是非常古老的（比如下图截取的这张）。可是卸载掉 Visual Studio 2019 只留下 Visual Studio 2022 之后这些项目就不再能编译通过了。如果点开 Visual Studio 2022 的安装程序，会发现已经删除掉了 .NET Framework 4.5 的目标包了，无法通过它安装回来。关键步骤第一步：安装 NuGet 包 Microsoft.NETFramework.ReferenceAssembliesMicrosoft.NETFramework.ReferenceAssemblies 这款 NuGet 包旨在解决没有目标包的时候编译 .NET Framework 框架的问题。因此，我们将通过安装此 NuGet 包来解决 Visual Studio 2022 中目标包的缺失问题。正常你只需要在项目中安装这个 NuGet 包即可。如果你整个解决方案里所有项目都需要兼容 .NET Framwework 4.5 或者更加古老的 .NET 框架，也可以用 Directory.Build.props 文件，详见：使用 Directory.Build.props 管理多个项目配置 - 林德熙&amp;lt;Project&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;PackageReference Include=&quot;Microsoft.NETFramework.ReferenceAssemblies&quot; Version=&quot;1.0.2&quot; PrivateAssets=&quot;all&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt;&amp;lt;/Project&amp;gt;请特别注意如果你正在开发的是库项目，那么在引用此 NuGet 包之后，应该加上 PrivateAssets=&quot;all&quot; 来标记此 NuGet 包不会成为你自己的库的其中一个依赖。否则就会像下图一样有一个不期望的依赖。▲ 不期望的依赖▲ 正常的依赖第二步：适配 Visual Studio 的特殊开发环境如果你不用 VS2022，而只是使用 dotnet build 或 msbuild 命令来编译，那么以上第一步完成后就够了。不过考虑到大家基本上都是用 Visual Studio 来开发，所以上述操作在 VS 中的水土不服也需要特别处理一下。在项目的 csproj 文件中添加一个 Target：&amp;lt;Target Name=&quot;WalterlvPackagesIncludeNetFrameworkReferences&quot; BeforeTargets=&quot;GetReferenceAssemblyPaths&quot; DependsOnTargets=&quot;Restore&quot; Condition=&quot; &#39;$(TargetFrameworkIdentifier)&#39; == &#39;.NETFramework&#39; And &#39;$(TargetFrameworkRootPath)&#39; == &#39;&#39; &quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;TargetFrameworkRootPath Condition=&quot; $(TargetFrameworkMoniker) == &#39;.NETFramework,Version=v4.5&#39; &quot;&amp;gt;$(UserProfile)\\.nuget\\packages\\microsoft.netframework.referenceassemblies.net45\\1.0.2\\build&amp;lt;/TargetFrameworkRootPath&amp;gt; &amp;lt;TargetFrameworkRootPath Condition=&quot; $(TargetFrameworkMoniker) == &#39;.NETFramework,Version=v4.0&#39; &quot;&amp;gt;$(UserProfile)\\.nuget\\packages\\microsoft.netframework.referenceassemblies.net40\\1.0.2\\build&amp;lt;/TargetFrameworkRootPath&amp;gt; &amp;lt;/PropertyGroup&amp;gt;&amp;lt;/Target&amp;gt;或者如果前面你是在 Directory.Build.props 文件中添加的引用，那么就在对应的 Directory.Build.targets 文件中添加这一段（没有此文件则新建）。解释一下这段代码如何适配了 Visual Studio 的特殊开发环境： 猜测 VS 会缓存 TargetFrameworkRootPath 属性，一旦获取到其值将再也不会更新之，就算后面紧跟着还原 NuGet 包后值已被正常赋值了也不会使用（即使重启 VS 也是如此）；于是我们在 TargetFrameworkRootPath 属性为 `` 时手工给其赋上正确的值。 猜测 VS 在发现 TargetFrameworkRootPath 属性所对应的路径不存在时视为与空同等处理；所以我们 DependsOnTargets=&quot;Restore&quot; 以便在第一次还原 NuGet 包相关路径还没有创建时马上完成 NuGet 包的还原以创建对应目录。在使用了以上代码后，Visual Studio 2022 刚打开项目时会短暂提示缺少 .NET Framework 4.5 框架，但真正编译时此提示会消失。这些问题都是单独使用命令来编译时不会遇到的问题。我也尝试过其他的解决方法，但都不能完美消除此错误提示（如果你没有 WPF 项目的话，也可以通过创建名为 GetReferenceAssemblyPaths 的空 Target 跳过检查）。写完上面的代码之后： 关闭 Visual Studio 2022 清理仓库，执行 git clean -xdf 命令（这会删除所有未被版本管理的文件，包括 Visual Studio 的各种缓存文件） 重新启动 Visual Studio 2022一些注意事项1. 需要覆盖整个解决方案中所有涉及到 .NET Framework 框架的项目这个 NuGet 包的本质是在编译的时候设置 TargetFrameworkRootPath 属性到 NuGet 包里安装过来的目录，并且通过 &amp;lt;Reference Include=&quot;mscorlib&quot; Pack=&quot;false&quot; /&amp;gt; 指定额外引用 mscorelib，所以不会产生额外的引用。于是这种方式安装的 NuGet 包不像其他的 NuGet 包那样可以传递到其他引用它的项目。你需要做的： 给所有含 .NET Framework 框架的项目安装 Microsoft.NETFramework.ReferenceAssemblies NuGet 包 如果不想直接给所有项目安装，可以使用 Directory.Build.props 来一并安装2. 不支持同一个文件夹下有两个 csproj 项目的情况有时候为了方便，当两个项目几乎所有文件都相同，只是项目配置不同时，我们会考虑将这两个项目放到同一个文件夹里面以共用文件。可惜这种方式组织的项目，跟本问所提供的方案不兼容。如果解决方案中存在这样的项目组织方式，你会发现其他项目都能编译通过，唯独这两个项目依旧死在缺少 .NET Framework 45 目标包上。解决方法就是把这两个项目拆开成两个文件夹。可是他们共用的文件怎么办？答案是在每个项目的 csproj 文件中添加下面几行： &amp;lt;ItemGroup&amp;gt; &amp;lt;Compile Include=&quot;..\\SomeCommonFolder\\**\\*.cs&quot; Link=&quot;%(RecursiveDir)%(Filename)%(Extension)&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt;即他们都去共同的目录下把文件都拉进来编译，并且以链接的方式显示到 Visual Studio 解决方案管理器里。详见：使用链接共享 Visual Studio 中的代码文件另外，这里的 %(RecursiveDir) 是递归显示文件夹（否则所有文件会拍平到项目里），%(Filename) 是将链接显示成文件名，%(Extension) 是在文件名后面显示文件扩展名。经此写法，项目里显示的其他文件夹的文件看起来就像真的在这个项目里一样。3. 对于经典 csproj 格式（而非 SDK 风格 csproj 格式）的情况评论区 @afunc233 的回复 说经典 csproj 格式没办法使用本文所述的方法。我个人建议还是迁移一下比较好，不难而且完全兼容旧格式的所有功能。迁移教程：将 WPF、UWP 以及其他各种类型的旧 csproj 迁移成 Sdk 风格的 csproj。如果不想迁移，也可以试试官方的方法。但我不想尝试，所以就在线等 TA 在评论区的回复吧！4. 不想折腾之一：还是装回 VS2019 吧有时候，你可能会遇到各种意料之外的问题，超出我上面列举的坑。不想折腾的话，那就把 .NET Framework 4.5 目标包装回来吧，可参见：Visual Studio 2022 升级不再附带 .NET Framework 4.5 这种古老的目标包了，本文帮你装回来。5. 不想折腾之二：打死也不装回 VS2019有时候，你可能会遇到各种意料之外的问题，超出我上面列举的坑。如果你跟我一样，无论如何都不想装回 VS2019，那么还有解决方法：直接把 .NET Framework 的引用全拷到项目里来。操作如下： 去 Microsoft.NETFramework.ReferenceAssemblies NuGet 包的下载页，找到 Dependencies 标签，里面有各个不同 .NET Framework 版本的 .NET Framework 引用包。 点开你项目需要的那个版本的 .NET Framework 包，然后在页面右边找到 Download package 链接，点它，下下来。 解压下载下来的 NuGet 包，取出其中的“/build/.NET Framework”文件夹，复制到你的项目里某个位置。 在你仓库的根目录添加或修改 Directory.Build.props 文件，里面添加下面的代码。Directory.Build.props 文件的新增内容：&amp;lt;Project&amp;gt;++ &amp;lt;PropertyGroup&amp;gt;++ &amp;lt;TargetFrameworkRootPath&amp;gt;$(MSBuildThisFileDirectory)Dependencies&amp;lt;/TargetFrameworkRootPath&amp;gt;++ &amp;lt;/PropertyGroup&amp;gt;++ &amp;lt;ItemGroup Condition=&quot; (&#39;$(TargetFrameworkIdentifier)&#39; == &#39;.NETFramework&#39;) And (&#39;$(TargetFrameworkVersion)&#39; == &#39;v4.5&#39;) &quot;&amp;gt;++ &amp;lt;Reference Include=&quot;mscorlib&quot; Pack=&quot;false&quot; /&amp;gt;++ &amp;lt;Reference Include=&quot;Microsoft.VisualBasic&quot; Pack=&quot;false&quot; Condition=&quot;&#39;$(Language)&#39; == &#39;VB&#39; And &#39;$(UsingMicrosoftNETSdk)&#39; == &#39;true&#39;&quot; /&amp;gt;++ &amp;lt;/ItemGroup&amp;gt;&amp;lt;/Project&amp;gt;其中： 如果没有此文件，那么创建一个。 那个 TargetFrameworkRootPath 的值是 .NETFramework 文件夹的父级文件夹。划重点，你需要确保那个文件夹里面包含我们从 NuGet 包里解压出来的 .NETFramework 完整文件夹。 后面的 ItemGroup 里的内容，直接照抄上文即可，我也是照抄 Microsoft.NETFramework.ReferenceAssemblies 包里的用最后的这种方法，算就究级解决方案了。没有这种方案解决不了的问题！如果有，那就是有某项目没受此文件影响，把这段代码拷到那个项目的 csproj 文件里去。" }, { "title": "WPF 使用 WindowChrome，在自定义窗口标题栏的同时最大程度保留原生窗口样式（类似 UWP/Chrome）", "url": "/post/wpf-simulate-native-window-style-using-window-chrome.html", "categories": "", "tags": "wpf, uwp, dotnet, windows", "date": "2021-11-12 14:31:33 +0800", "snippet": "WPF 自定义窗口样式有多种方式，不过基本核心实现都是在修改 Win32 窗口样式。然而，Windows 上的应用就应该有 Windows 应用的样子嘛，在保证自定义的同时也能与其他窗口样式保持一致当然能最大程度保证 Windows 操作系统上的体验一致性。本文将使用 WindowChrome 来自定义窗口样式，使其既保留原生窗口样式和交互习惯，又能够具备一定的自定义空间。使用 Windows 原生窗口体验的应用在自定义窗口样式的同时保证一致的 Windows 窗口风格体验的优秀应用有这些： Windows 10 UWP 应用 当然少不了 UWP 应用，毕竟这就是 Windows 10 窗口体验的代表 Google Chrome 如果我不提第三方应用，你们肯定会说微软都是自己拿内部 API，拿黑科技做的 Windows 文件资源管理器 Windows 文件资源管理器也有一些自定义（例如在标题栏上放按钮，虽然实际做得很丑），不过整体来说还没 Chrome 做得精致呢 ▲ Chrome 普通窗口▲ Chrome 最大化窗口为什么不做无边框窗口？WPF 自定义窗口可是非常容易的，完全自定义样式、异形都不在话下。&amp;lt;Window x:Class=&quot;Walterlv.Whitman.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:Walterlv.Whitman&quot; mc:Ignorable=&quot;d&quot; Title=&quot;Whitman&quot; Width=&quot;800&quot; Height=&quot;450&quot; WindowStyle=&quot;None&quot; AllowsTransparency=&quot;True&quot;&amp;gt;&amp;lt;/Window&amp;gt;然而，这就不贴近原生窗口体验了，有这么多事情都不好模拟： 最小化、最大化、关闭按钮 按钮要多大？位置在哪里？图标边距又是多少，颜色值又是什么？鼠标滑入划出的动画效果如何？ 窗口标题栏交互 标题栏上有右键菜单，如果自己模拟，基本上这个就要自己重新实现了。 窗口的位置和尺寸 你需要自己实现一套窗口的拖拽调整位置功能，需要自己实现一套拖拽调整大小的功能。而自己实现的方式在触摸屏下还很容易出现失效的情况。 窗口的阴影 要完全模拟 Windows 10 上的窗口阴影效果实在是一件头疼的事情，因为并不知道各种阴影参数是多少；就算模拟出来，性能也是个严重的问题。 窗口的边框颜色 虽然窗口边框是被广为吐槽的一点，但为了保证一致的窗口体验，这也是需要模拟的；正常情况和失焦的情况颜色还不一样。 第三方应用集成 第三方截图应用可以毫无障碍地捕捉到标准窗口的外框范围，但如果我们没有模拟好（而是拿一个 WPF 无边框窗口模拟），那么第三方截图应用就截不准（可能会超出窗口本来的大小）。 开始使用 WindowChrome你也许需要先阅读 Window 的 UI 元素及行为 - dino.c 了解一些基本概念。理论上 WindowChrome 的使用是非常简单的（呃……理论上）。你只需要在 &amp;lt;Window /&amp;gt; 节点里写如下代码便能够完成客户区（Client Area）到非客户区（Non-client Area）的覆盖：&amp;lt;WindowChrome.WindowChrome&amp;gt; &amp;lt;WindowChrome /&amp;gt;&amp;lt;/WindowChrome.WindowChrome&amp;gt;然而，默认的行为却并不那么像原生 Windows 10 窗口。事实上，这样的写法只是简单地把窗口的客户区覆盖到非客户区，原生窗口中的交互还在，但样式都已经被遮挡了。▲ 样式已经被遮挡不止是样式被遮挡，我们应该能注意相比于原生还有这些不同： 我们的边框是白色的，原生的边框是系统主题色 鼠标划入我们窗口内才开始拖拽改变大小，但原生的在阴影区域就能开始调整大小了现在，为了能够观察到 WindowChrome 各种属性设置的效果，我们为 Window 定义一个新的 Template，里面就是空的，这样就没有什么内容能够遮挡我们设置的样式了。&amp;lt;Window.Template&amp;gt; &amp;lt;ControlTemplate TargetType=&quot;Window&quot;&amp;gt; &amp;lt;Border /&amp;gt; &amp;lt;/ControlTemplate&amp;gt;&amp;lt;/Window.Template&amp;gt;▲ 没有遮挡的窗口然而即便如此，我们也只解决了系统主题色边框的问题，没有解决调整窗口的拖拽热区问题。而且边框还如此之丑。GlassFrameThickness在官方文档 WindowChrome.GlassFrameCompleteThickness Property (System.Windows.Shell) 中有说，如果指定 GlassFrameThickness 值为 -1，那么可以做到整个窗口都遮挡，但实际上全遮挡的效果也是不对劲的，就像下面这样：&amp;lt;WindowChrome.WindowChrome&amp;gt; &amp;lt;WindowChrome GlassFrameThickness=&quot;-1&quot; /&amp;gt;&amp;lt;/WindowChrome.WindowChrome&amp;gt;▲ GlassFrameThickness 为 -1不止边框颜色不见了，连右上角的三个按钮的位置都跟原生不同，这个窗口的位置不贴边。显然，GlassFrameThickness 属性我们不能指定为 -1。也不能指定为 0，你可以试试，会发现连阴影都不见了，这更不是我们想要的效果。▲ GlassFrameThickness 为 0那我们指定为其他正数呢？▲ 指定为其他正数显然，没有一个符合我们的要求。NonClientFrameEdges但好在我们还有一个属性可以尝试 —— NonClientFrameEdges。官方文档 WindowChrome.NonClientFrameEdges Property (System.Windows.Shell) 对此的解释是： Gets or sets a value that indicates which edges of the window frame are not owned by the client.即指定哪一边不属于客户区。考虑到我们前面的尝试中发现左、下、右的边框都是不符合要求的，所以我们现在将值设置为 Left,Bottom,Right：&amp;lt;WindowChrome.WindowChrome&amp;gt; &amp;lt;WindowChrome NonClientFrameEdges=&quot;Left,Bottom,Right&quot; /&amp;gt;&amp;lt;/WindowChrome.WindowChrome&amp;gt;▲ 比较接近的效果这回我们终于看到了比较接近原生窗口的效果了，除了窗口的边框效果在激活和非激活状态下与原生窗口一致，连右上角三个按钮的位置也是贴近原生窗口的。甚至拖拽调整窗口大小时的光标热区也是类似的：▲ 拖拽光标热区唯一不符合要求的是标题栏高度，这时我们可以继续设置 GlassFrameThickness，把顶部设置得更高一些。然而设置到多少呢？我测量了一下 Microsoft Store 应用的按钮高度，是 32。但是，这 32 包括了顶部 1 像素的边框吗？我使用放大镜查看，发现是包含的。而我们的 GlassFrameThickness 属性也是包含这个 1 像素边框的。所以含义一致，我们可以考虑直接将 32 设置到属性中：&amp;lt;WindowChrome.WindowChrome&amp;gt; &amp;lt;WindowChrome GlassFrameThickness=&quot;0 32 0 0&quot; NonClientFrameEdges=&quot;Left,Bottom,Right&quot; /&amp;gt;&amp;lt;/WindowChrome.WindowChrome&amp;gt;然而实测结果是 —— 又被耍了，虽然标题栏有 32 的高度，但按钮只有 30 而已：而且在最大化窗口之后，按钮高度继续压缩。标题栏只剩下 24 的高度，按钮只剩下 22 的高度了。这显然也模拟得不像。于是，我们霸气一点，直接把顶部边距改得更大。为了凑个整，我写 64 好了。&amp;lt;WindowChrome.WindowChrome&amp;gt; &amp;lt;WindowChrome GlassFrameThickness=&quot;0 64 0 0&quot; NonClientFrameEdges=&quot;Left,Bottom,Right&quot; /&amp;gt;&amp;lt;/WindowChrome.WindowChrome&amp;gt;虽然正常状态下的按钮依然是 30 高度，但最大化时还是 30 高度这一点与原生 UWP 窗口和 Chrome 的行为是类似的。（UWP 窗口按钮 32 高度，最大化 32 高度；Google Chrome 窗口按钮 30 高度，最大化 27 高度。）所以，截至这里，我们算是模拟得比较像了。其他的属性需要尝试吗？CornerRadius, ResizeBorderThickness, ResizeGripDirection, UseAeroCaptionButtons 在默认情况下的行为就已经够了；而 IsHitTestVisibleInChrome 是个与 WPF 相关的附加属性，与模拟窗口样式没有关系。所以基本模拟就靠前面的两个属性了。定制 Window 的控件模板WindowChrome 提供客户区内容覆盖到非客户区的能力，所以我们通过定制 Window 的 ControlTemplate 能够在保证原生窗口体验的同时，尽可能定制我们的窗口样式。在按照以上的方式设置了 WindowChrome 之后，我们能够定制的客户区已经有下图所示的这么多了：▲ 可定制的客户区特别注意：可定制区域中顶部是包含那 1 像素的边距的，但其他三边不包含。下面的窗口是我在 冷算法：自动生成代码标识符（类名、方法名、变量名） 中所述算法的一个应用，除了右上角的一个白色块，在保证接近原生窗口的情况下，定制了一些内容。▲ 一个试验品为了保证标题栏的标题文字也尽可能地接近原生窗口，我也通过测量得出了用于显示标题的 &amp;lt;TextBlock /&amp;gt; 的各种参数。整理之后，写成了下面的样式：&amp;lt;Window.Template&amp;gt; &amp;lt;ControlTemplate TargetType=&quot;Window&quot;&amp;gt; &amp;lt;Border Padding=&quot;0 30 0 0&quot;&amp;gt; &amp;lt;Grid x:Name=&quot;RootGrid&quot; Background=&quot;{TemplateBinding Background}&quot;&amp;gt; &amp;lt;Border Background=&quot;{TemplateBinding Background}&quot; VerticalAlignment=&quot;Top&quot; Height=&quot;30&quot; Margin=&quot;0 -29 140 0&quot;&amp;gt; &amp;lt;TextBlock Foreground=&quot;White&quot; Margin=&quot;16 0&quot; VerticalAlignment=&quot;Center&quot; FontSize=&quot;12&quot; Text=&quot;{TemplateBinding Title}&quot; /&amp;gt; &amp;lt;/Border&amp;gt; &amp;lt;ContentPresenter /&amp;gt; &amp;lt;/Grid&amp;gt; &amp;lt;/Border&amp;gt; &amp;lt;ControlTemplate.Triggers&amp;gt; &amp;lt;Trigger Property=&quot;WindowState&quot; Value=&quot;Maximized&quot;&amp;gt; &amp;lt;Setter TargetName=&quot;RootGrid&quot; Property=&quot;Margin&quot; Value=&quot;6&quot; /&amp;gt; &amp;lt;/Trigger&amp;gt; &amp;lt;/ControlTemplate.Triggers&amp;gt; &amp;lt;/ControlTemplate&amp;gt;&amp;lt;/Window.Template&amp;gt;需要注意，我写了一个触发器，当窗口最大化时根元素边距值设为 6。如果不设置，最大化时窗口边缘的像素将看不见。这是反复尝试的经验值，且在多种 DPI 下验证是依然有效的。实际上即便是最合适此时设置的 SystemParameters.WindowResizeBorderThickness 属性依然无法让窗口最大化时边缘距离保持为 0。标题栏上的三大金刚我们发现，在以上所有方法尝试完成后，还剩下右上角的三颗按钮的背景色无法定制。如果依然采用非客户区控件覆盖的方法，这三个按钮就会被遮挡，只能自己区模拟了，那是不小的工作量。然而我们还发现，Google Chrome 是定制了这三个按钮的背景色的，正在研究它的做法。不过 Win32 原生的方法顶多只支持修改标题栏按钮的背景色，而不支持让标题栏按钮全透明。也就是说，Win32 原生方法也许能达到 Google Chrome 的效果，但不可能达到 UWP 中的效果。为了完全模拟 UWP，标题栏上的按钮只能自绘了。关于自绘标题栏按钮以模拟 UWP 原生按钮，可以阅读我的另一篇文章（代码太长，还是分开了好）：WPF 应用完全模拟 UWP 的标题栏按钮。原生 Windows 窗口体验UWP 应用对窗口样式的定制能力是非常小的，远远小于传统 Win32 应用。但因为其与系统原生集成，如果要求保证原生窗口体验，UWP 的定制能力又是各种方法里面最大的，而且 API 非常简单。如果你正在使用 UWP 开发应用，可参考林德熙的博客 win10 uwp 标题栏 来定制标题栏。特别处理 Windows 7 上关闭 Aero 效果的情况博客更新：特别说明，在 Windows 7 上可以关闭 Aero 效果，这时用本文方法做出的窗口，透明部分会显示黑色。解决方法为调用 DwmIsCompositionEnabled() 判断一下是否开启了 Aero 特效，如果关闭了，则使用传统的 AllowsTransparency 属性替代或放弃异形窗口。[DllImport(&quot;Dwmapi.dll&quot;, ExactSpelling = true, PreserveSig = false)][return: MarshalAs(UnmanagedType.Bool)]public static extern bool DwmIsCompositionEnabled();参考资料 DwmSetWindowAttribute function - Microsoft Docs pinvoke.net: DwmSetWindowAttribute (Enums) Why does a maximized window have the wrong window rectangle? - The Old New Thing" }, { "title": "Visual Studio 2022 升级不再附带 .NET Framework 4.5 这种古老的目标包了，本文帮你装回来", "url": "/post/how-to-support-net45-on-vs2022-or-later.html", "categories": "", "tags": "visualstudio, dotnet", "date": "2021-11-11 17:49:43 +0800", "snippet": "就在北京时间 2021 年 11 月 9 日凌晨，Visual Studio 2022 正式发布了！着急升级的小伙伴兴致勃勃地升级并卸载了原来的 Visual Studio 2019 后，发现自己的几个库项目竟然无法编译通过了。究其原因，是因为我的一些库依旧在支持古老的 .NET Framework 4.5 框架，而 Visual Studio 2022 不再附带如此古老的目标包了。本文将说说如何继续让 Visual Studio 2022 编译古老的 .NET Framework 4.5 框架项目。无法编译 .NET Framework 4.5 项目为了更广泛的适用于各种项目，我的一些库兼容的框架版本是非常古老的（比如下图截取的这张）。可是卸载掉 Visual Studio 2019 只留下 Visual Studio 2022 之后这些项目就不再能编译通过了。如果点开 Visual Studio 2022 的安装程序，会发现已经删除掉了 .NET Framework 4.5 的目标包了，无法通过它安装回来。方法一：重新安装回 .NET Framework 4.5 的目标包重新安装 Visual Studio 2019 可以让你重新安装 .NET Framework 4.5 目标包，然而现在再去 Visual Studio 的官网，会发现下载链接已经全面替换成了新出的 Visual Studio 2022 了，那我改如何下载回来？事实上，旧版的 Visual STudio 可以在这里下载： Visual Studio 2019当然，更早的版本就算在这份文档里也找不到下载链接了；还想要下载的话可能得去 Visual Studio 订阅里下了。如果担心 Visual Studio 2019 不久后也丢失，可以自行收藏一下下载的文件。由于你已经有一个新的主力 Visual Studio 2022 了，所以再装 Visual Studio 2019 时就不需要勾选负载了，只需要勾选 2022 版本不带的几个目标包即可： .NET Framework 4 目标包 .NET Framework 4.5 目标包 .NET Framework 4.5.1 目标包方法二：安装 Microsoft.NETFramework.ReferenceAssemblies NuGet 包详见：无需安装 VS2019，在 Visual Studio 2022 中编译 .NET Framework 4.5/4/3.5 这样的古老框架" }, { "title": "各个版本 Windows 11 / Windows 10 的名称、完整版本号、开发代号和系统自带的 .NET Framework 版本", "url": "/post/embeded-dotnet-version-in-all-windows.html", "categories": "", "tags": "windows, dotnet", "date": "2021-11-08 16:51:50 +0800", "snippet": "自 Windows 10 (1903) 版本开始，自带的 .NET Framework 版本一直保持为 4.8 并且不再允许手动安装。如果 .NET Framework 出了问题，基本只能重装系统；而 Windows Update 就有可能把 .NET Framework 搞坏。Windows 11 Windows 11 名称 构建版本 产品版本 开发代号 自带的 .NET Framework 版本 Windows 11 10.0.22000 21H2 太阳谷 .NET Framework 4.8 Windows 10 Windows 10 名称 构建版本 产品版本 开发代号 自带的 .NET Framework 版本 November 2021 Update 10.0.19044 21H2 21H2 .NET Framework 4.8 May 2021 Update 10.0.19043 21H1 21H1 .NET Framework 4.8 October 2020 Update 10.0.19042 20H2 20H2 .NET Framework 4.8 May 2020 Update 10.0.19041 2004 20H1 .NET Framework 4.8 November 2019 Update 10.0.18363 1909 19H2 .NET Framework 4.8 Windows 10 May 2019 Update 10.0.18362 1903 19H1 .NET Framework 4.8 Windows 10 October 2018 Update 10.0.17763 1809 RS5 .NET Framework 4.7.2 Windows 10 April 2018 Update 10.0.17134 1803 RS4 .NET Framework 4.7.2 Windows 10 Fall Creators Update 10.0.16299 1709 RS3 .NET Framework 4.7.1 Windows 10 Creators Update 10.0.15063 1703 RS2 .NET Framework 4.7 Windows 10 Anniversary Update 10.0.14393 1607 RS1 .NET Framework 4.6.2 Windows 10 November Update 10.0.10586 1511 TH2 .NET Framework 4.6.1 Windows 10 10.0.10240 1507 TH1 .NET Framework 4.6 Windows Server Windows Server 名称 自带的 .NET Framework 版本 Windows Server 1803 .NET Framework 4.7.2 Windows Server 1709 .NET Framework 4.7.1 Windows Server 2016 .NET Framework 4.6.2 参考资料 How to: Determine which .NET Framework versions are installed -Microsoft Docs Windows 10 release information - current branch, build history Windows 10 version history - Wikipedia Builds • The Collection Book" }, { "title": "了解 Windows/Linux 下命令行/Shell 启动程序传参的区别，这下不用再担心 Windows 下启动程序传参到 Linux 下挂掉了", "url": "/post/typing-difference-among-shells-in-different-operating-systems.html", "categories": "", "tags": "windows, linux", "date": "2021-08-30 10:41:03 +0800", "snippet": "启动某个程序，再带上一堆参数，这几乎是程序员们每天必做到事情。另外再算上各种辅助程序员们的自动化脚本，辅助构建的 CI（持续集成）等等，程序员们在创造大量的应用程序然后调用它们。但是，不经常跨系统玩这些的小伙伴们注意了，Windows 下的 Shell 和 Linux 下的 Shell 是有区别的！如果你不了解这些区别，很容易造成在 Windows 下编写的代码/脚本在 Linux 下无法使用的问题。本文列举 Windows/Linux 下 Shell 的区别。分号（;）分号（;）在 Linux 的 Shell 中是不同命令的分割，而在 Windows 中只是一个普通的字符。例如：dotnet build;dotnet pack这在 Linux 中是执行两句不同的命令，dotnet build 和 dotnet pack。而换到 Windows 中，这变成了执行 dotnet 程序，然后传入 build;dotnet pack 这个参数。相反的：foo --tags NET48;NETCOREAPP3_1;RELEASE这在 Windows 下是启动 foo 程序，然后传入 NET48;NETCOREAPP3_1;RELEASE，而在 Linux 下则变成了执行三个不同的命令。后面两个显然不是命令，于是执行时会报 127 错误：Command not found。（程序执行完成退出，返回值为 127。）如果你希望你的执行脚本跨平台，那么： 不要使用分号 ; 来尝试将两个或多个不同的命令合并成 1 行，直接执行多个命令即可。 如果命令名称或参数中存在分号，则必须使用引号 &quot; 将它包裹起来。路径空格Windows 下针对路径中包含空格的情况，用引号包裹路径：&quot;C:\\Program Files\\Walterlv\\Foo.exe&quot;Linux 下，如果路径中包含空格，则有三种不同的解决策略：# 加 \\ 转义/mnt/c/Program\\ Files/Walterlv/Foo# 加双引号&quot;/mnt/c/Program Files/Walterlv/Foo&quot;# 加单引号&#39;/mnt/c/Program Files/Walterlv/Foo&#39;可以发现，两者都有的方案是加双引号。所以，如果希望你的命令脚本跨平台使用，则应该使用双引号包裹路径。路径分隔符Windows 下，\\ 和 / 都是路径分隔符。Linux 下，只有 / 是路径分隔符，\\ 是合理的文件名，在 Shell 中，\\ 是转义字符。虽然理论上所有路径都使用 / 可以让你的跨平台脚本在以上所有系统中正常工作，但考虑到 Windows 可能有一些逗比程序对 / 支持不好，更建议： 在所有场景下生成路径字符串时使用当前平台的路径分隔符 不要将某平台生成的路径分隔符直接拿到另一平台使用关于跨平台路径分隔符的问题，我专门写了一篇博客，在那里可以了解更多： .NET 将混合了多个不同平台（Windows / Mac / Linux）的文件/目录的路径格式化成同一个平台下的路径 - walterlv其他特殊字符（ ( $ { * # ）在 Linux 的 Shell 中，有很多字符有特殊用途，而在 Windows Shell 中，这些字符的作用完全由被调用的应用程序来决定。所以对于跨平台的脚本，最好尽量避免使用这些字符。关于 Linux 下这些转义字符的用途，可以阅读我的另一篇博客： Linux Shell 中的所有需要转义的字符 - walterlv" }, { "title": "Roslyn 入门：使用 .NET Core 版本的 Roslyn 编译并执行跨平台的静态的源码", "url": "/post/compile-and-invoke-code-using-roslyn.html", "categories": "", "tags": "visualstudio, dotnet, csharp, roslyn", "date": "2021-08-30 10:40:55 +0800", "snippet": "Roslyn 是微软为 C# 设计的一套分析器，它具有很强的扩展性。以至于我们只需要编写很少量的代码便能够编译并执行我们的代码。作为 Roslyn 入门篇文章之一，你将可以通过本文学习如何开始编写一个 Roslyn 扩展项目 —— 编译一个类，然后执行其中的一段代码。本文是 Roslyn 入门系列之一： Roslyn 入门：使用 Visual Studio 的语法可视化（Syntax Visualizer）窗格查看和了解代码的语法树 Roslyn 入门：使用 .NET Core 版本的 Roslyn 编译并执行跨平台的静态的源码（本文） Roslyn 入门：使用 Roslyn 静态分析现有项目中的代码我们希望做什么？是否有过在编译期间修改一段代码的想法呢？我曾经在 生成代码，从 T 到 T1, T2, Tn —— 自动生成多个类型的泛型 一文中提到过这样的想法，在这篇文章中，我希望只编写泛型的一个参数的版本 Demo&amp;lt;T&amp;gt;，然后自动生成 2~16 个参数的版本 Demo&amp;lt;T1, T2&amp;gt;, Demo&amp;lt;T1, T2, T3&amp;gt; … Demo&amp;lt;T1, T2, ... T16&amp;gt;。不过，在那篇文章中，我写了一个应用程序来完成这样的事情。我在另一篇文章 如何创建一个基于命令行工具的跨平台的 NuGet 工具包 中说到我们可以将这样的应用程序打包成一个 NuGet 工具包。也就是说，利用这两种不同的技术，我们可以制作一个在编译期间生成多个泛型的 NuGet 工具包。不过，这样的生成方式不够通用。今天我们想生成泛型，明天我们想生成多语言类，后天我们又想生成代理类。能否做一种通用的方式来完成这样的任务呢？于是，我想到可以使用 Roslyn。在项目中编写一段转换代码，我们使用通用的方式去编译和执行这段代码，以便完成各种各样日益增加的类型转换需求。具体来说，就是 使用 Roslyn 编译一段代码，然后执行它。准备工作与之前在 Roslyn 入门：使用 Roslyn 静态分析现有项目中的代码 中的不同，我们这次无需打开解决方案或者项目，而是直接寻找并编译源代码文件。所以（利好消息），我们这回可以使用 .NET Core 跨平台版本的 Roslyn 了。所以为了充分有跨平台特性，我们创建控制台应用 (.NET Core)。▲ 千万不要吐槽相比于上一个入门教程来说，这次的界面变成了英文安装必要的 NuGet 包这次不需要完整的 .NET Framework 环境，也不需要打开解决方案和项目这种重型 API，所以一个简单的 NuGet 包足矣： Microsoft.CodeAnalysis.CSharp准备一份用于编译和执行代码文件我直接使用 生成代码，从 T 到 T1, T2, Tn —— 自动生成多个类型的泛型 这篇文章中的例子。把其中最关键的文件拿来用于编译和生成试验。using System.Linq;using static System.Environment;namespace Walterlv.Demo.Roslyn{ public class GenericGenerator { private static readonly string GeneratedAttribute = @&quot;[System.CodeDom.Compiler.GeneratedCode(&quot;&quot;walterlv&quot;&quot;, &quot;&quot;1.0&quot;&quot;)]&quot;; public string Transform(string originalCode, int genericCount) { if (genericCount == 1) { return originalCode; } var content = originalCode // 替换泛型。 .Replace(&quot;&amp;lt;out T&amp;gt;&quot;, FromTemplate(&quot;&amp;lt;{0}&amp;gt;&quot;, &quot;out T{n}&quot;, &quot;, &quot;, genericCount)) .Replace(&quot;Task&amp;lt;T&amp;gt;&quot;, FromTemplate(&quot;Task&amp;lt;({0})&amp;gt;&quot;, &quot;T{n}&quot;, &quot;, &quot;, genericCount)) .Replace(&quot;Func&amp;lt;T, Task&amp;gt;&quot;, FromTemplate(&quot;Func&amp;lt;{0}, Task&amp;gt;&quot;, &quot;T{n}&quot;, &quot;, &quot;, genericCount)) .Replace(&quot; T, Task&amp;gt;&quot;, FromTemplate(&quot; {0}, Task&amp;gt;&quot;, &quot;T{n}&quot;, &quot;, &quot;, genericCount)) .Replace(&quot;(T, bool&quot;, FromTemplate(&quot;({0}, bool&quot;, &quot;T{n}&quot;, &quot;, &quot;, genericCount)) .Replace(&quot;var (t, &quot;, FromTemplate(&quot;var ({0}, &quot;, &quot;t{n}&quot;, &quot;, &quot;, genericCount)) .Replace(&quot;, t)&quot;, FromTemplate(&quot;, {0})&quot;, &quot;t{n}&quot;, &quot;, &quot;, genericCount)) .Replace(&quot;return (t, &quot;, FromTemplate(&quot;return ({0}, &quot;, &quot;t{n}&quot;, &quot;, &quot;, genericCount)) .Replace(&quot;&amp;lt;T&amp;gt;&quot;, FromTemplate(&quot;&amp;lt;{0}&amp;gt;&quot;, &quot;T{n}&quot;, &quot;, &quot;, genericCount)) .Replace(&quot;(T value)&quot;, FromTemplate(&quot;(({0}) value)&quot;, &quot;T{n}&quot;, &quot;, &quot;, genericCount)) .Replace(&quot;(T t)&quot;, FromTemplate(&quot;({0})&quot;, &quot;T{n} t{n}&quot;, &quot;, &quot;, genericCount)) .Replace(&quot;(t)&quot;, FromTemplate(&quot;({0})&quot;, &quot;t{n}&quot;, &quot;, &quot;, genericCount)) .Replace(&quot;var t =&quot;, FromTemplate(&quot;var ({0}) =&quot;, &quot;t{n}&quot;, &quot;, &quot;, genericCount)) .Replace(&quot; T &quot;, FromTemplate(&quot; ({0}) &quot;, &quot;T{n}&quot;, &quot;, &quot;, genericCount)) .Replace(&quot; t;&quot;, FromTemplate(&quot; ({0});&quot;, &quot;t{n}&quot;, &quot;, &quot;, genericCount)) // 生成 [GeneratedCode]。 .Replace(&quot; public interface &quot;, $&quot; {GeneratedAttribute}{NewLine} public interface &quot;) .Replace(&quot; public class &quot;, $&quot; {GeneratedAttribute}{NewLine} public class &quot;) .Replace(&quot; public sealed class &quot;, $&quot; {GeneratedAttribute}{NewLine} public sealed class &quot;); return content.Trim(); } private static string FromTemplate(string template, string part, string separator, int count) { return string.Format(template, string.Join(separator, Enumerable.Range(1, count).Select(x =&amp;gt; part.Replace(&quot;{n}&quot;, x.ToString())))); } }}这份代码你甚至可以直接复制到你的项目中，一定是可以编译通过的。编译这份代码使用 Roslyn 编译一份代码是非常轻松愉快的。写出以下这三行就够了：var syntaxTree = CSharpSyntaxTree.ParseText(&quot;那份代码的全文内容&quot;);var compilation = CSharpCompilation.Create(&quot;assemblyname&quot;, new[] { syntaxTree }, options: new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));var result = compilation.Emit(ms);好吧，其实我是开玩笑的，这三行代码确实能够跑通过，不过得到的 result 是编译不通过的结局。为了能够在多数情况下编译通过，我写了更多的代码：using System;using System.IO;using System.Linq;using System.Reflection;using Microsoft.CodeAnalysis;using Microsoft.CodeAnalysis.CSharp;namespace Walterlv.Demo.Roslyn{ class Program { static void Main(string[] args) { // 大家都知道在代码中写死文件路径是不对的，不过，我们这里是试验。放心，我会改的！ var file = @&quot;D:\\Development\\Demo\\Walterlv.Demo.Roslyn\\Walterlv.Demo.Roslyn.Tests\\GenericGenerator.cs&quot;; var originalText = File.ReadAllText(file); var syntaxTree = CSharpSyntaxTree.ParseText(originalText); var type = CompileType(&quot;GenericGenerator&quot;, syntaxTree); // 于是我们得到了编译后的类型，但是还不知道怎么办。 } private static Type CompileType(string originalClassName, SyntaxTree syntaxTree) { // 指定编译选项。 var assemblyName = $&quot;{originalClassName}.g&quot;; var compilation = CSharpCompilation.Create(assemblyName, new[] { syntaxTree }, options: new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary)) .AddReferences( // 这算是偷懒了吗？我把 .NET Core 运行时用到的那些引用都加入到引用了。 // 加入引用是必要的，不然连 object 类型都是没有的，肯定编译不通过。 AppDomain.CurrentDomain.GetAssemblies().Select(x =&amp;gt; MetadataReference.CreateFromFile(x.Location))); // 编译到内存流中。 using (var ms = new MemoryStream()) { var result = compilation.Emit(ms); if (result.Success) { ms.Seek(0, SeekOrigin.Begin); var assembly = Assembly.Load(ms.ToArray()); return assembly.GetTypes().First(x =&amp;gt; x.Name == originalClassName); } throw new CompilingException(result.Diagnostics); } } }}执行编译后的代码既然得到了类型，那么执行这份代码其实毫无压力，因为我们都懂得反射（好吧，我假装你懂反射）。var transformer = Activator.CreateInstance(type);var newContent = (string) type.GetMethod(&quot;Transform&quot;).Invoke(transformer, new object[] { &quot;某个泛型类的全文，假装我是泛型类 Walterlv&amp;lt;T&amp;gt; is a sb.&quot;, 2 });执行完之后，里面的 Walterlv&amp;lt;T&amp;gt; 真的变成了 Walterlv&amp;lt;T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16&amp;gt; 啊。说明成功执行。下面进入高阶模式作为入门篇，我才不会进入高阶模式呢！如果你想实现如本文开头所说的更通用的效果，欢迎发动你的大脑让想象力迸发。当然，如果你确实想不出来，欢迎在下方评论，我将尽快回复。参考资料 Compiling C# Code Into Memory and Executing It with Roslyn - Tugberk Ugurlu’s Blog" }, { "title": "使用 WPF 做一个可以逼真地照亮你桌面的高性能阳光", "url": "/post/create-a-realistic-sunshine-on-your-desktop-using-wpf.html", "categories": "", "tags": "wpf, dotnet", "date": "2021-08-05 17:20:04 +0800", "snippet": "本文想要做的，可不是随便弄一点阳光的半透明形状，然后简单地放到桌面上，而是真真正正地要照亮桌面上的窗口元素！并且，全程使用 GPU 加速，而且代码超简单。效果预览先放上两张动图看看效果，GIF 比较大，如果博客里看不到可以点击下面的小标题下载下来看。阳光扫过云层：阳光扫过 Visual Studio：可以看到，阳光经过云层时，强烈的光芒与云层的光光部分叠加起来了，让人感觉云层的照亮部分十分刺眼。阳光经过 Visual Studio 的界面时，纯色部分可以看出阳光的外形，高饱和度部分在阳光的照耀下显得格外亮眼。代码实现实现本文效果的代码其实很少，只有以下几步： 制作一个全透明窗口 编写一个像素着色器 画一个简单的阳光形状不过在开始之前，我们先创建一个空白的 WPF 项目吧：第一步：制作一个全透明窗口网上广为流传的 AllowsTransparency=&quot;True&quot; 的方式就可以，不过我个人不喜欢，因为性能不好。我更推荐大家使用我另一篇博客里推荐的高性能透明窗口的实现方案：WPF 制作高性能的透明背景异形窗口如果现在不想看的，我可以直接把 MainWindow.xaml.cs 的代码贴出来（放心，其他地方不需要写代码）：&amp;lt;Window x:Class=&quot;Walterlv.DesktopSunshine.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:Walterlv.DesktopSunshine&quot; mc:Ignorable=&quot;d&quot; Title=&quot;Walterlv.DesktopSunshine&quot; Width=&quot;240&quot; Height=&quot;240&quot; Background=&quot;Transparent&quot; WindowStyle=&quot;None&quot; ResizeMode=&quot;NoResize&quot;&amp;gt; &amp;lt;WindowChrome.WindowChrome&amp;gt; &amp;lt;WindowChrome GlassFrameThickness=&quot;-1&quot; ResizeBorderThickness=&quot;0&quot; CornerRadius=&quot;0&quot; CaptionHeight=&quot;240&quot; /&amp;gt; &amp;lt;/WindowChrome.WindowChrome&amp;gt; &amp;lt;Grid&amp;gt; &amp;lt;/Grid&amp;gt;&amp;lt;/Window&amp;gt;最重要的，是 Background=&quot;Transparent&quot;、WindowStyle=&quot;None&quot;、ResizeMode=&quot;NoResize&quot; 和 GlassFrameThickness=&quot;-1&quot; 这四个属性。其他的代码，我只是在做一个普通的窗口而已。大小 240 是为了容纳一个太阳的大小。第二步：编写一个像素着色器想了解怎么写像素着色器的，可以阅读我的另一篇博客：WPF 像素着色器入门：使用 Shazzam Shader Editor 编写 HLSL 像素着色器代码。需要在像素着色器里编写此代码（不想学像素着色器的可以忽略此代码直接往后看）：sampler2D inputSampler : register(S0);float Threshold : register(C0);float4 main(float2 uv : TEXCOORD) : COLOR{ float4 color = tex2D(inputSampler, uv); float a = color.a; if(a &amp;lt; Threshold) { color.a = 0; } else { color.a = 1; } return color;}如果不想自己编写并编译像素着色器，可以直接下载我已经编译好的 .ps 文件： BinaryAlphaEffect.ps下载下来的文件（或者你自己编译出来的文件）放到解决方案中的任意位置（本示例中放到了 Assets 文件夹中）：重要：接着，将 .ps 文件加入到编译。请双击项目（Walterlv.DesktopSunshine）以编辑其项目文件（.csproj）。需要增加的行我已经在下面高亮出来了。 &amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;OutputType&amp;gt;WinExe&amp;lt;/OutputType&amp;gt; &amp;lt;TargetFramework&amp;gt;net6.0-windows&amp;lt;/TargetFramework&amp;gt; &amp;lt;Nullable&amp;gt;enable&amp;lt;/Nullable&amp;gt; &amp;lt;UseWPF&amp;gt;true&amp;lt;/UseWPF&amp;gt; &amp;lt;/PropertyGroup&amp;gt;++ &amp;lt;ItemGroup&amp;gt;++ &amp;lt;Resource Include=&quot;Assets\\**\\*.ps&quot; /&amp;gt;++ &amp;lt;/ItemGroup&amp;gt; &amp;lt;/Project&amp;gt;然后，编写一个使用此 .ps 文件的 C# 类型。我取名为 BinaryAlphaEffect.cs。using System;using System.Windows;using System.Windows.Media;using System.Windows.Media.Effects;namespace Walterlv.DesktopSunshine{ public class BinaryAlphaEffect : ShaderEffect { public static readonly DependencyProperty InputProperty = RegisterPixelShaderSamplerProperty( &quot;Input&quot;, typeof(BinaryAlphaEffect), 0); public static readonly DependencyProperty ThresholdProperty = DependencyProperty.Register( &quot;Threshold&quot;, typeof(double), typeof(BinaryAlphaEffect), new UIPropertyMetadata(1.0d, PixelShaderConstantCallback(0))); public BinaryAlphaEffect() { PixelShader = new PixelShader { UriSource = new Uri(&quot;/Assets/BinaryAlphaEffect.ps&quot;, UriKind.Relative), }; UpdateShaderValue(InputProperty); UpdateShaderValue(ThresholdProperty); } public Brush Input { get =&amp;gt; (Brush)GetValue(InputProperty); set =&amp;gt; SetValue(InputProperty, value); } public double Threshold { get =&amp;gt; (double)GetValue(ThresholdProperty); set =&amp;gt; SetValue(ThresholdProperty, value); } }}这个 Threshold 是个二值化的阈值，可用来调阳光效果。我把默认值设为了 1，这样阳光效果最强烈。（实际上其他值的效果惨不忍睹。因为这段代码我本来编写的目的不是在做阳光，只是中间不小心做出了阳光效果，觉得很有意思就教大家一下。）第三步：画一个简单的阳光形状我只画一个圆来表示阳光的形状（想用其他形状的，自己发挥创意）。于是在 MainWindow.xaml 里添加一点点代码： &amp;lt;/WindowChrome.WindowChrome&amp;gt;++ &amp;lt;Border&amp;gt;++ &amp;lt;Ellipse Fill=&quot;White&quot; Width=&quot;160&quot; Height=&quot;160&quot;&amp;gt;++ &amp;lt;UIElement.Effect&amp;gt;++ &amp;lt;BlurEffect Radius=&quot;40&quot; /&amp;gt;++ &amp;lt;/UIElement.Effect&amp;gt;++ &amp;lt;/Ellipse&amp;gt;++ &amp;lt;/Border&amp;gt; &amp;lt;/Window&amp;gt;这里，给圆加了一些模糊效果，这是必要的。然后，把我们在第二步里写的像素着色器用上： &amp;lt;Border&amp;gt;++ &amp;lt;UIElement.Effect&amp;gt;++ &amp;lt;local:BinaryAlphaEffect /&amp;gt;++ &amp;lt;/UIElement.Effect&amp;gt; &amp;lt;Ellipse Fill=&quot;White&quot; Width=&quot;160&quot; Height=&quot;160&quot;&amp;gt; &amp;lt;UIElement.Effect&amp;gt; &amp;lt;BlurEffect Radius=&quot;40&quot; /&amp;gt; &amp;lt;/UIElement.Effect&amp;gt; &amp;lt;/Ellipse&amp;gt; &amp;lt;/Border&amp;gt;那么至此，所有代码已经完成。总结一下，我们写了这些代码： 一个新创建的 WPF 项目模板（包含模板自带的 App.xaml App.xaml.cs MainWindow.xaml MainWindow.xaml.cs AssemblyInfo.cs） 下载或编译的 BinaryAlphaEffect.ps 像素着色器文件，和用来使用它的 BinaryAlphaEffect.cs 文件 使用 BinaryAlphaEffect 类的 MainWindow.xaml 中的几个 Border 和 Ellipse是不是代码量非常少？接下来，就是见证奇迹的时刻。效果与性能阳光扫过 Windows 11 自带壁纸。在太阳附近，与太阳融为一体；在森林中，阳光被树叶遮挡；在水面，阳光跟随着波光闪耀；在岩石上，阳光把岩石照得通亮。你可以把这个阳光放到任何地方，就算是正在播放的视频前面也依然在每帧中都有实时效果。最重要的是——它几乎不消耗性能！因为它在图形渲染管线的像素着色器部分运行，其所有代码都在 GPU 中并行执行，且每次执行仅需不到 10 条指令。你可以看到任务管理器中，它的 CPU 和 GPU 消耗都是 0。" }, { "title": "路径标记语法（Path Markup Syntax）完全教程", "url": "/post/path-markup-syntax.html", "categories": "", "tags": "wpf, dotnet", "date": "2021-07-30 08:50:07 +0800", "snippet": "无论是 WPF、UWP 还是 Xamarin、MAUI、WinUI，都有可以绘制任意形状的 Geometry 类型，它支持一种路径标记语法，可以拟合各种形状。同时，SVG 格式使用的也是完全相同的路径语法，你用文本编辑器打开一个 SVG 格式时也会看到这样的字符串。你只需要阅读本文，即可从零开始了解并最终学会路径标记语法。示例一开始，我们用一张 SVG 图来看看一个典型的路径字符串是什么样子的：你可以点击上面这张图以单独打开它，然后查看网页源代码来观察它的字符串内容。我这里也贴一份：&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&amp;gt;&amp;lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&amp;gt;&amp;lt;svg width=&quot;100%&quot; height=&quot;100%&quot; viewBox=&quot;0 0 20 20&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; xml:space=&quot;preserve&quot; xmlns:serif=&quot;http://www.serif.com/&quot; style=&quot;fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;&quot;&amp;gt; &amp;lt;g id=&quot;控件&quot;&amp;gt; &amp;lt;g id=&quot;ic-备课端-主窗口-工具栏-文字&quot; serif:id=&quot;ic/备课端/主窗口/工具栏/文字&quot;&amp;gt; &amp;lt;g&amp;gt; &amp;lt;rect id=&quot;bounds&quot; x=&quot;0&quot; y=&quot;0&quot; width=&quot;20&quot; height=&quot;20&quot; style=&quot;fill:#f00;fill-opacity:0;&quot;/&amp;gt; &amp;lt;path id=&quot;形状结合&quot; d=&quot;M17,11c-1.342,-0 -3.872,1.385 -4.872,2.385c0.958,1.151 1.381,2.186 1.872,3.615l3,-0l0,-6Zm-5,6c-1.568,-3.869 -4.674,-6 -9,-6l0,6l9,-0Zm-9,-8c4,0 6,1 8,3c2,-2 4,-3 6,-3l0,-5l0.206,0c0.439,0 0.794,0.366 0.794,0.818l-0,12.364c-0.003,0.45 -0.356,0.814 -0.794,0.818l-14.412,0c-0.439,-0 -0.794,-0.366 -0.794,-0.818l-0,-12.364c0.003,-0.45 0.356,-0.814 0.794,-0.818l14.206,-0l0,1l-14,-0l0,4Zm10,-1c-0.663,-0 -1,-0.318 -1,-1c0,-0.682 0.337,-1 1,-1c0.663,-0 1,0.318 1,1c0,0.682 -0.337,1 -1,1Z&quot; style=&quot;fill:#666;fill-opacity:0.8;fill-rule:nonzero;&quot;/&amp;gt; &amp;lt;/g&amp;gt; &amp;lt;/g&amp;gt; &amp;lt;/g&amp;gt;&amp;lt;/svg&amp;gt;这里，path/@d 里的，就是我们即将学习的路径标记字符串。XAML 系的路径标记语法与之只有一点点不同。名称在 SVG 的解释文档中，对此语法的称呼为“SVG Path Syntax”（SVG 路径语法）。在 XAML 系语言中，称其为“Path Markup Syntax”（路径标记语法），官方也称其为“Mini-Language”。由于 SVG 和 XAML 的路径语法几乎一样，所以学会本文可以直接学会两者的语法。语法（Syntax）路径标记语法从前往后写下来，遵循“命令-参数-命令-参数-命令-参数-……”这样的要求。让我们再来一个更简单的例子：M 10,100 C 10,300 300,-200 300,100把解释放进这个字符串的话，是这样：M（命令）10,100（点坐标） C（命令）10,300 300,-200 300,100（三个点坐标）。在 SVG 路径语法中，一共有如下命令可以使用：M m L l H h V v C c Q q S s T t A a Z z额外的，XAML 系的路径标记语法还有一个 F。看起来很多，但实际上我们可以做一个分类，这样理解起来会更容易一些： 起点 M m 直线 L l、H h、V v 贝塞尔曲线 C c、Q q、S s、T t 椭圆弧 A a 封闭 Z z 先来说说一些共性的知识： 一个路径可以由多段组成，用 M m 来指定一个新段的开始 大写字母后面跟的参数中，点坐标是绝对坐标；小写字母后面跟的参数中，点坐标是相对坐标 如果连续几段都是相同的命令，那么后续可以只写参数而省略命令 字符串中间的空格 ` ` 和逗号 , 是用来分隔参数和点的 X、Y 坐标的，可以混用也可以多写下面，我们一个一个说：F相比于 SVG 来说，F 是 XAML 系路径标记语法唯一一个特有的语法。带上参数一起，F 只有三种写法： 省略不写 F0 表示 EvenOdd F1 表示 Nonzero省略不写和 F0 是相同的含义，即 EvenOdd。SVG 中如果要实现相同的效果，需要设置 path/@style 属性，即style=&quot;fill-rule:nonzero;&quot;。起点和终点M m 移动命令M m（Move，移动） 含义：开始一段新的路径，然后将起点移到 M m 后面的参数中 参数：startPoint（起点坐标） 示例：M10,100M 后面的 startPoint 参数是绝对点坐标，而 m 后面的 startPoint 参数是相对上一个命令中端点坐标的相对点坐标。L l H h V v 直线命令L l（Line，直线） 含义：从上一个点开始，连一条直线到此命令的端点 参数：endPoint（端点坐标） 示例：L100,200H h（Horizontal Line，水平线） 含义：从上一个点开始，连一条水平直线到此命令的横坐标 参数：x（横坐标） 示例：H100V v（Vertical Line，垂直线） 含义：从上一个点开始，连一条垂直直线到此命令的纵坐标 参数：y（纵坐标） 示例：V200与前面一样，大写字符后面的坐标和数值是绝对坐标，小写字符后面的坐标和数值是相对坐标。C c、Q q、S s、T t 贝塞尔曲线命令C c（Cubic Bezier Curve，三次贝塞尔曲线） 含义：从上一个点开始，连一条三次贝塞尔曲线到此命令的端点 参数：controlPoint1 controlPoint2 endPoint（控制点坐标1 控制点坐标2 端点坐标） 示例：C10,300 300,-200 300,100Q q（Quadratic Bezier Curve，二次贝塞尔曲线） 含义：从上一个点开始，连一条二次贝塞尔曲线到此命令的端点 参数：controlPoint endPoint（控制点坐标 端点坐标） 示例：Q300,-200 300,100S s（Smooth Cubic Bezier Curve，平滑三次贝塞尔曲线） 含义：从上一个点开始，连一条平滑的三次贝塞尔曲线到此命令的端点，确保在上一个点的曲线是连续的 参数：controlPoint2 endPoint（控制点坐标2 端点坐标） 示例：S300,-200 300,100所谓“平滑”，即保证曲线在上一个端点处的的曲线连续而没有突变（一次可导）。而平滑的方法，便是将上一个命令在端点处的贝塞尔控制点相对上一个点进行一次镜像。下面这张图可以说明是如何做到平滑的：你也可以注意到一个有趣的事情，S s 的参数中只有 controlPoint2 和 endPoint，这是因为 controlPoint 完全是根据上一个点的控制点的镜像来计算得到的，无需传入。T t（Smooth Quadratic Bezier Curve，平滑二次贝塞尔曲线） 含义：从上一个点开始，连一条平滑的二次贝塞尔曲线到此命令的端点，确保在上一个点的曲线是连续的 参数：endPoint（端点坐标） 示例：T300,100与 S s 一样，T t 也是确保在上一个点处平滑。控制点的计算方法也是一样对上一个点的控制点进行镜像。由于二次贝塞尔曲线只有一个控制点，所以它是无需传入控制点的，完全是算出来的。A a 椭圆弧命令A a（Elliptical Arc，椭圆弧） 含义：在上一个点和此命令的端点之间，连一条椭圆弧 参数：size rotationAngle isLargeArcFlag sweepDirectionFlag endPoint（包含宽高两个值的尺寸 以度数计量的角度值 大于平角或小于平角标识 顺时针或逆时针标识 端点坐标） 示例：A18.621,18.621,0,0,1,18.621,0.000isLargeArcFlag 标识，如果角度大于 180° 则为 1，否则为 0；sweepDirectionFlag 标识，如果顺时针则为 1，如果逆时针则为 0。Z z 闭合命令 含义：如果有此命令，那么图形将闭合形成填充区域；如果没有此命令，那么图形将只有线而不填充 没有参数 示例：z此命令不区分大小写。解析在这里挖一个坑，稍后贴出我用“访问者”模式编写的高性能高扩展性的路径语法解析代码。参考资料 Path Markup Syntax - WPF .NET Framework - Microsoft Docs Paths — SVG 2 Paths – SVG 1.1 (Second Edition)" }, { "title": "用 WiX 制作安装包：创建一个简单的 exe 安装包", "url": "/post/getting-started-with-wix-toolset-exe-hello-world.html", "categories": "", "tags": "dotnet, msi, wix", "date": "2021-07-20 09:11:05 +0800", "snippet": "本文是 WiX Toolset 安装包制作入门教程 系列中的一篇，可前往阅读完整教程。本文将带大家制作一个简单的 exe 安装包。本文开始前，请确保你已经可以生成一个最简单的 msi 安装包了： 用 WiX 制作安装包：创建一个简单的 msi 安装包由于 exe 格式的安装包自己带了 UI，所以 msi 中的 UI 怎么样都是可以不用管的（不用纠结 msi 做成了扫什么样，能像上文结尾一样正常安装就好）。创建 WiX EXE 项目在解决方案上右键，“添加”-&amp;gt;“新建项目…”，然后在“添加新项目”窗口中搜索“WiX”，找到“Bootstrapper Project for WiX v3”。按“下一步”取个名字，然后“创建”。注意，选择的模板要注意这些要点： 图标上标记了“wix”，标签上标记了“WiX” 模板简介中说明这是在创建“EXE”文件创建完后，记得去项目属性里改一下输出的文件名。例如可以改成主项目的名称，也可以改成“XXX_Setup”这些大家喜欢用的名称。引用 MSI 项目我们现在的这个项目生成的是捆绑包（Bundle），是为了将多个安装包集合到一起进行安装的。我们需要在这个捆绑包里面安装我们上一篇教程中创建的 MSI 安装包，所以我们需要引用这个创建 MSI 的项目。编辑 Bundle.wxs 文件在 Bundle.wxs 文件中，找到放 MSI 文件的注释处，将其替换成我们想安装的 MSI 文件。 &amp;lt;Chain&amp;gt;-- &amp;lt;!-- TODO: Define the list of chained packages. --&amp;gt;-- &amp;lt;!-- &amp;lt;MsiPackage SourceFile=&quot;path\\to\\your.msi&quot; /&amp;gt; --&amp;gt;++ &amp;lt;MsiPackage Compressed=&quot;yes&quot;++ SourceFile=&quot;$(var.Walterlv.Installer.Msi.TargetPath)&quot;/&amp;gt; &amp;lt;/Chain&amp;gt;注意： 这里的 Walterlv.Installer.Msi 是前一篇教程中引用的项目的名称，你可以改成你自己的生成 MSI 的项目的名称。 Compressed=&quot;yes&quot; 表示此 MSI 包会被嵌入到最终生成的 exe 文件中（反之则会松散地放到外部文件中）。可选值为 yes no default，对于 MSI 文件会默认嵌入，所以也可以不指定。编辑基本的安装包信息与 MSI 包一样，不填写基本的安装信息也会报编译错误：▲ 缺少厂商信息 &amp;lt;Product Id=&quot;*&quot;-- Name=&quot;Walterlv.Installer.Msi&quot;++ Name=&quot;Walterlv.Demo.MainApp&quot; Language=&quot;1033&quot; Version=&quot;1.0.0.0&quot;-- Manufacturer=&quot;&quot;++ Manufacturer=&quot;walterlv&quot; UpgradeCode=&quot;2aeffe1a-8bb6-4b06-b1c0-feca18e17cf7&quot;&amp;gt;-- &amp;lt;Bundle Name=&quot;Walterlv.Installer.Exe&quot;++ &amp;lt;Bundle Name=&quot;Walterlv.Demo.MainApp&quot; Version=&quot;1.0.0.0&quot;-- Manufacturer=&quot;&quot;++ Manufacturer=&quot;walterlv&quot;-- UpgradeCode=&quot;528f80ca-a8f5-4bd4-8131-59fdcd69a411&quot;&amp;gt;++ UpgradeCode=&quot;2aeffe1a-8bb6-4b06-b1c0-feca18e17cf7&quot;&amp;gt;这里的 UpgradeCode 如果改成和之前的 MSI 文件的一样，那么无论是做成 MSI 还是 EXE 格式的安装包，他们都是可以互相被升级的。当然，对于一个 Bundle 来说可以集合多个安装包。当要一次安装多个 MSI 包的时候，建议选不一样的 UpgradeCode。关于设置 MSI 和 EXE 安装包的 UpgradeCode 的更多细节，可以阅读我的另一篇博客： MSI 和 EXE 的 UpgradeCode 应该设置成相同还是不同？测试效果现在，我们完成了一个最简单的 EXE 安装包，测试安装一下。前往 EXE 文件的输出目录（在项目目录的 bin\\Debug 下）：▲ 前往 EXE 文件的输出目录双击安装，可以出现默认的安装界面：▲ 默认的安装界面安装完后，可以在系统设置“应用和功能”以及“Program Files”目录中找到它：▲ 系统设置应用和功能测试完成后，记得及时卸载掉这个包。虽然这次没什么影响，但后续我们会学到的某个操作可能导致未及时卸载的包再也无法通过正常途径卸载，所以请保持良好的习惯。（虚拟机调试的小伙伴可无视）。▲ 卸载包另外，觉得不错可以提交一下代码，方便后续章节的学习。附源代码附上必要的源码，避免你在阅读教程时因模板文件的版本差异造成一些意料之外的问题。Bundle.wxs// 除了本文所说的改动外，本文件的其他内容均保持模板文件的原始模样。&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;Wix xmlns=&quot;http://schemas.microsoft.com/wix/2006/wi&quot;&amp;gt; &amp;lt;Bundle Name=&quot;Walterlv.Demo.MainApp&quot; Version=&quot;1.0.0.0&quot; Manufacturer=&quot;walterlv&quot; UpgradeCode=&quot;528f80ca-a8f5-4bd4-8131-59fdcd69a411&quot;&amp;gt; &amp;lt;BootstrapperApplicationRef Id=&quot;WixStandardBootstrapperApplication.RtfLicense&quot; /&amp;gt; &amp;lt;Chain&amp;gt; &amp;lt;MsiPackage Compressed=&quot;yes&quot; SourceFile=&quot;$(var.Walterlv.Installer.Msi.TargetPath)&quot;/&amp;gt; &amp;lt;/Chain&amp;gt; &amp;lt;/Bundle&amp;gt;&amp;lt;/Wix&amp;gt;" }, { "title": "0x800b0109 - 已处理证书链，但是在不受信任提供程序信任的根证书中终止。", "url": "/post/terminated-in-a-root-certificate-which-is-not-trusted.html", "categories": "", "tags": "dotnet, msi, wix", "date": "2021-07-16 17:51:20 +0800", "snippet": "有时在安装程序时无法安装出现错误，或者在更新某些系统组件时也遇到同样的错误：“已处理证书链，但是在不受信任提供程序信任的根证书中终止。”。本文介绍其原因和解决方法。错误▲ 错误提示 - 来自 .NET Framework▲ 错误提示 - 来自WiX 入门教程错误码：0x800b0109。 已处理证书链，但是在不受信任提供程序信任的根证书中终止。 A certificate chain processed, but terminated in a root certificate which is not trusted by the trust provider.使用 err 工具来查询此错误码 也能得到相同的提示：❯ err 800b0109# for hex 0x800b0109 / decimal -2146762487 CERT_E_UNTRUSTEDROOT winerror.h# A certificate chain processed, but terminated in a root# certificate which is not trusted by the trust provider.# 1 matches found for &quot;800b0109&quot;原因操作系统中不含此 .NET Framework 版本需要验证的在有效时间内的微软根证书（Microsoft Root Certificate Authority 2011）。目前已知最新版的 Windows 7 SP1 (x86) 系统在未安装系统所需补丁的情况下不带此证书，而 Windows 7 SP1 (x64) 系统的最新版带有此证书。其他更(gèng)新的 Windows 8、Windows 10 全系都带有此证书。解决为系统安装有效的微软证书即可。第一步：下载证书 MicrosoftRootCertificateAuthority2011.zip，下载完后解压得到 MicrosoftRootCertificateAuthority2011.cer 文件。（你也可以从其他已安装证书的电脑上导出。）第二步：双击安装证书。 点击“安装证书”，下一步； 选择“将所有的证书放入下列存储”，然后选择“浏览…”； 选择“受信任的证书办法机构”，然后选择“下一步”； 在“安全性警告”中，点击“是”。最后，重新安装 .NET Framework 或者其他程序即可。" }, { "title": "WiX Toolset 安装包制作入门教程（目录篇）", "url": "/post/getting-started-with-wix-toolset.html", "categories": "", "tags": "dotnet, msi, wix", "date": "2021-07-16 17:48:46 +0800", "snippet": "WiX 全称为 Windows Installer XML，是使用 XML 文件创建 Windows 安装程序的一组工具集。它开源且完全免费。虽然这一组工具集功能非常强大，但学习曲线较陡峭，在没有人指导的情况下独立完成完整的安装包制作会比较困难。对安装包技术零基础的开发者，甚至仅凭阅读官方文档的教程系列也难以完成 Hello World 级别的安装包制作。所以本系列博客的出现旨在填补官方教程系列的这一空缺，希望零基础的开发者也能在本教程的帮助下独立完成整套安装包的制作。系列教程说明 截至 2021 年 7 月，WiX 4 尚处在预览阶段，所以本系列教程基于 WiX 3 进行。 本系列教程所需的所有源代码都已在 GitHub 上开源，你可以克隆下来学习和试验，也可以选择性忽略。 如果你在阅读教程时发现有些步骤不对（或者按步骤完成后依然无法跑通，或者遇到了各种奇葩问题），欢迎在评论区留言，或加我的 QQ 交流（450711383）。分类 Hello WorldWiX 能制作不同种类的安装包，各类安装包的制作方法不同，做 Hello World 所需的步骤也不一样。所以这里分一下类，每个类别都可从零开始完成整个类别的 Hello World。你可以挑自己想做的安装包类型，然后直接在这个类别里面从第一篇读至最后一篇。msi 格式安装包的 Hello World 安装 WiX Toolset 工具集 安装 WiX Toolset Visual Studio 插件 准备一个用于学习 WiX 安装包制作的 Visual Studio 解决方案 使用 WiX 创建一个简单的 msi 安装包exe 格式安装包的 Hello World 安装 WiX Toolset 工具集 安装 WiX Toolset Visual Studio 插件 准备一个用于学习 WiX 安装包制作的 Visual Studio 解决方案 使用 WiX 创建一个简单的 msi 安装包 使用 WiX 创建一个简单的 exe 安装包要求 .NET Framework 前置的 Hello World 安装 WiX Toolset 工具集 安装 WiX Toolset Visual Studio 插件 准备一个用于学习 WiX 安装包制作的 Visual Studio 解决方案 使用 WiX 创建一个简单的 msi 安装包 为 WiX 制作的 msi 安装包添加 .NET Framework 环境检查 使用 WiX 创建一个简单的 exe 安装包 为 WiX 制作的 exe 安装包添加 .NET Framework 前置的安装步骤使用 WPF 制作安装界面的 Hello World 安装 WiX Toolset 工具集 安装 WiX Toolset Visual Studio 插件 准备一个用于学习 WiX 安装包制作的 Visual Studio 解决方案 使用 WiX 创建一个简单的 msi 安装包 使用 WiX 创建一个简单的 exe 安装包 为 WiX 制作的 exe 安装包添加 .NET Framework 前置的安装步骤 使用 WPF 制作安装界面（入门篇）你可能在 Hello World 系列中遇到的问题和解决办法汇总方法与汇总 使用 WiX 创建最简单的安装包过程中可能出现的问题和解决方案汇总 如何查看用 WiX 制作的安装包的日志 如何调试用 WiX 制作的安装包具体问题 用 WiX 制作安装包：设置的 .NET Framework 前置会始终安装，即使目标电脑已经自带或装好 用 WiX Burn 制作托管安装包：出现 0x80070002 错误 用 WiX Burn 制作托管安装包：出现 0x80131508 错误 0x800b0109 - 已处理证书链，但是在不受信任提供程序信任的根证书中终止。基本概念和原则在完成了前面的 Hello World 系列教程后，你需要跑完整个流程才算真正做了一个安装包。然而，由于 WiX 本身的入门并不容易，你可能需要了解一些基本的概念才能更容易地完成整个安装流程。不用担心，这里只会涉及到完成最简流程需要用到的那些概念，更深入的概念我会在其他系列的教程里再说明。// 未完待续… WiX 安装包制作最佳实践：Id、UpgradeCode 应该怎么设置？完成主要安装流程// 未完待续…可供查阅的资料汇总 可在 wxs 中编写的项目引用变量 $(var.ProjectName.Xxx) 系列)其他 WiX Toolset 教程系列 WiX Toolset 安装包制作中级教程参考资料 WiX Toolset v3 Manual Table of Contents WiX Toolset 教程索引页 - 奇葩史 - 博客园 visual studio 2010 - WiX ‘Bundle’ ‘ExePackage’ ‘DetectCondition’ is always false - Stack Overflow" }, { "title": "如何调试 WiX Burn 制作的自定义托管引导程序的 exe 安装包", "url": "/post/how-to-debug-wix-burn-installer.html", "categories": "", "tags": "dotnet, msi, wix", "date": "2021-07-16 16:47:57 +0800", "snippet": "WiX 本身很强大，使用本来也没那么难。奈何 WiX 3 的官方文档可读性极差且长期不更新，于是新手在使用 WiX 制作安装包时极容易出问题，导致制作的安装包各种行为不正常。虽然我写了一系列的 WiX 安装包入门教程来帮助大家避坑，还写了一些常见问题的解决方法，但大家遇到的问题总会比我整理的要多。所以教大家查看日志很多时候，看日志能帮助你快速找到原因。以下是查看日志的方法： 如何查看用 WiX 制作的安装包的日志Debugger.Launch()如果安装过程能执行到你编写的 C# 代码中，那么可以在入口处加上 Debugger.Launch() 来启动调试器。 public class Program : BootstrapperApplication { protected override void Run() {++ if (Environment.GetCommandLineArgs().Contains(&quot;-debug&quot;, StringComparer.OrdinalIgnoreCase))++ {++ Debugger.Launch();++ } // 省略其他启动代码。 } }这里我加上了一个命令行参数的判断，即如果启动安装包 exe 的时候带上了 -debug 参数，那么就启动调试器。（我用一个 - 而不是 -- 或者 / 的原因是 burn 引擎用的就是单个短线。）对比测试如果出现的问题日志上说明不明显，代码也没执行到自定义引导程序部分，那么可以考虑对照正常状态的 WiX 项目替换组件调查。这可以快速将问题范围定位到某个文件甚至是某行代码上。例如在制作 WPF 安装包界面的教程中，我们有四个项目。这个示例已经开源到 GitHub 上了。于是我们可以尝试将出问题的项目中的部分模块替换成这个正常的项目对应部分。当最终能正常工作时，最近替换的模块便最有可能是问题模块。" }, { "title": "用 WiX Burn 制作托管安装包：出现 0x80131508 错误", "url": "/post/wix-managed-bootstrapper-application-error-80131508.html", "categories": "", "tags": "dotnet, msi, wix", "date": "2021-07-16 14:24:33 +0800", "snippet": "使用 WiX 的 Burn 引擎制作自定义托管引导程序的 exe 安装包时，双击生成的安装包没有反应。如果查看日志可以发现有 0x80131508 错误。本文介绍其调查和解决方法。现象双击制作的自定义引导程序的 exe 安装包没有反应，通过查看 Burn 引擎的输出日志可以发现如下关键的错误码：...[BCD8:B4DC][2021-07-16T11:47:32]i000: Loading managed bootstrapper application.[BCD8:B4DC][2021-07-16T11:47:32]e000: Error 0x80131508: Failed to create the managed bootstrapper application.[BCD8:B4DC][2021-07-16T11:47:32]e000: Error 0x80131508: Failed to create UX.[BCD8:B4DC][2021-07-16T11:47:32]e000: Error 0x80131508: Failed to load UX.[BCD8:B4DC][2021-07-16T11:47:32]e000: Error 0x80131508: Failed while running ...[BCD8:B4DC][2021-07-16T11:47:32]e000: Error 0x80131508: Failed to run per-user mode.[BCD8:B4DC][2021-07-16T11:47:32]i007: Exit code: 0x80131508, restarting: No调查通过查询 HRESULT 错误码 0x80131508 可以得知它代表的意思是“INDEXOUTOFRANGE”。啊这……说明是 Burn 引擎出现了内部因为某些原因出现了错误，并且没有正确把错误原因标记出来。然而对我们简单的托管安装包界面来说，更可能是我们自己的某些配置或代码不正确，导致 Burn 引擎内部代码炸掉的。解决这样的错误几乎不具有可调试性。因此，我直接将我偶然发现的原因和解决办法贴出来。参考这篇入门教程中的代码，如果 AssemblyInfo.cs 文件中缺少标记 BootstrapperApplication 类型的特性，那么就会出现此错误。...++ using Microsoft.Tools.WindowsInstallerXml.Bootstrapper;++ using Walterlv.InstallerUI;++ [assembly: BootstrapperApplication(typeof(Program))]...然而呀，官方在教大家写托管引导程序的时候，翻遍了整个文档都没有提醒过要写这个特性！所以特别容易被官方文档带偏，这里记录此文章避免大家踩坑。" }, { "title": "用 WiX 制作安装包：设置的 .NET Framework 前置会始终安装，即使目标电脑已经自带或装好", "url": "/post/wix-burn-always-install-netfx-even-if-already-installed.html", "categories": "", "tags": "dotnet, msi, wix", "date": "2021-07-16 12:08:39 +0800", "snippet": "使用 WiX 的 Burn 引擎制作自定义托管引导程序的 exe 安装包时，你可能会遇到这种情况：明明目标电脑上已经装好了 .NET Framework，但无论如何就是会提示安装，始终不启动自定义的安装界面。现象即使是在开发机上（.NET Framework 已经装好），双击制作的 exe 安装包也依然会提示安装 .NET Framework：如果强行安装，装完也依然不会启动自定义的引导程序。 小提示 这个错误其实非常有误导性！ 看起来不断提示要安装 .NET Framework，会让人误以为是 .NET Framework 的安装判断条件写出了问题，然后朝着 Product.wxs 中的 Condition、Bundle.wxs 中的 InstallCondition、DetectCondition 去调查。然而这是捆绑包中的判断，与 Product.wxs 无关；我们默认用的是 WixNetFxExtension.dll 中的判断，这很靠谱，也不会出问题，所以也与 InstallCondition 和DetectCondition 无关。 正确的调查方法是去看错误日志，看真实的错误原因是什么。当停留在这个“安装 .NET Framework”的界面时，查看 Burn 引擎的输出日志：[14A4:9F04][2021-07-16T11:13:57]i001: Burn v3.11.2.4516, Windows v10.0 (Build 22000: Service Pack 0), path: C:\\Users\\lvyi\\AppData\\Local\\Temp\\{4310ECA0-6A28-4BE6-922D-570EAA81C0CD}\\.cr\\Walterlv.Demo.MainApp.exe[14A4:9F04][2021-07-16T11:13:57]i009: Command Line: &#39;-burn.clean.room=D:\\WIP\\Desktop\\Walterlv.WixInstallerDemo\\Walterlv.Installer.Exe\\bin\\Debug\\Walterlv.Demo.MainApp.exe -burn.filehandle.attached=464 -burn.filehandle.self=460 -l debug.log&#39;[14A4:9F04][2021-07-16T11:13:57]i000: Setting string variable &#39;WixBundleOriginalSource&#39; to value &#39;D:\\WIP\\Desktop\\Walterlv.WixInstallerDemo\\Walterlv.Installer.Exe\\bin\\Debug\\Walterlv.Demo.MainApp.exe&#39;[14A4:9F04][2021-07-16T11:13:57]i000: Setting string variable &#39;WixBundleOriginalSourceFolder&#39; to value &#39;D:\\WIP\\Desktop\\Walterlv.WixInstallerDemo\\Walterlv.Installer.Exe\\bin\\Debug\\&#39;[14A4:9F04][2021-07-16T11:13:57]i000: Setting string variable &#39;WixBundleLog&#39; to value &#39;D:\\WIP\\Desktop\\Walterlv.WixInstallerDemo\\Walterlv.Installer.Exe\\bin\\Debug\\debug.log&#39;[14A4:9F04][2021-07-16T11:13:57]i000: Setting string variable &#39;WixBundleName&#39; to value &#39;Walterlv.Demo.MainApp&#39;[14A4:9F04][2021-07-16T11:13:57]i000: Setting string variable &#39;WixBundleManufacturer&#39; to value &#39;walterlv&#39;[14A4:9F04][2021-07-16T11:13:57]i000: Loading prerequisite bootstrapper application because managed host could not be loaded, error: 0x80070490.[14A4:A444][2021-07-16T11:13:58]i000: Setting numeric variable &#39;WixStdBALanguageId&#39; to value 2052[14A4:A444][2021-07-16T11:13:58]i000: Setting version variable &#39;WixBundleFileVersion&#39; to value &#39;1.0.0.0&#39;[14A4:9F04][2021-07-16T11:13:58]i100: Detect begin, 2 packages[14A4:9F04][2021-07-16T11:13:58]i000: Setting string variable &#39;NETFRAMEWORK45&#39; to value &#39;528449&#39;[14A4:9F04][2021-07-16T11:13:58]i052: Condition &#39;NETFRAMEWORK45 &amp;gt;= 394802&#39; evaluates to true.[14A4:9F04][2021-07-16T11:13:58]i101: Detected package: NetFx462Web, state: Present, cached: None[14A4:9F04][2021-07-16T11:13:58]i101: Detected package: Walterlv.Demo.MainApp.msi, state: Absent, cached: None[14A4:9F04][2021-07-16T11:13:58]i199: Detect complete, result: 0x0调查可以注意到唯一的一行错误：Loading prerequisite bootstrapper application because managed host could not be loaded, error: 0x80070490.加载安装前置的引导程序，因为托管宿主无法被加载，错误代码 0x80070490。所以导致弹出 .NET Framework 安装界面的原因是引导程序无法加载我们的自定义界面，误认为前置没有装好，所以弹出了前置安装界面。查询一下错误码：❯ err 80070490# No results found for hex 0x4c5c75a / decimal 80070490# for hex 0x80070490 / decimal -2147023728 PEER_E_NOT_FOUND p2p.h E_PROP_ID_UNSUPPORTED vfwmsgs.h# The specified property ID is not supported for the# specified property set.%0 WER_E_NOT_FOUND werapi.h DRM_E_NOT_FOUND windowsplayready.h# as an HRESULT: Severity: FAILURE (1), FACILITY_WIN32 (0x7), Code 0x490# for hex 0x490 / decimal 1168 ERROR_NOT_FOUND winerror.h# Element not found.# 5 matches found for &quot;80070490&quot;“Not Found”，并不能给我们带来什么有价值的信息。虽然错误码无法给我们带来有价值的信息，但那句提示至少可以让我们知道问题出在“无法加载托管宿主”这个范围。这可能是两个范围： 我们自定义的 BootstrapperApplication 的第一行代码 Run 之前 我们自定义的 BootstrapperApplication 的第一行代码 Run 之后这很好区分，在 Run 的第一句加上一个 “Debugger.Launch()”，看看再启动安装包的时候是否会弹出调试器选择框即可。 protected override void Run() {++ Debugger.Launch(); }我们就这样试一下，可以发现不会弹出调试器选择框。所以以上的两个范围只能是范围 1。 小提示 实际上按目前的日志输出，已经足以确定是范围 1 了，不过这需要一些先验知识，即托管引导程序能捕获 Run 方法中的所有异常。也就是说无论你的代码怎么写，托管引导程序都能把你引导起来，而不会出现此日志中输出的那样“无法加载托管宿主”。前面这个调查模拟没有此先验知识的情况，你可以从中学习到更多的 Burn MBA（Managed Bootstrapper Application）调试技巧。有哪些东西会在 Run 之前？ BootstrapperCore.config 文件的配置 程序集元数据对于 1，如果你能看出来 BootstrapperCore.config 配置出现了哪些问题更好，看不出来的话可以把现成的例子拿出来对比（例如我在入门教程里写的 DEMO 程序，记得要改项目名）。确保里面的 assemblyName 和 supportedRuntime 属性赋值正确（可参见我入门教程中写的配置和可用值说明）。对于 2，通过实验可以得知程序集元数据出现错误时的错误码不是这个（参见：0x80131508 错误）。于是我们也能得出问题出在 BootstrapperCore.config 配置里。解决可按下面的配置作为参考，将你的配置改到正确（参见我的 WiX 入门教程）：&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;&amp;lt;configuration&amp;gt; &amp;lt;configSections&amp;gt; &amp;lt;sectionGroup name=&quot;wix.bootstrapper&quot; type=&quot;Microsoft.Tools.WindowsInstallerXml.Bootstrapper.BootstrapperSectionGroup, BootstrapperCore&quot;&amp;gt; &amp;lt;section name=&quot;host&quot; type=&quot;Microsoft.Tools.WindowsInstallerXml.Bootstrapper.HostSection, BootstrapperCore&quot; /&amp;gt; &amp;lt;/sectionGroup&amp;gt; &amp;lt;/configSections&amp;gt; &amp;lt;wix.bootstrapper&amp;gt; &amp;lt;host assemblyName=&quot;Walterlv.InstallerUI&quot;&amp;gt; &amp;lt;supportedFramework version=&quot;v4\\Full&quot; /&amp;gt; &amp;lt;/host&amp;gt; &amp;lt;/wix.bootstrapper&amp;gt;&amp;lt;/configuration&amp;gt;另外多说一句，官方文档对 BootstrapperCore.config 的描述非常具有误导性： How To: Install the .NET Framework Using Burn 奇葩史的奇葩事 - [译]：WiX Toolset使用技巧——使用Burn引擎安装.NET Framework官方文档示例的注释中要大家改 host/@assemblyName，但实际上按官方文档的改法改好了就会出现本文所述的错误。参考资料 installation - Wix ExePackage always installs regardless of DetectCondition, InstallCondition, on install, or uninstall - Stack Overflow" }, { "title": "使用 WiX 创建最简单的安装包过程中可能出现的问题和解决方案汇总", "url": "/post/getting-started-with-wix-toolset-the-pit-you-might-step-on.html", "categories": "", "tags": "dotnet, msi, wix", "date": "2021-07-16 11:50:15 +0800", "snippet": "本文是 WiX Toolset 安装包制作入门教程 系列中的番外篇，可前往阅读完整教程。用 WiX 制作安装包还是有些门槛的。如果你没有完全按照我教程中提供的步骤来执行（例如你用了自己的项目名，却在复制关键代码时没有改成自己的），那么极有可能在最终生成安装包后无法运行。本文记录一些跟着教程做时可能遇到的常见问题，帮助你在遇到问题后能及时找到解决方案。如果看完还没有解决你的问题，欢迎留言探讨，也可以尝试 调试 WiX 制作的安装包。无法启动 exe 安装包 用 WiX Burn 制作托管安装包：出现 0x80070002 错误 用 WiX Burn 制作托管安装包：出现 0x80131508 错误.NET Framework 始终会安装 用 WiX 制作安装包：设置的 .NET Framework 前置会始终安装，即使目标电脑已经自带或装好" }, { "title": "用 WiX Burn 制作托管安装包：出现 0x80070002 错误", "url": "/post/wix-managed-bootstrapper-application-error-80070002.html", "categories": "", "tags": "dotnet, msi, wix", "date": "2021-07-16 10:48:59 +0800", "snippet": "使用 WiX 的 Burn 引擎制作自定义托管引导程序的 exe 安装包时，双击生成的安装包没有反应。如果查看日志可以发现有 0x80070002 错误。本文介绍其调查和解决方法。现象双击制作的自定义引导程序的 exe 安装包没有反应，通过查看 Burn 引擎的输出日志可以发现如下关键的错误码：...[1874:8D8C][2021-07-15T19:28:29]i000: Loading managed bootstrapper application.[1874:8D8C][2021-07-15T19:28:29]e000: Error 0x80070002: Failed to create the managed bootstrapper application.[1874:8D8C][2021-07-15T19:28:29]e000: Error 0x80070002: Failed to create UX.[1874:8D8C][2021-07-15T19:28:29]e000: Error 0x80070002: Failed to load UX.[1874:8D8C][2021-07-15T19:28:29]e000: Error 0x80070002: Failed while running ...[1874:8D8C][2021-07-15T19:28:29]e000: Error 0x80070002: Failed to run per-user mode.[1874:8D8C][2021-07-15T19:28:29]i007: Exit code: 0x80070002, restarting: No调查通过查询 HRESULT 错误码 0x80070002 可以得知它代表的意思是“文件不存在”。❯ err 0x80070002# for hex 0x80070002 / decimal -2147024894 COR_E_FILENOTFOUND corerror.h DIERR_NOTFOUND dinput.h DIERR_OBJECTNOTFOUND dinput.h STIERR_OBJECTNOTFOUND stierr.h DRM_E_WIN32_FILE_NOT_FOUND windowsplayready.h E_FILE_NOT_FOUND wpc.h# as an HRESULT: Severity: FAILURE (1), FACILITY_NTWIN32 (0x7), Code 0x2# for hex 0x2 / decimal 2 STATUS_WAIT_2 ntstatus.h# as an HRESULT: Severity: FAILURE (1), FACILITY_WIN32 (0x7), Code 0x2 ERROR_FILE_NOT_FOUND winerror.h# The system cannot find the file specified.# 8 matches found for &quot;0x80070002&quot;所以到底是什么不存在呢？这篇入门教程中，涉及到找不到托管引导程序（WiX 官方喜欢称之为 MBA，Managed Bootstrapper Application）的地方可能有这些： Bundle.wxs 文件中将托管引导程序加入到负载的地方 BootstrapperCore.config 文件中，设置的 assemblyName 属性对于 1，如果加入到负载时文件不存在，那么这个 Bundle.wxs 所在的项目都无法编译通过，所以 1 原因可以排除。那么只剩下原因 2 了，如果发现其名称与实际程序集名称不一样（例如改了项目名，或者从教程中复制了代码却没有对应改成自己项目中的名字），那么原因就是这个了。解决修改 BootstrapperCore.config 文件（在这篇教程中是 App.config 文件），将 assemblyName 的值改为正确的托管引导程序（MBA）的名字。" }, { "title": "如何查看用 WiX 制作的安装包的日志", "url": "/post/how-to-view-wix-burn-installer-logs.html", "categories": "", "tags": "dotnet, msi, wix", "date": "2021-07-15 20:18:52 +0800", "snippet": "如果你使用 WiX 制作安装包，并且遇到了问题，一定需要一个趁手的调试方案。本文介绍如何查看 WiX 制作的安装包的日志。WiX 使用 Burn 引擎来制作 exe 捆绑包，默认情况下 Burn 引擎使用自带的安装界面来执行安装。Burn 引擎提供了自定义引导程序的功能，于是你可以利用 Burn 引擎做出自己的 UI 来。比如 用 WPF 来制作安装包界面。因此，我们有通用的方法来查看安装日志，只需要在启动安装程序时传入参数：&amp;gt; .\\Walterlv.Demo.MainApp.exe -l &quot;debug.log&quot;其中，Walterlv.Demo.MainApp.exe 是我在 WiX 入门教程系列中使用的安装包名。-l &quot;debug.log&quot; 表示在当前目录下使用“debug.log”文件记录日志。以下是一个成功运行的自定义捆绑包的日志：[476C:2F20][2021-07-15T19:35:43]i001: Burn v3.11.2.4516, Windows v10.0 (Build 22000: Service Pack 0), path: C:\\Users\\lvyi\\AppData\\Local\\Temp\\{AC43FA57-2BC7-45FA-8A6C-B8ADABB376C7}\\.cr\\Walterlv.Demo.MainApp.exe[476C:2F20][2021-07-15T19:35:44]i009: Command Line: &#39;-burn.clean.room=D:\\WIP\\Desktop\\Walterlv.WixInstallerDemo\\Walterlv.Installer.Exe\\bin\\Debug\\Walterlv.Demo.MainApp.exe -burn.filehandle.attached=684 -burn.filehandle.self=692 -l debug.log&#39;[476C:2F20][2021-07-15T19:35:44]i000: Setting string variable &#39;WixBundleOriginalSource&#39; to value &#39;D:\\WIP\\Desktop\\Walterlv.WixInstallerDemo\\Walterlv.Installer.Exe\\bin\\Debug\\Walterlv.Demo.MainApp.exe&#39;[476C:2F20][2021-07-15T19:35:44]i000: Setting string variable &#39;WixBundleOriginalSourceFolder&#39; to value &#39;D:\\WIP\\Desktop\\Walterlv.WixInstallerDemo\\Walterlv.Installer.Exe\\bin\\Debug\\&#39;[476C:2F20][2021-07-15T19:35:44]i000: Setting string variable &#39;WixBundleLog&#39; to value &#39;D:\\WIP\\Desktop\\Walterlv.WixInstallerDemo\\Walterlv.Installer.Exe\\bin\\Debug\\debug.log&#39;[476C:2F20][2021-07-15T19:35:44]i000: Setting string variable &#39;WixBundleName&#39; to value &#39;Walterlv.Demo.MainApp&#39;[476C:2F20][2021-07-15T19:35:44]i000: Setting string variable &#39;WixBundleManufacturer&#39; to value &#39;walterlv&#39;[476C:2F20][2021-07-15T19:35:44]i000: Loading managed bootstrapper application.[476C:2F20][2021-07-15T19:35:44]i000: Creating BA thread to run asynchronously.[476C:A250][2021-07-15T19:35:44]i000: Running the Walterlv.InstallerUI.[476C:A250][2021-07-15T19:35:59]i000: Exiting the Walterlv.InstallerUI.[476C:A250][2021-07-15T19:35:59]i000: The Walterlv.InstallerUI has exited.[476C:2F20][2021-07-15T19:35:59]i500: Shutting down, exit code: 0x0[476C:2F20][2021-07-15T19:35:59]i410: Variable: WixBundleAction = 5[476C:2F20][2021-07-15T19:35:59]i410: Variable: WixBundleElevated = 0[476C:2F20][2021-07-15T19:35:59]i410: Variable: WixBundleLog = D:\\WIP\\Desktop\\Walterlv.WixInstallerDemo\\Walterlv.Installer.Exe\\bin\\Debug\\debug.log[476C:2F20][2021-07-15T19:35:59]i410: Variable: WixBundleManufacturer = walterlv[476C:2F20][2021-07-15T19:35:59]i410: Variable: WixBundleName = Walterlv.Demo.MainApp[476C:2F20][2021-07-15T19:35:59]i410: Variable: WixBundleOriginalSource = D:\\WIP\\Desktop\\Walterlv.WixInstallerDemo\\Walterlv.Installer.Exe\\bin\\Debug\\Walterlv.Demo.MainApp.exe[476C:2F20][2021-07-15T19:35:59]i410: Variable: WixBundleOriginalSourceFolder = D:\\WIP\\Desktop\\Walterlv.WixInstallerDemo\\Walterlv.Installer.Exe\\bin\\Debug\\[476C:2F20][2021-07-15T19:35:59]i410: Variable: WixBundleProviderKey = {87942d31-3870-42ca-8100-4e381772c7d6}[476C:2F20][2021-07-15T19:35:59]i410: Variable: WixBundleSourceProcessFolder = D:\\WIP\\Desktop\\Walterlv.WixInstallerDemo\\Walterlv.Installer.Exe\\bin\\Debug\\[476C:2F20][2021-07-15T19:35:59]i410: Variable: WixBundleSourceProcessPath = D:\\WIP\\Desktop\\Walterlv.WixInstallerDemo\\Walterlv.Installer.Exe\\bin\\Debug\\Walterlv.Demo.MainApp.exe[476C:2F20][2021-07-15T19:35:59]i410: Variable: WixBundleTag = [476C:2F20][2021-07-15T19:35:59]i410: Variable: WixBundleUILevel = 4[476C:2F20][2021-07-15T19:35:59]i410: Variable: WixBundleVersion = 1.0.0.0[476C:2F20][2021-07-15T19:35:59]i007: Exit code: 0x0, restarting: No" }, { "title": "用 WiX 制作安装包：制作 WPF 安装包界面（入门篇）", "url": "/post/getting-started-with-wix-toolset-create-a-wpf-installer-ui.html", "categories": "", "tags": "dotnet, msi, wix", "date": "2021-07-15 19:52:35 +0800", "snippet": "本文是 WiX Toolset 安装包制作入门教程 系列中的一篇，可前往阅读完整教程。前面我们制作完成了一个可自动安装 .NET Framework 依赖的 exe 安装包，下面我们将学习制作自己的安装界面。本文使用 WPF 制作安装包界面。本文准备做什么？本文将继续在前一篇文章的解决方案基础上继续学习。我们将做这些事情： 创建一个 WPF 项目，用来做安装包的 UI 处理一下这个 WPF 项目，使其对接 WiX 的捆绑包 修改用来生成 exe 格式安装包的捆绑包项目，使其接入 WPF UI 项目创建 WPF 项目为我们的解决方案新建一个 WPF 项目。创建好后，我们需要双击这个 WPF 项目名，以编辑其项目文件，把框架改为 .NET Framework。-- &amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt;++ &amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk.WindowsDesktop&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;OutputType&amp;gt;WinExe&amp;lt;/OutputType&amp;gt;-- &amp;lt;TargetFramework&amp;gt;net5.0-windows&amp;lt;/TargetFramework&amp;gt;++ &amp;lt;TargetFramework&amp;gt;net462&amp;lt;/TargetFramework&amp;gt; &amp;lt;UseWPF&amp;gt;true&amp;lt;/UseWPF&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;/Project&amp;gt;为了后面能适配 WiX 捆绑包，我们先建一个 Program.cs 文件作为启动文件。（名字随便取，我用 Program 只是为了体现出它是一个入口。）在 Program.cs 里写一个 Main 方法替代 App.xaml 自动生成的 Main：namespace Walterlv.InstallerUI{ public class Program { [STAThread] public static int Main(string[] args) { // 这里的代码仅为调试使用，在最终的项目中无任何用途。 var app = new App(); return app.Run(); } }}然后，设置此 WPF UI 项目的属性，将启动对象修改成我们新建的 Program 类：因为 App.xaml 里面有实质上的有效代码（StartupUri=&quot;MainWindow.xaml&quot;），所以我们需要调用 InitializeComponent 来使这段代码生效。打开 App.xaml.cs 文件，我们加一个构造函数： public partial class App : Application {++ public App()++ {++ InitializeComponent();++ } }至此，我们便能直接启动我们的 Walterlv.InstallerUI 项目了。这对后续的调试很有用。 小提示 实际上，这个 WPF UI 项目本应该做成 dll 而不是 exe，然后 App.xaml 和 App.xaml.cs 应该被删掉。这样，这个 WPF UI 项目就是一个纯 UI 库，用于后面被捆绑包调用。 但是，为了让这个项目与普通的 WPF 应用程序项目目录结构一样，也为了后续方便直接从 Visual Studio 启动调试，所以我刻意做成一个 exe，并保留了 App.xaml 和 App.xaml.cs 文件。将 WPF UI 项目对接 WiX 捆绑包1. 添加“BootstrapperCore.dll”引用现在，为此 WPF UI 项目添加“BootstrapperCore.dll”引用： 在项目的“依赖项”上右键，“添加引用…”； 点击“浏览…”； 找到 Wix Toolset 的安装目录（如果没改，那么应该在 C:\\Program Files (x86)\\WiX Toolset v3.11\\SDK 这样的地方），找到 BootstrapperCore.dll 文件选中然后添加； 点击“确定”。注意，WPF 项目并不像 WiX 项目一样针对引用的绝对路径进行了属性引用处理，因此我们需要自己来做这件事。双击 WPF UI 的项目名称以修改项目文件，将绝对路径改成环境变量引用 $(WIX)（注意这里引用的是环境变量，而不是之前的 MSBuild 属性，虽然写法一模一样）： &amp;lt;ItemGroup&amp;gt; &amp;lt;Reference Include=&quot;BootstrapperCore&quot;&amp;gt;-- &amp;lt;HintPath&amp;gt;C:\\Program Files (x86)\\WiX Toolset v3.11\\SDK\\BootstrapperCore.dll&amp;lt;/HintPath&amp;gt;++ &amp;lt;HintPath&amp;gt;$(WIX)\\SDK\\BootstrapperCore.dll&amp;lt;/HintPath&amp;gt; &amp;lt;/Reference&amp;gt; &amp;lt;/ItemGroup&amp;gt; 小提示 本教程前面为了不引入过多的复杂度，没有使用 NuGet 包中的工具集而是单独下载了；所以实际上大家已经有了现成的工具集可供引用，我们才能使用此方法修改引用路径。并且此方法也能确保 WiX 打包项目使用的工具集版本和 WPF UI 项目使用的工具集版本一致。然而使用 WiX 的 NuGet 包有额外的好处，可以使得团队成员无需每人单独安装 Wix 工具集即可完整编译安装包。不过这涉及到一些 NuGet 相关的高级操作，我在其他博客里有说到。为了保证教程依然便于入门，所以我使用单独安装 WiX 工具集的方式来讲解。如果大家感兴趣使用 NuGet 的方式来完成整个打包项目的构建，替代现在单独安装的方式，我可以单独再写一篇高级教程。2. 实现自己的引导程序（Bootstrapper）修改 Program.cs 文件，我们要实现自己的引导程序（Bootstrapper）：++ using Microsoft.Tools.WindowsInstallerXml.Bootstrapper; namespace Walterlv.InstallerUI {-- public class Program++ public class Program : BootstrapperApplication { private static int Main(string[] args) { // 这里的代码仅为调试使用，在最终的项目中无任何用途。 var app = new App(); return app.Run(); }++++ protected override void Run()++ {++ // 稍后要在这里添加安装流程控制。++ } } }在引导程序的入口代码（就是 Run 方法）里，我们要实现基本的安装流程控制。最重要的，当然是向本文第一节那样，把 App 跑起来。++ using System;++ using System.Reflection;++ using System.Windows;... protected override void Run() {-- // 稍后要在这里添加安装流程控制。++ Engine.Log(LogLevel.Standard, &quot;Running the Walterlv.InstallerUI.&quot;);++ try++ {++ LaunchUI();++ Engine.Log(LogLevel.Standard, &quot;Exiting the Walterlv.InstallerUI.&quot;);++ Engine.Quit(0);++ }++ catch (Exception ex)++ {++ Engine.Log(LogLevel.Error, $&quot;The Walterlv.InstallerUI is failed: {ex}&quot;);++ Engine.Quit(-1);++ }++ finally++ {++ Engine.Log(LogLevel.Standard, &quot;The Walterlv.InstallerUI has exited.&quot;);++ } }++++ private int LaunchUI()++ {++ // 设置 WPF Application 的资源程序集，避免 WPF 自己找不到。++ Application.ResourceAssembly = Assembly.GetExecutingAssembly();++++ // 正常启动 WPF Application。++ var app = new App();++ return app.Run();++ }...在这段代码中，我们做了这些事情： 在 Run 方法中全程记录日志（使用 BootstrapperApplication 基类 Engine 属性的 Log 方法来记）； 做了全局异常处理（避免因出现未知异常导致安装程序无法退出又看不到界面）； 正常退出安装过程（通过调用 Engine.Quit）； 设置 WPF 资源程序集（默认情况下 WPF 会去入口程序集中找，但在 WiX 引导启动后入口程序集为 null，所以我们需要手动指定资源程序集为本程序集）； 正常启动 WPF 的 Application。接下来，在 AssemblyInfo.cs 文件中，我们将 Program 类标记为自定义的引导程序：...++ using Microsoft.Tools.WindowsInstallerXml.Bootstrapper;++ using Walterlv.InstallerUI;++ [assembly: BootstrapperApplication(typeof(Program))]...至此，WPF UI 项目的纯 WPF 代码部分已经完成。3. 添加 BootstrapperCore.config 文件WiX 要引导到我们自己写的 WPF UI 上启动需要一个关键的配置文件 BootstrapperCore.config。在最终生成的捆绑包中，这个配置文件必须严格使用此名称。一个典型的 BootstrapperCore.config 文件的完整内容如下：&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;&amp;lt;configuration&amp;gt; &amp;lt;configSections&amp;gt; &amp;lt;sectionGroup name=&quot;wix.bootstrapper&quot; type=&quot;Microsoft.Tools.WindowsInstallerXml.Bootstrapper.BootstrapperSectionGroup, BootstrapperCore&quot;&amp;gt; &amp;lt;section name=&quot;host&quot; type=&quot;Microsoft.Tools.WindowsInstallerXml.Bootstrapper.HostSection, BootstrapperCore&quot; /&amp;gt; &amp;lt;/sectionGroup&amp;gt; &amp;lt;/configSections&amp;gt; &amp;lt;startup useLegacyV2RuntimeActivationPolicy=&quot;true&quot;&amp;gt; &amp;lt;supportedRuntime version=&quot;v4.0&quot; sku=&quot;.NETFramework,Version=v4.6.2&quot; /&amp;gt; &amp;lt;/startup&amp;gt; &amp;lt;wix.bootstrapper&amp;gt; &amp;lt;host assemblyName=&quot;Walterlv.InstallerUI&quot;&amp;gt; &amp;lt;supportedFramework version=&quot;v4\\Full&quot; /&amp;gt; &amp;lt;/host&amp;gt; &amp;lt;/wix.bootstrapper&amp;gt;&amp;lt;/configuration&amp;gt;这个文件并不是 WPF UI 项目必须的文件，却是最终捆绑包所必须的文件。所以这个文件即可放到 WPF UI 项目中，也可放到 exe 的打包项目中。但是我们可以留意到 &amp;lt;startup&amp;gt; 元素的全部内容跟一个标准 .NET Framework 应用程序的配置文件中的 &amp;lt;startup&amp;gt; 元素一模一样，所以实际上我推荐把此文件放到 WPF UI 项目中，以提升代码复用性。于是，我们来创建这个文件： 在 WPF UI 项目上右键，“添加”，“新建项…”； 在模板中找到“应用程序配置文件”，然后点“添加”。通过模板生成的文件里有个空的 configuration 元素，我们可以无视；然后将以下内容复制到你的 App.config 文件中：&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;&amp;lt;configuration&amp;gt; &amp;lt;configSections&amp;gt; &amp;lt;sectionGroup name=&quot;wix.bootstrapper&quot; type=&quot;Microsoft.Tools.WindowsInstallerXml.Bootstrapper.BootstrapperSectionGroup, BootstrapperCore&quot;&amp;gt; &amp;lt;section name=&quot;host&quot; type=&quot;Microsoft.Tools.WindowsInstallerXml.Bootstrapper.HostSection, BootstrapperCore&quot; /&amp;gt; &amp;lt;/sectionGroup&amp;gt; &amp;lt;/configSections&amp;gt; &amp;lt;wix.bootstrapper&amp;gt; &amp;lt;host assemblyName=&quot;Walterlv.InstallerUI&quot;&amp;gt; &amp;lt;supportedFramework version=&quot;v4\\Full&quot; /&amp;gt; &amp;lt;/host&amp;gt; &amp;lt;/wix.bootstrapper&amp;gt;&amp;lt;/configuration&amp;gt;请特别注意 1：请加上述 assemblyName 的值改成你的程序集名称（注意是程序集名称，不一定等于项目名）。请注意 2，相比于 BootstrapperCore.config 的典型内容，我们删除了 &amp;lt;startup&amp;gt; 元素，这是因为 .NET Framework 生成应用程序配置文件时，此元素会自动生成。还请注意 3，无论你使用 .NET Framework 4.x 的哪个版本，wix.bootstrapper-&amp;gt;host-&amp;gt;supportedFramework 中的 version 值请始终设为 v4\\Full！不要设置成任何类似 v4.6.2、v4.8、.NETFramework,Version=v4.5 之类的值。虽然官方文档有提到可以设置成 v3.5、v4/Client 之类，但那会增加 WiX 打包项目配置的复杂程度，完成基本的打包需要配置更多（例如编写安装 .NET Framework 3.5 的代码）。至此，WPF UI 项目的所有代码已全部完成。在捆绑包项目里接入 WPF UI 项目现在回到我们的 Bundle.wxs 文件，我们需要做四件事情： 设置捆绑包打包项目引用 WPF UI 项目； 将捆绑包引导程序设置成托管引导程序（ManagedBootstrapperApplicationHost）； 将此 WPF UI 作为捆绑包负载放入捆绑包中； 将前面编写的 BootstrapperCore.config 文件作为捆绑包负载放入捆绑包中。还是像之前一样添加项目引用：接下来我们一次性把对 Bundle.wxs 的所有改变代代码贴到下面：-- &amp;lt;BootstrapperApplicationRef Id=&quot;WixStandardBootstrapperApplication.RtfLicense&quot; /&amp;gt;++ &amp;lt;BootstrapperApplicationRef Id=&quot;ManagedBootstrapperApplicationHost&quot;&amp;gt;++ &amp;lt;Payload Name=&quot;BootstrapperCore.config&quot; SourceFile=&quot;$(var.Walterlv.InstallerUI.TargetDir)\\$(var.Walterlv.InstallerUI.TargetFileName).config&quot;/&amp;gt;++ &amp;lt;Payload SourceFile=&quot;$(var.Walterlv.InstallerUI.TargetPath)&quot; /&amp;gt;++ &amp;lt;/BootstrapperApplicationRef&amp;gt;解读： 我们把 BootstrapperApplicationRef 的 Id 换成了 ManagedBootstrapperApplicationHost（含义为将引导程序引用的 Id 设置为托管引导程序宿主）。 我们把 WPF UI 项目中生成的配置文件用 BootstrapperCore.config 这个名字放入到了负载中。（注意，WPF UI 项目中的 App.config 编译完成后生成的文件名为“程序集名.config”，在本教程中，为“Walterlv.InstallerUI.exe.config”，而我们通过引用项目变量的方式避免 WPF UI 项目的修改对这里的代码造成影响。） 我们把 WPF UI 项目中生成的文件加入到了负载中。（在本教程中，是“Walterlv.InstallerUI.exe”。另外，如果你的 WPF UI 项目有依赖的 dll，请一并在这里加入到负载，方法是依次写多个 &amp;lt;Payload&amp;gt; 元素，将依赖的 dll 设置到 SourceFile 属性中。）至此，拥有 WPF UI 的最简单的 exe 安装包全部完成，你可以开始调试体验了。测试效果现在编译 EXE 项目，然后双击运行看一下。如果发现无法运行，请前往此篇文章调试和解决问题： 使用 WiX 创建最简单的安装包过程中可能出现的问题和解决方案汇总如果可以正常运行，那么恭喜你，完成了 WiX 安装包入门教程的 Hello World 部分，可以进阶到入门教程的后续内容了。请回到目录： WiX Toolset 安装包制作入门教程运行效果：关闭这个界面后，安装程序也将退出。附源代码附上必要的源码，避免你在阅读教程时因模板文件的版本差异造成一些意料之外的问题。由于本文最终得到的源码较多，所以也同时放了一份到 GitHub 上： walterlv/Walterlv.WixInstallerDemo at 1b6600bb694c593894fc20cea76154b61ccf0c1fBundle.wxs&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;Wix xmlns=&quot;http://schemas.microsoft.com/wix/2006/wi&quot;&amp;gt; &amp;lt;Bundle Name=&quot;Walterlv.Demo.MainApp&quot; Version=&quot;1.0.0.0&quot; Manufacturer=&quot;walterlv&quot; UpgradeCode=&quot;528f80ca-a8f5-4bd4-8131-59fdcd69a411&quot;&amp;gt; &amp;lt;BootstrapperApplicationRef Id=&quot;ManagedBootstrapperApplicationHost&quot;&amp;gt; &amp;lt;Payload SourceFile=&quot;$(var.Walterlv.InstallerUI.TargetPath)&quot; /&amp;gt; &amp;lt;Payload Name=&quot;BootstrapperCore.config&quot; SourceFile=&quot;$(var.Walterlv.InstallerUI.TargetDir)\\$(var.Walterlv.InstallerUI.TargetFileName).config&quot;/&amp;gt; &amp;lt;/BootstrapperApplicationRef&amp;gt; &amp;lt;Chain&amp;gt; &amp;lt;PackageGroupRef Id=&quot;NetFx462Web&quot;/&amp;gt; &amp;lt;MsiPackage Compressed=&quot;yes&quot; SourceFile=&quot;$(var.Walterlv.Installer.Msi.TargetPath)&quot;/&amp;gt; &amp;lt;/Chain&amp;gt; &amp;lt;/Bundle&amp;gt;&amp;lt;/Wix&amp;gt;App.config&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;&amp;lt;configuration&amp;gt; &amp;lt;configSections&amp;gt; &amp;lt;sectionGroup name=&quot;wix.bootstrapper&quot; type=&quot;Microsoft.Tools.WindowsInstallerXml.Bootstrapper.BootstrapperSectionGroup, BootstrapperCore&quot;&amp;gt; &amp;lt;section name=&quot;host&quot; type=&quot;Microsoft.Tools.WindowsInstallerXml.Bootstrapper.HostSection, BootstrapperCore&quot; /&amp;gt; &amp;lt;/sectionGroup&amp;gt; &amp;lt;/configSections&amp;gt; &amp;lt;wix.bootstrapper&amp;gt; &amp;lt;host assemblyName=&quot;Walterlv.InstallerUI&quot;&amp;gt; &amp;lt;supportedFramework version=&quot;v4\\Full&quot; /&amp;gt; &amp;lt;/host&amp;gt; &amp;lt;/wix.bootstrapper&amp;gt;&amp;lt;/configuration&amp;gt;App.xaml&amp;lt;Application x:Class=&quot;Walterlv.InstallerUI.App&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:local=&quot;clr-namespace:Walterlv.InstallerUI&quot; StartupUri=&quot;MainWindow.xaml&quot;&amp;gt; &amp;lt;Application.Resources&amp;gt; &amp;lt;/Application.Resources&amp;gt;&amp;lt;/Application&amp;gt;App.xaml.csusing System;using System.Collections.Generic;using System.Configuration;using System.Data;using System.Linq;using System.Threading.Tasks;using System.Windows;namespace Walterlv.InstallerUI{ /// &amp;lt;summary&amp;gt; /// Interaction logic for App.xaml /// &amp;lt;/summary&amp;gt; public partial class App : Application { public App() { InitializeComponent(); } }}AssemblyInfo.csusing System.Windows;using Microsoft.Tools.WindowsInstallerXml.Bootstrapper;using Walterlv.InstallerUI;[assembly: BootstrapperApplication(typeof(Program))][assembly: ThemeInfo( ResourceDictionaryLocation.None, //where theme specific resource dictionaries are located //(used if a resource is not found in the page, // or application resource dictionaries) ResourceDictionaryLocation.SourceAssembly //where the generic resource dictionary is located //(used if a resource is not found in the page, // app, or any theme specific resource dictionaries))]Program.csusing System;using System.Diagnostics;using System.Reflection;using System.Windows;using Microsoft.Tools.WindowsInstallerXml.Bootstrapper;namespace Walterlv.InstallerUI{ public class Program : BootstrapperApplication { [STAThread] public static int Main(string[] args) { // 这里的代码仅为调试使用，在最终的项目中无任何用途。 var app = new App(); return app.Run(); } protected override void Run() { Engine.Log(LogLevel.Standard, &quot;Running the Walterlv.InstallerUI.&quot;); try { LaunchUI(); Engine.Log(LogLevel.Standard, &quot;Exiting the Walterlv.InstallerUI.&quot;); Engine.Quit(0); } catch (Exception ex) { Engine.Log(LogLevel.Error, $&quot;The Walterlv.InstallerUI is failed: {ex}&quot;); Engine.Quit(-1); } finally { Engine.Log(LogLevel.Standard, &quot;The Walterlv.InstallerUI has exited.&quot;); } } private int LaunchUI() { // 设置 WPF Application 的资源程序集，避免 WPF 自己找不到。 Application.ResourceAssembly = Assembly.GetExecutingAssembly(); // 正常启动 WPF Application。 var app = new App(); return app.Run(); } }}" }, { "title": "用 WiX 制作安装包：为 WiX 制作的 msi 安装包添加 .NET Framework 环境检查", "url": "/post/getting-started-with-wix-toolset-msi-detect-net-framework.html", "categories": "", "tags": "dotnet, msi, wix", "date": "2021-07-15 19:46:48 +0800", "snippet": "本文是 WiX Toolset 安装包制作入门教程 系列中的一篇，可前往阅读完整教程。前面我们制作完成了一个简单的 msi 安装包。如果我们要安装的程序运行需要 .NET Framework 环境，那么也可以先进行 .NET Framework 版本检查。本文将指导你在 msi 安装前检查 .NET Framework 的版本。本文基于前一篇文章已经建好的项目继续： 用 WiX 制作安装包：创建一个简单的 msi 安装包添加 WixNetFxExtension 引用 在 msi 安装包项目的“Reference”上右键，“添加引用…”； 在打开的“Add Reference”窗口中确保选中的是“浏览”标签，然后在查找范围中找到 Wix Toolset 的安装目录（如果没改，那么应该在 C:\\Program Files (x86)\\WiX Toolset v3.11\\bin 这样的地方）； 在文件列表中找到“WixNetFxExtension.dll”； 点击“添加”； 点击“确定”。 小提示 你不用担心绝对路径问题。 虽然我们前面选择的 C:\\Program Files (x86)\\WiX Toolset v3.11\\bin 看起来是个绝对路径，但实际上在 wixproj 项目里记录的是一个属性引用，因此可以很容易在团队成员之间共享和跨版本迁移。 如下是 Walterlv.Installer.Msi.wixproj 项目文件中对 WixNetFxExtension 的引用代码： &amp;lt;WixExtension Include=&quot;WixNetFxExtension&quot;&amp;gt; &amp;lt;HintPath&amp;gt;$(WixExtDir)\\WixNetFxExtension.dll&amp;lt;/HintPath&amp;gt; &amp;lt;Name&amp;gt;WixNetFxExtension&amp;lt;/Name&amp;gt;&amp;lt;/WixExtension&amp;gt; 添加完 WixNetFxExtension 的引用后，还需要把它的命名空间添加到 Product.wxs 中。打开 Product.wxs 文件，在里面添加一行：-- &amp;lt;Wix xmlns=&quot;http://schemas.microsoft.com/wix/2006/wi&quot;&amp;gt;++ &amp;lt;Wix xmlns=&quot;http://schemas.microsoft.com/wix/2006/wi&quot; xmlns:netfx=&quot;http://schemas.microsoft.com/wix/NetFxExtension&quot;&amp;gt;注意，添加此命名空间不是必要操作，因为本教程后续没有用到此命名空间。编辑 Product.wxs现在，我们需要编辑 Product.wxs 文件。做两件事情： 得知当前系统环境是否已具备 .NET Framework 某版本； 根据判断结果决定此 MSI 包是否能被安装。 小提示 MSI 包只能判断 .NET Framework 是否存在，无法在不存在时执行 .NET Framework 的安装操作。如果需要安装 .NET Framework，你需要继续阅读本教程系列的 exe 打包部分。判断 .NET Framework 是否已满足要求因为我们已经引用了 WixNetFxExtension.dll，那里面已经写好了 .NET Framework 各版本是否存在的判断逻辑，所以我们只需要引用一下它的判断结果就好了。在 WiX 的配置文件 wxs 里，引用一个属性的方法是使用 &amp;lt;PropertyRef&amp;gt; 元素。所以，我们在 Product.wxs 里添加这样的一行： &amp;lt;Package InstallerVersion=&quot;200&quot; Compressed=&quot;yes&quot; InstallScope=&quot;perMachine&quot; /&amp;gt;++ &amp;lt;PropertyRef Id=&quot;WIX_IS_NETFRAMEWORK_462_OR_LATER_INSTALLED&quot;/&amp;gt;++ &amp;lt;MajorUpgrade DowngradeErrorMessage=&quot;A newer version of [ProductName] is already installed.&quot; /&amp;gt;注意： &amp;lt;PropertyRef&amp;gt; 元素必须是 &amp;lt;Product&amp;gt; 元素的直接子级； &amp;lt;Package&amp;gt; 元素必须是 &amp;lt;Product&amp;gt; 元素的第一个子级（也就是说，&amp;lt;PropertyRef&amp;gt; 必须在 &amp;lt;Package&amp;gt; 的后面）。决定此 MSI 包是否能被安装紧接在刚刚那句的后面，我们再添加一句： &amp;lt;PropertyRef Id=&quot;WIX_IS_NETFRAMEWORK_462_OR_LATER_INSTALLED&quot;/&amp;gt;++ &amp;lt;Condition Message=&quot;This application requires .NET Framework 4.6.2. Please install the .NET Framework then run this installer again.&quot;&amp;gt;++ &amp;lt;![CDATA[WIX_IS_NETFRAMEWORK_462_OR_LATER_INSTALLED]]&amp;gt;++ &amp;lt;/Condition&amp;gt;++ &amp;lt;MajorUpgrade DowngradeErrorMessage=&quot;A newer version of [ProductName] is already installed.&quot; /&amp;gt;这句话的意思是： 此 MSI 包安装需要满足指定条件 中间的判断条件我们用了 &amp;lt;![CDATA[ 和 ]]&amp;gt; 包裹起来了，避免判断条件中出现了一些会破坏 XML 语法的字符（如 &amp;lt; &amp;gt; 等）出现导致意外的问题（但实际上在本例中，我们只用了字母和下划线，所以你也可以直接写 WIX_IS_NETFRAMEWORK_462_OR_LATER_INSTALLED）； 如果不满足指定条件，则弹出提示信息，在 Message 属性中指定不满足条件时要弹出的信息。不过，考虑到在卸载程序时无需检查 .NET Framework（反正也不会再运行了），所以我们可以在判断条件里加上 OR： &amp;lt;Condition Message=&quot;This application requires .NET Framework 4.6.2. Please install the .NET Framework then run this installer again.&quot;&amp;gt;-- &amp;lt;![CDATA[WIX_IS_NETFRAMEWORK_462_OR_LATER_INSTALLED]]&amp;gt;++ Installed OR WIX_IS_NETFRAMEWORK_462_OR_LATER_INSTALLED &amp;lt;/Condition&amp;gt;因为我们的判断条件里没有使用到 XML 特殊字符，所以我刻意删掉了 &amp;lt;![CDATA[ 和 ]]&amp;gt; 以提升可读性。有的团队为避免出错要求强制加上此包裹，有的团队为了提升可读性建议如无必要则不要加上包裹。你也可以定义你的团队规范。Installed 属性表示当前此产品是否已安装。也就是说新的判断条件的意思是：如果当前产品已安装，或者 .NET Framework 已安装有 4.6.2 或更高版本，则满足安装条件，准许安装，否则弹出错误提示。可供判断的 .NET Framework 版本WiX 已开源，其中 wix3 的代码在这里： wixtoolset/wix3: WiX Toolset v3.x在 /src/ext/NetFxExtension/wixlib 目录下有已定义好的各种 .NET Framework 版本的判断逻辑。我整理成下表，方便大家根据自己的需要查阅： .NET Framework 版本 对应判断属性 4.8 WIX_IS_NETFRAMEWORK_48_OR_LATER_INSTALLED 4.7.2 WIX_IS_NETFRAMEWORK_472_OR_LATER_INSTALLED 4.7.1 WIX_IS_NETFRAMEWORK_471_OR_LATER_INSTALLED 4.7 WIX_IS_NETFRAMEWORK_47_OR_LATER_INSTALLED 4.6.2 WIX_IS_NETFRAMEWORK_462_OR_LATER_INSTALLED 4.6.1 WIX_IS_NETFRAMEWORK_461_OR_LATER_INSTALLED 4.6 WIX_IS_NETFRAMEWORK_46_OR_LATER_INSTALLED 4.5.2 WIX_IS_NETFRAMEWORK_452_OR_LATER_INSTALLED 4.5.1 WIX_IS_NETFRAMEWORK_451_OR_LATER_INSTALLED 4.5 WIX_IS_NETFRAMEWORK_45_OR_LATER_INSTALLED 4 WIX_IS_NETFRAMEWORK_40_OR_LATER_INSTALLED 更低版本的 .NET Framework 没有直接的“是否安装”判断方法，需要根据版本号比较来判断，所以我不在此入门教程中列出。WiX 3 不支持 .NET Core 3.x、.NET 5 以及 .NET 6 的判断。如需检查这些环境，要么需要自己写判断方法（不属于此新手教程内容），要么需要升级到 WiX 4（本教程基于 WiX 3）。见：Support .NET Standard and/or .NET Core custom Bootstrapper · Issue #6108 · wixtoolset/issues。测试效果现在，编译 MSI 项目，然后运行输出目录下的 msi 文件，你会……呃……看不到任何效果……因为我们的开发机上具备 .NET Framework 4.8 的环境，可完美运行 .NET Framework 4.6.2 需求的应用。下图是我魔改了 DEMO 后在 Windows 11 上的截图（放上来就是为了平衡美感的）：不过为了真实性，我还是找了台 Windows 7 纯净系统来测试：如果点击“OK”，安装程序将直接退出，不会执行任何安装操作。附源代码附上必要的源码，避免你在阅读教程时因模板文件的版本差异造成一些意料之外的问题。Product.wxs// 除了本文所说的改动外，本文件的其他内容均保持模板文件的原始模样。&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;Wix xmlns=&quot;http://schemas.microsoft.com/wix/2006/wi&quot; xmlns:netfx=&quot;http://schemas.microsoft.com/wix/NetFxExtension&quot;&amp;gt; &amp;lt;Product Id=&quot;*&quot; Name=&quot;Walterlv.Demo.MainApp&quot; Language=&quot;1033&quot; Version=&quot;1.0.0.0&quot; Manufacturer=&quot;walterlv&quot; UpgradeCode=&quot;2aeffe1a-8bb6-4b06-b1c0-feca18e17cf7&quot;&amp;gt; &amp;lt;Package InstallerVersion=&quot;200&quot; Compressed=&quot;yes&quot; InstallScope=&quot;perMachine&quot; /&amp;gt; &amp;lt;PropertyRef Id=&quot;WIX_IS_NETFRAMEWORK_462_OR_LATER_INSTALLED&quot;/&amp;gt; &amp;lt;Condition Message=&quot;This application requires .NET Framework 4.6.2. Please install the .NET Framework then run this installer again.&quot;&amp;gt; &amp;lt;![CDATA[WIX_IS_NETFRAMEWORK_462_OR_LATER_INSTALLED]]&amp;gt; &amp;lt;/Condition&amp;gt; &amp;lt;MajorUpgrade DowngradeErrorMessage=&quot;A newer version of [ProductName] is already installed.&quot; /&amp;gt; &amp;lt;MediaTemplate /&amp;gt; &amp;lt;Feature Id=&quot;ProductFeature&quot; Title=&quot;Walterlv.Installer.Msi&quot; Level=&quot;1&quot;&amp;gt; &amp;lt;ComponentGroupRef Id=&quot;ProductComponents&quot; /&amp;gt; &amp;lt;/Feature&amp;gt; &amp;lt;/Product&amp;gt; &amp;lt;Fragment&amp;gt; &amp;lt;Directory Id=&quot;TARGETDIR&quot; Name=&quot;SourceDir&quot;&amp;gt; &amp;lt;Directory Id=&quot;ProgramFilesFolder&quot;&amp;gt; &amp;lt;Directory Id=&quot;INSTALLFOLDER&quot; Name=&quot;Walterlv.Installer.Msi&quot; /&amp;gt; &amp;lt;/Directory&amp;gt; &amp;lt;/Directory&amp;gt; &amp;lt;/Fragment&amp;gt; &amp;lt;Fragment&amp;gt; &amp;lt;ComponentGroup Id=&quot;ProductComponents&quot; Directory=&quot;INSTALLFOLDER&quot;&amp;gt; &amp;lt;Component Id=&quot;ProductComponent&quot;&amp;gt; &amp;lt;File Source=&quot;$(var.Walterlv.Demo.MainApp.TargetPath)&quot; /&amp;gt; &amp;lt;/Component&amp;gt; &amp;lt;/ComponentGroup&amp;gt; &amp;lt;/Fragment&amp;gt;&amp;lt;/Wix&amp;gt;参考资料 How To: Check for .NET Framework Versions Expression Syntax" }, { "title": "用 WiX 制作安装包：创建一个简单的 msi 安装包", "url": "/post/getting-started-with-wix-toolset-msi-hello-world.html", "categories": "", "tags": "dotnet, msi, wix", "date": "2021-07-15 19:46:48 +0800", "snippet": "本文是 WiX Toolset 安装包制作入门教程 系列中的一篇，可前往阅读完整教程。本文将带大家制作一个简单的 msi 安装包。本文操作基于系列教程中的一个最简项目，见 准备一个用于学习 WiX 安装包制作的 Visual Studio 解决方案。如果你没准备这样的项目，拿一个现成的项目也行，毕竟打包对目标程序的形式没有任何要求，只要是一个能跑起来的程序即可。创建 WiX MSI 项目在解决方案上右键，“添加”-&amp;gt;“新建项目…”，然后在“添加新项目”窗口中搜索“WiX”，找到“Setup Project for WiX v3”。按“下一步”取个名字，然后“创建”。注意，选择的模板要注意这些要点： 图标上标记了“wix”，标签上标记了“WiX” 模板简介中说明这是在创建“MSI”文件引用目标项目 在 WiX MSI 项目（在本教程中，我取的名字为 Walterlv.Installer.Msi）的“References”上右键，选“添加引用…”； 在打开的“Add Reference”窗口中选择“项目”标签； 选中希望打包的项目； 点“添加”； 点“确定”。编辑 Product.wxs 文件添加要打包的文件在 Product.wxs 文件中，找到提示你放文件、注册表项和其他资源的注释“&amp;lt;!-- TODO: Insert files, registry keys, and other resources here. --&amp;gt;”： 把周围的“Component”解除注释（因为我们真的要加打包的文件了）； 删除“TODO”注释（本教程会继续教你如何完成打包，不需要 TODO 提示了）； 在“Component”块中添加一行 &amp;lt;File Source=&quot;$(var.Walterlv.Demo.MainApp.TargetPath)&quot; /&amp;gt;。 &amp;lt;Fragment&amp;gt; &amp;lt;ComponentGroup Id=&quot;ProductComponents&quot; Directory=&quot;INSTALLFOLDER&quot;&amp;gt;-- &amp;lt;!-- TODO: Remove the comments around this Component element and the ComponentRef below in order to add resources to this installer. --&amp;gt;-- &amp;lt;!-- &amp;lt;Component Id=&quot;ProductComponent&quot;&amp;gt; --&amp;gt;++ &amp;lt;Component Id=&quot;ProductComponent&quot;&amp;gt;-- &amp;lt;!-- TODO: Insert files, registry keys, and other resources here. --&amp;gt;++ &amp;lt;File Source=&quot;$(var.Walterlv.Demo.MainApp.TargetPath)&quot; /&amp;gt;-- &amp;lt;!-- &amp;lt;/Component&amp;gt; --&amp;gt;++ &amp;lt;/Component&amp;gt; &amp;lt;/ComponentGroup&amp;gt; &amp;lt;/Fragment&amp;gt;注意： 这里的 Walterlv.Demo.MainApp 是上一个步骤中引用的项目的名称（不是程序集或 exe 的名称）！如果你有自己的项目名，则在此改成你自己的项目名称。 本例的目标程序只有一个文件，因此我们只放了一行，如果你要打包多个文件，可返回本教程目录页查阅其他文章。编辑基本的安装包信息此时，我们距离完成 msi 打包只剩最后一步了，就是填写基本的安装包信息。因为如果你不填，编译会报错：▲ 缺少厂商信息这个信息在 Product 标签的特性上更改： &amp;lt;Product Id=&quot;*&quot;-- Name=&quot;Walterlv.Installer.Msi&quot;++ Name=&quot;Walterlv.Demo.MainApp&quot; Language=&quot;1033&quot; Version=&quot;1.0.0.0&quot;-- Manufacturer=&quot;&quot;++ Manufacturer=&quot;walterlv&quot; UpgradeCode=&quot;2aeffe1a-8bb6-4b06-b1c0-feca18e17cf7&quot;&amp;gt;除了改了厂商（Manufacturer）之外，我还额外改了一下 Name，这个名字是最终出现在系统设置“应用和功能”中的名字，当然也是控制面板“卸载程序”中的名字。毕竟谁也不希望系统“应用和功能”里显示的名字不是真正的产品名吧……另外，其他属性的值也值得留意。但在你明白他们的真实含义之前，不建议修改其值。关于这些值的含义，你可以阅读我的另一篇博客： Windows 安装包制作最佳实践：ProductCode、UpgradeCode、PackageCode 应该怎么设置？修改输出文件名以上 Product.wxs 修改的是安装包的信息。如果希望更改 MSI 安装包的文件名，则需要去项目的属性页里去修改，如下图：测试效果现在，我们完成了一个最简单的 MSI 安装包，测试安装一下。前往 MSI 文件的输出目录（在项目目录的 bin\\Debug 下）：▲ 前往 MSI 文件的输出目录安装完后，可以在系统设置“应用和功能”以及“Program Files”目录中找到它：▲ 系统设置应用和功能▲ Program Files 文件夹测试完成后，记得及时卸载掉这个包。虽然这次没什么影响，但后续我们会学到的某个操作可能导致未及时卸载的包再也无法通过正常途径卸载，所以请保持良好的习惯。（虚拟机调试的小伙伴可无视）。另外，觉得不错可以提交一下代码，方便后续章节的学习。附源代码附上必要的源码，避免你在阅读教程时因模板文件的版本差异造成一些意料之外的问题。Product.wxs// 除了本文所说的改动外，本文件的其他内容均保持模板文件的原始模样。&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;Wix xmlns=&quot;http://schemas.microsoft.com/wix/2006/wi&quot;&amp;gt; &amp;lt;Product Id=&quot;*&quot; Name=&quot;Walterlv.Demo.MainApp&quot; Language=&quot;1033&quot; Version=&quot;1.0.0.0&quot; Manufacturer=&quot;walterlv&quot; UpgradeCode=&quot;2aeffe1a-8bb6-4b06-b1c0-feca18e17cf7&quot;&amp;gt; &amp;lt;Package InstallerVersion=&quot;200&quot; Compressed=&quot;yes&quot; InstallScope=&quot;perMachine&quot; /&amp;gt; &amp;lt;MajorUpgrade DowngradeErrorMessage=&quot;A newer version of [ProductName] is already installed.&quot; /&amp;gt; &amp;lt;MediaTemplate /&amp;gt; &amp;lt;Feature Id=&quot;ProductFeature&quot; Title=&quot;Walterlv.Installer.Msi&quot; Level=&quot;1&quot;&amp;gt; &amp;lt;ComponentGroupRef Id=&quot;ProductComponents&quot; /&amp;gt; &amp;lt;/Feature&amp;gt; &amp;lt;/Product&amp;gt; &amp;lt;Fragment&amp;gt; &amp;lt;Directory Id=&quot;TARGETDIR&quot; Name=&quot;SourceDir&quot;&amp;gt; &amp;lt;Directory Id=&quot;ProgramFilesFolder&quot;&amp;gt; &amp;lt;Directory Id=&quot;INSTALLFOLDER&quot; Name=&quot;Walterlv.Installer.Msi&quot; /&amp;gt; &amp;lt;/Directory&amp;gt; &amp;lt;/Directory&amp;gt; &amp;lt;/Fragment&amp;gt; &amp;lt;Fragment&amp;gt; &amp;lt;ComponentGroup Id=&quot;ProductComponents&quot; Directory=&quot;INSTALLFOLDER&quot;&amp;gt; &amp;lt;Component Id=&quot;ProductComponent&quot;&amp;gt; &amp;lt;File Source=&quot;$(var.Walterlv.Demo.MainApp.TargetPath)&quot; /&amp;gt; &amp;lt;/Component&amp;gt; &amp;lt;/ComponentGroup&amp;gt; &amp;lt;/Fragment&amp;gt;&amp;lt;/Wix&amp;gt;" }, { "title": "用 WiX 制作安装包：为 WiX 制作的 exe 安装包添加 .NET Framework 前置的安装步骤", "url": "/post/getting-started-with-wix-toolset-bundle-detect-and-install-net-framework.html", "categories": "", "tags": "dotnet, msi, wix", "date": "2021-07-15 19:46:34 +0800", "snippet": "本文是 WiX Toolset 安装包制作入门教程 系列中的一篇，可前往阅读完整教程。前面我们制作完成了一个简单的 exe 安装包。如果我们要安装的程序运行需要 .NET Framework 环境，那么可以检查 .NET Framework 是否安装，如果未安装则可将其装上。 小提示 Bundle（exe 格式）的判断方法和 Product（msi 格式）的不一样，因此 为 WiX 制作的 msi 安装包添加 .NET Framework 环境检查 一文中所编写的代码对本文没有任何影响。因此即使跳过了那篇文章也丝毫不影响本文的学习。本文基于前一篇文章已经建好的项目继续： 用 WiX 制作安装包：创建一个简单的 exe 安装包背景知识在开始给我们的 exe 安装包增加 .NET Framework 环境检查之前，我们先了解一点背景知识，以便后续步骤可以使用更专业的词汇来准确描述我们正在做的事情。注意到我们解决方案里面的两个 wxs 文件了吗？他们分别是用来打 msi 包的 Product.wxs 和用来打 exe 包的 Bundle.wxs。这两个文件的结构分别像这样：&amp;lt;!-- Product.wxs --&amp;gt;&amp;lt;Wix&amp;gt; &amp;lt;Product&amp;gt; &amp;lt;Package /&amp;gt; &amp;lt;!-- 其他元素 --&amp;gt; &amp;lt;/Product&amp;gt;&amp;lt;/Wix&amp;gt;&amp;lt;!-- Bundle.wxs --&amp;gt;&amp;lt;Wix&amp;gt; &amp;lt;Bundle&amp;gt; &amp;lt;BootstrapperApplicationRef /&amp;gt; &amp;lt;!-- 其他元素 --&amp;gt; &amp;lt;/Product&amp;gt;&amp;lt;/Wix&amp;gt;这里引入了两个很重要的概念：产品（Product）和捆绑包（Bundle）。&amp;lt;Product&amp;gt; 元素负责定义如何安装一个产品，而 &amp;lt;Bundle&amp;gt; 元素负责定义如何安装一组包。在 wxs 文件中，他们分别是 &amp;lt;Wix&amp;gt; 元素的直接子级，彼此拥有不同的元素特性（Attribute）和子级（Child）——相互之间不可通用。也就是说，如果哪天你在网上某处扒出来某份 WiX 安装包代码，你需要清楚到底应该把这份代码放到哪个文件中。WiX 的官方文档中明确说明了这两个元素分别具有的不同特性和子级： Product Element Bundle Element添加 WixNetFxExtension 引用 在 exe 安装包项目的“Reference”上右键，“添加引用…”； 在打开的“Add Reference”窗口中确保选中的是“浏览”标签，然后在查找范围中找到 Wix Toolset 的安装目录（如果没改，那么应该在 C:\\Program Files (x86)\\WiX Toolset v3.11\\bin 这样的地方）； 在文件列表中找到“WixNetFxExtension.dll”； 点击“添加”； 点击“确定”。与之前添加引用一样，虽然我们选的路径是绝对路径，但实际上写入到 wixproj 文件中的是一个属性引用，所以不会存在团队协作和跨版本迁移问题。上次我们添加 WixNetFxExtension.dll 的引用是为了引用一个属性。而这次，我们是为了引用一个 .NET Framework 的安装包。编辑 Bundle.wxs现在，我们需要编辑 Bundle.wxs 文件。做两件事情： 将 .NET Framework 的安装加入到捆绑包的安装过程中； 将 .NET Framework 的安装包文件嵌入到捆绑包中或随包放到单独的文件中（可选）。将 .NET Framework 的安装加入到捆绑包的安装过程中WixNetFxExtension.dll 中已经自带好了各种版本的 .NET Framework 安装方法，其中每个版本都含在线安装和离线安装两种方法。对于小型项目，我们可以考虑在线安装 .NET Framework。于是，我们在 Bundle.wxs 文件中添加一行： &amp;lt;Chain&amp;gt;++ &amp;lt;PackageGroupRef Id=&quot;NetFx462Web&quot;/&amp;gt; &amp;lt;MsiPackage Compressed=&quot;yes&quot; SourceFile=&quot;$(var.Walterlv.Installer.Msi.TargetPath)&quot;/&amp;gt; &amp;lt;/Chain&amp;gt;对于面向大量用户的产品，我们可能需要考虑本地安装 .NET Framework。于是，我们在 Bundle.wxs 文件中添加另一行： &amp;lt;Chain&amp;gt;++ &amp;lt;PackageGroupRef Id=&quot;NetFx462Redist&quot;/&amp;gt; &amp;lt;MsiPackage Compressed=&quot;yes&quot; SourceFile=&quot;$(var.Walterlv.Installer.Msi.TargetPath)&quot;/&amp;gt; &amp;lt;/Chain&amp;gt;以上两种方式选择一种即可，看你的需要。WiX 已开源，其中 wix3 的代码在这里： wixtoolset/wix3: WiX Toolset v3.x在 /src/ext/NetFxExtension/wixlib 目录下有已定义好的各种 .NET Framework 版本的安装逻辑。我整理成下表，方便大家根据自己的需要查阅： .NET Framework 版本 在线安装 本地安装 4.8 NetFx48Web NetFx48Redist 4.7.2 无 NetFx472Redist 4.7.1 无 无 4.7 无 无 4.6.2 NetFx462Web NetFx462Redist 4.6.1 NetFx461Web NetFx461Redist 4.6 NetFx46Web NetFx46Redist 4.5.2 NetFx452Web NetFx452Redist 4.5.1 NetFx451Web NetFx451Redist 4.5 NetFx45Web NetFx45Redist 4 Full NetFx40Web NetFx40Redist 4 Client Profile NetFx40ClientWeb NetFx40ClientRedist 其他版本未提供安装逻辑，如果需要，你得自己写。鉴于这部分需要用到更多代码，所以我不在本入门教程内说明。如果需要的话，我单独写一篇。将 .NET Framework 的安装包文件嵌入到捆绑包中如果你在前一个步骤中选择的是通过 Web 的方式来安装 .NET Framework，那么此步骤就不需要了。而如果你打算将 .NET Framework 的安装包嵌入到捆绑包中或者随包放到单独的文件中，那么请继续操作。根据 WiX 3 已开源的源码我们可以得知，本地安装 .NET Framework 时选取的目录为 redist\\。对于 Bundle 捆绑包来说，这个目录指代了两种意思： 跟捆绑包的 exe 同一目录下的“redist”文件夹中； 捆绑包打包后包内的虚拟目录“redist”中。这对应了两种本地安装时，.NET Framework 安装包的两种再分发（redistribute）方法。来看看怎么做： 下载 .NET Framework 的离线安装包（官方下载地址（含各种版本）； 将下载好的 .NET Framework 安装包拖入到 exe 安装包项目中的根目录或任一文件夹下（也可以通过右键添加文件的方式添加）； 编辑 Bundle.wxs 文件，在 &amp;lt;BootstrapperApplicationRef&amp;gt; 内加入负载； 编辑 Bundle.wxs 文件，把 NetFx462Web 改成 NetFx462Redist。▲ 下载 .NET Framework-- &amp;lt;BootstrapperApplicationRef Id=&quot;WixStandardBootstrapperApplication.RtfLicense&quot; /&amp;gt;++ &amp;lt;BootstrapperApplicationRef Id=&quot;WixStandardBootstrapperApplication.RtfLicense&quot;&amp;gt;++ &amp;lt;Payload Name=&quot;redist\\NDP462-KB3151800-x86-x64-AllOS-ENU.exe&quot;++ SourceFile=&quot;Assets\\ndp462-kb3151800-x86-x64-allos-enu.exe&quot;/&amp;gt; &amp;lt;/BootstrapperApplicationRef&amp;gt;-- &amp;lt;PackageGroupRef Id=&quot;NetFx462Web&quot;/&amp;gt;++ &amp;lt;PackageGroupRef Id=&quot;NetFx462Redist&quot;/&amp;gt;以上四个步骤完成后，你的解决方案应该像下面这样：解释一下： 我创建了一个“Assets”文件夹用于存放刚下载好的 .NET Framework 的离线安装包（为了避免读者在概念上产生混淆，我刻意避开使用 redist 这个名字，以示说明解决方案内的文件夹结构仅为开发文件夹结构，不代表最终捆绑包内的虚拟目录结构）。 我在 &amp;lt;BootstrapperApplicationRef&amp;gt; 元素内新建了一个子元素 &amp;lt;Payload&amp;gt;（负载），其中 Name 设为 redist\\NDP462-KB3151800-x86-x64-AllOS-ENU.exe（这个对应的就是最终捆绑包的虚拟目录结构），SourceFile 设为 Assets\\ndp462-kb3151800-x86-x64-allos-enu.exe（这个对应的是开发时项目中的文件结构）。 每个 .NET Framework 版本都有自己对应的文件名称，如果还想继续用 WixNetFxExtension.dll 中提供的安装 .NET Framework 的功能，那么从官网下载文件后就不能改名字（WiX 中定义这些文件名是全大写的，下载下来的是全小写的，虽然实际上大小写并不影响）。编译这个项目，去输出目录下插件，可以发现几百 KB 的安装包现在变成了 59.6MB。很明显，.NET Framework 已经嵌入到了捆绑包中。而如果你跳过前面加 &amp;lt;Payload&amp;gt; 的步骤，那么最终生成的的 exe 将不含 .NET Framework 的安装包。如果用户此时双击这个 exe 安装文件并且当前的 .NET Framework 版本不满足要求，则会弹出一个文件选择对话框，要求用户选择正确的 .NET Framework 安装文件以继续安装过程。如果你希望避免用户选择文件，那么就需要把安装包放到 exe 文件同级目录下的 redist 文件夹中。测试效果现在，编译 MSI 项目，然后去没有 .NET Framework 4.6.2 的电脑上运行输出目录下的 exe 文件，可以看到已经在安装 .NET Framework 了。附源代码附上必要的源码，避免你在阅读教程时因模板文件的版本差异造成一些意料之外的问题。Bundle.wxs// 除了本文所说的改动外，本文件的其他内容均保持模板文件的原始模样。&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;Wix xmlns=&quot;http://schemas.microsoft.com/wix/2006/wi&quot;&amp;gt; &amp;lt;Bundle Name=&quot;Walterlv.Demo.MainApp&quot; Version=&quot;1.0.0.0&quot; Manufacturer=&quot;walterlv&quot; UpgradeCode=&quot;528f80ca-a8f5-4bd4-8131-59fdcd69a411&quot;&amp;gt; &amp;lt;BootstrapperApplicationRef Id=&quot;WixStandardBootstrapperApplication.RtfLicense&quot;&amp;gt; &amp;lt;Payload Name=&quot;redist\\NDP462-KB3151800-x86-x64-AllOS-ENU.exe&quot; SourceFile=&quot;Assets\\ndp462-kb3151800-x86-x64-allos-enu.exe&quot;/&amp;gt; &amp;lt;/BootstrapperApplicationRef&amp;gt; &amp;lt;Chain&amp;gt; &amp;lt;PackageGroupRef Id=&quot;NetFx462Redist&quot;/&amp;gt; &amp;lt;MsiPackage Compressed=&quot;yes&quot; SourceFile=&quot;$(var.Walterlv.Installer.Msi.TargetPath)&quot;/&amp;gt; &amp;lt;/Chain&amp;gt; &amp;lt;/Bundle&amp;gt;&amp;lt;/Wix&amp;gt;" }, { "title": "用 WiX 制作安装包：安装 WiX Toolset 系列 Visual Studio 插件", "url": "/post/getting-started-with-wix-toolset-installing-visual-studio-extensions.html", "categories": "", "tags": "dotnet, msi, wix", "date": "2021-07-14 17:47:10 +0800", "snippet": "本文是 WiX Toolset 安装包制作入门教程 系列中的一篇，可前往阅读完整教程。本文介绍安装 WiX Toolset 的两款 Visual Studio 插件，以便你能直接在 Visual Studio 里完整整套安装包的制作，无需使用命令行工具。对初学 WiX 的开发者来说比较友好。关于插件Wix Toolset Visual Studio Extension 为 Visual Studio 带来了这些功能： 通过模板创建 WiX 项目 支持 .wixproj 这个 WiX 专属的项目格式（只是新扩展名，里面的内容还是其他各种项目格式都用的那种） 为 WiX 打包项目提供专属的属性面板页，可供设置一些基本的属性反正，装了这款插件能让你更容易编写和管理 WiX 安装包相关文件。安装插件截至目前（2021年7月），WiX Toolset 的 Visual Studio 扩展最高支持到 VS2019，因此你需要在不高于 VS2019 的扩展管理里面下载插件。方法是： 启动 Visual Studio 2019，选“继续但无需代码”； 选菜单“扩展”-&amp;gt;“管理扩展”； 在“联机”页中搜索“WiX”，找到“Wix Toolset Visual Studio 2019 Extension”，然后点“下载”； 接下来，关闭所有已经打开的 Visual Studio，等待自动弹出的插件安装界面； 在 VSIX Installer 界面中，点击“Modify”以应用插件的安装。其他说明WiX 插件暂不支持 Visual Studio 2022，毕竟到了 Visual Studio 2022 开始 VS 使用 AMD64 架构了。如果你有自己的插件需要升级到支持 VS2022，可阅读我的另一篇博客： Visual Studio 2022 出来啦！教你如何将 VS2019 的 VSIX 扩展/插件项目迁移到 VS2022" }, { "title": "用 WiX 制作安装包：安装 WiX Toolset 工具集", "url": "/post/getting-started-with-wix-toolset-installing-build-tools.html", "categories": "", "tags": "dotnet, msi, wix", "date": "2021-07-14 17:47:10 +0800", "snippet": "本文是 WiX Toolset 安装包制作入门教程 系列中的首篇，可前往阅读完整教程。WiX 提供一组工具集，我们的安装包正是通过这一组工具集来编译生成的。你可以通过很多方式来安装这组工具集，本文会提到多种方案，但仅会详细说其中一种，以便让教程尽可能简单。从官网下载安装 WiX Toolset请前往其 GitHub 发布页下载： Releases · wixtoolset/wix3为了简单，可下载其中的 wix311.exe 文件。这份安装包可帮助我们更简单地部署好 WiX Toolset 的构建环境。点击中间最大的那个按钮“Install”即可开始安装：安装完成之后，在中间的按钮上它会提示可以安装 Visual Studio 集成：点击这个按钮后可安装 Visual Studio 插件。关于安装此插件的详细信息，可阅读下一篇入门博客： 安装 WiX Toolset Visual Studio 插件另特别说明一下，这个安装包界面是用 WPF 做的。是后续入门教程系列博客里也会说到如何做一个 WPF 界面的安装包。其他安装途径此段非新手教程部分，如果不关心可略过。scoop 安装如果你安装有 scoop 包管理器，可直接输入以下命令安装：scoop install wixtoolset这套工具是在 scoop 的 main bucket 里面的，所以无需添加新的 bucket。安装完成后会自动添加环境变量，所以即便是 scoop 安装后，也可以直接在 Visual Studio 里面正常构建安装包。nuget 安装以上方式均为全局安装，如果是团队合作，要求所有维护 WiX 安装包的开发人员都安装好 WiX Toolset。你也可以考虑将 WiX 安装到你的某个 Visual Studio 项目中，这样打开此项目的所有开发人员在还原 NuGet 包后都自动拥有了 WiX 全套工具集。使用 NuGet 的方式是按项目安装的，仅此解决方案（sln）有效。安装了此 NuGet 包的项目将可完全使用 WiX 工具集（因为包里包含了构建安装包需要的 MSBuild 属性）。以下是 NuGet 包中自带的属性一览：&amp;lt;Project ToolsVersion=&quot;4.0&quot; xmlns=&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;WixInstallPath&amp;gt;$(MSBuildThisFileDirectory)..\\tools&amp;lt;/WixInstallPath&amp;gt; &amp;lt;WixExtDir&amp;gt;$(WixInstallPath)\\&amp;lt;/WixExtDir&amp;gt; &amp;lt;WixTargetsPath&amp;gt;$(WixInstallPath)\\wix.targets&amp;lt;/WixTargetsPath&amp;gt; &amp;lt;LuxTargetsPath&amp;gt;$(WixInstallPath)\\lux.targets&amp;lt;/LuxTargetsPath&amp;gt; &amp;lt;WixTasksPath&amp;gt;$(WixInstallPath)\\WixTasks.dll&amp;lt;/WixTasksPath&amp;gt; &amp;lt;WixSdkPath&amp;gt;$(WixInstallPath)\\sdk\\&amp;lt;/WixSdkPath&amp;gt; &amp;lt;WixCATargetsPath&amp;gt;$(WixSdkPath)wix.ca.targets&amp;lt;/WixCATargetsPath&amp;gt; &amp;lt;/PropertyGroup&amp;gt;&amp;lt;/Project&amp;gt;如果感兴趣通过 NuGet 的方式来安装 WiX Toolset，我可以再写一篇专门使用此方式安装并在团队所有人电脑上可直接构建安装包的博客。" }, { "title": "用 WiX 制作安装包：准备一个用于学习 WiX 安装包制作的 Visual Studio 解决方案", "url": "/post/getting-started-with-wix-toolset-create-a-new-learning-vs-solution.html", "categories": "", "tags": "dotnet, msi, wix", "date": "2021-07-14 17:47:10 +0800", "snippet": "本文是 WiX Toolset 安装包制作入门教程 系列中的一篇，可前往阅读完整教程。严格来说，本文算不得教程，只是带大家创建一个需要被打包的项目。如果你本身对使用 Visual Studio 开发非常得心应手，本文完全可以跳过，你可以用你的任何一个现成的项目进行练手。创建示例项目我这里拿一个控制台项目示例，当作被打包的对象。▲ 启动 Visual Studio 创建新项目▲ 选择控制台应用程序作为模板▲ 输入好项目和解决方案名称▲ 选好目标框架那么，我们就创建好了一个最简单的项目：我们后续学习打包时，就需要打包这个项目生成的应用。加入 git 版本管理为了避免学习过程中各种修改导致文件无法还原，建议大家将此新项目加入到 git 版本管理中。▲ 创建 Git 存储库▲ 仅限本地现在，我们已经准备了一个最简单的项目，可以开始后续 WiX 打包的正式学习了。" }, { "title": "WiX 安装包制作最佳实践：Id、UpgradeCode 应该怎么设置？", "url": "/post/windows-installer-using-wix-best-practice-product-id-and-upgrade-code.html", "categories": "", "tags": "dotnet, msi, wix", "date": "2021-07-14 17:46:49 +0800", "snippet": "在 WiX 安装包制作时，Product.wxs 文件中的 Product 标签中存在一些属性，这些属性应该如何设置才是比较合适的呢？本文是对我另一篇入门教程博客的一点补充： 用 WiX 制作安装包：创建一个简单的 msi 安装包Id、Version Id：产品 Id。 Version：产品版本。关于这两个值的变化： 如果这两个值都没有更改而构建出一个新的 MSI 安装包，那么 Windows Installer 会认为这两个包之间属于“小型更新”（Update）。 如果 Version 属性更改，而 Id 属性没有更改，那么 Windows Installer 会认为这两个包之间属于“次要升级”（Upgrade）。 如果这两个值都更改了，那么 Windows Installer 会认为这两个包之间属于“主要升级”（MajorUpgrade）。特别把这几种升级类型的英文名称拿出来说，是因为我们在 Product.wxs 中配置升级策略时会使用到这些名称。了解这些升级方式有助于我们写出符合预期的升级策略。如果保持 Product.wxs 文件的 Product 元素的 Id 属性为 *，那么每次构建一个 MSI 文件都会视为一次“主要升级”（MajorUpgrade）。在没有配置升级策略的情况下，如果有两个不同的 MSI 包设置了相同的 Id 和 Version，那么当安装了其中一个之后，另一个将无法安装。双击 msi 文件时，Windows Installer 将弹出错误框：UpgradeCode对于同一个产品，无论其产品 Id、Version 如何变化，都应该保持 UpgradeCode 不变，以便 Windows Installer 能准确认为这是同一个产品的“主要升级”（MajorUpgrade）。参考资料 修补和升级 - Win32 apps - Microsoft Docs Product Identification (ProductCode and UpgradeCode) In WiX, where is the ProductCode specified? - Stack Overflow ProductCode 属性 - Win32 apps - Microsoft Docs" }, { "title": "WPF 窗口和控件的 Unloaded 事件什么情况下不会触发", "url": "/post/wpf-unloaded-event-not-fired.html", "categories": "", "tags": "wpf", "date": "2021-06-30 16:11:02 +0800", "snippet": "WPF 中如果监听窗口或者控件的的 Unloaded 事件，那么这个事件会触发吗？答案是不确定的。示例代码&amp;lt;Window x:Class=&quot;Walterlv.TempDemo.Wpf.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; Unloaded=&quot;Window_Unloaded&quot; Closed=&quot;Window_Closed&quot;&amp;gt; &amp;lt;Grid Unloaded=&quot;Grid_Unloaded&quot;&amp;gt; &amp;lt;/Grid&amp;gt;&amp;lt;/Window&amp;gt;private void Window_Unloaded(object sender, RoutedEventArgs e){ // 断点 1}private void Grid_Unloaded(object sender, RoutedEventArgs e){ // 断点 2}private void Window_Closed(object sender, EventArgs e){ // 断点 3}你觉得以上事件中，断点都会进入吗？不确定的答案在微软的官方文档中说： Note that the Unloaded event is not raised after an application begins shutting down. Application shutdown occurs when the condition defined by the ShutdownMode property occurs. If you place cleanup code within a handler for the Unloaded event, such as for a Window or a UserControl, it may not be called as expected.如果应用程序正在关闭，那么 Unloaded 时间将不会触发。WPF 通过设置在 Application 上的 ShutdownMode 来决定是否在关闭窗口后关闭应用程序。因此，如果你试图通过在 Unloaded 事件中执行清理操作，那么可能不会如预期般完成。因此，一般情况下，Unloaded 事件是会触发的，但满足如下任一情况时，此事件将不不会触发： Application.ShutdownMode=&quot;OnLastWindowClose&quot; 且最后一个窗口关闭时； Application.ShutdownMode=&quot;OnMainWindowClose&quot; 且主窗口关闭时。顺序当触发 Unloaded 事件时，以上事件的触发顺序为： 断点 3 断点 1 断点 2参考资料 Unloaded event not called on Window when app closed · Issue #1442 · dotnet/wpf FrameworkElement.Unloaded Event (System.Windows) - Microsoft Docs" }, { "title": "编译并体验 .NET MAUI 官方示例代码", "url": "/post/getting-started-with-maui-official-samples.html", "categories": "", "tags": "dotnet, maui", "date": "2021-06-25 17:36:03 +0800", "snippet": "在微软的 Build 2021 大会上，微软发布了 .NET 6 Preview 4，同时发布了于它的 MAUI 第四个预览版。在 MAUI 成为 Visual Studio 2022 的官方工作负载之前，成功编译并运行 MAUI 的示例程序会比较麻烦，本文旨在帮助大家完成示例程序的编译运行和体验。更新：现在已经 .NET 6 Preview 5 了，配上 Visual Studio 2022 17.0 Preview 1 依然如本文这般麻烦。TL;DR本段属太长不读系列。完整版请看下一段。截至 2021 年 5 月 31 日，要成功编译并运行 .NET MAUI 官方示例项目，你需要准备如下环境： 安装 Visual Studio 2019 16.11 Preview 1 或更高版本（否则只能编译而无法运行，旧版 VS 不知道如何调试这种项目） 安装 .NET 6 Preview 4（MAUI 示例项目要求的最低 .NET 版本） 安装 maui-check，检查并修复所有环境问题（包含各类 SDK、模拟器等） 增加 NuGet 源 https://aka.ms/maui-preview/index.json（否则无法识别用到的 MAUI 类型）在以上都准备就绪的情况下，你只需要使用 Visual Studio 2019 16.11 Preview 1 创建 MAUI 项目或打开官方 MAUI 示例项目即可调试 MAUI 项目。当然，预计 .NET 6 和 Visual Studio 2022 发布后，MAUI 将成为 Visual Studio 工作负载的一部分。届时，只需要在 Visual Studio 2022 里勾选 MAUI 就够了，其他什么也不用管。安装 Visual Studio 2019 16.11 Preview 1 或更高版本如果你电脑上已经安装过预览版的 Visual Studio，那么直接去开始菜单搜索并打开 Visual Studio Installer，然后把预览版更新到最新就好了。但如果你电脑上只有正式版的 Visual Studio，那么你需要前往预览版的下载地址下载一个预览版的在线安装包来安装。 下载 Visual Studio 预览版（常年不变的地址）安装 .NET 6 Preview 4你还需要将你电脑上的 .NET 更新到 .NET 6 Preview 4 或者以上的版本。 下载 .NET 6（常年不变的地址）安装 maui-check 工具打开你喜爱的终端，然后输入如下命令：dotnet tool install -g redth.net.maui.check这将在全局安装 maui-check 工具，辅助你完成 MAUI 开发环境的搭建。工具安装完成后，直接输入命令 maui-check 然后回车运行，工具将自动检查你的电脑上是否已完成 MAUI 开发环境的搭建。它会在检查到问题之后发出轻轻的一声“嘟”，然后问你：“要尝试修复吗？（! Attempt to fix?）”你只需要打 y 告诉它要修复就好了。这样的问题会问很多次，你都需要答 y 修复，甚至可能还需要多次运行 maui-check 工具来进行修复。到最后，当你再次运行 maui-check 时，它会兴奋地告诉你：“Congratulations, everything looks great!”这意味着，MAUI 所需的环境已全部搭建完成。如果 maui-check 不断失败，可阅读本文末尾一节。增加 NuGet 源我有另一篇博客介绍如何添加 NuGet 源，详细的方法你可以去那里看： 全局或为单独的项目添加自定义的 NuGet 源 - walterlv要简单一点，你只需要在命令行中输入：dotnet nuget add source -n maui-preview https://aka.ms/maui-preview/index.json这会直接修改 %AppData%\\NuGet\\NuGet.Config 文件，并在其中添加一行 NuGet 源。MAUI 官方示例仓库在以上所有步骤执行完成之后，以下项目就能直接在 Visual Studio 2019 16.11 Preview 1 或更高版本中编译并调试了。 dotnet/maui-samples: .NET 6 preview samples. Not for production use. The main branch tracks the current preview release, and develop tracks the upcoming preview. davidortinau/WeatherTwentyOne例如，以 maui-samples 项目举例，将 HelloMaui 项目设为启动项目，在 Visual Studio 中将启动框架设置为 .net6.0-android，就可以在 Android 模拟器中运行 HelloMaui 应用了。以下是 HelloMaui 在 Android 模拟器中的运行效果。另外，Visual Studio 2019 16.11 Preview 1 中已经内置了 MAUI 的项目模板，你也可以直接新建 MAUI 项目自行调试。其他问题无法创建 Android 模拟器Android Emulator - x86 - API30 - Google API&#39;s not created.如果 maui-check 时出现 Android 模拟器无法创建的错误（就像下图这样），可尝试在 Visual Studio 里手工创建一个 Android 模拟器。在 Visual Studio 里手工创建 Android 模拟器的方法如下：第一步：打开 Android 设备管理器第二步：创建新设备创建时，要注意操作系统必须选择“R 11.0 - API 30”，这是 MAUI 示例应用要求的最低版本。其他随意，然后点“创建 ”。创建完后，等待下载、解压直至安装完成。第三步：重新使用 maui-check 检查这时，应该就能全部通过检查了。无法调试 WinUI3 项目调试官方示例中的 HelloMauiWinUI3 项目时，你可能会遇到 COM 异常“没有注册类”：原因是，你应该将“HelloMauiWinUI3 (Package)”后缀的 WinUI 项目设为启动项，而不应该将“HelloMauiWinUI3”设为启动项。并且，调试启动时，应该选 Local Machine。以下是我运行另一个“Weather TwentyOne”官方示例应用的截图：参考资料 Announcing .NET MAUI Preview 4 - .NET Blog [Bug] An unhandled exception of type ‘System.Reflection.TargetInvocationException’ occurred in System.Private.CoreLib.dll · Issue #1127 · dotnet/maui" }, { "title": "Visual Studio 2022 出来啦！教你如何将 VS2019 的 VSIX 扩展/插件项目迁移到 VS2022", "url": "/post/add-vs2019-extension-support-to-vs2022.html", "categories": "", "tags": "visualstudio, dotnet", "date": "2021-06-25 14:05:52 +0800", "snippet": "从 Visual Studio 2022 开始，Visual Studio 正式启用了 amd64 架构。为了确保扩展的兼容性，Visual Studio 2022 不会启用以前编译过的扩展，即使以前编译过的扩展把支持的 Visual Studio 版本号加到了 17.0（对应 VS2022）也不行。毕竟 x64 的进程真加载一个 x86 的程序集时，会炸得体无完肤。因为保证安全，Visual Studio 2022 仅加载专门为它开发和编译过的插件。如果你正好有一个为 Visual Studio 2019（或更早）开发的插件，那么可以通过阅读本文完成对插件项目的升级，以支持 Visual Studio 2022。TL;DR 最简改法如果你赶时间，只想马上把项目改好，那么阅读这一小节就够了。首先我们确认一下，你原来的项目至少是这样的结构： 是一个 Visual Studio 扩展项目 有一个 Visual Studio 扩展清单文件 source.extension.vsixmanifest在此基础上，你需要修改两个文件。source.extension.vsixmanifest：请将原来的安装目标改成 17.0 以前和以后两个，以前的用 x86 架构，以后的用 amd64 架构。 &amp;lt;Installation&amp;gt;-- &amp;lt;InstallationTarget Id=&quot;Microsoft.VisualStudio.Community&quot; Version=&quot;[16.0,)&quot; /&amp;gt;++ &amp;lt;InstallationTarget Id=&quot;Microsoft.VisualStudio.Community&quot; Version=&quot;[16.0, 17.0)&quot;&amp;gt;++ &amp;lt;ProductArchitecture&amp;gt;x86&amp;lt;/ProductArchitecture&amp;gt;++ &amp;lt;/InstallationTarget&amp;gt;++ &amp;lt;InstallationTarget Id=&quot;Microsoft.VisualStudio.Community&quot; Version=&quot;[17.0, 18.0)&quot;&amp;gt;++ &amp;lt;ProductArchitecture&amp;gt;amd64&amp;lt;/ProductArchitecture&amp;gt;++ &amp;lt;/InstallationTarget&amp;gt; &amp;lt;/Installation&amp;gt;*.csproj 文件：必须将 VS 构建工具升级到 17.0 或以上版本。-- &amp;lt;PackageReference Include=&quot;Microsoft.VSSDK.BuildTools&quot; Version=&quot;16.9.1050&quot; /&amp;gt;++ &amp;lt;PackageReference Include=&quot;Microsoft.VSSDK.BuildTools&quot; Version=&quot;17.0.2140-preview2&quot; /&amp;gt;如果你还有引用其他的 VS 构建工具，请一并升级到 17.0 或以上版本。升级时，此 VSIX 项目引用的其他项目（例如基于 .NET Standard 的分析器项目）无需升级 NuGet 包。至此，你再编译这个 Visual Studio 扩展项目，即可正常在旧的 Visual Studio 2019 和新的 Visual Studio 2022 上安装：完整改法如果你比较强迫症，我还是建议你完整改完整个项目。完整改完后，你将获得如下好处： 在 Visual Studio 2022 里双击 source.extension.vsixmanifest 后能打开专属的清单编辑器，避免手写容易出现明显错误 csproj 项目文件里不会有之前版本为了解决一些特定的 bug 而额外写的 bugfix 代码完整改法，即使用 Visual Studio 2022 来创建新的 VSIX 扩展项目。第一步：请确保已安装 SDK在开始菜单找到并启动 Visual Studio Installer，然后确保勾选 Visual Studio 扩展开发的工作负载，并将右边的 .NET Compiler Platform SDK 勾选。前者提供编写和调试扩展的能力，而后者提供了新建模板和 Roslyn 相关工具。第二步：重新创建 VSIX 项目新建一个 VSIX 项目：第三步：复制并替换整个扩展文件你可以把新创建项目的 csproj 文件和 source.extension.vsixmanifest 文件替换掉原项目的这两个文件，然后保留原项目。也可以考虑反过来操作，将原项目里的代码（如果有的话）放到新项目里来，然后保留新项目。合并这两个项目时，记得 source.extension.vsixmanifest 文件里的清单信息要与原来的保持一致，这样才能对原来的扩展进行升级（而不会创建出新的扩展来）。如果需要一个修改示例，你可以看我的一个 Pull Request（拉取请求）： 为插件添加 Visual Studio 2022 的支持 by walterlv · Pull Request #28 · walterlv/Walterlv.Packages重新上传扩展到市场前往 Visual Studio 扩展市场的管理界面 https://marketplace.visualstudio.com/manage，需要登录。在你需要升级的扩展旁边的“…”里点“Edit”编辑。重新上传你新编译出来的 VSIX 文件，等待审核即可。参考资料 visualstudio-docs/update-visual-studio-extension.md at master · MicrosoftDocs/visualstudio-docs" }, { "title": "两个方法，让 WPF 绘制的笔迹更加平滑", "url": "/post/wpf-smooth-ink.html", "categories": "", "tags": "wpf", "date": "2021-06-21 17:38:14 +0800", "snippet": "在 WPF 中绘制笔迹的时候，你可能会注意到绘制的笔迹非常的……呃……棱角分明。这在鼠标绘制的时候大家基本都能接受，但如果遇到一些触摸框报告触摸点也那么稀疏，那么写的字很不好看。另外，还有可能绘制的笔迹点来源于其他设备，通过网络传输而来，这时更容易遇到稀疏的点。本文将用两种方法来让 WPF 的笔迹更加平滑。两种方法我们有两种方法来解决这样的问题： 点插值 曲线拟合点插值如果导致不平滑的主要原因是点太稀疏，那么采用点插值算法可以解决很大的问题。常用的点插值算法是贝赛尔插值算法。通过贝赛尔插值算法的具体算法和代码，可参考这篇博客：一种简单的贝塞尔拟合算法_Iron 的博客-CSDN博客。使用以上插值算法后的效果如下（两次分别绘制，因此笔迹不一样）：▲ 插值前▲ 插值后曲线拟合WPF 的 Stroke 类型的 DrawingAttributes.FitToCurve 属性可开启或关闭笔迹的曲线拟合。这个属性是实时生效的，所以你可以在绘制笔迹的任何时刻设置它。例如一开始绘制时设置，你将可以在书写的过程中实时得到平滑的曲线，但用户可以明显看到绘制笔迹的过程中曲线拟合的过程（可看到笔迹在来回摆动）；你也可以在笔迹绘制结束插入到画布时再设置，这样在插入时用户只会看到一次笔迹的突变。使用以上曲线拟合后的效果如下（两次分别绘制，因此笔迹不一样）：▲ 拟合前▲ 拟合后综合使用正常情况下，仅“点插值”就足够让笔记看起来很平滑了。但如果你要求笔迹看不出棱角（例如此笔迹非用户直接书写，而是从其他平台传输过来呈现），那么你可能需要采用“曲线拟合”。然而，如果你觉得无法忍受“曲线拟合”带来的笔迹来回摆动，那么可考虑将两个方法结合起来使用。参考资料 一种简单的贝塞尔拟合算法_Iron 的博客-CSDN博客" }, { "title": "C# 的事件，一般你不需要担心它的线程安全问题！", "url": "/post/thread-safety-of-csharp-event.html", "categories": "", "tags": "csharp, dotnet", "date": "2021-06-18 15:42:18 +0800", "snippet": "时不时会有小伙伴跟我提到在 C# 写事件 += -= 以及 Invoke 时可能遇到线程安全问题。然而实际上这些操作并不会有线程安全问题，所以我特别写一篇博客来说明一下，从原理层面说说为什么不会有线程安全问题。顺便再提一下哪种情况下你却可能遇到线程安全问题。委托是不可变类型 委托是不可变类型。这点很重要，这是 C# 事件一般使用场景不会发生线程安全问题的关键！那既然委托是不可变类型，那我们在写 += -= 以及引发事件的时候，是如何处理最新注册或注销的事件呢？+= 和 -= 的本质我们随便写一个类型，里面包含一个事件：using System;namespace Walterlv.TempDemo{ class DemoClass { public event EventHandler SomeEvent; }}从外表上，这个事件就像一个字段一样的不线程安全。但实际上，他像一个属性一样能处理好线程安全问题。众所周知，这个事件会编译成以下两个方法： add_SomeEvent remove_SomeEvent// Methods// Token: 0x06000001 RID: 1 RVA: 0x00002050 File Offset: 0x00000250.method public hidebysig specialname instance void add_SomeEvent ( class [System.Runtime]System.EventHandler &#39;value&#39; ) cil managed { .custom instance void [System.Runtime]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) // Header Size: 12 bytes // Code Size: 41 (0x29) bytes // LocalVarSig Token: 0x11000001 RID: 1 .maxstack 3 .locals init ( [0] class [System.Runtime]System.EventHandler, [1] class [System.Runtime]System.EventHandler, [2] class [System.Runtime]System.EventHandler ) /* 0x0000025C 02 */ IL_0000: ldarg.0 /* 0x0000025D 7B01000004 */ IL_0001: ldfld class [System.Runtime]System.EventHandler Walterlv.TempDemo.DemoClass::SomeEvent /* 0x00000262 0A */ IL_0006: stloc.0 // loop start (head: IL_0007) /* 0x00000263 06 */ IL_0007: ldloc.0 /* 0x00000264 0B */ IL_0008: stloc.1 /* 0x00000265 07 */ IL_0009: ldloc.1 /* 0x00000266 03 */ IL_000A: ldarg.1 /* 0x00000267 280D00000A */ IL_000B: call class [System.Runtime]System.Delegate [System.Runtime]System.Delegate::Combine(class [System.Runtime]System.Delegate, class [System.Runtime]System.Delegate) /* 0x0000026C 740D000001 */ IL_0010: castclass [System.Runtime]System.EventHandler /* 0x00000271 0C */ IL_0015: stloc.2 /* 0x00000272 02 */ IL_0016: ldarg.0 /* 0x00000273 7C01000004 */ IL_0017: ldflda class [System.Runtime]System.EventHandler Walterlv.TempDemo.DemoClass::SomeEvent /* 0x00000278 08 */ IL_001C: ldloc.2 /* 0x00000279 07 */ IL_001D: ldloc.1 /* 0x0000027A 280100002B */ IL_001E: call !!0 [System.Threading]System.Threading.Interlocked::CompareExchange&amp;lt;class [System.Runtime]System.EventHandler&amp;gt;(!!0&amp;amp;, !!0, !!0) /* 0x0000027F 0A */ IL_0023: stloc.0 /* 0x00000280 06 */ IL_0024: ldloc.0 /* 0x00000281 07 */ IL_0025: ldloc.1 /* 0x00000282 33DF */ IL_0026: bne.un.s IL_0007 // end loop /* 0x00000284 2A */ IL_0028: ret} // end of method DemoClass::add_SomeEvent// Token: 0x06000002 RID: 2 RVA: 0x00002088 File Offset: 0x00000288.method public hidebysig specialname instance void remove_SomeEvent ( class [System.Runtime]System.EventHandler &#39;value&#39; ) cil managed { .custom instance void [System.Runtime]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) // Header Size: 12 bytes // Code Size: 41 (0x29) bytes // LocalVarSig Token: 0x11000001 RID: 1 .maxstack 3 .locals init ( [0] class [System.Runtime]System.EventHandler, [1] class [System.Runtime]System.EventHandler, [2] class [System.Runtime]System.EventHandler ) /* 0x00000294 02 */ IL_0000: ldarg.0 /* 0x00000295 7B01000004 */ IL_0001: ldfld class [System.Runtime]System.EventHandler Walterlv.TempDemo.DemoClass::SomeEvent /* 0x0000029A 0A */ IL_0006: stloc.0 // loop start (head: IL_0007) /* 0x0000029B 06 */ IL_0007: ldloc.0 /* 0x0000029C 0B */ IL_0008: stloc.1 /* 0x0000029D 07 */ IL_0009: ldloc.1 /* 0x0000029E 03 */ IL_000A: ldarg.1 /* 0x0000029F 280F00000A */ IL_000B: call class [System.Runtime]System.Delegate [System.Runtime]System.Delegate::Remove(class [System.Runtime]System.Delegate, class [System.Runtime]System.Delegate) /* 0x000002A4 740D000001 */ IL_0010: castclass [System.Runtime]System.EventHandler /* 0x000002A9 0C */ IL_0015: stloc.2 /* 0x000002AA 02 */ IL_0016: ldarg.0 /* 0x000002AB 7C01000004 */ IL_0017: ldflda class [System.Runtime]System.EventHandler Walterlv.TempDemo.DemoClass::SomeEvent /* 0x000002B0 08 */ IL_001C: ldloc.2 /* 0x000002B1 07 */ IL_001D: ldloc.1 /* 0x000002B2 280100002B */ IL_001E: call !!0 [System.Threading]System.Threading.Interlocked::CompareExchange&amp;lt;class [System.Runtime]System.EventHandler&amp;gt;(!!0&amp;amp;, !!0, !!0) /* 0x000002B7 0A */ IL_0023: stloc.0 /* 0x000002B8 06 */ IL_0024: ldloc.0 /* 0x000002B9 07 */ IL_0025: ldloc.1 /* 0x000002BA 33DF */ IL_0026: bne.un.s IL_0007 // end loop /* 0x000002BC 2A */ IL_0028: ret} // end of method DemoClass::remove_SomeEvent于是 += 和 -= 本质上是调用了 Delegate.Combine 方法和 Delegate.Remove 方法。而 Delegate.Combine 和 Delegate.Remove 不会修改原委托，只会生成新的委托。于是，任何时候当你拿到这个事件的一个实例，并将它存在一个变量里之后，只要不给这个变量额外赋值，这个变量包含的已注册的委托数就已经完全确定了下来。之后无论什么时候再 += 或 -= 这个事件，已经跟这个变量无关了。Delegate.Combine 和 Delegate.Remove现在让我们再来看看 Delegate.Combine 的实现（Remove 就不举例了，相反操作）。[return: NotNullIfNotNull(&quot;a&quot;)][return: NotNullIfNotNull(&quot;b&quot;)]public static Delegate? Combine(Delegate? a, Delegate? b){ if (a is null) return b; return a.CombineImpl(b);}最终调用了实例的 CombineImpl 方法，不过 Delegate 基类的 CombineImpl 方法没有实现（只有个异常）。为了实现事件的 += 和 -=，事件实际上是 MultiCastDelegate 类型，其实现如下：// This method will combine this delegate with the passed delegate// to form a new delegate.protected sealed override Delegate CombineImpl(Delegate? follow){ if (follow is null) return this; // Verify that the types are the same... if (!InternalEqualTypes(this, follow)) throw new ArgumentException(SR.Arg_DlgtTypeMis); MulticastDelegate dFollow = (MulticastDelegate)follow; object[]? resultList; int followCount = 1; object[]? followList = dFollow._invocationList as object[]; if (followList != null) followCount = (int)dFollow._invocationCount; int resultCount; if (!(_invocationList is object[] invocationList)) { resultCount = 1 + followCount; resultList = new object[resultCount]; resultList[0] = this; if (followList == null) { resultList[1] = dFollow; } else { for (int i = 0; i &amp;lt; followCount; i++) resultList[1 + i] = followList[i]; } return NewMulticastDelegate(resultList, resultCount); } else { int invocationCount = (int)_invocationCount; resultCount = invocationCount + followCount; resultList = null; if (resultCount &amp;lt;= invocationList.Length) { resultList = invocationList; if (followList == null) { if (!TrySetSlot(resultList, invocationCount, dFollow)) resultList = null; } else { for (int i = 0; i &amp;lt; followCount; i++) { if (!TrySetSlot(resultList, invocationCount + i, followList[i])) { resultList = null; break; } } } } if (resultList == null) { int allocCount = invocationList.Length; while (allocCount &amp;lt; resultCount) allocCount *= 2; resultList = new object[allocCount]; for (int i = 0; i &amp;lt; invocationCount; i++) resultList[i] = invocationList[i]; if (followList == null) { resultList[invocationCount] = dFollow; } else { for (int i = 0; i &amp;lt; followCount; i++) resultList[invocationCount + i] = followList[i]; } } return NewMulticastDelegate(resultList, resultCount, true); }}计算好新委托所需的委托列表和个数后，创建一个新的委托实例，然后用计算所得的结果初始化它。这座实了委托不变，于是不存在线程安全问题。线程安全的事件引发从 C# 6.0 开始，大家引发事件都喜欢使用下面这样的方式：SomeEvent?.Invoke(this, EventArgs.Empty);不用担心，这就是线程安全的写法！以上这个写法是空传递写法，相当于：var handler = SomeEvent;if (handler != null){ handler.Invoke(this, EventArgs.Empty);}我们前面已经通过原理证实了“委托不变”，所以这里我们用变量存这个事件的时候，这个变量就完全确认了此时此刻已经注册的所有委托，后面的判空和引发都不会受与之发生在同一时刻的 += 和 -= 的影响。有人说以上写法有可能会被编译器优化掉（《CLR via C#》说的），造成意料之外的线程安全问题，于是推荐写成下面这样：var handler = Volatile.Read(ref SomeEvent);if (handler != null){ handler.Invoke(this, EventArgs.Empty);}这样写当然是没有问题的。可是这样就没有 C#6.0 带来的一句话写下来的畅快感了！实际上，你根本无需担心编译器会对你引发事件带来线程不安全的优化，因为现在的 C# 编译器和 .NET 运行时很聪明，非常清楚你是在引发事件，于是不会随便优化掉你这里的逻辑。归根结底，只需要用 C# 6.0 的空传递操作符写引发事件就没有问题了。是否可能出现线程不安全的情况呢？从前面原理层面的剖析，我们可以明确知道，普通的事件 +=、-= 和引发是不会产生线程安全问题的；但这不代表任何情况你都不会遇到线程安全问题。如果你引发事件的代码逻辑比较复杂，涉及到多次读取事件成员（例如前面例子中的 SomeEvent），那么依然会出现线程安全问题，因为你无法保证两次读取事件成员时，期间没有发生过事件的 += 和 -=。关于 += -= 的额外说明在上文写完之后，有小伙伴说，C# 里面 += -= 不是线程安全的，并举了以下例子：private int _value;public void AddValue(int i){ _value += i;}当并发调用 AddValue 时，可能导致部分调用的结果被另一部分覆盖，从而出现线程安全问题。因为 _value += i 这个语法糖相当于以下句子：var temp = _value + i;_value = temp;然而，事件没有这样的问题，因为事件的 += 语法糖相当于以下句子：// demo.SomeEvent += DemoClass_SomeEvent;// 相当于：demo.add_SomeEvent(new EventHandler(DemoClass_SomeEvent));注意这是一次函数调用，并没有像普通的数值运算一样执行两步计算；所以至少这一次方法调用不会有问题。那么，add_SomeEvent 里面是线程安全的吗？如果只是单纯 Delegate.Combine 然后赋值当然不是线程安全，但它不是简单赋值，而是通过 Interlocked.CompareExchange 原子操作赋值，在保证线程安全的同时还确保了性能：/* 0x000002B2 280100002B */ IL_001E: call !!0 [System.Threading]System.Threading.Interlocked::CompareExchange&amp;lt;class [System.Runtime]System.EventHandler&amp;gt;(!!0&amp;amp;, !!0, !!0)转换成容易理解的 C# 代码大约是这样：while (true){ var originalValue = _value; var value = originalValue + add; var resultValue = Interlocked.CompareExchange(ref _value, value, originalValue); if (resultValue == value) { break; }} 当 CompareExchange 的返回值与第三个参数相同，说明本次原子操作成功完成，那么赋值有效，退出循环。 当 CompareExchange 的返回值与第三个参数不同，说明本次原子操作冲突，在下一次循环中重试赋值。 因为赋值是很迅速的，所以即使大量并发，也只会有少数冲突，整体是非常快的。完整的 IL 代码可以在本文前面看到。这里的 !!0 是引用第 0 号泛型类型，即找到 CompareExchange(!!T$, !!T, !!T):!!T 重载。" }, { "title": "Windows 中的 HRESULT", "url": "/post/hresult-in-windows.html", "categories": "", "tags": "windows", "date": "2021-06-16 10:51:05 +0800", "snippet": "Windows 协议文档中所描述的协议规范中，错误码使用 HRESULT、Win32 错误码和 NTSTATUS 来描述。本文科普一下 HRESULT。一个简单的例子我们先举一个大家可能常用的 HRESULT 例子，这样后面的介绍能更简单一点。0x80070070将它改写成二进制：1000 0000 0000 0111 0000 0000 0111 0000它的意思是“There is not enough space on the disk.”即“磁盘空间不足。”规范中的 HRESULT按照规范，HRESULT 的格式如下，其中首行的数字代表第几位（bit）： 0 1 2 3 4 5~15 16~31 S R C N X Facility Code S: 1 位，表示严重性。为 1 表示此结果为失败，为 0 表示此结果为成功。 R: 1 位，保留位。如果 N 位是 0，那么此位必须也是 0。如果 N 位是 1，那么此位由 NTSTATUS 定义的数字范围决定。 C: 1 位，自定义位。为 1 表示由微软定义，为 0 表示由其他厂商定义。 N: 1 位。为 1 表示此结果为 NTSTATUS 错误码。 X: 1 位。保留位，应设为 0。 Facility: 11 位。设施代码。指定错误来源。后面的列表中有已定义的错误源，微软偶尔会添加新的种类。 Code: 16 位（2 字节）。错误码的其他部分，指定错误的具体细节。其中，Facility 设施代码的详细列表可以参见这里：[MS-ERREF]: HRESULT - Microsoft Docs。对 Win32 开发来说，0x7 是很常见的，表示 FACILITY_WIN32。Win32 错误码现在再来看我们前面的例子：1000 0000 0000 0111 0000 0000 0111 0000 严重性：1，表示失败 设施代码：0x7，表示 FACILITY_WIN32 错误码：0x70，表示 ERROR_DISK_FULL所有的 Win32 错误码应该仅使用 16 位来表示，即范围从 0x0000 到 0xFFFF。关于 Win32 错误码的详细列表可以参见这里：[MS-ERREF]: Win32 Error Codes - Microsoft Docs微软错误查询工具如果你遇到了某个 Win32 错误码，或者 HRESULT 值，那么可以使用微软错误查询工具（The Microsoft Error Lookup Tool）查询其含义。下载地址：Download Microsoft Error Lookup Tool from Official Microsoft Download Center在 .NET/C# 代码中的使用例如，我们可能需要在一些 IO 操作中处理好磁盘空间已满的情况：try{ SaveFile(fileContent, filePath);}catch (IOException ex){ if (ex.IsDiskFullException()) { // 磁盘空间已满。 break; }}由于磁盘空间已满没有对应的 .NET Exception，所以我们只能通过提取 IOException 中的 HResult 属性来判断操作的 HRESULT 值。我们定义了一个扩展方法 IsDiskFullException，实现如下：/// &amp;lt;summary&amp;gt;/// There is not enough space on the disk./// 磁盘空间不足。/// &amp;lt;/summary&amp;gt;private static readonly int ERROR_DISK_FULL = 0x0070;/// &amp;lt;summary&amp;gt;/// 判断某个 &amp;lt;see cref=&quot;IOException&quot;/&amp;gt; 是否是“磁盘空间不足”的异常。/// &amp;lt;/summary&amp;gt;/// &amp;lt;param name=&quot;ex&quot;&amp;gt;IO 异常。&amp;lt;/param&amp;gt;/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;public static bool IsDiskFullException(this IOException ex){ var errorCode = ex.HResult &amp;amp; 0xFFFF; return errorCode == ERROR_DISK_FULL;}参考资料 MS-ERREF: HRESULT - Microsoft Docs HRESULT - 维基百科，自由的百科全书 The Microsoft Error Lookup Tool - Win32 apps - Microsoft Docs" }, { "title": "无法加载为扩展“Microsoft.VisualStudio.Diagnostics.ServiceModelSink.Behavior”注册的类型", "url": "/post/wcf-exception-microsoft-visualstudio-diagnostics-servicemodelsink-behavior.html", "categories": "", "tags": "dotnet", "date": "2021-06-11 14:34:28 +0800", "snippet": "一天，某用户反馈过来说我们的软件无法运行，我一看异常信息看到了这个：“System.Configuration.ConfigurationErrorsException: 无法加载为扩展“Microsoft.VisualStudio.Diagnostics.ServiceModelSink.Behavior”注册的类型“Microsoft.VisualStudio.Diagnostics.ServiceModelSink.Behavior, Microsoft.VisualStudio.Diagnostics.ServiceModelSink, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a”。 (C:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\Config\\machine.config line 232)”。异常异常的完整堆栈如下：System.Configuration.ConfigurationErrorsException: 无法加载为扩展“Microsoft.VisualStudio.Diagnostics.ServiceModelSink.Behavior”注册的类型“Microsoft.VisualStudio.Diagnostics.ServiceModelSink.Behavior, Microsoft.VisualStudio.Diagnostics.ServiceModelSink, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a”。 (C:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\Config\\machine.config line 232) 在 System.Configuration.BaseConfigurationRecord.EvaluateOne(String[] keys, SectionInput input, Boolean isTrusted, FactoryRecord factoryRecord, SectionRecord sectionRecord, Object parentResult) 在 System.Configuration.BaseConfigurationRecord.Evaluate(FactoryRecord factoryRecord, SectionRecord sectionRecord, Object parentResult, Boolean getLkg, Boolean getRuntimeObject, Object&amp;amp; result, Object&amp;amp; resultRuntimeObject) 在 System.Configuration.BaseConfigurationRecord.GetSectionRecursive(String configKey, Boolean getLkg, Boolean checkPermission, Boolean getRuntimeObject, Boolean requestIsHere, Object&amp;amp; result, Object&amp;amp; resultRuntimeObject) 在 System.Configuration.BaseConfigurationRecord.GetSectionRecursive(String configKey, Boolean getLkg, Boolean checkPermission, Boolean getRuntimeObject, Boolean requestIsHere, Object&amp;amp; result, Object&amp;amp; resultRuntimeObject) 在 System.Configuration.BaseConfigurationRecord.GetSectionRecursive(String configKey, Boolean getLkg, Boolean checkPermission, Boolean getRuntimeObject, Boolean requestIsHere, Object&amp;amp; result, Object&amp;amp; resultRuntimeObject) 在 System.Configuration.BaseConfigurationRecord.GetSectionRecursive(String configKey, Boolean getLkg, Boolean checkPermission, Boolean getRuntimeObject, Boolean requestIsHere, Object&amp;amp; result, Object&amp;amp; resultRuntimeObject) 在 System.Configuration.BaseConfigurationRecord.GetSection(String configKey) 在 System.Configuration.ClientConfigurationSystem.System.Configuration.Internal.IInternalConfigSystem.GetSection(String sectionName) 在 System.Configuration.ConfigurationManager.GetSection(String sectionName) 在 System.ServiceModel.Activation.AspNetEnvironment.UnsafeGetSectionFromConfigurationManager(String sectionPath) 在 System.ServiceModel.Activation.AspNetEnvironment.UnsafeGetConfigurationSection(String sectionPath) 在 System.ServiceModel.Configuration.ConfigurationHelpers.UnsafeGetAssociatedSection(ContextInformation evalContext, String sectionPath) 在 System.ServiceModel.Description.ConfigLoader.LookupCommonBehaviors(ContextInformation context) 在 System.ServiceModel.Description.ConfigLoader.LoadServiceDescription(ServiceHostBase host, ServiceDescription description, ServiceElement serviceElement, Action`1 addBaseAddress, Boolean skipHost) 在 System.ServiceModel.ServiceHostBase.LoadConfigurationSectionInternal(ConfigLoader configLoader, ServiceDescription description, ServiceElement serviceSection) 在 System.ServiceModel.ServiceHostBase.ApplyConfiguration() 在 System.ServiceModel.ServiceHost.ApplyConfiguration() 在 System.ServiceModel.ServiceHostBase.InitializeDescription(UriSchemeKeyedCollection baseAddresses) 在 System.ServiceModel.ServiceHost.InitializeDescription(Type serviceType, UriSchemeKeyedCollection baseAddresses) 在 System.ServiceModel.ServiceHost..ctor(Type serviceType, Uri[] baseAddresses) 在 Walterlv.DemoLib.IPC.WCF.Duplex.Pipe.Server..ctor(Uri address, String serverId, IClientInfoBuilder clientInfoBuilder) 在 Walterlv.DemoApp.IPCLinks.IPCCloudLinkProvider..ctor(String identity, IClientInfoBuilder clientInfoBuilder) 在 Walterlv.DemoApp.IPCLinks.IPCLinkProviderFactory.Build(IIPCLinkEnvironment environment, IClientInfoBuilder clientInfoBuilder) 在 Walterlv.DemoApp.Tasks.IPCLinkInitializeStartup.RunAsync(IStartupContext context) 在 Walterlv.DemoApp.Startup.Core.StartupTask.&amp;lt;&amp;gt;c__DisplayClass0_0.&amp;lt;&amp;lt;JoinAsync&amp;gt;b__0&amp;gt;d.MoveNext()--- 引发异常的上一位置中堆栈跟踪的末尾 --- 在 System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) 在 System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) 在 Walterlv.DemoApp.Startup.Core.StartupTask.&amp;lt;JoinAsync&amp;gt;d__0.MoveNext()--- 引发异常的上一位置中堆栈跟踪的末尾 --- 在 System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) 在 System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) 在 Walterlv.DemoApp.Startup.Core.StartupTaskWrapper.&amp;lt;&amp;gt;c__DisplayClass36_0.&amp;lt;&amp;lt;ExecuteTask&amp;gt;b__1&amp;gt;d.MoveNext()初步探索这个异常消息提示基本已经把表层原因说得很明白了：System.Configuration.ConfigurationErrorsException: 无法加载为扩展“Microsoft.VisualStudio.Diagnostics.ServiceModelSink.Behavior”注册的类型“Microsoft.VisualStudio.Diagnostics.ServiceModelSink.Behavior, Microsoft.VisualStudio.Diagnostics.ServiceModelSink, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a”。 (C:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\Config\\machine.config line 232)即“C:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\Config\\machine.config”文件的 232 行有一个关于 Microsoft.VisualStudio.Diagnostics.ServiceModelSink.Behavior 注册的类型无法加载。我打开那个文件，看到了相关行：&amp;lt;commonBehaviors&amp;gt;&amp;lt;endpointBehaviors&amp;gt;&amp;lt;Microsoft.VisualStudio.Diagnostics.ServiceModelSink.Behavior/&amp;gt;&amp;lt;/endpointBehaviors&amp;gt;&amp;lt;serviceBehaviors&amp;gt;&amp;lt;Microsoft.VisualStudio.Diagnostics.ServiceModelSink.Behavior/&amp;gt;&amp;lt;/serviceBehaviors&amp;gt;&amp;lt;/commonBehaviors&amp;gt;&amp;lt;/system.serviceModel&amp;gt;修复方法将这一行里面的 Microsoft.VisualStudio.Diagnostics.ServiceModelSink.Behavior 部分删除后问题即解决。也就是说，这一行会变成：&amp;lt;commonBehaviors&amp;gt;&amp;lt;endpointBehaviors&amp;gt;&amp;lt;/endpointBehaviors&amp;gt;&amp;lt;serviceBehaviors&amp;gt;&amp;lt;/serviceBehaviors&amp;gt;&amp;lt;/commonBehaviors&amp;gt;&amp;lt;/system.serviceModel&amp;gt;至于元素开闭不匹配的问题不用关心，放到整个文件中是匹配的。（不知道是什么程序写成这样的格式化乱的 XML 文件。）记得要以管理员权限保存。如果目标电脑没有好用的编辑器，可将其复制到桌面等低权限的目录下，编辑好再放回去。额外说明无需担心删除这一行会造成什么不良影响，因为正常情况下没有装 Visual Studio 的电脑上，这个文件本就不应该有这一行的。（感谢 @kkwpsv 在 Win7/10 虚拟机中的试验。）至于目标电脑上究竟是为什么会导致没有 Visual Studio 时注册了一个 WCF 的行为扩展，这就不得而知了……（如果你知道，欢迎评论区教教我！）参考资料 [ServiceModel Registration Tool (ServiceModelReg.exe) - WCF Microsoft Docs](https://docs.microsoft.com/en-us/dotnet/framework/wcf/servicemodelreg-exe?redirectedfrom=MSDN) What is Microsoft.VisualStudio.Diagnostics.ServiceModelSink.dll? .net - microsoft.visualstudio.diagnostics.servicemodelsink.dll – present on most systems, missing on new system - Stack Overflow visual studio 2010 - ‘Microsoft.VisualStudio.Diagnostics.ServiceModelSink.Behavior’ could not be loaded - Stack Overflow c# - WCF and Windows Store apps, ConfigurationErrorsException - Stack Overflow iis 7 - WCF: Routing service and “Unable to automatically debug ‘service name’. The remote procedure could not be debugged - Stack Overflow" }, { "title": ".NET 单个异步任务如何同时监听多个取消请求（CancellationToken）", "url": "/post/a-single-task-listen-to-multiple-cancellation-requests.html", "categories": "", "tags": "dotnet", "date": "2021-06-11 09:13:06 +0800", "snippet": "异步编程中，并不是所有时候 await 等的都是新的异步任务；有时候同一个异步任务可能被多次等待，并且每个等待都可以有自己的取消请求，即 CancellationToken。那么如何在一个异步任务中同时响应多个取消请求呢？可被多次 await 的单个任务我们先来列举一个最简单的例子，用来作为多次取消请求的示例。class WalterlvDemoClass{ private readonly CancellationToken _currentCancellationToken = default; public async Task DoSomethingAsync(CancellationToken cancellationToken) { // 省略真正的异步代码。 }}现在，DoSomethingAsync 可能被调用多次，但执行的都是同一件事情。当任务完成时所有 await 全部等待完成，当任务取消时所有 await 全部取消。合并 CancellationToken合并 CancellationToken 的方法是：var token = CancellationTokenSource.CreateLinkedTokenSource(token1, token2)合并完成后的 CancellationToken 在两者任一个取消时都会被取消。于是我们前面的 DoSomethingAsync 加一行即可： class WalterlvDemoClass { private readonly CancellationToken _currentCancellationToken = default; public async Task DoSomethingAsync(CancellationToken cancellationToken) {++ _currentCancellationToken = CancellationTokenSource.CreateLinkedTokenSource(_currentCancellationToken, cancellationToken);++ // 省略真正的异步代码，需要判断取消请求时，判断 _currentCancellationToken。 } }参考资料 How to: Listen for Multiple Cancellation Requests - Microsoft Docs" }, { "title": "从零开始制作 NuGet 源代码包（全面支持 .NET Core / .NET Framework / WPF 项目）", "url": "/post/build-source-code-package-for-wpf-projects.html", "categories": "", "tags": "dotnet, csharp, visualstudio, nuget, msbuild, roslyn, wpf", "date": "2021-06-07 15:14:39 +0800", "snippet": "默认情况下，我们打包 NuGet 包时，目标项目安装我们的 NuGet 包会引用我们生成的库文件（dll）。除此之外，我们也可以专门做 NuGet 工具包，还可以做 NuGet 源代码包。然而做源代码包可能是其中最困难的一种了，目标项目安装完后，这些源码将直接随目标项目一起编译。本文将从零开始，教你制作一个支持 .NET 各种类型项目的源代码包。前置知识在开始制作一个源代码包之间，建议你提前了解项目文件的一些基本概念： 理解 C# 项目 csproj 文件格式的本质和编译流程当然就算不了解也没有关系。跟着本教程你也可以制作出来一个源代码包，只不过可能遇到了问题的时候不容易调试和解决。制作一个源代码包接下来，我们将从零开始制作一个源代码包。我们接下来的将创建一个完整的解决方案，这个解决方案包括： 一个将打包成源代码包的项目 一个调试专用的项目（可选） 一个测试源代码包的项目（可选）第一步：创建一个 .NET 项目像其他 NuGet 包的引用项目一样，我们需要创建一个空的项目。不过差别是我们需要创建的是控制台程序。当创建好之后，Main 函数中的所有内容都是不需要的，于是我们删除 Main 函数中的所有内容但保留 Main 函数。这时 Program.cs 中的内容如下：namespace Walterlv.PackageDemo.SourceCode{ class Program { static void Main(string[] args) { } }}双击创建好的项目的项目，或者右键项目 “编辑项目文件”，我们可以编辑此项目的 csproj 文件。在这里，我将目标框架改成了 net48。实际上如果我们不制作动态源代码生成，那么这里无论填写什么目标框架都不重要。在这篇博客中，我们主要篇幅都会是做静态源代码生成，所以你大可不必关心这里填什么。提示：如果 net48 让你无法编译这个项目，说明你电脑上没有装 .NET Framework 4.8 框架，请改成 net473, net472, net471, net47, net462, net 461, net46, net45, netcoreapp3.0, netcoreapp2.1, netcoreapp2.0 中的任何一个可以让你编译通过的目标框架即可。&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;OutputType&amp;gt;Exe&amp;lt;/OutputType&amp;gt; &amp;lt;TargetFramework&amp;gt;net48&amp;lt;/TargetFramework&amp;gt; &amp;lt;/PropertyGroup&amp;gt;&amp;lt;/Project&amp;gt;第二步：组织项目的目录结构接下来，我们会让这个项目像一个 NuGet 包的样子。当然，是 NuGet 源代码包。请在你的项目当中创建这些文件和文件夹：- Assets - build + Package.props + Package.targets - buildMultiTargeting + Package.props + Package.targets - src + Foo.cs - tools+ Program.cs在这里，- 号表示文件夹，+ 号表示文件。Program.cs 是我们一开始就已经有的，可以不用管。src 文件夹里的 Foo.cs 是我随意创建的一个类，你就想往常创建正常的类文件一样创建一些类就好了。比如我的 Foo.cs 里面的内容很简单：using System;namespace Walterlv.PackageDemo.SourceCode{ internal class Foo { public static void Print() =&amp;gt; Console.WriteLine(&quot;Walterlv is a 逗比.&quot;); }}props 和 targets 文件你可能在 Visual Studio 的新建文件的模板中找不到这样的模板文件。这不重要，你随便创建一个文本文件，然后将名称修改成上面列举的那样即可。接下来我们会依次修改这些文件中的所有内容，所以无需担心模板自动为我们生成了哪些内容。为了更直观，我将我的解决方案截图贴出来，里面包含所有这些文件和文件夹的解释。我特别说明了哪些文件和文件夹是必须存在的，哪些文件和文件夹的名称一定必须与本文说明的一样。如果你是以教程的方式阅读本文，建议所有的文件和文件夹都跟我保持一样的结构和名称；如果你已经对 NuGet 包的结构有一定了解，那么可自作主张修改一些名称。第三步：编写项目文件 csproj现在，我们要双击项目名称或者右键“编辑项目文件”来编辑项目的 csproj 文件我们编辑项目文件的目的，是让我们前一步创建的项目文件夹结构真正成为 NuGet 包中的文件夹结构。&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;OutputType&amp;gt;Exe&amp;lt;/OutputType&amp;gt; &amp;lt;TargetFramework&amp;gt;net48&amp;lt;/TargetFramework&amp;gt; &amp;lt;!-- 要求此项目编译时要生成一个 NuGet 包。--&amp;gt; &amp;lt;GeneratePackageOnBuild&amp;gt;true&amp;lt;/GeneratePackageOnBuild&amp;gt; &amp;lt;!-- 这里为了方便，我将 NuGet 包的输出路径设置在了解决方案根目录的 bin 文件夹下，而不是项目的 bin 文件夹下。--&amp;gt; &amp;lt;PackageOutputPath&amp;gt;..\\bin\\$(Configuration)&amp;lt;/PackageOutputPath&amp;gt; &amp;lt;!-- 创建 NuGet 包时，项目的输出文件对应到 NuGet 包的 tools 文件夹，这可以避免目标项目引用我们的 NuGet 包的输出文件。 同时，如果将来我们准备动态生成源代码，而不只是引入静态源代码，还可以有机会运行我们 Program 中的 Main 函数。--&amp;gt; &amp;lt;BuildOutputTargetFolder&amp;gt;tools&amp;lt;/BuildOutputTargetFolder&amp;gt; &amp;lt;!-- 此包将不会传递依赖。意味着如果目标项目安装了此 NuGet 包，那么安装目标项目包的项目不会间接安装此 NuGet 包。--&amp;gt; &amp;lt;DevelopmentDependency&amp;gt;true&amp;lt;/DevelopmentDependency&amp;gt; &amp;lt;!-- 包的版本号，我们设成了一个预览版；当然你也可以设置为正式版，即没有后面的 -alpha 后缀。--&amp;gt; &amp;lt;Version&amp;gt;0.1.0-alpha&amp;lt;/Version&amp;gt; &amp;lt;!-- 设置包的作者。在上传到 nuget.org 之后，如果作者名与 nuget.org 上的账号名相同，其他人浏览包是可以直接点击链接看作者页面。--&amp;gt; &amp;lt;Authors&amp;gt;walterlv&amp;lt;/Authors&amp;gt; &amp;lt;!-- 设置包的组织名称。我当然写成我所在的组织 dotnet 职业技术学院啦。--&amp;gt; &amp;lt;Company&amp;gt;dotnet-campus&amp;lt;/Company&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;!-- 在生成 NuGet 包之前，我们需要将我们项目中的文件夹结构一一映射到 NuGet 包中。--&amp;gt; &amp;lt;Target Name=&quot;IncludeAllDependencies&quot; BeforeTargets=&quot;_GetPackageFiles&quot;&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;!-- 将 Package.props / Package.targets 文件的名称在 NuGet 包中改为需要的真正名称。 因为 NuGet 包要自动导入 props 和 targets 文件，要求文件的名称必须是 包名.props 和 包名.targets； 然而为了避免我们改包名的时候还要同步改四个文件的名称，所以就在项目文件中动态生成。--&amp;gt; &amp;lt;None Include=&quot;Assets\\build\\Package.props&quot; Pack=&quot;True&quot; PackagePath=&quot;build\\$(PackageId).props&quot; /&amp;gt; &amp;lt;None Include=&quot;Assets\\build\\Package.targets&quot; Pack=&quot;True&quot; PackagePath=&quot;build\\$(PackageId).targets&quot; /&amp;gt; &amp;lt;None Include=&quot;Assets\\buildMultiTargeting\\Package.props&quot; Pack=&quot;True&quot; PackagePath=&quot;buildMultiTargeting\\$(PackageId).props&quot; /&amp;gt; &amp;lt;None Include=&quot;Assets\\buildMultiTargeting\\Package.targets&quot; Pack=&quot;True&quot; PackagePath=&quot;buildMultiTargeting\\$(PackageId).targets&quot; /&amp;gt; &amp;lt;!-- 我们将 src 目录中的所有源代码映射到 NuGet 包中的 src 目录中。--&amp;gt; &amp;lt;None Include=&quot;Assets\\src\\**&quot; Pack=&quot;True&quot; PackagePath=&quot;src&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;/Target&amp;gt;&amp;lt;/Project&amp;gt;第四步：编写编译文件 targets接下来，我们将编写编译文件 props 和 targets。注意，我们需要写的是四个文件的内容，不要弄错了。如果我们做好的 NuGet 源码包被其他项目使用，那么这四个文件中的其中一对会在目标项目被自动导入（Import）。在你理解 理解 C# 项目 csproj 文件格式的本质和编译流程 一文内容之前，你可能不明白“导入”是什么意思。但作为从零开始的入门博客，你也不需要真的理解导入是什么意思，只要知道这四个文件中的代码将在目标项目编译期间运行就好。buildMultiTargeting 文件夹中的 Package.props 文件你只需要将下面的代码拷贝到 buildMultiTargeting 文件夹中的 Package.props 文件即可。注意将包名换成你自己的包名，也就是项目名。&amp;lt;Project&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;MSBuildAllProjects&amp;gt;$(MSBuildAllProjects);$(MSBuildThisFileFullPath)&amp;lt;/MSBuildAllProjects&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;!-- 为了简单起见，如果导入了这个文件，那么我们将直接再导入 ..\\build\\Walterlv.PackageDemo.SourceCode.props 文件。 注意到了吗？我们并没有写 Package.props，因为我们在第三步编写项目文件时已经将这个文件转换为真实的包名了。--&amp;gt; &amp;lt;Import Project=&quot;..\\build\\Walterlv.PackageDemo.SourceCode.props&quot; /&amp;gt;&amp;lt;/Project&amp;gt;buildMultiTargeting 文件夹中的 Package.targets 文件你只需要将下面的代码拷贝到 buildMultiTargeting 文件夹中的 Package.targets 文件即可。注意将包名换成你自己的包名，也就是项目名。&amp;lt;Project&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;MSBuildAllProjects&amp;gt;$(MSBuildAllProjects);$(MSBuildThisFileFullPath)&amp;lt;/MSBuildAllProjects&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;!-- 为了简单起见，如果导入了这个文件，那么我们将直接再导入 ..\\build\\Walterlv.PackageDemo.SourceCode.targets 文件。 注意到了吗？我们并没有写 Package.targets，因为我们在第三步编写项目文件时已经将这个文件转换为真实的包名了。--&amp;gt; &amp;lt;Import Project=&quot;..\\build\\Walterlv.PackageDemo.SourceCode.targets&quot; /&amp;gt;&amp;lt;/Project&amp;gt;build 文件夹中的 Package.props 文件下面是 build 文件夹中 Package.props 文件的全部内容。可以注意到我们几乎没有任何实质性的代码在里面。即便我们在此文件中还没有写任何代码，依然需要创建这个文件，因为后面第五步我们将添加更复杂的代码时将再次用到这个文件完成里面的内容。现在，保持你的文件中的内容与下面一模一样就好。&amp;lt;Project&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;MSBuildAllProjects&amp;gt;$(MSBuildAllProjects);$(MSBuildThisFileFullPath)&amp;lt;/MSBuildAllProjects&amp;gt; &amp;lt;/PropertyGroup&amp;gt;&amp;lt;/Project&amp;gt;build 文件夹中的 Package.targets 文件下面是 build 文件夹中的 Package.targets 文件的全部内容。我们写了两个编译目标，即 Target。_WalterlvDemoEvaluateProperties 没有指定任何执行时机，但帮我们计算了两个属性： _WalterlvDemoRoot 即 NuGet 包的根目录 _WalterlvDemoSourceFolder 即 NuGet 包中的源代码目录另外，我们添加了一个 Message 任务，用于在编译期间显示一条信息，这对于调试来说非常方便。_WalterlvDemoIncludeSourceFiles 这个编译目标指定在 CoreCompile 之前执行，并且执行需要依赖于 _WalterlvDemoEvaluateProperties 编译目标。这意味着当编译执行到 CoreCompile 步骤时，将在它执行之前插入 _WalterlvDemoIncludeSourceFiles 编译目标来执行，而 _WalterlvDemoIncludeSourceFiles 依赖于 _WalterlvDemoEvaluateProperties，于是 _WalterlvDemoEvaluateProperties 会插入到更之前执行。那么在微观上来看，这三个编译任务的执行顺序将是：_WalterlvDemoEvaluateProperties -&amp;gt; _WalterlvDemoIncludeSourceFiles -&amp;gt; CoreCompile。_WalterlvDemoIncludeSourceFiles 中，我们定义了一个集合 _WalterlvDemoCompile，集合中包含 NuGet 包源代码文件夹中的所有 .cs 文件。另外，我们又定义了 Compile 集合，将 _WalterlvDemoCompile 集合中的所有内容添加到 Compile 集合中。Compile 是 .NET 项目中的一个已知集合，当 CoreCompile 执行时，所有 Compile 集合中的文件将参与编译。注意到我没有直接将 NuGet 包中的源代码文件引入到 Compile 集合中，而是经过了中转。后面第五步中，你将体会到这样做的作用。我们也添加一个 Message 任务，用于在编译期间显示信息，便于调试。&amp;lt;Project&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;MSBuildAllProjects&amp;gt;$(MSBuildAllProjects);$(MSBuildThisFileFullPath)&amp;lt;/MSBuildAllProjects&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;Target Name=&quot;_WalterlvDemoEvaluateProperties&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;_WalterlvDemoRoot&amp;gt;$(MSBuildThisFileDirectory)..\\&amp;lt;/_WalterlvDemoRoot&amp;gt; &amp;lt;_WalterlvDemoSourceFolder&amp;gt;$(MSBuildThisFileDirectory)..\\src\\&amp;lt;/_WalterlvDemoSourceFolder&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;Message Text=&quot;1. 初始化源代码包的编译属性&quot; /&amp;gt; &amp;lt;/Target&amp;gt; &amp;lt;!-- 引入 C# 源码。 --&amp;gt; &amp;lt;Target Name=&quot;_WalterlvDemoIncludeSourceFiles&quot; BeforeTargets=&quot;CoreCompile&quot; DependsOnTargets=&quot;_WalterlvDemoEvaluateProperties&quot;&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;_WalterlvDemoCompile Include=&quot;$(_WalterlvDemoSourceFolder)**\\*.cs&quot; /&amp;gt; &amp;lt;Compile Include=&quot;@(_WalterlvDemoCompile)&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;Message Text=&quot;2 引入源代码包中的所有源代码：@(_WalterlvDemoCompile)&quot; /&amp;gt; &amp;lt;/Target&amp;gt;&amp;lt;/Project&amp;gt;这四个文件分别的作用我们刚刚花了很大的篇幅教大家完成 props 和 targets 文件，那么这四个文件是做什么的呢？如果安装我们源代码包的项目使用 TargetFramework 属性写目标框架，那么 NuGet 会自动帮我们导入 build 文件夹中的两个编译文件。如果安装我们源代码包的项目使用 TargetFrameworks（注意复数形式）属性写目标框架，那么 NuGet 会自动帮我们导入 buildMultiTargeting 文件夹中的两个编译文件。如果你对这个属性不熟悉，请回到第一步看我们一开始创建的代码，你会看到这个属性的设置的。如果还不清楚，请阅读博客： 让一个 csproj 项目指定多个开发框架体验和查看 NuGet 源代码包也许你已经从本文拷贝了很多代码过去了，但直到目前我们还没有看到这些代码的任何效果，那么现在我们就可以来看看了。这可算是一个阶段性成果呢！先编译生成一下我们一直在完善的项目，我们就可以在解决方案目录的 bin\\Debug 目录下找到一个 NuGet 包。现在，我们要打开这个 NuGet 包看看里面的内容。你需要先去应用商店下载 NuGet Package Explorer，装完之后你就可以开始直接双击 NuGet 包文件，也就是 nupkg 文件。现在我们双击打开看看。我们的体验到此为止。如果你希望在真实的项目当中测试，可以阅读其他博客了解如何在本地测试 NuGet 包。第五步：加入 WPF 项目支持截至目前，我们只是在源代码包中引入了 C# 代码。如果我们需要加入到源代码包中的代码包含 WPF 的 XAML 文件，或者安装我们源代码包的目标项目包含 WPF 的 XAML 文件，那么这个 NuGet 源代码包直接会导致无法编译通过。至于原因，你需要阅读我的另一篇博客来了解： WPF 程序的编译过程即便你不懂 WPF 程序的编译过程，你也可以继续完成本文的所有内容，但可能就不会明白为什么接下来我们要那样去修改我们之前创建的文件。接下来我们将修改这些文件： build 文件夹中的 Package.props 文件 build 文件夹中的 Package.targets 文件build 文件夹中的 Package.props 文件自微软在 .NET SDK 5.0.2 开始修复了 WPF 项目中 NuGet 代码生成器的 bug 后，已经不需要在这里新增属性了。当然，如果你想增加其他的属性则可以在这里加。关于这个 bug，详见：[release/5.0] Support Source Generators in WPF projects by ryalanms · Pull Request #3846 · dotnet/wpf在这个文件中，我们将新增一个属性 ShouldFixNuGetImportingBugForWpfProjects。这是我取的名字，意为“是否应该修复 WPF 项目中 NuGet 包自动导入的问题”。我做一个开关的原因是怀疑我们需要针对 WPF 项目进行特殊处理是 WPF 项目自身的 Bug，如果将来 WPF 修复了这个 Bug，那么我们将可以直接通过此开关来关闭我们在这一节做的特殊处理。另外，后面我们将采用一些特别的手段来调试我们的 NuGet 源代码包，在调试项目中我们也会将这个属性设置为 False 以关闭 WPF 项目的特殊处理。&amp;lt;Project&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;MSBuildAllProjects&amp;gt;$(MSBuildAllProjects);$(MSBuildThisFileFullPath)&amp;lt;/MSBuildAllProjects&amp;gt;-- &amp;lt;!-- 当生成 WPF 临时项目时，不会自动 Import NuGet 中的 props 和 targets 文件，这使得在临时项目中你现在看到的整个文件都不会参与编译。-- 然而，我们可以通过欺骗的方式在主项目中通过 _GeneratedCodeFiles 集合将需要编译的文件传递到临时项目中以间接参与编译。-- WPF 临时项目不会 Import NuGet 中的 props 和 targets 可能是 WPF 的 Bug，也可能是刻意如此。-- 所以我们通过一个属性开关 `ShouldFixNuGetImportingBugForWpfProjects` 来决定是否修复这个错误。--&amp;gt;-- &amp;lt;ShouldFixNuGetImportingBugForWpfProjects Condition=&quot; &#39;$(ShouldFixNuGetImportingBugForWpfProjects)&#39; == &#39;&#39; &quot;&amp;gt;True&amp;lt;/ShouldFixNuGetImportingBugForWpfProjects&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;/Project&amp;gt;build 文件夹中的 Package.targets 文件请按照下面的差异说明来修改你的 Package.targets 文件。实际上我们几乎删除任何代码，所以其实你可以将下面的所有内容作为你的新的 Package.targets 中的内容。 &amp;lt;Project&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;MSBuildAllProjects&amp;gt;$(MSBuildAllProjects);$(MSBuildThisFileFullPath)&amp;lt;/MSBuildAllProjects&amp;gt; &amp;lt;/PropertyGroup&amp;gt;++ &amp;lt;PropertyGroup&amp;gt;++ &amp;lt;!-- 我们增加了一个属性，用于处理 WPF 特殊项目的源代码之前，确保我们已经收集到所有需要引入的源代码。 --&amp;gt;++ &amp;lt;_WalterlvDemoImportInWpfTempProjectDependsOn&amp;gt;_WalterlvDemoIncludeSourceFiles&amp;lt;/_WalterlvDemoImportInWpfTempProjectDependsOn&amp;gt;++ &amp;lt;/PropertyGroup&amp;gt; &amp;lt;Target Name=&quot;_WalterlvDemoEvaluateProperties&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;_WalterlvDemoRoot&amp;gt;$(MSBuildThisFileDirectory)..\\&amp;lt;/_WalterlvDemoRoot&amp;gt; &amp;lt;_WalterlvDemoSourceFolder&amp;gt;$(MSBuildThisFileDirectory)..\\src\\&amp;lt;/_WalterlvDemoSourceFolder&amp;gt;++ &amp;lt;!-- 修复旧版本的 Microsoft.NET.Sdk 中，WPF 项目不支持在临时项目中通过 NuGet 包生成源代码的问题。++ 微软自称从 .NET 5.0.2 开始，可通过 IncludePackageReferencesDuringMarkupCompilation 属性来支持在 NuGet 包中生成源代码，该值默认为 true。++ 不过，在低版本的 .NET 中，或者用户主动设置此值为 false 时，依然需要修复此问题。++ 以下是此问题的描述：--&amp;gt;++ &amp;lt;!-- 当生成 WPF 临时项目时，不会自动 Import NuGet 中的 props 和 targets 文件，这使得在临时项目中你现在看到的整个文件都不会参与编译。++ 然而，我们可以通过欺骗的方式在主项目中通过 _GeneratedCodeFiles 集合将需要编译的文件传递到临时项目中以间接参与编译。++ WPF 临时项目不会 Import NuGet 中的 props 和 targets 可能是 WPF 的 Bug，也可能是刻意如此。++ 所以我们通过一个属性开关 `ShouldFixNuGetImportingBugForWpfProjects` 来决定是否修复这个错误。--&amp;gt;++ &amp;lt;ShouldFixNuGetImportingBugForWpfProjects Condition=&quot; &#39;$(IncludePackageReferencesDuringMarkupCompilation)&#39; != &#39;True&#39; And &#39;$(ShouldFixNuGetImportingBugForWpfProjects)&#39; == &#39;&#39; &quot;&amp;gt;True&amp;lt;/ShouldFixNuGetImportingBugForWpfProjects&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;Message Text=&quot;1. 初始化源代码包的编译属性&quot; /&amp;gt; &amp;lt;/Target&amp;gt; &amp;lt;!-- 引入 C# 源码。 --&amp;gt; &amp;lt;Target Name=&quot;_WalterlvDemoIncludeSourceFiles&quot; BeforeTargets=&quot;CoreCompile&quot; DependsOnTargets=&quot;_WalterlvDemoEvaluateProperties&quot;&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;_WalterlvDemoCompile Include=&quot;$(_WalterlvDemoSourceFolder)**\\*.cs&quot; /&amp;gt;++ &amp;lt;_WalterlvDemoAllCompile Include=&quot;@(_WalterlvDemoCompile)&quot; /&amp;gt; &amp;lt;Compile Include=&quot;@(_WalterlvDemoCompile)&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt;-- &amp;lt;Message Text=&quot;2 引入源代码包中的所有源代码：@(_WalterlvDemoCompile)&quot; /&amp;gt;++ &amp;lt;Message Text=&quot;2.1 引入源代码包中的所有源代码：@(_WalterlvDemoCompile)&quot; /&amp;gt; &amp;lt;/Target&amp;gt;++ &amp;lt;!-- 引入 WPF 源码。 --&amp;gt;++ &amp;lt;Target Name=&quot;_WalterlvDemoIncludeWpfFiles&quot;++ BeforeTargets=&quot;MarkupCompilePass1&quot;++ DependsOnTargets=&quot;_WalterlvDemoEvaluateProperties&quot;&amp;gt;++ &amp;lt;ItemGroup&amp;gt;++ &amp;lt;_WalterlvDemoPage Include=&quot;$(_WalterlvDemoSourceFolder)**\\*.xaml&quot; /&amp;gt;++ &amp;lt;Page Include=&quot;@(_WalterlvDemoPage)&quot; Link=&quot;%(_WalterlvDemoPage.FileName).xaml&quot; /&amp;gt;++ &amp;lt;/ItemGroup&amp;gt;++ &amp;lt;Message Text=&quot;2.2 引用 WPF 相关源码：@(_WalterlvDemoPage)&quot; /&amp;gt;++ &amp;lt;/Target&amp;gt;++ &amp;lt;!-- 当生成 WPF 临时项目时，不会自动 Import NuGet 中的 props 和 targets 文件，这使得在临时项目中你现在看到的整个文件都不会参与编译。++ 然而，我们可以通过欺骗的方式在主项目中通过 _GeneratedCodeFiles 集合将需要编译的文件传递到临时项目中以间接参与编译。++ WPF 临时项目不会 Import NuGet 中的 props 和 targets 可能是 WPF 的 Bug，也可能是刻意如此。++ 所以我们通过一个属性开关 `ShouldFixNuGetImportingBugForWpfProjects` 来决定是否修复这个错误。--&amp;gt;++ &amp;lt;Target Name=&quot;_WalterlvDemoImportInWpfTempProject&quot;++ AfterTargets=&quot;MarkupCompilePass1&quot;++ BeforeTargets=&quot;GenerateTemporaryTargetAssembly&quot;++ DependsOnTargets=&quot;$(_WalterlvDemoImportInWpfTempProjectDependsOn)&quot;++ Condition=&quot; &#39;$(ShouldFixNuGetImportingBugForWpfProjects)&#39; == &#39;True&#39; &quot;&amp;gt;++ &amp;lt;ItemGroup&amp;gt;++ &amp;lt;_GeneratedCodeFiles Include=&quot;@(_WalterlvDemoAllCompile)&quot; /&amp;gt;++ &amp;lt;/ItemGroup&amp;gt;++ &amp;lt;Message Text=&quot;3. 正在欺骗临时项目，误以为此 NuGet 包中的文件是 XAML 编译后的中间代码：@(_WalterlvDemoAllCompile)&quot; /&amp;gt;++ &amp;lt;/Target&amp;gt; &amp;lt;/Project&amp;gt;我们增加了 _WalterlvDemoImportInWpfTempProjectDependsOn 属性，这个属性里面将填写一个到多个编译目标（Target）的名称（多个用分号分隔），用于告知 _WalterlvDemoImportInWpfTempProject 这个编译目标在执行之前必须确保执行的依赖编译目标。而我们目前的依赖目标只有一个，就是 _WalterlvDemoIncludeSourceFiles 这个引入 C# 源代码的编译目标。如果你有其他考虑有引入更多 C# 源代码的编译目标，则需要把他们都加上（当然本文是不需要的）。为此，我还新增了一个 _WalterlvDemoAllCompile 集合，如果存在多个依赖的编译目标会引入 C# 源代码，则需要像 _WalterlvDemoIncludeSourceFiles 一样，将他们都加入到 Compile 的同时也加入到 _WalterlvDemoAllCompile 集合中。为什么可能有多个引入 C# 源代码的编译目标？因为本文我们只考虑了引入我们提前准备好的源代码放入源代码包中，而我们提到过可能涉及到动态生成 C# 源代码的需求。如果你有一两个编译目标会动态生成一些 C# 源代码并将其加入到 Compile 集合中，那么请将这个编译目标的名称加入到 _WalterlvDemoImportInWpfTempProjectDependsOn 属性（注意多个用分号分隔），同时将集合也引入一份到 _WalterlvDemoAllCompile 中。_WalterlvDemoIncludeWpfFiles 这个编译目标的作用是引入 WPF 的 XAML 文件，这很容易理解，毕竟我们的源代码中包含 WPF 相关的文件。请特别注意： 我们加了一个 Link 属性，并且将其指定为 %(_WalterlvDemoPage.FileName).xaml。这意味着我们会把所有的 XAML 文件都当作在项目根目录中生成，如果你在其他的项目中用到了相对或绝对的 XAML 文件的路径，这显然会改变路径。但是，我们没有其他的方法来根据 XAML 文件所在的目录层级来自定指定 Link 属性让其在正确的层级上，所以这里才写死在根目录中。 如果要解决这个问题，我们就需要在生成 NuGet 包之前生成此项目中所有 XAML 文件的正确的 Link 属性（例如改为 Views\\%(_WalterlvDemoPage.FileName).xaml），这意味着需要在此项目编译期间执行一段代码，把 Package.targets 文件中为所有的 XAML 文件生成正确的 Link 属性。本文暂时不考虑这个问题，但你可以参考 dotnet-campus/SourceYard 项目来了解如何动态生成 Link。 我们使用了 _WalterlvDemoPage 集合中转地存了 XAML 文件，这是必要的。因为这样才能正确通过 % 符号获取到 FileName 属性。而 _WalterlvDemoImportInWpfTempProject 这个编译目标就不那么好理解了，而这个也是完美支持 WPF 项目源代码包的关键编译目标！这个编译目标指定在 MarkupCompilePass1 之后，GenerateTemporaryTargetAssembly 之前执行。GenerateTemporaryTargetAssembly 编译目标的作用是生成一个临时的项目，用于让 WPF 的 XAML 文件能够依赖同项目的 .NET 类型而编译。然而此临时项目编译期间是不会导入任何 NuGet 的 props 或 targets 文件的，这意味着我们特别添加的所有 C# 源代码在这个临时项目当中都是不存在的——如果项目使用到了我们源代码包中的源代码，那么必然因为类型不存在而无法编译通过——临时项目没有编译通过，那么整个项目也就无法编译通过。但是，我们通过在 MarkupCompilePass1 和 GenerateTemporaryTargetAssembly 之间将我们源代码包中的所有源代码加入到 _GeneratedCodeFiles 集合中，即可将这些文件加入到临时项目中一起编译。而原本 _GeneratedCodeFiles 集合中是什么呢？就是大家熟悉的 XAML 转换而成的 xxx.g.cs 文件。测试和发布源代码包现在我们再次编译这个项目，你将得到一个支持 WPF 项目的 NuGet 源代码包。完整项目结构和源代码至此，我们已经完成了编写一个 NuGet 源代码包所需的全部源码。接下来你可以在项目中添加更多的源代码，这样打出来的源代码包也将包含更多源代码。由于我们将将 XAML 文件都通过 Link 属性指定到根目录了，所以如果你需要添加 XAML 文件，你将只能添加到我们项目中的 Assets\\src 目录下，除非做 dotnet-campus/SourceYard 中类似的动态 Link 生成的处理，或者在 Package.targets 文件中手工为每一个 XAML 编写一个特别的 Link 属性。另外，在不改变我们整体项目结构的情况下，你也可以任意添加 WPF 所需的图片资源等。但也需要在 Package.targets 中添加额外的 Resource 引用。如果没有 dotnet-campus/SourceYard 的自动生成代码，你可能也需要手工编写 Resource。接下来我会贴出更复杂的代码，用于处理更复杂的源代码包的场景。目录结构更复杂源代码包的项目组织形式会是下面这样图这样：我们在 Assets 文件夹中新增了一个 assets 文件夹。由于资源在此项目中的路径必须和安装后的目标项目中一样才可以正确用 Uri 的方式使用资源，所以我们在项目文件 csproj 和编译文件 Package.targets 中都对这两个文件设置了 Link 到同一个文件夹中，这样才可以确保两边都能正常使用。我们在 src 文件夹的不同子文件夹中创建了 XAML 文件。按照我们前面的说法，我们也需要像资源文件一样正确在 Package.targets 中设置 Link 才可以确保 Uri 是一致的。注意，我们接下来的源代码中没有在项目文件中设置 Link，原则上也是需要设置的，就像资源一样，这样才可以确保此项目和安装此 NuGet 包中的目标项目具有相同的 XAML Uri。此例子只是因为没有代码使用到了 XAML 文件的路径，所以才能得以幸免。我们还利用了 tools 文件夹。我们在项目文件的末尾将输出文件拷贝到了 tools 目录下，这样，我们项目的 Assets 文件夹几乎与最终的 NuGet 包的文件夹结构一模一样，非常利于调试。但为了防止将生成的文件上传到版本管理，我在 tools 中添加了 .gitignore 文件：/net*/*项目文件-- &amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt;++ &amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk.WindowsDesktop&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;OutputType&amp;gt;Exe&amp;lt;/OutputType&amp;gt; &amp;lt;TargetFramework&amp;gt;net48&amp;lt;/TargetFramework&amp;gt;++ &amp;lt;UseWpf&amp;gt;True&amp;lt;/UseWpf&amp;gt; &amp;lt;!-- 要求此项目编译时要生成一个 NuGet 包。--&amp;gt; &amp;lt;GeneratePackageOnBuild&amp;gt;true&amp;lt;/GeneratePackageOnBuild&amp;gt; &amp;lt;!-- 这里为了方便，我将 NuGet 包的输出路径设置在了解决方案根目录的 bin 文件夹下，而不是项目的 bin 文件夹下。--&amp;gt; &amp;lt;PackageOutputPath&amp;gt;..\\bin\\$(Configuration)&amp;lt;/PackageOutputPath&amp;gt; &amp;lt;!-- 创建 NuGet 包时，项目的输出文件对应到 NuGet 包的 tools 文件夹，这可以避免目标项目引用我们的 NuGet 包的输出文件。 同时，如果将来我们准备动态生成源代码，而不只是引入静态源代码，还可以有机会运行我们 Program 中的 Main 函数。--&amp;gt; &amp;lt;BuildOutputTargetFolder&amp;gt;tools&amp;lt;/BuildOutputTargetFolder&amp;gt; &amp;lt;!-- 此包将不会传递依赖。意味着如果目标项目安装了此 NuGet 包，那么安装目标项目包的项目不会间接安装此 NuGet 包。--&amp;gt; &amp;lt;DevelopmentDependency&amp;gt;true&amp;lt;/DevelopmentDependency&amp;gt; &amp;lt;!-- 包的版本号，我们设成了一个预览版；当然你也可以设置为正式版，即没有后面的 -alpha 后缀。--&amp;gt; &amp;lt;Version&amp;gt;0.1.0-alpha&amp;lt;/Version&amp;gt; &amp;lt;!-- 设置包的作者。在上传到 nuget.org 之后，如果作者名与 nuget.org 上的账号名相同，其他人浏览包是可以直接点击链接看作者页面。--&amp;gt; &amp;lt;Authors&amp;gt;walterlv&amp;lt;/Authors&amp;gt; &amp;lt;!-- 设置包的组织名称。我当然写成我所在的组织 dotnet 职业技术学院啦。--&amp;gt; &amp;lt;Company&amp;gt;dotnet-campus&amp;lt;/Company&amp;gt; &amp;lt;/PropertyGroup&amp;gt; ++ &amp;lt;!-- 我们添加的其他资源需要在这里 Link 到一个统一的目录下，以便在此项目和安装 NuGet 包的目标项目中可以用同样的 Uri 使用。 --&amp;gt;++ &amp;lt;ItemGroup&amp;gt;++ &amp;lt;Resource Include=&quot;Assets\\assets\\Icon.ico&quot; Link=&quot;Assets\\Icon.ico&quot; Visible=&quot;False&quot; /&amp;gt;++ &amp;lt;Resource Include=&quot;Assets\\assets\\Background.png&quot; Link=&quot;Assets\\Background.png&quot; Visible=&quot;False&quot; /&amp;gt;++ &amp;lt;/ItemGroup&amp;gt; &amp;lt;!-- 在生成 NuGet 包之前，我们需要将我们项目中的文件夹结构一一映射到 NuGet 包中。--&amp;gt; &amp;lt;Target Name=&quot;IncludeAllDependencies&quot; BeforeTargets=&quot;_GetPackageFiles&quot;&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;!-- 将 Package.props / Package.targets 文件的名称在 NuGet 包中改为需要的真正名称。 因为 NuGet 包要自动导入 props 和 targets 文件，要求文件的名称必须是 包名.props 和 包名.targets； 然而为了避免我们改包名的时候还要同步改四个文件的名称，所以就在项目文件中动态生成。--&amp;gt; &amp;lt;None Include=&quot;Assets\\build\\Package.props&quot; Pack=&quot;True&quot; PackagePath=&quot;build\\$(PackageId).props&quot; /&amp;gt; &amp;lt;None Include=&quot;Assets\\build\\Package.targets&quot; Pack=&quot;True&quot; PackagePath=&quot;build\\$(PackageId).targets&quot; /&amp;gt; &amp;lt;None Include=&quot;Assets\\buildMultiTargeting\\Package.props&quot; Pack=&quot;True&quot; PackagePath=&quot;buildMultiTargeting\\$(PackageId).props&quot; /&amp;gt; &amp;lt;None Include=&quot;Assets\\buildMultiTargeting\\Package.targets&quot; Pack=&quot;True&quot; PackagePath=&quot;buildMultiTargeting\\$(PackageId).targets&quot; /&amp;gt; &amp;lt;!-- 我们将 src 目录中的所有源代码映射到 NuGet 包中的 src 目录中。--&amp;gt; &amp;lt;None Include=&quot;Assets\\src\\**&quot; Pack=&quot;True&quot; PackagePath=&quot;src&quot; /&amp;gt;++ &amp;lt;!-- 我们将 assets 目录中的所有源代码映射到 NuGet 包中的 assets 目录中。--&amp;gt;++ &amp;lt;None Include=&quot;Assets\\assets\\**&quot; Pack=&quot;True&quot; PackagePath=&quot;assets&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;/Target&amp;gt; ++ &amp;lt;!-- 在编译结束后将生成的可执行程序放到 Tools 文件夹中，使得 Assets 文件夹的目录结构与 NuGet 包非常相似，便于 Sample 项目进行及时的 NuGet 包调试。 --&amp;gt;++ &amp;lt;Target Name=&quot;_WalterlvDemoCopyOutputToDebuggableFolder&quot; AfterTargets=&quot;AfterBuild&quot;&amp;gt;++ &amp;lt;ItemGroup&amp;gt;++ &amp;lt;_WalterlvDemoToCopiedFiles Include=&quot;$(OutputPath)**&quot; /&amp;gt;++ &amp;lt;/ItemGroup&amp;gt;++ &amp;lt;Copy SourceFiles=&quot;@(_WalterlvDemoToCopiedFiles)&quot; DestinationFolder=&quot;Assets\\tools\\$(TargetFramework)&quot; /&amp;gt;++ &amp;lt;/Target&amp;gt; &amp;lt;/Project&amp;gt;编译文件 &amp;lt;Project&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;MSBuildAllProjects&amp;gt;$(MSBuildAllProjects);$(MSBuildThisFileFullPath)&amp;lt;/MSBuildAllProjects&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;!-- 我们增加了一个属性，用于处理 WPF 特殊项目的源代码之前，确保我们已经收集到所有需要引入的源代码。 --&amp;gt; &amp;lt;_WalterlvDemoImportInWpfTempProjectDependsOn&amp;gt;_WalterlvDemoIncludeSourceFiles&amp;lt;/_WalterlvDemoImportInWpfTempProjectDependsOn&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;Target Name=&quot;_WalterlvDemoEvaluateProperties&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;_WalterlvDemoRoot&amp;gt;$(MSBuildThisFileDirectory)..\\&amp;lt;/_WalterlvDemoRoot&amp;gt; &amp;lt;_WalterlvDemoSourceFolder&amp;gt;$(MSBuildThisFileDirectory)..\\src\\&amp;lt;/_WalterlvDemoSourceFolder&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;Message Text=&quot;1. 初始化源代码包的编译属性&quot; /&amp;gt; &amp;lt;/Target&amp;gt; &amp;lt;!-- 引入主要的 C# 源码。 --&amp;gt; &amp;lt;Target Name=&quot;_WalterlvDemoIncludeSourceFiles&quot; BeforeTargets=&quot;CoreCompile&quot; DependsOnTargets=&quot;_WalterlvDemoEvaluateProperties&quot;&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;_WalterlvDemoCompile Include=&quot;$(_WalterlvDemoSourceFolder)**\\*.cs&quot; /&amp;gt; &amp;lt;_WalterlvDemoAllCompile Include=&quot;@(_WalterlvDemoCompile)&quot; /&amp;gt; &amp;lt;Compile Include=&quot;@(_WalterlvDemoCompile)&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;Message Text=&quot;2.1 引入源代码包中的所有源代码：@(_WalterlvDemoCompile)&quot; /&amp;gt; &amp;lt;/Target&amp;gt; &amp;lt;!-- 引入 WPF 源码。 --&amp;gt; &amp;lt;Target Name=&quot;_WalterlvDemoIncludeWpfFiles&quot; BeforeTargets=&quot;MarkupCompilePass1&quot; DependsOnTargets=&quot;_WalterlvDemoEvaluateProperties&quot;&amp;gt; &amp;lt;ItemGroup&amp;gt;-- &amp;lt;_WalterlvDemoPage Include=&quot;$(_WalterlvDemoSourceFolder)**\\*.xaml&quot; /&amp;gt;-- &amp;lt;Page Include=&quot;@(_WalterlvDemoPage)&quot; Link=&quot;Views\\%(_WalterlvDemoPage.FileName).xaml&quot; /&amp;gt;++ &amp;lt;_WalterlvDemoRootPage Include=&quot;$(_WalterlvDemoSourceFolder)FooView.xaml&quot; /&amp;gt;++ &amp;lt;Page Include=&quot;@(_WalterlvDemoRootPage)&quot; Link=&quot;Views\\%(_WalterlvDemoRootPage.FileName).xaml&quot; /&amp;gt;++ &amp;lt;_WalterlvDemoThemesPage Include=&quot;$(_WalterlvDemoSourceFolder)Themes\\Walterlv.Windows.xaml&quot; /&amp;gt;++ &amp;lt;Page Include=&quot;@(_WalterlvDemoThemesPage)&quot; Link=&quot;Views\\%(_WalterlvDemoThemesPage.FileName).xaml&quot; /&amp;gt;++ &amp;lt;_WalterlvDemoIcoResource Include=&quot;$(_WalterlvDemoRoot)assets\\*.ico&quot; /&amp;gt;++ &amp;lt;_WalterlvDemoPngResource Include=&quot;$(_WalterlvDemoRoot)assets\\*.png&quot; /&amp;gt;++ &amp;lt;Resource Include=&quot;@(_WalterlvDemoIcoResource)&quot; Link=&quot;assets\\%(_WalterlvDemoIcoResource.FileName).ico&quot; /&amp;gt;++ &amp;lt;Resource Include=&quot;@(_WalterlvDemoPngResource)&quot; Link=&quot;assets\\%(_WalterlvDemoPngResource.FileName).png&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt;-- &amp;lt;Message Text=&quot;2.2 引用 WPF 相关源码：@(_WalterlvDemoPage);@(_WalterlvDemoIcoResource);@(_WalterlvDemoPngResource)&quot; /&amp;gt;++ &amp;lt;Message Text=&quot;2.2 引用 WPF 相关源码：@(_WalterlvDemoRootPage);@(_WalterlvDemoThemesPage);@(_WalterlvDemoIcoResource);@(_WalterlvDemoPngResource)&quot; /&amp;gt; &amp;lt;/Target&amp;gt; &amp;lt;!-- 当生成 WPF 临时项目时，不会自动 Import NuGet 中的 props 和 targets 文件，这使得在临时项目中你现在看到的整个文件都不会参与编译。 然而，我们可以通过欺骗的方式在主项目中通过 _GeneratedCodeFiles 集合将需要编译的文件传递到临时项目中以间接参与编译。 WPF 临时项目不会 Import NuGet 中的 props 和 targets 可能是 WPF 的 Bug，也可能是刻意如此。 所以我们通过一个属性开关 `ShouldFixNuGetImportingBugForWpfProjects` 来决定是否修复这个错误。--&amp;gt; &amp;lt;Target Name=&quot;_WalterlvDemoImportInWpfTempProject&quot; AfterTargets=&quot;MarkupCompilePass1&quot; BeforeTargets=&quot;GenerateTemporaryTargetAssembly&quot; DependsOnTargets=&quot;$(_WalterlvDemoImportInWpfTempProjectDependsOn)&quot; Condition=&quot; &#39;$(ShouldFixNuGetImportingBugForWpfProjects)&#39; == &#39;True&#39; &quot;&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;_GeneratedCodeFiles Include=&quot;@(_WalterlvDemoAllCompile)&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;Message Text=&quot;3. 正在欺骗临时项目，误以为此 NuGet 包中的文件是 XAML 编译后的中间代码：@(_WalterlvDemoAllCompile)&quot; /&amp;gt; &amp;lt;/Target&amp;gt; &amp;lt;/Project&amp;gt;开源项目本文涉及到的所有代码均已开源到： walterlv.demo/Walterlv.PackageDemo at master · walterlv/walterlv.demo更多内容SourceYard 开源项目本文服务于开源项目 SourceYard，为其提供支持 WPF 项目的解决方案。dotnet-campus/SourceYard: Add a NuGet package only for dll reference? By using dotnetCampus.SourceYard, you can pack a NuGet package with source code. By installing the new source code package, all source codes behaviors just like it is in your project.相关博客更多制作源代码包的博客可以阅读。从简单到复杂的顺序： 将 .NET Core 项目打一个最简单的 NuGet 源码包，安装此包就像直接把源码放进项目一样 - 吕毅 Roslyn 如何基于 Microsoft.NET.Sdk 制作源代码包 - 林德熙 制作通过 NuGet 分发的源代码包时，如果目标项目是 WPF 则会出现一些问题（探索篇，含解决方案） - 吕毅 SourceYard 制作源代码包 - 林德熙" }, { "title": "在项目文件 / MSBuild / NuGet 包中编写扩展编译的时候，正确使用 props 文件和 targets 文件", "url": "/post/write-msbuild-codes-into-props-or-targets.html", "categories": "", "tags": "visualstudio, msbuild, nuget, dotnet", "date": "2021-06-07 15:12:04 +0800", "snippet": ".NET 扩展编译用的文件有 .props 文件和 .targets 文件。不给我选择还好，给了我选择之后我应该使用哪个文件来编写扩展编译的代码呢？如果你不了解 .props 文件或者 .targets 文件，可以阅读下面的博客： 理解 C# 项目 csproj 文件格式的本质和编译流程 - walterlv具体的例子有下面这些博客。不过大概阅读一下就好，这只是 .props 和 .targets 文件的一些应用。文章比较长，你可以考虑稍后阅读。 从零开始制作 NuGet 源代码包（全面支持 .NET Core / .NET Framework / WPF 项目） - walterlv 如何创建一个基于 MSBuild Task 的跨平台的 NuGet 工具包 - walterlv 如何创建一个基于命令行工具的跨平台的 NuGet 工具包 - walterlv当我们创建的 NuGet 包中包含 .props 和 .targets 文件的时候，我们相当于在项目文件 csproj 的两个地方添加了 Import 这些文件的代码。&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;!-- 本来是没有下面这一行的，我只是为了说明 NuGet 相当于帮我们添加了这一行才假装写到了这里。 --&amp;gt; &amp;lt;Import Project=&quot;$(NuGetPackageRoot)walterlv.samplepackage\\0.8.3-alpha\\build\\Walterlv.SamplePackage.props&quot; Condition=&quot;Exists(&#39;$(NuGetPackageRoot)walterlv.samplepackage\\0.8.3-alpha\\build\\Walterlv.SamplePackage.props&#39;)&quot; /&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;OutputType&amp;gt;Exe&amp;lt;/OutputType&amp;gt; &amp;lt;TargetFrameworks&amp;gt;netcoreapp3.0&amp;lt;/TargetFrameworks&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;!-- 本来是没有下面这一行的，我只是为了说明 NuGet 相当于帮我们添加了这一行才假装写到了这里。 --&amp;gt; &amp;lt;Import Project=&quot;$(NuGetPackageRoot)walterlv.samplepackage\\0.8.3-alpha\\build\\Walterlv.SamplePackage.targets&quot; Condition=&quot;Exists(&#39;$(NuGetPackageRoot)walterlv.samplepackage\\0.8.3-alpha\\build\\Walterlv.SamplePackage.targets&#39;)&quot; /&amp;gt;&amp;lt;/Project&amp;gt;如果你安装的多份 NuGet 包都带有 .props 和 .targets 文件，那么就相当于帮助你 Import 了多个：&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;!-- 本来是没有下面这一行的，我只是为了说明 NuGet 相当于帮我们添加了这一行才假装写到了这里。 --&amp;gt; &amp;lt;Import Project=&quot;$(NuGetPackageRoot)walterlv.samplepackage1\\0.8.3-alpha\\build\\Walterlv.SamplePackage1.props&quot; Condition=&quot;Exists(&#39;$(NuGetPackageRoot)walterlv.samplepackage1\\0.8.3-alpha\\build\\Walterlv.SamplePackage1.props&#39;)&quot; /&amp;gt; &amp;lt;Import Project=&quot;$(NuGetPackageRoot)walterlv.samplepackage2\\0.5.1-beta\\build\\Walterlv.SamplePackage2.props&quot; Condition=&quot;Exists(&#39;$(NuGetPackageRoot)walterlv.samplepackage2\\0.5.1-beta\\build\\Walterlv.SamplePackage2.props&#39;)&quot; /&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;OutputType&amp;gt;Exe&amp;lt;/OutputType&amp;gt; &amp;lt;TargetFrameworks&amp;gt;netcoreapp3.0&amp;lt;/TargetFrameworks&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;!-- 本来是没有下面这一行的，我只是为了说明 NuGet 相当于帮我们添加了这一行才假装写到了这里。 --&amp;gt; &amp;lt;Import Project=&quot;$(NuGetPackageRoot)walterlv.samplepackage1\\0.8.3-alpha\\build\\Walterlv.SamplePackage1.targets&quot; Condition=&quot;Exists(&#39;$(NuGetPackageRoot)walterlv.samplepackage1\\0.8.3-alpha\\build\\Walterlv.SamplePackage1.targets&#39;)&quot; /&amp;gt; &amp;lt;Import Project=&quot;$(NuGetPackageRoot)walterlv.samplepackage2\\0.5.1-beta\\build\\Walterlv.SamplePackage2.targets&quot; Condition=&quot;Exists(&#39;$(NuGetPackageRoot)walterlv.samplepackage2\\0.5.1-beta\\build\\Walterlv.SamplePackage2.targets&#39;)&quot; /&amp;gt;&amp;lt;/Project&amp;gt;于是，什么代码写到 .props 里而什么代码写到 .targets 里就一目了然了： 如果你是定义属性或者为属性设置初值，那么请写到 .props 里面 这样，所有的 NuGet 包或者扩展的编译流程都将可以访问到你设置的属性的值 如果你是使用属性，或者按条件设置属性，那么请写到 .targets 里面 因为这个时候多数的属性已经初始化完毕，你可以使用到属性的值了 如果你写的是编译目标（Target），那么请写到 .targets 里面 编译目标是扩展编译的，通常都是使用属性 也会有一些产生属性的，但那都是需要在编译期间产生的属性，其他依赖需要使用 DependsOn 等属性来获取 例如下面的属性适合写到 .props 里面。这是一个设置属性初始值的地方：&amp;lt;Project&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;MSBuildAllProjects&amp;gt;$(MSBuildAllProjects);$(MSBuildThisFileFullPath)&amp;lt;/MSBuildAllProjects&amp;gt; &amp;lt;!-- 当生成 WPF 临时项目时，不会自动 Import NuGet 中的 props 和 targets 文件，这使得在临时项目中你现在看到的整个文件都不会参与编译。 然而，我们可以通过欺骗的方式在主项目中通过 _GeneratedCodeFiles 集合将需要编译的文件传递到临时项目中以间接参与编译。 WPF 临时项目不会 Import NuGet 中的 props 和 targets 可能是 WPF 的 Bug，也可能是刻意如此。 所以我们通过一个属性开关 `ShouldFixNuGetImportingBugForWpfProjects` 来决定是否修复这个错误。--&amp;gt; &amp;lt;ShouldFixNuGetImportingBugForWpfProjects Condition=&quot; &#39;$(ShouldFixNuGetImportingBugForWpfProjects)&#39; == &#39;&#39; &quot;&amp;gt;True&amp;lt;/ShouldFixNuGetImportingBugForWpfProjects&amp;gt; &amp;lt;/PropertyGroup&amp;gt;&amp;lt;/Project&amp;gt;这个属性的含义你可以在我的另一篇博客中找到：从零开始制作 NuGet 源代码包（全面支持 .NET Core / .NET Framework / WPF 项目）而下面的属性适合写到 .targets 里面，因为这里使用到了其他的属性：&amp;lt;Project&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;MSBuildAllProjects&amp;gt;$(MSBuildAllProjects);$(MSBuildThisFileFullPath)&amp;lt;/MSBuildAllProjects&amp;gt; &amp;lt;!-- 因为这里使用到了 `Configuration` 属性，需要先等到此属性已经初始化完成再使用，否则我们会拿到非预期的值。 --&amp;gt; &amp;lt;ShouldOptimizeDebugging&amp;gt; Condition=&quot; &#39;$(Configuration)&#39; == &#39;Debug&#39; &quot;&amp;gt;True&amp;lt;/ShouldOptimizeDebugging&amp;gt; &amp;lt;/PropertyGroup&amp;gt;&amp;lt;/Project&amp;gt;" }, { "title": "Windows 系统上如何揪出阻止你屏幕关闭的程序", "url": "/post/detect-which-process-is-keeping-your-screen-on-in-windows.html", "categories": "", "tags": "windows", "date": "2021-06-07 13:42:18 +0800", "snippet": "使用 Win32 API SetThreadExecutionState 可以阻止进入屏幕保护程序，也能阻止屏幕关闭、阻止系统睡眠。这很方便，这也就可能造成各种参差不齐的程序都试图阻止你的屏幕关闭，于是来一个一整晚亮瞎眼就很难受。本文教大家如何揪出阻止你屏幕关闭的程序。我们主要使用系统自带的 powercfg 来查询相关的应用。因此，你需要以管理员权限打开你喜欢的终端。命令 powercfg /requests在终端中输入命令：powercfg /requests/requests 参数的作用是‎“列举应用程序和驱动程序的电源请求。电源请求可防止计算机自动关闭显示屏或进入低功耗睡眠模式。‎”官方文档对此的描述是： Enumerates application and driver Power Requests. Power Requests prevent the computer from automatically powering off the display or entering a low-power sleep mode.于是，如果有某个应用或驱动设置了阻止屏幕关闭，那么就会出现在此命令执行的结果里面。比如下面是我的例子： SteamVR 的几个进程试图阻止屏幕关闭，另外一些进程试图阻止系统睡眠结束掉 SteamVR 后重新执行此命令，可以发现已经没有进程在阻止屏幕关闭和系统睡眠了：命令 powercfg -energy -trace在终端中输入命令：powercfg -energy -trace有时，应用并没有直接阻止你的屏幕关闭，而是在一段时间之内试图不断重置睡眠计时器，这种情况，前面的命令不能完全帮助你找到问题所在，于是你需要使用这个新命令。运行这个命令，你需要等待 60 秒，就像下面这样：注意：等待期间不要碰电脑，因为鼠标和键盘事件也会影响到追踪结果！等待完成后，它会提示你“跟踪完成”，但不会直接告诉你任何结果。结果都存在了你个账户目录下的 energy-trace.etl 日志文件里面，例如 C:\\Users\\lvyi\\energy-trace.etl。这个文件要用事件查看器打开。第一步：右键开始按钮，选择“事件查看器”。第二步：操作→打开保存的日志去用户文件夹中寻找“energy-trace.etl”文件，例如“C:\\Users\\lvyi\\energy-trace.etl”，然后打开。第三步：在保存的日志中找到可疑记录由于日志太多（几十万条），建议右击日志选择“筛选当前日志(L)…”，在筛选器里将事件来源选成“Kernel-Power”，事件 ID 设为 63。可以看到，即便我设置完成，也还有 7,852 个条目。不过这时也比较容易找到问题在哪里了。提示的是： The application or service 0x0 is attempting to update the system timer resolution to a value of 0x0.即有程序试图重置系统计时器。在详细信息里，可以找到是哪个程序：可以看到，在这条记录里，是“msedge.exe”。所以，可以去 Edge 浏览器标签里找找，是否有正在播放的视频或音频等。常用阻止关闭屏幕的程序发现电脑屏幕总是不自动关闭？看看你是否打开了这些程序……参考资料 Powercfg command-line options - Microsoft Docs" }, { "title": "发现电脑屏幕总是不自动关闭？看看你是否打开了这些程序……", "url": "/post/these-windows-applications-always-keep-display-on.html", "categories": "", "tags": "windows", "date": "2021-06-07 13:39:27 +0800", "snippet": "本文收集一些已知的导致电脑屏幕不关闭的程序。如果你发现无论你设置多短的屏幕关闭超时时间但一直都不关闭，那么可以参考本文检查是否打开了这些程序。系统设置电源和睡眠先检查一下你系统设置中的电源和睡眠选项，时间不应该太长。一定要先看看这里，别到时候折腾了半天发现是自己设错了就亏了……另外，找程序的时候，不要第一眼看过去没有就忽略它了。因为你可能像我一样有很多个桌面。最好还是用任务管理器找，不会漏掉。程序和游戏列表大多数游戏如果你有游戏没关，你第一个就应该怀疑它！我不想把我正在玩的游戏列举出来，因为容易过时还会暴露些什么…… FEZ RiME应用 Microsoft PowerPoint 在演示模式下 金山 WPS 演示 在演示模式下 Wallpaper Engine工具 GPU-Z 只要打开就会为什么我想整理这份名单因为我总是时不时发现某一天电脑屏幕一直亮着。到了晚上很刺眼的，而且费电……所以，每发现一个就补充一个好了。如果你有已知的，麻烦在评论区告诉我哟！如果看不到评论区，可以前往这里评论，或者给我发邮件。列表之外如何揪出阻止屏幕关闭的程序？可以看我的另一篇博客：Windows 系统上如何揪出阻止你屏幕关闭的程序" }, { "title": "编写你的专属 MSBuild C# 代码生成器：在保存文件时自动实时生成你的代码", "url": "/post/msbuild-generate-code-when-file-is-saved.html", "categories": "", "tags": "dotnet, msbuild, csharp", "date": "2021-06-01 20:34:17 +0800", "snippet": "我之前的博客中有介绍如何在项目中生成额外的代码，也有介绍制作一个生成代码的 NuGet 包。而本文是在此基础上更进一步，可以让生成代码变成实时的；更准确的说，是在保存文件时即生成代码，而无需完整编译一次项目。一天，头像全白昵称空格的“wuweilai”童鞋问我为什么 GRPC 的 NuGet 包能自动在 .proto 文件保存时更新生成的代码，怎么才能做到像它那样。然后，我研究了下 Grpc.Tools 包里的代码，外加跟他反复讨论，摸清了自动生成代码的方法。背景知识本文的知识非常简单，如果只是希望知道怎么实时生成代码的话，把本文后面的代码复制一下就可以了。但如果希望完整了解基于 MSBuild 生成代码的原理，你可以需要了解以下知识或教程： 理解 C# 项目 csproj 文件格式的本质和编译流程 如何创建一个基于命令行工具的跨平台的 NuGet 工具包 如何创建一个基于 MSBuild Task 的跨平台的 NuGet 工具包准备项目我们创建一个全新的项目，用来了解如何实时生成代码。如下图，就是个普通的控制台应用程序。我额外生成了一个 Test.txt 文件，里面什么也没有。我们即将实现的是：在保存 Test.txt 文件时，会立即执行我们的编译流程，这样，我们便能基于 Test.txt 来实时生成一些代码。最简单的自动生成代码的逻辑现在，我们打开项目 csproj 文件（双击项目名称即可打开编辑这个文件）： &amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;OutputType&amp;gt;Exe&amp;lt;/OutputType&amp;gt; &amp;lt;TargetFramework&amp;gt;net5.0&amp;lt;/TargetFramework&amp;gt; &amp;lt;/PropertyGroup&amp;gt;+ &amp;lt;!-- 将项目中的所有 txt 文件搜集起来，用 WalterlvDemoFile 集合存起来。--&amp;gt;+ &amp;lt;ItemGroup&amp;gt;+ &amp;lt;WalterlvDemoFile Include=&quot;**\\*.txt&quot; Generator=&quot;MSBuild:Compile&quot; /&amp;gt;+ &amp;lt;/ItemGroup&amp;gt;+ &amp;lt;!-- 注册 WalterlvDemoFile 项为一个 Item，这样它的通用属性就能被识别了。 --&amp;gt;+ &amp;lt;ItemGroup&amp;gt;+ &amp;lt;AvailableItemName Include=&quot;WalterlvDemoFile&quot; /&amp;gt;+ &amp;lt;/ItemGroup&amp;gt;+ &amp;lt;!-- 随便写一个 Target，在编译之前做些什么。 --&amp;gt;+ &amp;lt;Target Name=&quot;WalterlvDemoTarget&quot; BeforeTargets=&quot;BeforeCompile&quot;&amp;gt;+ &amp;lt;Exec Command=&quot;winver&quot; /&amp;gt;+ &amp;lt;/Target&amp;gt; &amp;lt;/Project&amp;gt;我把新增的代码高亮出来了。如果你想复制到你的项目里，记得去掉行首的所有 + 号。等你复制到项目里之后，试着在 Test.txt 文件里面随便写点什么，然后保存。你会发现……呃……弹出了一个 Windows 版本号窗口……最简代码解读 我们定义了一个 Target，名为 WalterlvDemoTarget（随便取的名字），并要求在 BeforeCompile 这个 Target 执行之前执行。 关于时机，可以阅读： 通过重写预定义的 Target 来扩展 MSBuild / Visual Studio 的编译过程 在制作多框架项目的 NuGet 包时应该注意的问题（buildMultiTargeting/TargetFrameworks 我们做了一个有趣的事情，在这个 Target 里面，显示了“系统版本号”（因为我想让实时编译过程变得更直观） 我们定义了一个 WalterlvDemoFile 项，这是随便取的名字，是为了搜集 *.txt 文件。 我们在 WalterlvDemoFile 里指定 Generator 为 MSBuild:Compile。 对于已知的项（Item）来说，Generator 属性是 MSBuild 编译时的一个已知元数据（Metadata），其作用为当此文件改变时，会执行一个指定的 Target 我们将其指定为 MSBuild:Compile，即指定为 MSBuild 内置的一个 Target Compile，意为执行一次编译 然而，WalterlvDemoFile 并不是已知的项，所以我们还需要额外将 WalterlvDemoFile 添加到 AvailableItemName 集合里。 关于已知的项，可以阅读： Common MSBuild Project Items - Visual Studio - Microsoft Docs 加完之后，WalterlvDemoFile 的 Generator 属性就可以被自动启用了 延伸在上面那个最简的 Demo 中，我们弹出了个 Windows 版本号，这真的只是为了让你立刻注意到某个代码执行了。当然真正生成代码肯定不会是这样的弹窗。不过，你可以从我的其他博客里找到很多生成代码的方法，比如这篇……还有这篇……还有这这这篇…… 生成代码，从 T 到 T1, T2, Tn —— 自动生成多个类型的泛型 如何创建一个基于命令行工具的跨平台的 NuGet 工具包 如何创建一个基于 MSBuild Task 的跨平台的 NuGet 工具包 将 .NET Core 项目打一个最简单的 NuGet 源码包，安装此包就像直接把源码放进项目一样 Roslyn 如何基于 Microsoft.NET.Sdk 制作源代码包参考资料 Build Time Code Generation in MSBuild · mhut.ch grpc/grpc: The C based gRPC (C++, Python, Ruby, Objective-C, PHP, C#) NuGet Gallery - Grpc.Tools" }, { "title": "Unity OpenVR 虚拟现实入门六：通过摇杆控制玩家移动", "url": "/post/unity-openvr-starting-6.html", "categories": "", "tags": "unity, openvr", "date": "2021-05-17 08:31:31 +0800", "snippet": "在 Unity 的帮助下，虚拟现实应用的开发非常容易。不过国内竟然还是没有什么教程，所以这里就来一点入门的，适合新手。本文将基于第四篇的简单场景，通过摇杆的方式控制玩家移动。系列博客： Unity OpenVR 虚拟现实入门一：安装配置 Unity + OpenVR 环境 Unity OpenVR 虚拟现实入门二：一个最简单的虚拟现实游戏/程序 Unity OpenVR 虚拟现实入门三：最简单的五指交互 Unity OpenVR 虚拟现实入门四：通过脚本控制手与控制器 Unity OpenVR 虚拟现实入门五：通过传送控制玩家移动 Unity OpenVR 虚拟现实入门六：通过摇杆控制玩家移动准备场景如果你是基于本系列第四篇来做的摇杆移动，那么直接开始本篇。如果是基于第五篇（传送），那么，在本文开始之前，我们需要先把第五篇里传送相关的游戏对象禁用。如下图，选择所有与传送相关的游戏对象，右键然后“切换激活状态”。▲ 禁用传送相关的对象编写移动玩家的脚本选中“Player”，在检查器中添加组件。我们添加一个名为“PlayerMovementScript”的脚本。双击新添加的脚本文件，会用 Visual Studio 打开这个脚本文件，我们需要添加一点点的代码。using UnityEngine;using Valve.VR;using Valve.VR.InteractionSystem;public class PlayerMovementScript : MonoBehaviour{ public SteamVR_Action_Vector2 input; public float speed; void Update() { var localMovement = new Vector3(input.axis.x, 0, input.axis.y); var worldMovement = Player.instance.hmdTransform.TransformDirection(localMovement); var worldMovementOfPlane = Vector3.ProjectOnPlane(worldMovement, Vector3.up); transform.position += speed * Time.deltaTime * worldMovementOfPlane; }}这里，我们定义了两个属性： SteamVR_Action_Vector2 类型的 input float 类型的 speed我们现在定义的这个 SteamVR_Action_Vector2 类型是 SteamVR 输入的一种类型，当使用 VR 控制器产生一个二维向量类型的数据时，就会生成 SteamVR_Action_Vector2 类型的数据。例如推动摇杆会产生这样的二维向量。我们稍后也会将这个类型绑定到摇杆上。关于 SteamVR 能产生的其他输入类型，可以参考林德熙的博客：Unity3D OpenVR SteamVR Input Action 动作。而 float 类型则跟所有编程语言一样，只是一个浮点数而已。在 Update 函数中： input.axis.x、input.axis.y 是我们从 SteamVR 的二维向量中取得的 X、Y 分量；但是，我们将它转换成一个三维向量。这样，我们就能得到一个摇杆映射到三维坐标中与地面平行的平面上的坐标（相对坐标）。 这个坐标是相对坐标，而要移动玩家，我们需要一个世界坐标下的移动向量，于是我们拿头显的变换量，将这个本地坐标转换到世界坐标中。最终得到的世界坐标，我们保存到了 worldMovement 变量中。 为了避免让玩家移动到空中或地面以下，我们将 worldMovement 向量投影到与地面平行的二维平面上。 最终，我们用速度、经过的时间和之前计算得到的二维平面上的世界三维坐标相乘，便得到了这一帧的移动向量，将其叠加到玩家的位置坐标上即得到了新一帧的玩家坐标。设置 SteamVR 输入现在，回到 Unity 编辑器中，在“Player”对象的检查器中，找到我们刚刚添加的“PlayerMovementScript”脚本，我们需要设置这个 input 属性应该由什么进行输入。▲ 选择输入在这个下拉列表中，我们点击“Add”（添加）。我们添加一个新的（默认名字是 NewAction）：▲ 添加新的输入这是一个抽象的，二维向量类型的输入，我将其取名为“DirectMovement”（意为直接移动，与之相对的是本系列第五篇说的传送移动 Teleport）。SteamVR 的这种抽象的输入可以很好地将编写代码时的输入与各种各样不同类型的 VR 控制器隔离开来，避免 VR 应用绑死某个控制器的按键。以下是我为此添加的“DirectMovement”： 名字是“DirectMovement” 类型是 Vector2 必要性为“suggested”（suggested 表示开发者定义的，但允许用户修改的按键绑定设置；而 mandatory 表示开发者强制定义不允许用户修改的按键绑定设置） 我额外添加了中文和英文的两个不同本地化语言（这会在 SteamVR 的按键绑定设置时显示给开发者和用户看）▲ DirectMovement 的动作设置添加完成之后，点击“SteamVR Input”窗口左下角的“Save and generate”按钮，等待编译完成后，关闭这个窗口。特别注意：default 的动作组不建议删除，因为 SteamVR 组件里很多组件都用到了 default 动作组里的动作，删除会导致无法看见手和手柄。再回到“Player”游戏对象的检查器中找到“PlayerMovementScript”脚本，我们可以为输入选择我们刚刚添加的“DirectMovement”动作了。▲ 选择 DirectMovement 动作设置控制器按键绑定现在，我们需要重新打开“SteamVR Input”窗口来设置按键绑定。这个窗口在“窗口”-&amp;gt;“SteamVR Input”菜单里。▲ SteamVR Input 菜单在这个“SteamVR Input”窗口中，选择右下角的“Open binding UI”按钮。▲ Open binding UI稍等片刻，会打开“控制器按键设置”界面（这是 SteamVR 的界面，以后玩家去改键的时候看到的也是这个界面）。▲ 控制器按键设置首屏会显示这些信息： 当前正在开发的应用的按键设置（我们即将选择编辑它） 当前控制器（我用的是 Index Controller） 官方按键设置（对玩家来说，可通过这个设置还原成开发者的官方按键；而对我们开发者来说，也就是代码仓库里的那个按键设置）我们点击“编辑”以编辑当前的按键设置。▲ 编辑按键设置将鼠标放到“Thumb Stick”上可以看到摇杆高亮了，这就是我们即将要绑定的那个按键。点击旁边的“➕”号，会弹出这个键的各种不同用法： 摇杆：像摇杆一样使用这个键，会产生 X、Y 坐标（这正好产生我们刚刚新建的动作里需要的 Vector2 类型的输入数据） 十字键：像“上”“下”“左”“右”四个按键一样使用这个键 滚动：像滚轮一样使用这个键，报告水平和垂直滚动量 径向菜单：像一个圆形菜单一样使用这个键 按键：像按键一样使用这个键，可以处理触摸、点击、按下、双击和长按。 切换按键：像切换一样使用这个键，按一下为开启，再按一下为关闭。我们需要的是“摇杆”用法，因为这样才能产生我们需要的移动玩家的“Vector2”类型的输入数据。于是我们选择“摇杆”。现在，以摇杆的方式使用这个键可以产生三种不同的输入： 点击：按下这个摇杆键时触发 触摸：摇杆键被触摸时触发 位置：推动摇杆时触发，产生位置输入（这是我们需要的输入）▲ 三种不同的输入我们在“位置”上点击，在打开的新界面中，我们可以看到它产生“矢量2”类型的数据，并且还能发现我们刚刚在 Unity 编辑器中定义的“Direct Movement”动作。我们选择它。点击“✔️”来确定对这个摇杆键的设置。▲ 确认摇杆键的设置为了使我们的按键设置直接修改到我们的源代码，我们点击整个界面右下角的“替换默认按键设置”按钮，这将直接修改我们代码中的按键绑定文件。▲ 替换默认按键设置运行现在，回到 Unity 编辑器，运行一下。可以看到，已经可以通过摇杆来控制玩家移动了。" }, { "title": "Unity OpenVR 虚拟现实入门四：通过脚本控制手与控制器", "url": "/post/unity-openvr-starting-4.html", "categories": "", "tags": "unity, openvr", "date": "2021-05-16 17:50:13 +0800", "snippet": "在 Unity 的帮助下，虚拟现实应用的开发非常容易。不过国内竟然还是没有什么教程，所以这里就来一点入门的，适合新手。本文将基于第三篇的简单场景，打开和关闭控制器的显示。系列博客： Unity OpenVR 虚拟现实入门一：安装配置 Unity + OpenVR 环境 Unity OpenVR 虚拟现实入门二：一个最简单的虚拟现实游戏/程序 Unity OpenVR 虚拟现实入门三：最简单的五指交互 Unity OpenVR 虚拟现实入门四：通过脚本控制手与控制器 Unity OpenVR 虚拟现实入门五：通过传送控制玩家移动 Unity OpenVR 虚拟现实入门六：通过摇杆控制玩家移动添加脚本本文继续第三篇的内容。在“Player”上添加脚本。我们在“Update”中简单添加一些代码：using UnityEngine;using Valve.VR;using Valve.VR.InteractionSystem;public class PlayerDemoScript : MonoBehaviour{ public bool showControllers; void Update() { foreach (var hand in Player.instance.hands) { if (showControllers) { hand.ShowController(); hand.SetSkeletonRangeOfMotion(EVRSkeletalMotionRange.WithController); } else { hand.HideController(); hand.SetSkeletonRangeOfMotion(EVRSkeletalMotionRange.WithoutController); } } }}这样，当 showControllers 被设置为 true 时，可以同时显示手与控制器，当设置为 false 时，则只显示手。这里 ShowController 是显示控制器，HideController 是隐藏控制器。后面的 SetSkeletonRangeOfMotion 是让手的骨骼动画适配控制器，如果指定为 WithController 则会在运动手指的时候握紧时只会握住控制器，而不会穿模到控制器里面；反之，握紧的时候则不考虑控制器的位置，会穿模。▲ 手握住控制器运行运行场景，当我们在“检查器”中勾选“showControllers”时，会在场景中看到手握住控制器。" }, { "title": "Unity OpenVR 虚拟现实入门五：通过传送控制玩家移动", "url": "/post/unity-openvr-starting-5.html", "categories": "", "tags": "unity, openvr", "date": "2021-05-16 17:47:41 +0800", "snippet": "在 Unity 的帮助下，虚拟现实应用的开发非常容易。不过国内竟然还是没有什么教程，所以这里就来一点入门的，适合新手。本文将基于第四篇的简单场景，通过传送的方式控制玩家移动。系列博客： Unity OpenVR 虚拟现实入门一：安装配置 Unity + OpenVR 环境 Unity OpenVR 虚拟现实入门二：一个最简单的虚拟现实游戏/程序 Unity OpenVR 虚拟现实入门三：最简单的五指交互 Unity OpenVR 虚拟现实入门四：通过脚本控制手与控制器 Unity OpenVR 虚拟现实入门五：通过传送控制玩家移动 Unity OpenVR 虚拟现实入门六：通过摇杆控制玩家移动搭建一个简单的场景基于之前第四篇中我们添加的“Player”和控制器，我们这里简单打建一个场景。于是我们添加一个 3D 物体——“平面”——这足够简单。当然这不是必要的，只是会让我们后续的玩家移动看起来是踩在地面上，而不是悬在空中。▲ 创建平面创建完记得在检查器里面将平面的位置设置到 (0,0,0)。▲ 设置平面的位置创建传送动作在资源中定位到“SteamVR”-&amp;gt;“InteractionSystem”-&amp;gt;“Teleport”-&amp;gt;“Prefabs”，找到“Teleporting”然后将它拖拽到场景中。只需要运行场景，你就能发现在推动手柄摇杆时就能传送了：▲ 传送不过，我们只能做出这个传送的动作，而不会真正地传送出去，因为我们还没有传送的“目的地”。创建传送目的地依然是在“SteamVR”-&amp;gt;“InteractionSystem”-&amp;gt;“Teleport”-&amp;gt;“Prefabs”中。这次，我们拖拽“TeleportPoint”进入场景。▲ 拖拽 TeleportPoint 进入场景我们拖拽多个这样的传送目的地到场景中，运行看看效果。可传送到目的地在这张图片中，白色的地面让传送点很难看清，我们随便找一个非白色的材质拖拽到平面上。这里我直接使用“SteamVR”-&amp;gt;“InteractionSystem”-&amp;gt;“Teleport”-&amp;gt;“Textures”里的“TeleportArea”材质（偷懒）。创建传送目的区域不过，只是传送到某个点的话，更像是看某场全景电影。要实现更加沉浸的体验，我们需要能让场景中的大多数地面都可被传送。创建一个新的平面，同样将位置调整到 (0,0,0)，再调整大小，将其与之前的白色“地面”重叠在一起。不过这个新的平面，我们要添加一个“TeleportArea”的脚本。▲ 添加脚本 Teleport Area运行看看，发现并不能传送（如下图）：无法传送这是因为，我们创建的这两的平面完全重叠了。我们只需要将“TeleportArea”那个平面的 Y 坐标稍微向上移动一点点（例如 0.1 个单位）就可以了。▲ Y 移动一点点▲ 可以传送了" }, { "title": "Unity OpenVR 虚拟现实入门二：一个最简单的虚拟现实游戏/程序", "url": "/post/unity-openvr-starting-2.html", "categories": "", "tags": "unity, openvr", "date": "2021-05-16 16:51:42 +0800", "snippet": "在 Unity 的帮助下，虚拟现实应用的开发非常容易。不过国内竟然还是没有什么教程，所以这里就来一点入门的，适合新手。本文将开发一个最简单的虚拟现实应用。系列博客： Unity OpenVR 虚拟现实入门一：安装配置 Unity + OpenVR 环境 Unity OpenVR 虚拟现实入门二：一个最简单的虚拟现实游戏/程序 Unity OpenVR 虚拟现实入门三：最简单的五指交互 Unity OpenVR 虚拟现实入门四：通过脚本控制手与控制器 Unity OpenVR 虚拟现实入门五：通过传送控制玩家移动 Unity OpenVR 虚拟现实入门六：通过摇杆控制玩家移动安装 SteamVR出于性能考虑，Unity 编辑器已经把“资源商店”（Assets Store）从编辑器里面移到了浏览器。所以大家可以去 https://assetstore.unity.com/ 下载资源。搜索“Steam VR”，找到“SteamVR Plugin”插件（https://assetstore.unity.com/packages/tools/integration/steamvr-plugin-32647），直接点“添加至我的资源”。（如果需要登录，就登录一下。）然后，顶部会弹出在 Unity 编辑器中打开的提示，选“是”就好了。▲ SteamVR Plugin在 Unity 编辑器中，如果网络状况不太好，可能需要等待非常久的时间才能刷出 SteamVR 插件的导入界面。▲ 下载导入 SteamVR Plugin当成功显示了 SteamVR 下载界面后，点击右下角的“下载”按钮。等待下载完成后，点击“导入”按钮。这样，你的项目中就有了 SteamVR 的插件了。接下来，我们将利用 SteamVR 插件来开发我们的第一个虚拟现实应用。第一个虚拟现实应用因为我们刚刚安装了 SteamVR 插件，所以我们可以在界面的资产面板中看到“SteamVR”文件夹，定位到“SteamVR”-“InteractionSystem”-&amp;gt;“Core”-&amp;gt;“Prefabs”，找到“Player”，然后将它拖入到场景中（如图）。▲ 拖入 Player 预制件然后，点击顶部的“▶”按钮开始调试你的第一个虚拟现实应用。▲ 开始调试如果询问你还没有生成 SteamVR 的输入行为，是否要打开输入窗口时，点“是”。并在最后点击“Save and generate”。▲ SteamVR 输入窗口随后，拿起你的头戴式显示器（HMD，Head-mounted display），享受你的第一个虚拟现实应用（也许是游戏）吧！可以点开下面的视频看看我运行的效果：▲ 实机运行效果" }, { "title": "Unity OpenVR 虚拟现实入门三：最简单的五指交互", "url": "/post/unity-openvr-starting-3.html", "categories": "", "tags": "unity, openvr", "date": "2021-05-16 16:06:12 +0800", "snippet": "在 Unity 的帮助下，虚拟现实应用的开发非常容易。不过国内竟然还是没有什么教程，所以这里就来一点入门的，适合新手。本文将基于前两篇搭建的环境，做一个简单的五指交互。系列博客： Unity OpenVR 虚拟现实入门一：安装配置 Unity + OpenVR 环境 Unity OpenVR 虚拟现实入门二：一个最简单的虚拟现实游戏/程序 Unity OpenVR 虚拟现实入门三：最简单的五指交互 Unity OpenVR 虚拟现实入门四：通过脚本控制手与控制器 Unity OpenVR 虚拟现实入门五：通过传送控制玩家移动 Unity OpenVR 虚拟现实入门六：通过摇杆控制玩家移动前提你需要有一个在第二篇中做出的“Player”。▲ Unity 编辑器中的 Player将控制器换成手找到场景中的“Player”-&amp;gt;“SteamVRObjects”，选择“LeftHand”，在“检查器”中找到“Render Model Prefab”。▲ Render Model Prefab将前面在“SteamVR”-&amp;gt;“InteractionSystem”-&amp;gt;“Core”-&amp;gt;“Prefabs”中的其他种类的左手拖拽到检查器的“Render Model Prefab”中。例如，我们拖入了“LeftRenderModel”。▲ 拖入 LeftRenderModelSteamVR 中自带的其他几种控制器模型有：▲ SteamVR 自带的手模型同样，我们将右手也替换一个模型。运行运行我们刚刚替换过手模型的场景，看看效果：▲ RenderModel▲ RenderModel Floppy" }, { "title": "Unity OpenVR 虚拟现实入门一：安装配置 Unity + OpenVR 环境", "url": "/post/unity-openvr-starting-1.html", "categories": "", "tags": "unity, openvr", "date": "2021-05-16 16:06:12 +0800", "snippet": "在 Unity 的帮助下，虚拟现实应用的开发非常容易。不过国内竟然还是没有什么教程，所以这里就来一点入门的，适合新手。本文将搭建好虚拟现实的开发环境。系列博客： Unity OpenVR 虚拟现实入门一：安装配置 Unity + OpenVR 环境 Unity OpenVR 虚拟现实入门二：一个最简单的虚拟现实游戏/程序 Unity OpenVR 虚拟现实入门三：最简单的五指交互 Unity OpenVR 虚拟现实入门四：通过脚本控制手与控制器 Unity OpenVR 虚拟现实入门五：通过传送控制玩家移动 Unity OpenVR 虚拟现实入门六：通过摇杆控制玩家移动第一步：安装 Unity Hub去官网 https://unity.cn/releases 下载 Unity Hub。这是必要的，因为 Unity 编辑器的运行一定要先安装有 Unity Hub，且必须始终保持最新版，否则可能还会导致无法连接。下载完成后安装即可。▲ Unity Hub 界面第二步：安装最新版本的 Unity 编辑器启动 Unity Hub，然后选择左侧的“安装”，再选择右上角的“安装”选择你当前最新版本的 Unity，点“下一步”，选“安装”。然后等就好了。▲ 安装最新版本 Unity 编辑器 1/2▲ 安装最新版本 Unity 编辑器 2/2第三步：安装 XR 插件管理器在 Unity Hub 中，新建一个项目，然后等这个项目被 Unity 编辑器打开。首次创建项目或第一次打开某个项目会等很久，在恢复项目中所需的包。耐心等待吧。▲ 等待创建项目▲ XR 插件管理等你看到 Unity 编辑器的界面后，选择“编辑”-&amp;gt;“项目设置”，在打开的项目设置窗格中，拉到最下面的“XR 插件管理”然后选择它。在里面，你可以看到“安装 XR 插件管理”的按钮，点击它，然后等上几分钟到数小时，直到安装完成。安装完成后，需要重启 Unity 编辑器。▲ Unity 编辑器界面重启完编辑器后，再进入到最底部的“XR Plug-in Management”则可以看到已经加载完成的“XR Plug-in Management”插件。勾选你打算适配的虚拟现实设备。▲ XR Plug-in Management" }, { "title": "WPF 制作高性能的透明背景异形窗口（使用 WindowChrome 而不要使用 AllowsTransparency=True）", "url": "/post/wpf-transparent-window-without-allows-transparency.html", "categories": "", "tags": "wpf, dotnet, csharp", "date": "2021-01-16 08:30:49 +0800", "snippet": "在 WPF 中，如果想做一个背景透明的异形窗口，基本上都要设置 WindowStyle=&quot;None&quot;、AllowsTransparency=&quot;True&quot; 这两个属性。如果不想自定义窗口样式，还需要设置 Background=&quot;Transparent&quot;。这样的设置会让窗口变成 Layered Window，WPF 在这种类型窗口上的渲染性能是非常糟糕的。本文介绍如何使用 WindowChrome 而不设置 AllowsTransparency=&quot;True&quot; 制作背景透明的异形窗口，这可以避免异形窗口导致的低渲染性能。背景透明的异形窗口如下是一个背景透明异形窗口的示例：此窗口包含很大的圆角，还包含 DropShadowEffect 制作的阴影效果。对于非透明窗口来说，这是不可能实现的。如何实现要实现这种背景透明的异形窗口，需要为窗口设置以下三个属性： WindowStyle=&quot;None&quot; ResizeMode=&quot;CanMinimize&quot; 或 ResizeMode=&quot;NoResize&quot; WindowChrome.GlassFrameThickness=&quot;-1&quot; 或设置为其他较大的正数（可自行尝试设置之后的效果）如下就是一个最简单的例子，最关键的三个属性我已经高亮标记出来了。 &amp;lt;Window x:Class=&quot;Walterlv.Demo.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;++ WindowStyle=&quot;None&quot; ResizeMode=&quot;CanMinimize&quot; Title=&quot;walterlv demo&quot; Height=&quot;450&quot; Width=&quot;800&quot;&amp;gt;++ &amp;lt;WindowChrome.WindowChrome&amp;gt;++ &amp;lt;WindowChrome GlassFrameThickness=&quot;-1&quot; /&amp;gt;++ &amp;lt;/WindowChrome.WindowChrome&amp;gt; &amp;lt;Window.Template&amp;gt; &amp;lt;ControlTemplate TargetType=&quot;Window&quot;&amp;gt; &amp;lt;Border Padding=&quot;64&quot; Background=&quot;Transparent&quot;&amp;gt; &amp;lt;Border CornerRadius=&quot;16&quot; Background=&quot;White&quot;&amp;gt; &amp;lt;Border.Effect&amp;gt; &amp;lt;DropShadowEffect BlurRadius=&quot;64&quot; /&amp;gt; &amp;lt;/Border.Effect&amp;gt; &amp;lt;ContentPresenter ClipToBounds=&quot;True&quot; /&amp;gt; &amp;lt;/Border&amp;gt; &amp;lt;/Border&amp;gt; &amp;lt;/ControlTemplate&amp;gt; &amp;lt;/Window.Template&amp;gt; &amp;lt;Grid&amp;gt; &amp;lt;TextBlock FontSize=&quot;20&quot; Foreground=&quot;#0083d0&quot; TextAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;&amp;gt; &amp;lt;Run Text=&quot;欢迎访问吕毅的博客&quot; /&amp;gt; &amp;lt;LineBreak /&amp;gt; &amp;lt;Run Text=&quot;blog.walterlv.com&quot; FontSize=&quot;64&quot; FontWeight=&quot;Light&quot; /&amp;gt; &amp;lt;/TextBlock&amp;gt; &amp;lt;/Grid&amp;gt; &amp;lt;/Window&amp;gt;网上流传的主流方法在网上流传的主流方法中，AllowsTransparency=&quot;True&quot; 都是一个必不可少的步骤，另外也需要 WindowStyle=&quot;None&quot;。但是我一般都会极力反对大家这么做，因为 AllowsTransparency=&quot;True&quot; 会造成很严重的性能问题。如果你有留意到我的其他博客，你会发现我定制窗口样式的时候都在极力避开设置此性能极差的属性： WPF 使用 WindowChrome，在自定义窗口标题栏的同时最大程度保留原生窗口样式（类似 UWP/Chrome）性能对比既然特别说到性能，那也是口说无凭，我们要拿出数据来说话。以下是我用来测试渲染性能所使用的例子：相比于上面的例子来说，主要就是加了背景动画效果，这可以用来测试帧率。 &amp;lt;Window x:Class=&quot;Walterlv.Demo.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; WindowStyle=&quot;None&quot; ResizeMode=&quot;CanMinimize&quot; Title=&quot;walterlv demo&quot; Height=&quot;450&quot; Width=&quot;800&quot;&amp;gt; &amp;lt;WindowChrome.WindowChrome&amp;gt; &amp;lt;WindowChrome GlassFrameThickness=&quot;-1&quot; /&amp;gt; &amp;lt;/WindowChrome.WindowChrome&amp;gt; &amp;lt;Window.Template&amp;gt; &amp;lt;ControlTemplate TargetType=&quot;Window&quot;&amp;gt; &amp;lt;Border Padding=&quot;64&quot; Background=&quot;Transparent&quot;&amp;gt; &amp;lt;Border CornerRadius=&quot;16&quot; Background=&quot;White&quot;&amp;gt; &amp;lt;Border.Effect&amp;gt; &amp;lt;DropShadowEffect BlurRadius=&quot;64&quot; /&amp;gt; &amp;lt;/Border.Effect&amp;gt; &amp;lt;ContentPresenter ClipToBounds=&quot;True&quot; /&amp;gt; &amp;lt;/Border&amp;gt; &amp;lt;/Border&amp;gt; &amp;lt;/ControlTemplate&amp;gt; &amp;lt;/Window.Template&amp;gt; &amp;lt;Grid&amp;gt;++ &amp;lt;Rectangle x:Name=&quot;BackgroundRectangle&quot; Margin=&quot;0 16&quot; Fill=&quot;#d0d1d6&quot;&amp;gt;++ &amp;lt;Rectangle.RenderTransform&amp;gt;++ &amp;lt;TranslateTransform /&amp;gt;++ &amp;lt;/Rectangle.RenderTransform&amp;gt;++ &amp;lt;Rectangle.Triggers&amp;gt;++ &amp;lt;EventTrigger RoutedEvent=&quot;FrameworkElement.Loaded&quot;&amp;gt;++ &amp;lt;BeginStoryboard&amp;gt;++ &amp;lt;BeginStoryboard.Storyboard&amp;gt;++ &amp;lt;Storyboard RepeatBehavior=&quot;Forever&quot;&amp;gt;++ &amp;lt;DoubleAnimation Storyboard.TargetName=&quot;BackgroundRectangle&quot;++ Storyboard.TargetProperty=&quot;(UIElement.RenderTransform).(TranslateTransform.X)&quot;++ From=&quot;800&quot; To=&quot;-800&quot; /&amp;gt;++ &amp;lt;/Storyboard&amp;gt;++ &amp;lt;/BeginStoryboard.Storyboard&amp;gt;++ &amp;lt;/BeginStoryboard&amp;gt;++ &amp;lt;/EventTrigger&amp;gt;++ &amp;lt;/Rectangle.Triggers&amp;gt;++ &amp;lt;/Rectangle&amp;gt; &amp;lt;TextBlock FontSize=&quot;20&quot; Foreground=&quot;#0083d0&quot; TextAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;&amp;gt; &amp;lt;Run Text=&quot;欢迎访问吕毅的博客&quot; /&amp;gt; &amp;lt;LineBreak /&amp;gt; &amp;lt;Run Text=&quot;blog.walterlv.com&quot; FontSize=&quot;64&quot; FontWeight=&quot;Light&quot; /&amp;gt; &amp;lt;/TextBlock&amp;gt; &amp;lt;/Grid&amp;gt; &amp;lt;/Window&amp;gt;那么性能数据表现如何呢？我们让这个窗口在 2560×1080 的屏幕上全屏渲染，得出以下数据： 方案 WindowChrome AllowsTransparency 帧率（fps）数值越大越好，60 为最好 59 19 脏区刷新率（rects/s）数值越大越好 117 38 显存占用（MB）数值越小越好 83.31 193.29 帧间目标渲染数（个）数值越大越好 2 1 另外，对于显存的使用，如果我在 7680×2160 的屏幕上全屏渲染，WindowChrome 方案依然保持在 80+MB，而 AllowsTransparency 已经达到惊人的 800+MB 了。可见，对于渲染性能，使用 WindowChrome 制作的背景透明异形窗口性能完虐使用 AllowsTransparency 制作的背景透明异形窗口，实际上跟完全没有设置透明窗口的性能保持一致。此性能差异的原理解读，请参阅： WPF 从最底层源代码了解 AllowsTransparency 性能差的原因功能对比既然 WindowChrome 方法在性能上完虐网上流传的设置 AllowsTransparency 方法，那么功能呢？值得注意的是，由于在使用 WindowChrome 制作透明窗口的时候设置了 ResizeMode=&quot;None&quot;，所以你拖动窗口在屏幕顶部和左右两边的时候，Windows 不会再帮助你最大化窗口或者靠边停靠窗口，于是你需要自行处理。不过窗口的标题栏拖动功能依然保留了下来，标题栏上的右键菜单也是可以继续使用的。 方案 WindowChrome AllowsTransparency 拖拽标题栏移动窗口 保留 自行实现 最小化最大化关闭按钮 丢失 丢失 拖拽边缘调整窗口大小 丢失 丢失 移动窗口到顶部可最大化 丢失 自行实现 拖拽最大化窗口标题栏还原窗口 保留 自行实现 移动窗口到屏幕两边可侧边停靠 丢失 自行实现 拖拽摇动窗口以最小化其他窗口 保留 自行实现 窗口打开/关闭/最小化/最大化/还原动画 丢失 丢失 表格中： 保留 表示此功能无需任何处理即可继续支持 自行实现 表示此功能已消失，但仅需要一两行代码即可补回功能 丢失 表示此功能已消失，如需实现需要编写大量代码另外，以上表格仅针对鼠标操作窗口。如果算上使用触摸来操作窗口，那么所有标记为 自行实现 的都将变为 丢失。因为虽然你可以一句话补回功能，但在触摸操作下各种 Bug，你解不完…… WPF 程序无法触摸操作？我们一起来找原因和解决方法！这两种实现的窗口之间还有一些功能上的区别： 方案 WindowChrome AllowsTransparency 点击穿透 在完全透明的部分点击依然点在自己的窗口上 在完全透明的部分点击会穿透到下面的其他窗口 然而，如果你希望在使用高性能的 WindowChrome 时也依然能点击穿透，那么你需要使用到一点点的小技巧来绕过 WPF 对 WS_EX_LAYERED 窗口样式的锁定。请参见：WPF 制作支持点击穿透的高性能的透明背景异形窗口。" }, { "title": "Windows 下的高 DPI 应用开发（UWP / WPF / Windows Forms / Win32）", "url": "/post/windows-high-dpi-development.html", "categories": "", "tags": "windows, dotnet, wpf, uwp", "date": "2021-01-04 20:33:15 +0800", "snippet": "本文将介绍 Windows 系统中高 DPI 开发的基础知识。由于涉及到坐标转换，这种转换经常发生在计算的不知不觉中；所以无论你使用哪种 Windows 下的 UI 框架进行开发，你都需要了解这些内容，以免不断踩坑。各种不同的 Windows 桌面 UI 框架微软主推的 Windows 桌面 UI 框架有： UWP WPF Windows Forms Win32 与 C++ DirectX后两者实际上并不是 UI 框架，是 UI 框架的底层不同实现。当然你单纯凭借 Win32 和 DirectX 去开发 GUI 应用也没有人拦你，只不过如果你试图只用 Win32 和 DirectX 而不进行各种 UI 组件封装的话，最终会非常痛苦的。UWP 只支持 Windows 10（当然也分不同的小版本，兼容起来有些小麻烦）。WPF 和 Windows Forms 的最新版本只支持 Windows 7 SP1 及以上系统。如果要支持 Windows 7 和更早的系统，你需要降低 .NET Framework 的版本至 4.5.2 及以下；如果要 XP 支持，还需要到 4.0 及以下。对普通用户而言的 DPI 级别DPI 值有两种：系统 DPI (System DPI) 和屏幕 DPI (Monitor DPI)。自 Windows Vista 开始引入系统 DPI 概念，自 Windows 8.1 开始引入屏幕 DPI 概念。在 Windows Vista / 7 / 8 中，操作系统提供了真正的 DPI 的设置：▲ Windows 7 的 DPI 设置（控制面板 -&amp;gt; 外观与个性化 -&amp;gt; 显示）这里的设置改的就是系统的 DPI 值。Windows 7 中还额外提供了传统 Windows XP 风格 DPI 缩放比例的选项（此选项在 Windows 8 之后就删掉了），这也是在修改 DPI 值，只不过可以选择非 1/4 整数倍的 DPI 值。▲ 自定义 DPI 设置自 Windows 8.1 开始，操作系统开始可以设置不同屏幕的 DPI 值了：▲ Windows 10 中的多个屏幕选择▲ Windows 10 中针对每个屏幕的 DPI 设置如果用户在设置中更改了系统 DPI 值或屏幕 DPI 值，那么 Windows 系统会提示需要注销才会应用修改。对于 Windows 8.1 以下的系统，注销是必要的。因为系统 DPI 值如果不注销就不会改变，应用需要在系统重新登录后有了新的 DPI 值时才会正常根据新的系统 DPI 值进行渲染。否则就是系统进行的位图缩放。对于 Windows 8.1 及以上的系统，注销通常也是必要的。虽然屏幕 DPI 值已经更新，并且已向应用窗口发送了 Dpi Change 消息，但系统 DPI 值依然没变。应用必须处理 Dpi Change 消息才会正常渲染。如果应用不支持屏幕 DPI 感知，那么使用的就是系统 DPI 值，于是一样的会被系统进行位图缩放。但事情到 Windows 10 (1803) 之后，事情又有了转机。现在，你可以通过在设置中打开一个开关，使得无需注销，只要重新打开应用即可让此应用获取到最新的系统 DPI 的值。方法是：打开“设置” -&amp;gt; “系统” -&amp;gt; “显示器” -&amp;gt; “高级缩放设置”，在“高级缩放设置”上，打开“允许 Windows 尝试修复应用，使其不模糊”。额外的，对于 Windows 8.1 及以上的系统，系统 DPI 值等于主屏在系统启动时的屏幕 DPI 值。对 Windows 应用而言的 DPI 感知级别（Dpi Awareness）Windows 的 DPI 感知级别经过历代升级，已经有四种了。 无感知 (Unaware) DPI 值就是一个常量 96。 如果在系统中设置缩放，那么就会采用位图拉伸（会模糊）。 更多信息请看本文末尾的故事。 系统级感知 (System DPI Awareness) Vista 系统引入。 所有显示器上的应用共用这一个 DPI 值。 每个用户会话固定一个 DPI 值，修改 DPI 后不需要重启系统而只需要注销当前用户重新登录即可。 如果在设置中修改了 DPI，那么就会采用位图拉伸（会模糊）。 屏幕级感知 (Per-Monitor DPI Awareness) 随 Windows 8.1 引入 应用的 DPI 值会随着所在屏幕的不同而改变。 当多个屏幕 DPI 不一样，而应用从一个屏幕切换到另一个屏幕的时候，应用会收到 DPI 改变的消息 只有应用的顶层 HWND 会收到 DPI 改变消息 屏幕级感知第二代 (Per-Monitor V2 DPI Awareness) 随 Windows 10 (1607) 引入 应用的 DPI 值会随着所在屏幕的不同而改变。 当多个屏幕 DPI 不一样，而应用从一个屏幕切换到另一个屏幕的时候，应用会收到 DPI 改变的消息 应用的顶层和子 HWND 都会收到 DPI 改变消息 以下 UI 元素也会在 DPI 改变时缩放 非客户区（Non-client Area） 系统通用控件中的位图（comctl32V6） 对话框（CreateDialog） 在 Windows 10 19H1 中，可以直接在任务管理器中查看到进程的 DPI Awareness：▲ 在任务管理器中查看 DPI Awareness方法是在任务管理器中 Details 的标题栏右键，选择列，然后找到 DPI Awareness。可以看到，目前仅文件资源管理器是 Per-Monitor V2 的。关于在任务管理器中查看 DPI，可以阅读我的另一篇博客： Windows 系统上使用任务管理器查看进程的各项属性（命令行、DPI、管理员权限等） - 吕毅任务管理器上关于 DPI 的中文翻译也是蛮有意思的。不同 UI 框架对 DPI 的支持情况UWPUWP 当然支持最新的各种 DPI 感知级别，而且是完全支持。WPFWPF 的最新版支持最新的 DPI 感知级别，不过依然有限制： Native WPF applications will DPI scale WPF hosted in other frameworks and other frameworks hosted in WPF do not automatically scale即原生 WPF 应用支持 DPI 缩放，在其他 UI 框架中的 WPF 也支持 DPI 缩放；但是 WPF 中嵌入的其他 UI 框架不支持自动 DPI 缩放。WPF 第一个版本（随 .NET Framework 3.5 发布）就已支持系统级 DPI 感知。.NET Framework 4.6.2 开始的 WPF 才开始支持屏幕级 DPI 感知。而 Per-Monitor V1 和 Per-Monitor V2 的支持在操作系统级别是兼容的，所以只需要修改 WPF 中的应用程序清单即可兼容第二代屏幕级 DPI 感知。Windows FormsWindows Forms 也是在 .NET Framework 4.7 才开始支持屏幕级 DPI 感知的。不过部分控件不支持自动随屏幕 DPI 切换。其他 UI 框架原生 Win32 是支持最新 DPI 感知的，其他如 GDI/GDI+/MFC 等都不支持，除非开发者手工编写。混合 DPI 感知级别当项目足够大的时候，一个或几个项目成员可能很难了解所有的窗口逻辑。让一个进程的所有窗口开启 DPI 缩放对应用的高 DPI 迁移来说比较困难。不过好在我们可以开启混合 DPI 缩放。Windows 10 (1604) 开始引入顶级窗口（Top-level Window）级别的 DPI 感知，而 Windows 10 (1703) 开始引入每一个 HWND 的 DPI 感知，包括顶级窗口和非顶级窗口。这里的顶级窗口指的是没有父级的窗口，指的是 Parent，而不是 Owner。（实际上 API 在更早版本就引入了，这里有故事，详见本文末尾。）在创建一个窗口的前后分别调用 SetThreadDpiAwarenessContext 函数可以让创建的这个窗口具有单独的 DPI 感知级别。前一次是为了让窗口在创建时有一个对此线程的新的 DPI 感知级别，而后一次调用是恢复此线程的 DPI 感知级别。关于混合 DPI 感知级别的其他内容，可以阅读官网：Mixed-Mode DPI Scaling and DPI-aware APIs - Microsoft Docs。微软的 Office 系列就是典型的使用了混合 DPI 感知级别的应用。在以下实验中，我组成了一个 96 DPI 的主屏和 144 DPI 的副屏，先在 96 DPI 的屏幕上截一张图，再将窗口移动到 144 DPI 的屏幕中再截一张图。Microsoft PowerPoint 使用的是系统 DPI 感知级别：▲ 96 DPI 下的主界面▲ 144 DPI 下的主界面你可以通过点开图片查看原图来比较这两幅图在原图尺寸下的模糊程度。Microsoft PowerPoint 的演示页面使用的是屏幕 DPI 感知级别：▲ 96 DPI 下的演示页面▲ 144 DPI 下的演示页面可以看到，演示页面在多屏 DPI 下是没有产生缩放的模糊，即采用了屏幕 DPI 感知级别。而以上的主界面和演示页面属于同一个进程。▲ 只有一个 PowerPoint 进程DPI 相关的 Windows API 的迁移 GetSystemMetrics -&amp;gt; GetSystemMetricsForDpi AdjustWindowRectEx -&amp;gt; AdjustWindowRectExForDpi SystemParametersInfo -&amp;gt; SystemParametersInfoForDpi GetDpiForMonitor -&amp;gt; GetDpiForWindow关于 DPI 相关 API 变化的故事感谢 Mouri_Naruto（毛利）提供的故事，API 的具体使用也可参考他的文章：【原创】实现每显示器高DPI识别(Per-Monitor DPI Aware)的注意事项。关于 Windows 10前文提到 Per-Monitor V2 是 Windows 10 (1703) 引入的，微软官方文档 High DPI Desktop Application Development on Windows - Win32 apps 也是这么写的。但实际上更早的 Windows 10 (1607) 就引入了相关 API，包括 SetThreadDpiAwarenessContext 和 PerMonitorV2 应用程序清单。并且更早的，V2 带来的非客户区缩放和子窗口 DPI 变更消息的 API 在 1507 和 1511（分别是 Windows 10 的第一和第二个正式版本）就已经有了，不过是未公开的（可参阅 【原创】实现每显示器高DPI识别(Per-Monitor DPI Aware)的注意事项）。1607 开始这两个非公开 API 不能使用了，因为换成了新的 API，参见 Setting the default DPI awareness for a process (Windows) - Win32 apps。可以发现微软实际上宣称 1607 已经支持 Per-Monitor V2 了，而完整支持是在 1703。所谓的“完整”体现在这些地方： comctl32 从 1703 开始完整支持缩放（参见 High DPI Scaling Improvements for Desktop Applications and “Mixed Mode” DPI Scaling in the Windows 10 Anniversary Update (1607) - Windows Developer Blog） 如果你指定了 PerMonitor 但没指定 PerMonitorV2，那么 1607 默认是 PerMonitor，1703 默认是 PerMonitorV2。关于 Windows Vista 之前的系统感谢 Mouri_Naruto（毛利）提供的历史： Windows Vista 之前的系统不代表就对 DPI 无感知，事实上 Windows Vista 之前的版本，大概是 Windows 98 开始就支持通过 GDI 相关的 API 获取当前系统的 DPI 值（当时 Windows Phone 之前的 Windows 移动端 OS 通过这种 API 支持 PPI 高达 280 的手机屏幕，毕竟我也算是 2008 年就入手 HTC Touch Diamond 的用户，那个屏幕的 PPI 值（PPI 280）直到 iPhone Retina 概念（PPI 320）出现后才超过）。 只是 Windows Vista 提供了对不明确表示 DPI 支持的应用的暴力缩放（通过 Desktop Window Manager 合成实现），毕竟那个时代除了手机之外，基本没有什么屏幕涉及到高 DPI。 倒是 Windows Vista 之前的系统的 DPI 修改是需要重启机器的……所以当时我作死给我的手机修改 DPI 也是要重启的（Windows CE 5.2 内核） Vista 之前的版本，系统中设置缩放，如果你做到了 System Aware 的要求位图是不会模糊的（Vista 引入 DWM 虚拟化强制拉伸，主要是当时的引用没有做相关支持，在高 DPI 情况下会控件会变得非常小且布局大概率会乱掉）。参考资料 High DPI Desktop Application Development on Windows - Microsoft Docs WPF-Samples/Developer Guide - Per Monitor DPI - WPF Preview.docx at master · Microsoft/WPF-Samples 在 Windows 10 中修复显示模糊的应用 - Windows Help Fix apps that appear blurry in Windows 10 - Windows Help" }, { "title": "适合 .NET 开发者用的 GitHub Actions（时不时更新）", "url": "/post/github-actions-for-dotnet-developers.html", "categories": "", "tags": "dotnet, github", "date": "2020-12-03 17:44:51 +0800", "snippet": "本文制作并长期更新适合 .NET 开发者用的 GitHub Actions。整理方式为整个文件而不是单个可用的模块，这样可以方便大家以最快的速度为自己的项目添加 GitHub Actions。当然自己改改也可。.NET 编译与单元测试（全平台）功能：编译你的 .NET 项目，并进行单元测试。适用：如果你的项目是纯 .NET 项目，无论项目是 .NET Core 还是 .NET Framework，无论是 Asp.NET Core 还是 WPF / Windows Forms，都可以用这个文件来编译和单元测试。要求：仓库的根目录有且仅有一个 sln 文件，且这个文件包含了所有重要的项目和单元测试。name: .NET Build &amp;amp; Teston: push: branches: [ master ] pull_request: branches: [ master ]jobs: build: strategy: matrix: configuration: [Debug, Release] runs-on: windows-latest steps: - name: Checkout uses: actions/checkout@v2 - name: Setup uses: actions/setup-dotnet@v1 - name: Build run: dotnet build --configuration $env:Configuration env: Configuration: ${{ matrix.configuration }} - name: Test run: dotnet test --configuration $env:Configuration env: Configuration: ${{ matrix.configuration }}.NET 编译与单元测试（仅限 Windows 系统下的编译）功能：编译你的 .NET 项目，并进行单元测试。适用：如果你的项目是纯 .NET 项目，无论项目是 .NET Core 还是 .NET Framework，无论是 Asp.NET Core 还是 WPF / Windows Forms，都可以用这个文件来编译和单元测试。要求：仓库的根目录有且仅有一个 sln 文件，且这个文件包含了所有重要的项目和单元测试。name: .NET Build &amp;amp; Teston: push: branches: [ master ] pull_request: branches: [ master ]jobs: build: strategy: matrix: configuration: [Debug, Release] runs-on: windows-latest steps: - name: Checkout uses: actions/checkout@v2 with: fetch-depth: 0 # 安装 .NET Core - name: Install .NET Core uses: actions/setup-dotnet@v1 with: dotnet-version: 3.1.202 # 添加 MSBuild.exe 到环境变量: https://github.com/microsoft/setup-msbuild - name: Add msbuild to PATH uses: microsoft/setup-msbuild@v1.0.2 # 安装 NuGet（如果后面需要，可以使用它） - name: Setup NuGet uses: nuget/setup-nuget@v1 with: nuget-api-key: ${{ secrets.NuGetAPIKey }} nuget-version: &#39;5.x&#39; # 编译整个项目 - name: Build the solution run: msbuild /p:Configuration=$env:Configuration -restore env: Configuration: ${{ matrix.configuration }} # 执行单元测试 - name: Execute unit tests run: dotnet test -c $env:Configuration env: Configuration: ${{ matrix.configuration }}在这个文件中： 我们测试编译了 DEBUG 和 Release 两个不同的环境 我们使用的是 msbuild 来编译，因为这样对旧项目的兼容性最好，当然也就失去了跨平台的能力NuGet Push功能：如果你的项目是要推送 NuGet 包的，那么可以使用此工作流推送 NuGet 包。适用：任何 .NET 项目。要求：仓库的根目录有且仅有一个 sln 文件。name: NuGet Pushon: push: branches: - masterjobs: build: runs-on: windows-latest steps: - name: Checkout uses: actions/checkout@v2 - name: Setup uses: actions/setup-dotnet@v1 - name: Pack run: dotnet build --configuration Release - name: Push run: dotnet nuget push .\\bin\\Release\\*.nupkg --source https://api.nuget.org/v3/index.json --api-key ${{ secrets.NuGetAPIKey }} --skip-duplicate --no-symbols 1关于最后的那个参数 1，很魔性，只要有任何一个值都行。参见：dotnet nuget push - Missing value for option · Issue #4864 · NuGet/Home。自带环境GitHub Actions 自带了很多环境可以用，这些自带的环境不需要再去配了： virtual-environments/Windows2019-Readme.md at master · actions/virtual-environments" }, { "title": "使用 Xamarin 在 iOS 真机上部署应用进行调试", "url": "/post/deploy-and-debug-ios-app-using-xamarin.html", "categories": "", "tags": "xamarin, dotnet, csharp, ios", "date": "2020-10-31 09:00:51 +0800", "snippet": "虽然 Xamarin 可以在 Windows 操作系统上编写和调试，但如果开发 iOS 应用，那么我们依然需要一台安装有 XCode 和 Visual Studio for Mac 的 Mac 电脑。做真机部署不是像平时使用太阳系第一 IDE Visual Studio 那样方便。所以本文需要介绍如何使用 Xamarin 在 iOS 真机上部署应用进行调试，然后顺便说一些注意事项。准备一台 Mac 电脑如果你没有 Mac 电脑，那我只能很不幸地告诉你：本文读下去已经没有什么用了，你不会成功的……当然你也可以考虑使用 Mac OS 虚拟机，但成功率太低，本文不会涉及。在 Mac 电脑上安装以下两款必备应用： XCode：从苹果应用商店安装 Visual Studio for Mac：在这里下载 https://visualstudio.microsoft.com/vs/mac/这两款应用的体积都很大，如果你没有很好的网络代理设置，安装一整天都是可能的。所以还是强烈建议你有一个稳定的代理网络来下载。本文接下来的内容都假设你已经安装好了这两款应用。背景知识你需要知道一些背景知识，不然后面真机部署的时候失败了都不知道怎么回事。 你的账号必须是苹果开发者账号 只需要注册 Apple Developer Portal，不需要注册 Apple Developer Program 只有 XCode 才能生成开发者的 provisioning profiles 只有 XCode 才能在 iOS 真机上部署全新的应用也就是说，你必须有一些操作是在 XCode 中完成；只使用 Visual Studio for Mac 是无法完成部署任务的。在 XCode 中准备 在 XCode 中新建一个空白 iOS 项目（什么类型都可以），这个项目随时可以丢弃。 选择你新建的项目，会出现这个项目的信息可以填，默认在 General 标签中。 *[重要] 修改 Bundle Identifier。 将这个 Bundle Identifier 修改为你希望部署的应用的 Bundle Identifier。比如你在 Xamarin 的 Info.plist 中写的 Bundle Identifier 是 com.walterlv.CloudKeyboard，那么这里也必须写 com.walterlv.CloudKeyboard。 *[重要] 一定要让这个 Bundle Identifier 文本框失焦（比如按下 Tab 或在其他文本框中点一下）。 这个时候下面的 Signing Certificate 会出现一个加载中的动画，大概持续不到一秒钟，就会生成 iPhone Developer 的信息，这个就是包含 provisioning profiles 的信息（可以在 Provisioning Profile 旁边的感叹号中看到详细信息） 在 Mac 上插入你的 iPhone，解锁 iPhone，等待左上角出现你 iPhone 的名称和图标。 点击 XCode 左上角的运行按钮，等待这个空白的应用部署到你的手机上。更新：XCode 新版本的界面布局和本文略有不同，可前往以下链接查看变化： Xamarin iOS 切换开发者账号之后的签名标识和预配配置文件更新方法 Xamarin iOS 部署项目提示 Failed to register bundle identifier 失败*[重要] 额外的，如果你开发的是 iOS 扩展，有两个或者更多的包，那么你需要重复步骤 3 到 6。也就是不断地修改 Bundle Identifier，等待生成新的 Developer 信息，然后部署这个空的应用在 Visual Studio for Mac 中部署 *[重要] 请回到你的 iPhone 手机，删除刚刚部署的应用 如果你刚刚部署了多个空白应用，那么都要删除 回到 Visual Studio for Mac 并打开你的 Xamarin 项目，然后打开准备部署的应用的 Info.plist 文件 检查 Bundle Identifier，一定要确认跟前面 XCode 中填入的是同一个 Bundle Identifier 额外的，如果你是开发 iOS 扩展，有两个或更多包，那么每个包都需要进入 Info.plist 文件检查 Bundle Identifier 点击 Bundle Signing Options，选择刚刚使用 XCode 生成的开发者信息（如果你看不到，那么就是前面 XCode 的步骤没有执行正确） 在 Mac 上插入你的 iPhone，解锁 iPhone，等待左上角出现你 iPhone 的名称和图标。 如果没有出现，你可能需要点击一下 Debug iPhone 区域，一定要确保选中了 iPhone 而不是 iPhone Simulator 点击 Visual Studio for Mac 左上角的运行按钮，等待你 Xamarin 的应用部署到你的手机上（可能需要数十秒到数分钟）。理论上经过以上步骤，你就可以在你的 iPhone 上看到你用 Xamarin 开发的应用了。但其实是无法运行的。如果部署过程中发生了任何错误，请： 检查你的步骤与本文是否有出入； 参考：使用 Xamarin 开发 iOS 应用中需要注意的若干个问题在 iPhone 上操作 打开设置 -&amp;gt; 通用 -&amp;gt; 设备管理 点开 [自己的开发者账号]，点击 [信任]如果你是首次进行此操作（实际上阅读本文操作的应该也就是首次了），那么信任自己的开发者账号可能会花比较长的时间，Visual Studio for Mac 的部署调试可能会因为等待超时而调试失败。不过这不重要，你只需要在 Visual Studio for Mac 上点击停止调试，然后再次重来就可以了。还需要注意，如果你删除了你部署的应用，那么下次部署的时候在 iPhone 上的操作部分需要重新进行。还需要注意，可能每过 6 天，本文所述的所有步骤都需要重新进行一遍。" }, { "title": "设置进程的 RedirectStandardOutput 重定向输出后，如果不将输出读出来，会卡死此进程", "url": "/post/standard-output-must-be-read-if-you-redirect-standard-output.html", "categories": "", "tags": "dotnet, csharp", "date": "2020-08-04 11:00:19 +0800", "snippet": "设置进程的 RedirectStandardOutput 重定向输出后，必须将其读出来。本文带你做一个实验并得出结论。重定向输出一个简单的尝试重定向输出的代码如下：using var process = new Process{ StartInfo = new ProcessStartInfo(&quot;Walterlv.Demo.Output.exe&quot;) { UseShellExecute = false, CreateNoWindow = true, RedirectStandardOutput = true, },};process.Start();Console.ReadLine();正常跑起来的话不会出什么问题。不过对于 Walterlv.Demo.exe 那个进程来说，就比较危险了……卡死！Walterlv.Demo.Output.exe 是什么程序呢？自己写的测试程序，如下：namespace Walterlv.Demo.Output{ class Program { static void Main(string[] args) { for (var i = 0; i &amp;lt; int.MaxValue; i++) { System.Console.WriteLine($&quot;[{i.ToString().PadLeft(7)}] Console.WriteLine();&quot;); } } }}用 Visual Studio 附加到两个进程后，点击“暂停”按钮，会发现这个 for 循环并没有像平常的其他循环一样瞬间炸裂，而是停在了一个神奇的数字“128”上。点击“继续”按钮，过一会儿再点击“暂停”，依然显示的是“128”。说明–现在卡死了！缓冲区已满因为我们前面的代码使用 Console.ReadLine() 等待用户输入，我们在下一行打一个断点，可以在按下回车后进入断点，于是可以观察到 process 里面的各种字段和属性。可以注意到，StandardOutput 属性中是存在缓冲区的，大小只有 4096 字节。打开 charBuffer 字段，可观察到每一个字节的值。我们的输出程序，总共输出 128 次即死掉，而每次输出的行（就是那个 [ 1] Console.WriteLine();）我正好安排到 32 个字符。乘起来刚好 4096 大小。开发注意如果你重定向了输出流，那么一定记得取出输出数据，否则会导致被启动的程序卡死在下一个 Console.WriteLine 中。" }, { "title": "三种方法设置 .NET/C# 项目的编译顺序，而不影响项目之间的引用", "url": "/post/affects-project-building-order.html", "categories": "", "tags": "visualstudio, msbuild, dotnet", "date": "2020-06-24 09:40:36 +0800", "snippet": "当 A 项目引用 B 项目，那么使用 Visual Studio 或者 MSBuild 编译 A 项目之前就会确保 B 项目已经编译完毕。通常我们指定这种引用是因为 A 项目确实在运行期间需要 B 项目生成的程序集。但是，现在 B 项目可能仅仅只是一个工具项目，或者说 A 项目编译之后的程序集并不需要 B，仅仅只是将 B 打到一个包中，那么我们其实需要的仅仅是 B 项目先编译而已。本文介绍如何影响项目的编译顺序，而不带来项目实际引用。方法一：设置 ReferenceOutputAssembly&amp;lt;ItemGroup&amp;gt; &amp;lt;ProjectReference Include=&quot;..\\Walterlv.Demo.Analyzer\\Walterlv.Demo.Analyzer.csproj&quot; ReferenceOutputAssembly=&quot;false&quot; /&amp;gt; &amp;lt;ProjectReference Include=&quot;..\\Walterlv.Demo.Build\\Walterlv.Demo.Build.csproj&quot; ReferenceOutputAssembly=&quot;false&quot; /&amp;gt;&amp;lt;/ItemGroup&amp;gt;详见 通过 ReferenceOutputAssembly=False 在引用项目时，不额外引入依赖文件 - walterlv。方法二：设置解决方案级别的项目依赖此方法可能会是更加常用的方法，但兼容性不那么好，可能在部分旧版本的 Visual Studio 或者 .NET Core 版本的 dotnet build 命令下不容易工作起来。在解决方案上右键，然后选择“设置项目依赖”：然后在弹出的项目依赖对话框中选择一个项目的依赖：详见：通过设置 sln 解决方案依赖，确保不引用的两个项目之间有明确的编译顺序 - walterlv。方法三：使用 MSBuild 编译任务来编译其他项目&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;TargetFramework&amp;gt;net48&amp;lt;/TargetFramework&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;Target Name=&quot;BuildTheCompilerProject&quot; BeforeTargets=&quot;BeforeBuild&quot;&amp;gt; &amp;lt;MSBuild Projects=&quot;..\\Walterlv.Packages.Compiler\\Walterlv.Packages.Compiler.csproj&quot; Targets=&quot;Build&quot; Properties=&quot;Configuration=$(Configuration);Platform=$(Platform)&quot; /&amp;gt; &amp;lt;/Target&amp;gt;&amp;lt;/Project&amp;gt;详见 Visual Studio 在编译 A 项目时，确保 B 项目已编译 - walterlv。使用哪一种？   ReferenceOutputAssembly 解决方案依赖 MSBuild 编译任务 位置 项目文件（csproj）或编译文件（*.props / *.targets） 解决方案文件（sln） 项目文件（csproj）或编译文件（*.props / *.targets） 编译项目 ✔️生效 ❌无效 ✔️生效 编译解决方案 ✔️生效 ✔️生效 ✔️生效 拷贝依赖项目的输出文件 否 ⚠是 否 要求匹配目标框架TargetFramework ⚠是 否 否 占用一个编译时机 否 否 ⚠是 兼容性 ✔️ ⚠早期版本的dotnet build 不支持 ✔️ ✔️优势❌劣势⚠可能优可能劣（但在本文场景是劣势）位置：代码可以写到哪些文件中编译项目：使用 dotnet build 或者 msbuild 命令来编译时，传入项目文件编译解决方案：使用 dotnet build 或者 msbuild 命令来编译时，传入解决方案文件拷贝依赖项目的输出文件：如果 A 项目引用 B 项目，那么 B 项目的输出文件会被自动拷贝到 A 项目的输出目录中要求匹配目标框架：必须匹配的框架才能引用，例如 net48 能引用 net45，netcoreapp3.1 能引用 netstandard2.0，但 net45 不能引用 netcoreapp3.1占用一个编译时机：在此编译时机之前的依赖是无效的（详见：Visual Studio 在编译 A 项目时，确保 B 项目已编译）参考资料 Question about Visual Studio *.sln file format - Stack Overflow" }, { "title": "通过设置 sln 解决方案依赖，确保不引用的两个项目之间有明确的编译顺序", "url": "/post/setup-project-dependencies-in-the-solution-file.html", "categories": "", "tags": "visualstudio, dotnet", "date": "2020-06-24 09:04:14 +0800", "snippet": "有时在编译解决方案的时候，希望两个项目有明确的编译顺序，而不是自动决定，或者在并行编译的时候同时编译。本文介绍通过设置 sln 解决方案依赖来解决编译顺序问题。设置解决方案级别的项目依赖在解决方案上右键，然后选择“设置项目依赖”：然后在弹出的项目依赖对话框中选择一个项目的依赖：这时，如果看看解决方案文件（.sln）则可以看到多出了 ProjectDependencies 区：Project(&quot;{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}&quot;) = &quot;Walterlv.Demo&quot;, &quot;Walterlv.Demo\\Walterlv.Demo.csproj&quot;, &quot;{DC0B1D44-5DF4-4590-BBFE-072183677A78}&quot; ProjectSection(ProjectDependencies) = postProject {98FF9756-B95A-4FDB-9858-5106F486FBF3} = {98FF9756-B95A-4FDB-9858-5106F486FBF3} EndProjectSectionEndProject更多关于 sln 文件的理解，可以阅读我的另一篇博客： 理解 Visual Studio 解决方案文件格式（.sln）其他方法本文的方法已加入到此类型解法的方法列表中，详情请看： 三种方法设置 .NET/C# 项目的编译顺序，而不影响项目之间的引用 - walterlv" }, { "title": "通过 ReferenceOutputAssembly=False 在引用项目时，不额外引入依赖文件", "url": "/post/reference-a-project-without-referencing-output-assembly.html", "categories": "", "tags": "visualstudio, dotnet", "date": "2020-06-24 08:42:26 +0800", "snippet": "正常当两个 .NET 项目有引用的时候，会将一个的输出拷贝到另一个的输出目录下。但有时我们只是希望通过引用建立一个依赖关系而已，最终两个项目的输出是独立的。通过本文的方法，你可以在 A 项目编译时，确保 B 项目已经编译，而无需引用 B。ReferenceOutputAssembly=False依然在项目中使用往常习惯的方法设置项目引用：但是，在项目引用设置完成之后，需要打开项目的项目文件（.csproj）给 ProjectReference 节点加上 ReferenceOutputAssembly 的属性设置，将其值设置为 false。这表示仅仅是项目引用，而不将项目的任何输出程序集作为此项目的依赖。&amp;lt;ItemGroup&amp;gt; &amp;lt;ProjectReference Include=&quot;..\\Walterlv.Demo.Analyzer\\Walterlv.Demo.Analyzer.csproj&quot; ReferenceOutputAssembly=&quot;false&quot; /&amp;gt; &amp;lt;ProjectReference Include=&quot;..\\Walterlv.Demo.Build\\Walterlv.Demo.Build.csproj&quot; ReferenceOutputAssembly=&quot;false&quot; /&amp;gt;&amp;lt;/ItemGroup&amp;gt;上面的 ProjectReference 是 Sdk 风格的 csproj 文件中的项目引用。即便不是 Sdk 风格，也是一样的加这个属性。当然，你写多行也是可以的：&amp;lt;ItemGroup&amp;gt; &amp;lt;ProjectReference Include=&quot;..\\Walterlv.Demo.Analyzer\\Walterlv.Demo.Analyzer.csproj&quot;&amp;gt; &amp;lt;ReferenceOutputAssembly&amp;gt;false&amp;lt;/ReferenceOutputAssembly&amp;gt; &amp;lt;/ProjectReference&amp;gt; &amp;lt;ProjectReference Include=&quot;..\\Walterlv.Demo.Build\\Walterlv.Demo.Build.csproj&quot;&amp;gt; &amp;lt;ReferenceOutputAssembly&amp;gt;false&amp;lt;/ReferenceOutputAssembly&amp;gt; &amp;lt;/ProjectReference&amp;gt;&amp;lt;/ItemGroup&amp;gt;这种做法有两个非常棒的用途： 生成代码 依赖的项目（如上面的 Walterlv.Demo.Build）编译完成之后会生成一个可执行程序，它的作用是为我们当前的项目生成新的代码的。 于是我们仅仅需要在编译当前项目之前先把这个依赖项目编译好就行，并不需要生成运行时的依赖。 NuGet 包中附带其他文件 如果要生成 NuGet 包，我们有时需要多个项目生成的文件来共同组成一个 NuGet 包，这个时候我们需要的仅仅是把其他项目生成的文件放到 NuGet 包中，而不是真的需要在 NuGet 包级别建立对此项目的依赖。 当使用 ReferenceOutputAssembly 来引用项目，最终生成的 NuGet 包中就不会生成对这些项目的依赖。 其他方法本文的方法已加入到此类型解法的方法列表中，详情请看： 三种方法设置 .NET/C# 项目的编译顺序，而不影响项目之间的引用 - walterlv" }, { "title": ".NET 程序集/项目/包的版本号设置有最大范围，最大不能超过 65534", "url": "/post/dotnet-version-number-too-large.html", "categories": "", "tags": "visualstudio, dotnet", "date": "2020-06-19 00:05:08 +0800", "snippet": "试过给 .NET Core 项目设置一个大于 65535 的版本号吗？可能没有，因为设置了会炸！最简问题项目用最普通的项目模板创建一个 .NET 项目（要求是 SDK 风格的），于是，你会得到两个文件：项目文件 Walterlv.Demo.csproj 和代码文件 Class1.cs。Walterlv.Demo.csproj：&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;TargetFramework&amp;gt;netcoreapp3.1&amp;lt;/TargetFramework&amp;gt; &amp;lt;/PropertyGroup&amp;gt;&amp;lt;/Project&amp;gt;Class1.cs 应该不用贴出来了，因为没啥关系。现在，我们加个版本号： &amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt;++ &amp;lt;Version&amp;gt;1.0.0.65535&amp;lt;/Version&amp;gt; &amp;lt;TargetFramework&amp;gt;netcoreapp3.1&amp;lt;/TargetFramework&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;/Project&amp;gt;一编译就立刻编译错误：然而，只要把版本号改到 65534 或者更小的值就没有问题。因为我们可以知道，在 SDK 风格的项目当中，版本号的任何一位的范围只能是 0~65534。传统项目没问题你可能会说，创建了一个 .NET Framework 的项目，并没有出现问题。那是因为此问题的复现要求： 必须是 SDK 风格的项目（.NET Core 默认的风格，也可用于 .NET Framework）； 必须是通过 .csproj 或者 .props / .targets 文件来指定的版本号。这两个条件缺一不可。而通过模板创建的 .NET Framework 项目默认使用的是传统风格的 csproj 项目文件。如果是传统风格的项目，必须使用 AssemblyInfo.cs 来指定版本号；新的 SDK 风格的版本号也可以使用 AssemblyInfo.cs 来指定版本号。而这两种情况的版本号范围是整个 int 范围（0~2G）。附，在 SDK 风格项目中使用 AssemblyInfo.cs 来指定版本号前，你需要先用以下属性关闭默认自动生成 AssemblyInfo.cs 功能： &amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;TargetFramework&amp;gt;netcoreapp3.1&amp;lt;/TargetFramework&amp;gt;++ &amp;lt;GenerateAssemblyInfo&amp;gt;False&amp;lt;/GenerateAssemblyInfo&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;/Project&amp;gt;谁的限制？实际上，版本号限制是 Windows 系统带来的，Windows 系统限制到 65535 了。虽然你可以通过以上 AssemblyInfo 的方法绕过编译错误，但实际上生成的文件版本会溢出：.NET 运行时是可以支持 int 范围的版本号的，无奈兼容 Windows 的部分却不行。参考资料 Why are build numbers limited to 65535? - Microsoft Docs c# - The specified version string does not conform to the required format - major[.minor[.build[.revision]]] - Stack Overflow" }, { "title": "Visual Studio 在编译 A 项目时，确保 B 项目已编译", "url": "/post/msbuild-another-project-in-msbuild-targets.html", "categories": "", "tags": "visualstudio, dotnet", "date": "2020-06-18 08:53:17 +0800", "snippet": "如果考虑在你的某个项目中安插一个专门用来做编译的项目，这个项目要求最先编译，那么你会考虑用什么方法呢？本文讲述在编译 A 项目时，确保 B 项目已编译的方法。使用 MSBuild 编译目标来编译A 在编译的时候，需要确保 B 项目已经编译（因为可能用到 B 的输出）。然而 A 项目并不需要引用 B，因为仅仅是编译需要用到 B 而已，不需要在最终产品中带上 B。那么在 A 项目中，使用 MSBuild 编译任务来编译 B：&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;TargetFramework&amp;gt;net48&amp;lt;/TargetFramework&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;Target Name=&quot;BuildTheCompilerProject&quot; BeforeTargets=&quot;BeforeBuild&quot;&amp;gt; &amp;lt;MSBuild Projects=&quot;..\\Walterlv.Packages.Compiler\\Walterlv.Packages.Compiler.csproj&quot; Targets=&quot;Build&quot; Properties=&quot;Configuration=$(Configuration);Platform=$(Platform)&quot; /&amp;gt; &amp;lt;/Target&amp;gt;&amp;lt;/Project&amp;gt;而 B 项目，则可能是框架完全不兼容的另一种项目：&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;TargetFramework&amp;gt;netcoreapp3.1&amp;lt;/TargetFramework&amp;gt; &amp;lt;/PropertyGroup&amp;gt;&amp;lt;/Project&amp;gt;其他方法本文的方法已加入到此类型解法的方法列表中，详情请看： 三种方法设置 .NET/C# 项目的编译顺序，而不影响项目之间的引用 - walterlv" }, { "title": "理解 Visual Studio 解决方案文件格式（.sln）", "url": "/post/understand-the-sln-file.html", "categories": "", "tags": "visualstudio, dotnet", "date": "2020-06-18 08:34:02 +0800", "snippet": "一般情况下我们并不需要关心 Visual Studio 解决方案文件格式（.sln），因为 Visual Studio 对解决方案文件的自动修复能力是非常强的。但是如果遇到自动解冲突错误或者编译不通过了，那么此文件还是需要手工修改的。本文介绍 Visual Studio 解决方案（.sln）文件的格式。基本概念Visual Studio 的解决方案文件由这三个部分组成： 版本信息 Microsoft Visual Studio Solution File, Format Version 12.00 # Visual Studio Version 16 VisualStudioVersion = 16.0.28606.126 MinimumVisualStudioVersion = 10.0.40219.1 项目信息 Project EndProject 全局信息 Global EndGlobal 虽然看起来是三个独立的部分，但其实除了版本号之外，项目信息和全局信息还是有挺多耦合部分的。比如我们来看一个 sln 文件的例子，是一个最简单的只有一个项目的 sln 文件：Microsoft Visual Studio Solution File, Format Version 12.00# Visual Studio Version 16VisualStudioVersion = 16.0.29102.190MinimumVisualStudioVersion = 10.0.40219.1Project(&quot;{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}&quot;) = &quot;Walterlv.Demo&quot;, &quot;Walterlv.Demo\\Walterlv.Demo.csproj&quot;, &quot;{DC0B1D44-5DF4-4590-BBFE-072183677A78}&quot;EndProjectGlobal GlobalSection(SolutionConfigurationPlatforms) = preSolution Debug|Any CPU = Debug|Any CPU Release|Any CPU = Release|Any CPU EndGlobalSection GlobalSection(ProjectConfigurationPlatforms) = postSolution {DC0B1D44-5DF4-4590-BBFE-072183677A78}.Debug|Any CPU.ActiveCfg = Debug|Any CPU {DC0B1D44-5DF4-4590-BBFE-072183677A78}.Debug|Any CPU.Build.0 = Debug|Any CPU {DC0B1D44-5DF4-4590-BBFE-072183677A78}.Release|Any CPU.ActiveCfg = Release|Any CPU {DC0B1D44-5DF4-4590-BBFE-072183677A78}.Release|Any CPU.Build.0 = Release|Any CPU EndGlobalSection GlobalSection(SolutionProperties) = preSolution HideSolutionNode = FALSE EndGlobalSection GlobalSection(ExtensibilityGlobals) = postSolution SolutionGuid = {F2F1AD1B-207B-4731-ABEB-92882F89B155} EndGlobalSectionEndGlobal下面我们来一一说明。结构版本信息Microsoft Visual Studio Solution File, Format Version 12.00# Visual Studio Version 16VisualStudioVersion = 16.0.29102.190MinimumVisualStudioVersion = 10.0.40219.1记录文件的格式版本是 12.0。使用 Visual Studio 2019 编辑/创建。这里有一个小技巧，这里的 VisualStudioVersion 版本号设置为 15.0 会使得打开 sln 文件的时候默认使用 Visual Studio 2017，而设置为 16.0 会使得打开 sln 文件的时候默认使用 Visual Studio 2019。项目信息ProjectProject(&quot;{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}&quot;) = &quot;Walterlv.Demo&quot;, &quot;Walterlv.Demo\\Walterlv.Demo.csproj&quot;, &quot;{DC0B1D44-5DF4-4590-BBFE-072183677A78}&quot;EndProject项目信息至少由两行组成，第一行标记项目信息开始，而最后一行表示信息结束。其格式为：Project(&quot;{项目类型}&quot;) = &quot;项目名称&quot;, &quot;项目路径&quot;, &quot;项目 Id&quot;EndProject你可以在我的另一篇博客中找到项目类型： 解决方案文件 sln 中的项目类型 GUID但是本文列举几个 .NET/C# 项目中的常见类型： 9A19103F-16F7-4668-BE54-9A1E7A4F7556 SDK 风格的 C# 项目文件 FAE04EC0-301F-11D3-BF4B-00C04F79EFBC 传统风格的 C# 项目文件 2150E333-8FDC-42A3-9474-1A3956D46DE8 解决方案文件夹关于 SDK 风格的项目文件，可以阅读我的另一篇博客： 将 WPF、UWP 以及其他各种类型的旧 csproj 迁移成 Sdk 风格的 csproj - walterlv项目名称和项目路径不必多说，都知道。对于文件夹而言，项目名称就是文件夹的名称，而项目路径也是文件夹的名称。项目 Id 是在解决方案创建项目的过程中生成的一个新的 GUID，每个项目都不一样。对于 SDK 风格的 C# 项目文件，csproj 中可以指定项目依赖，而如果没有直接的项目依赖，而只是解决方案编译级别的依赖，那么也可以靠 sln 文件中的项目 Id 来指定项目的依赖关系。另外，也通过项目 Id 来对项目做一些编译上的解决方案级别的配置。ProjectSectionProject 和 EndProject 的内部还可以放 ProjectSection。比如对于解决方案文件夹，可以包含解决方案文件：Project(&quot;{2150E333-8FDC-42A3-9474-1A3956D46DE8}&quot;) = &quot;Solution Items&quot;, &quot;Solution Items&quot;, &quot;{B002382D-4C9E-4F08-85E5-F12E2C061F5A}&quot; ProjectSection(SolutionItems) = preProject .gitattributes = .gitattributes .gitignore = .gitignore README.md = README.md build\\Version.props = build\\Version.props EndProjectSectionEndProject这个解决方案文件夹中包含了四个文件，其路径分别记录在了 ProjectSection 节点里面。ProjectSection 还可以记录项目依赖关系（非项目之间的真实依赖，而是解决方案级别的编译依赖）：Project(&quot;{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}&quot;) = &quot;Walterlv.Demo&quot;, &quot;Walterlv.Demo\\Walterlv.Demo.csproj&quot;, &quot;{DC0B1D44-5DF4-4590-BBFE-072183677A78}&quot; ProjectSection(ProjectDependencies) = postProject {98FF9756-B95A-4FDB-9858-5106F486FBF3} = {98FF9756-B95A-4FDB-9858-5106F486FBF3} EndProjectSectionEndProjectProject(&quot;{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}&quot;) = &quot;Walterlv.Demo2&quot;, &quot;Walterlv.Demo2\\Walterlv.Demo2.csproj&quot;, &quot;{98FF9756-B95A-4FDB-9858-5106F486FBF3}&quot;EndProject在这一段节点里面，我们的 Walterlv.Demo 项目依赖于另外一个 Walterlv.Demo2 项目。依赖是以 项目 Id = 项目 Id 的方式写出来的；如果有多个依赖，那么就写多行。不用吐槽为什么一样还要写两遍，因为这是一个固定的格式，后面我们会介绍一些全局配置里面会有两个不一样的。关于设置项目依赖关系的方法，除了 sln 文件里面的设置之外，还有通过设置项目依赖属性的方式，详情可以阅读： 三种方法设置 .NET/C# 项目的编译顺序，而不影响项目之间的引用全局信息一个全局信息的例子如下：Global GlobalSection(SolutionConfigurationPlatforms) = preSolution Debug|Any CPU = Debug|Any CPU Release|Any CPU = Release|Any CPU EndGlobalSection GlobalSection(ProjectConfigurationPlatforms) = postSolution {DC0B1D44-5DF4-4590-BBFE-072183677A78}.Debug|Any CPU.ActiveCfg = Debug|Any CPU {DC0B1D44-5DF4-4590-BBFE-072183677A78}.Debug|Any CPU.Build.0 = Debug|Any CPU {DC0B1D44-5DF4-4590-BBFE-072183677A78}.Release|Any CPU.ActiveCfg = Release|Any CPU {DC0B1D44-5DF4-4590-BBFE-072183677A78}.Release|Any CPU.Build.0 = Release|Any CPU {98FF9756-B95A-4FDB-9858-5106F486FBF3}.Debug|Any CPU.ActiveCfg = Debug|Any CPU {98FF9756-B95A-4FDB-9858-5106F486FBF3}.Debug|Any CPU.Build.0 = Debug|Any CPU {98FF9756-B95A-4FDB-9858-5106F486FBF3}.Release|Any CPU.ActiveCfg = Release|Any CPU {98FF9756-B95A-4FDB-9858-5106F486FBF3}.Release|Any CPU.Build.0 = Release|Any CPU EndGlobalSection GlobalSection(SolutionProperties) = preSolution HideSolutionNode = FALSE EndGlobalSection GlobalSection(ExtensibilityGlobals) = postSolution SolutionGuid = {F2F1AD1B-207B-4731-ABEB-92882F89B155} EndGlobalSectionEndGlobal在这个全局信息的例子中，为解决方案指定了两个配置（Configuration），Debug 和 Release，平台都是 Any CPU。同时也为每个项目指定了单独的配置种类，可供选择，每一行都是 项目的配置 = 解决方案的配置 表示此项目的此种配置在解决方案的某个全局配置之下。如果我们将这两个项目放到文件夹中，那么我们可以额外看到一个新的全局配置 NestedProjects 字面意思是说 {DC0B1D44-5DF4-4590-BBFE-072183677A78} 和 {98FF9756-B95A-4FDB-9858-5106F486FBF3} 两个项目在 {20B61509-640C-492B-8B33-FB472CCF1391} 项目中嵌套，实际意义代表 Walterlv.Demo 和 Walterlv.Demo2 两个项目在 Folder 文件夹下。GlobalSection(NestedProjects) = preSolution {DC0B1D44-5DF4-4590-BBFE-072183677A78} = {20B61509-640C-492B-8B33-FB472CCF1391} {98FF9756-B95A-4FDB-9858-5106F486FBF3} = {20B61509-640C-492B-8B33-FB472CCF1391}EndGlobalSection上图解决方案下的整个解决方案全部内容如下：Microsoft Visual Studio Solution File, Format Version 12.00# Visual Studio Version 16VisualStudioVersion = 16.0.29102.190MinimumVisualStudioVersion = 10.0.40219.1Project(&quot;{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}&quot;) = &quot;Walterlv.Demo&quot;, &quot;Walterlv.Demo\\Walterlv.Demo.csproj&quot;, &quot;{DC0B1D44-5DF4-4590-BBFE-072183677A78}&quot; ProjectSection(ProjectDependencies) = postProject {98FF9756-B95A-4FDB-9858-5106F486FBF3} = {98FF9756-B95A-4FDB-9858-5106F486FBF3} EndProjectSectionEndProjectProject(&quot;{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}&quot;) = &quot;Walterlv.Demo2&quot;, &quot;Walterlv.Demo2\\Walterlv.Demo2.csproj&quot;, &quot;{98FF9756-B95A-4FDB-9858-5106F486FBF3}&quot;EndProjectProject(&quot;{2150E333-8FDC-42A3-9474-1A3956D46DE8}&quot;) = &quot;Folder&quot;, &quot;Folder&quot;, &quot;{20B61509-640C-492B-8B33-FB472CCF1391}&quot;EndProjectGlobal GlobalSection(SolutionConfigurationPlatforms) = preSolution Debug|Any CPU = Debug|Any CPU Release|Any CPU = Release|Any CPU EndGlobalSection GlobalSection(ProjectConfigurationPlatforms) = postSolution {DC0B1D44-5DF4-4590-BBFE-072183677A78}.Debug|Any CPU.ActiveCfg = Debug|Any CPU {DC0B1D44-5DF4-4590-BBFE-072183677A78}.Debug|Any CPU.Build.0 = Debug|Any CPU {DC0B1D44-5DF4-4590-BBFE-072183677A78}.Release|Any CPU.ActiveCfg = Release|Any CPU {DC0B1D44-5DF4-4590-BBFE-072183677A78}.Release|Any CPU.Build.0 = Release|Any CPU {98FF9756-B95A-4FDB-9858-5106F486FBF3}.Debug|Any CPU.ActiveCfg = Debug|Any CPU {98FF9756-B95A-4FDB-9858-5106F486FBF3}.Debug|Any CPU.Build.0 = Debug|Any CPU {98FF9756-B95A-4FDB-9858-5106F486FBF3}.Release|Any CPU.ActiveCfg = Release|Any CPU {98FF9756-B95A-4FDB-9858-5106F486FBF3}.Release|Any CPU.Build.0 = Release|Any CPU EndGlobalSection GlobalSection(SolutionProperties) = preSolution HideSolutionNode = FALSE EndGlobalSection GlobalSection(NestedProjects) = preSolution {DC0B1D44-5DF4-4590-BBFE-072183677A78} = {20B61509-640C-492B-8B33-FB472CCF1391} {98FF9756-B95A-4FDB-9858-5106F486FBF3} = {20B61509-640C-492B-8B33-FB472CCF1391} EndGlobalSection GlobalSection(ExtensibilityGlobals) = postSolution SolutionGuid = {F2F1AD1B-207B-4731-ABEB-92882F89B155} EndGlobalSectionEndGlobal" }, { "title": "从 “x is null 和 x == null” 的区别看 C# 7 模式匹配中常量和 null 的匹配", "url": "/post/is-null-vs-==-null.html", "categories": "", "tags": "csharp, msil, dotnet, decompile", "date": "2020-06-16 10:39:41 +0800", "snippet": "尝试过写 if (x is null)？它与 if (x == null) 相比，孰优孰劣呢？x is null 还有 x is constant 是 C# 7.0 中引入的模式匹配（Pattern Matching）中的一个小细节。阅读本文将了解 x is constant 和 x == constant 之间的差别，并给出一些代码编写建议。🤓 C# 7 的模式匹配说到 C# 中新增的模式匹配，想必大家一定不会忘了变量的匹配。以下例子来自于微软官方 C# 7.0 的介绍文档 What’s New in C# 7 - C# Guide - Microsoft Docs：public static int DiceSum2(IEnumerable&amp;lt;object&amp;gt; values){ var sum = 0; foreach(var item in values) { if (item is int val) sum += val; else if (item is IEnumerable&amp;lt;object&amp;gt; subList) sum += DiceSum2(subList); } return sum;}public static int DiceSum3(IEnumerable&amp;lt;object&amp;gt; values){ var sum = 0; foreach (var item in values) { switch (item) { case int val: sum += val; break; case IEnumerable&amp;lt;object&amp;gt; subList: sum += DiceSum3(subList); break; } } return sum;}其实，官方文档中也顺带提及了常量的匹配：public static int DiceSum5(IEnumerable&amp;lt;object&amp;gt; values){ var sum = 0; foreach (var item in values) { switch (item) { case 0: break; case int val: sum += val; break; case PercentileDie die: sum += die.Multiplier * die.Value; break; case IEnumerable&amp;lt;object&amp;gt; subList when subList.Any(): sum += DiceSum5(subList); break; case IEnumerable&amp;lt;object&amp;gt; subList: break; case null: break; default: throw new InvalidOperationException(&quot;unknown item type&quot;); } } return sum;}然而，微软居然只在 switch-case 里面说了常量的匹配，而且 case 0、case null 这不本来就是我们以前熟悉的写法吗！（只不过以前只能判断一个类型的常量）🤔 x is null Vs. x == null好了，回到正题。我们想说的是 x is null 和 x == null。为了得知它们的区别，我们写一段代码：private void TestInWalterlvDemo(object value){ if (value is null) { } if (value == null) { }}反编译看看：.method private hidebysig instance void TestInWalterlvDemo( object &#39;value&#39; ) cil managed { .maxstack 2 .locals init ( [0] bool V_0, [1] bool V_1 ) // [37 9 - 37 10] IL_0000: nop // [38 13 - 38 31] IL_0001: ldarg.1 // &#39;value&#39; IL_0002: ldnull IL_0003: ceq IL_0005: stloc.0 // V_0 IL_0006: ldloc.0 // V_0 IL_0007: brfalse.s IL_000b // [39 13 - 39 14] IL_0009: nop // [40 13 - 40 14] IL_000a: nop // [41 13 - 41 31] IL_000b: ldarg.1 // &#39;value&#39; IL_000c: ldnull IL_000d: ceq IL_000f: stloc.1 // V_1 IL_0010: ldloc.1 // V_1 IL_0011: brfalse.s IL_0015 // [42 13 - 42 14] IL_0013: nop // [43 13 - 43 14] IL_0014: nop // [44 9 - 44 10] IL_0015: ret } // end of method MainPage::Testx is null 对应的是：IL_0001: ldarg.1 // &#39;value&#39;IL_0002: ldnull IL_0003: ceq IL_0005: stloc.0 // V_0先 ldarg.1 将第 1 号参数压到评估栈（为什么不是第 0 号？因为第 0 号是 this）。然后将 ldnull 将 null 压到评估栈上。随后，ceq 比较压入的两个值是否相等。（注意是比较栈中的值哦，不会看引用的对象的！所以如果是引用类型，则比较的是引用本身哦，类似于指针！） 此处划重点，因为考试要考！咳咳……哦不，是后面要用到……x == null 对应的是：IL_000b: ldarg.1 // &#39;value&#39;IL_000c: ldnull IL_000d: ceq IL_000f: stloc.1 // V_1于是发现两个完全一样！！！-_- 本文完，全剧终。然而，如果那个 x 是一个重写了 == 的自定义类型就不一样了（感谢 TimAndy 提供的示例）：private void TestInWalterlvDemo(Foo value){ if (value is null) { } if (value == null) { }}public class C{ bool M1(C x) =&amp;gt; x is null; bool M2(C x) =&amp;gt; x == null; int x; public C(int x) =&amp;gt; this.x=x; public static bool operator== (C o1, C o2) =&amp;gt; o1.x == o2.x; public static bool operator!= (C o1, C o2)=&amp;gt; o1.x != o2.x; public override bool Equals(object o2) =&amp;gt; ((C)o2).x == x; public override int GetHashCode() =&amp;gt; x.GetHashCode();}x is null 对应的是：IL_0000: ldarg.1IL_0001: ldnullIL_0002: ceqIL_0004: retx == null 对应的是：IL_0000: ldarg.1IL_0001: ldnullIL_0002: call bool C::op_Equality(class C, class C)IL_0007: ret这时，调用了重写的 == 运算符。TimAndy 提供的示例详情在如下链接：https://sharplab.io/#v2:EYLgZgpghgLgrgJwgZwLQGUCWBbADgGwgAUEB7AcwSm2QBoYRN8AfAAQCYBGAWACg/WAZgAEHYQGFhAbz7C5w4KVL5hAWU4AKSQA8AlMIC8APmHbhmZMIB2cfPgDcfAJCLla9ltP7jpwweu2DrLywXKYVjCmjrzyoiLiGuGRelIwABYWAHTaBtr2AL6hcaKcAGwKSiqkuBBUMKQIBv6epJy0EsKk7N4mrdl+nezZ0bFCJeWuVTV1DQCEzZKt7YvdPn1m84PDRWOkAG61CJgAJhAVbgCiAI5wUPjIGqTAAFYQAMaRXT3CGlq6X/0mlEdiJ9ocTmcksIAOIQGAACSgyDS4lIpw0320mVhCKRKLREAx0XyQA===。😏 x is 常量 Vs. x == 常量现在我们把 null 换成其它常量：private void TestInWalterlvDemo(object value){ if (value is 1) { } if (value == 1) { }}😲呀……编译不通过！改改……private void TestInWalterlvDemo(object value){ if (value is 1) { } if (value == (object) 1) { }}于是再看看反编译出来的结果。value is 1：IL_0001: ldc.i4.1 IL_0002: box [mscorlib]System.Int32IL_0007: ldarg.1 // &#39;value&#39;IL_0008: call bool [mscorlib]System.Object::Equals(object, object)IL_000d: stloc.0 // V_0value == (object) 1：IL_0013: ldarg.1 // &#39;value&#39;IL_0014: ldc.i4.1 IL_0015: box [mscorlib]System.Int32IL_001a: ceq IL_001c: stloc.1 // V_1现在已经不一样了，前者再比较时用的是 call，调用了 bool [mscorlib]System.Object::Equals(object, object) 方法；而后者依然用的是 ceq。区别已经很明显了，前者会根据具体类型具体判断相等，也就是说引用类型会调用引用类型自己的方法判断相等，值类型也会调用值类型的方法判断相等。而后者依然是比较评估栈中的两个值是否相等。关键是这两者均出现了装箱！也就是说——因为装箱的存在，对后者而言，ceq 会压入 0，即永远返回 false，这就是 BUG 所在。这就是不一样的地方！🧐如果重写了 == 或者 Equals 呢？using System;namespace Walterlv.EqualsTest{ class Program { static void Main(string[] args) { var foo = new Foo(); Console.WriteLine(foo == null); Console.WriteLine(foo.Equals(null)); Console.WriteLine(foo is null); Console.WriteLine(Equals(foo, null)); Console.ReadLine(); } } public class Foo { public override bool Equals(object obj) { return true; } public static bool operator ==(Foo left, Foo right) { return true; } public static bool operator !=(Foo left, Foo right) { return !(left == right); } }}这段代码的执行结果是：TrueTrueFalseFalse他们的 IL 代码如下。可以看到 == 和 Equals 会调用重载的运算符和方法；而使用 is 判断和前面是一样的，不受重载影响，可以和 Object 的 Equals 静态方法一样正常完成判空。// foo == nullIL_0005: dupIL_0006: ldnullIL_0007: call bool Walterlv.EqualsTest.Foo::op_Equality(class Walterlv.EqualsTest.Foo, class Walterlv.EqualsTest.Foo)IL_000c: call void [System.Console]System.Console::WriteLine(bool)// foo.Equals(null)IL_0011: dupIL_0012: ldnullIL_0013: callvirt instance bool [System.Runtime]System.Object::Equals(object)IL_0018: call void [System.Console]System.Console::WriteLine(bool)// foo is nullIL_001d: dupIL_001e: ldnullIL_001f: ceqIL_0021: call void [System.Console]System.Console::WriteLine(bool)// Equals(foo, null)IL_0026: ldnullIL_0027: call bool [System.Runtime]System.Object::Equals(object, object)IL_002c: call void [System.Console]System.Console::WriteLine(bool)你可以阅读 Object.Equals Method (System) - Microsoft Docs 了解到静态 Equals 方法的实现。回顾模式匹配中的常量匹配在 C# 7 的模式匹配中，null 和常量其实都一样是常量，本来都是会调用 Object.Equals(object, object) 静态方法进行比较的；但 null 因为其特殊性，被编译器优化掉了，于是 x is null 和 x == null 完全一样；x is constant 和 x == constant 依然有区别。从反编译的 MSIL 代码中我们也可以得出一些代码编写上的建议。在比较常量的时候，如果可能，尽量使用 is 进行比较，而不是 ==。好处多多： 如果是 null，写 x is null 很符合英语的阅读习惯，代码阅读起来比较舒适。 如果是值常量，可以避免装箱带来的相等判断错误问题参考资料 What’s New in C# 7 - C# Guide - Microsoft Docs Dissecting the pattern matching in C# 7 – Dissecting the code c# - What is the difference between “x is null” and “x == null”? - Stack Overflow C# 7.0 语言新特性 - 技术翻译 - 开源中国社区 OpCodes.Ceq Field (System.Reflection.Emit) OpCodes.Ldarg_0 Field (System.Reflection.Emit) OpCodes.Stloc Field (System.Reflection.Emit) OpCodes.Ldc_I4_1 Field (System.Reflection.Emit)" }, { "title": "如何根据一个绝对文件路径生成一个相对文件路径", "url": "/post/make-relative-file-path.html", "categories": "", "tags": "dotnet", "date": "2020-06-15 17:23:04 +0800", "snippet": "日常的开发中，获取绝对文件路径才是主流吧！连 Path.GetFullPath 这种生成绝对路径的方法都已经成为 .NET Standard 的一部分了。然而，生成相对路径依然有用——比如你的配置文件是相对于工作目录的，必须这个路径是输出给用户看的…….NET Core 2.0 开始，提供了 Path.GetRelativePath 这样的方法来获取两个路径之间的相对路径，但是 .NET Framework 却没有这样的方法可以用。那么，在旧版本的 .NET Core 或者 .NET Framework 中 Path 没有生成相对路径的方法，还能怎么生成相对路径呢？别跟我说自己去做字符串比较……Uri 提供了 MakeRelativeUri 方法，可以生成一个路径到另一个路径的相对路径。于是我们可以写出这样的代码：public static string MakeRelativePath(string fromPath, string toPath){ var fromUri = new Uri(fromPath); var toUri = new Uri(toPath); var relativeUri = fromUri.MakeRelativeUri(toUri); return Uri.UnescapeDataString(relativeUri.ToString());}运行传入 C:\\Users\\walterlv\\OpenSource\\Demo 和 C:\\Users\\walterlv\\OpenSource\\Demo\\build\\config.xml。结果，竟然得到的相对路径是：Demo/build/config.xml。 那个 Demo 明明是两者共有的路径部分，却存在于相对路径中； 生成的路径使用 /，而不是 Windows 系统使用的 \\。于是我们需要分别进行这两个处理。对于前者，我们必须让 Uri 意识到这是一个文件夹才能让最终生成的路径不带这个重复的部分；对于后者，我们需要进行路径连接符转换。于是最终的代码我整理成了如下方法：public static string MakeRelativePath(string fromPath, string toPath){ if (string.IsNullOrEmpty(fromPath)) throw new ArgumentNullException(nameof(fromPath)); if (string.IsNullOrEmpty(toPath)) throw new ArgumentNullException(nameof(toPath)); var fromUri = new Uri(fromPath); var toUri = new Uri(toPath); if (fromUri.Scheme != toUri.Scheme) { // 不是同一种路径，无法转换成相对路径。 return toPath; } if (fromUri.Scheme.Equals(&quot;file&quot;, StringComparison.InvariantCultureIgnoreCase) &amp;amp;&amp;amp; !fromPath.EndsWith(&quot;/&quot;, StringComparison.OrdinalIgnoreCase) &amp;amp;&amp;amp; !fromPath.EndsWith(&quot;\\\\&quot;, StringComparison.OrdinalIgnoreCase)) { // 如果是文件系统，则视来源路径为文件夹。 fromUri = new Uri(fromPath + Path.DirectorySeparatorChar); } var relativeUri = fromUri.MakeRelativeUri(toUri); var relativePath = Uri.UnescapeDataString(relativeUri.ToString()); if (toUri.Scheme.Equals(&quot;file&quot;, StringComparison.InvariantCultureIgnoreCase)) { relativePath = relativePath.Replace(Path.AltDirectorySeparatorChar, Path.DirectorySeparatorChar); } return relativePath;}现在重新传入 C:\\Users\\walterlv\\OpenSource\\Demo 和 C:\\Users\\walterlv\\OpenSource\\Demo\\build\\config.xml。结果，已经能够得到：build\\config.xml 了。关于 .NET Core 中的 Path.GetRelativePath 方法，可以参考：GetRelativePath参考资料 .net - How to get relative path from absolute path - Stack Overflow Path.GetRelativePath" }, { "title": ".NET/C# 使用 SetWindowsHookEx 监听鼠标或键盘消息以及此方法的坑", "url": "/post/add-global-windows-hook-in-dotnet.html", "categories": "", "tags": "windows, dotnet, csharp", "date": "2020-06-13 17:39:12 +0800", "snippet": "一般来说，大家在需要监听全局消息的时候会考虑 SetWindowsHookEx 这个 API。或者需要处理一些非自己编写的窗口的消息循环的时候，也会考虑使用它。如果要知道如何使用这个 API，你可以在网上搜到大量这样的文章/博客/教程/文档，然而大多不会提及使用此 API 时遇到的一些坑。阅读本文，你当然也可以知道应该如何使用这个 API，但同时也能了解如何正确使用以避免一些奇怪的问题。基本使用如果你在阅读本文的时候遇到了一些问题，可考虑去 GitHub 上克隆我的源码，跑一跑试试。在这里：walterlv/Walterlv.Demo.SetWindowsHookEx。简单一点，先贴出一部分可以工作起来的代码，你直接可以放到你的项目当中运行测试：public partial class MainWindow : Window{ private readonly HookProc _mouseHook; private IntPtr _hMouseHook; public MainWindow() { InitializeComponent(); _mouseHook = OnMouseHook; Loaded += OnLoaded; } private void OnLoaded(object sender, RoutedEventArgs e) { var hModule = GetModuleHandle(null); // 你可能会在网上搜索到下面注释掉的这种代码，但实际上已经过时了。 // 下面代码在 .NET Core 3.x 以上可正常工作，在 .NET Framework 4.0 以下可正常工作。 // 如果不满足此条件，你也可能可以正常工作，详情请阅读本文后续内容。 // var hModule = Marshal.GetHINSTANCE(Assembly.GetExecutingAssembly().GetModules()[0]); _hMouseHook = SetWindowsHookEx( HookType.WH_MOUSE_LL, _mouseHook, hModule, 0); if (_hMouseHook == IntPtr.Zero) { int errorCode = Marshal.GetLastWin32Error(); throw new Win32Exception(errorCode); } } private IntPtr OnMouseHook(int nCode, IntPtr wParam, IntPtr lParam) { // 在这里，你可以处理全局鼠标消息。 return CallNextHookEx(new IntPtr(0), nCode, wParam, lParam); }}本文讨论使用 .NET/C# 来完成 SetWindowsHookEx 的调用，所以自然少不了 P/Invoke（平台调用）。因此你必须将以下代码也添加到你的代码仓库中：[DllImport(&quot;kernel32.dll&quot;)]public static extern IntPtr GetModuleHandle(string lpModuleName);[DllImport(&quot;kernel32&quot;, SetLastError = true)]static extern IntPtr LoadLibrary(string lpFileName);[DllImport(&quot;user32.dll&quot;)]static extern uint GetWindowThreadProcessId(IntPtr hWnd, out uint lpdwProcessId);[DllImport(&quot;user32.dll&quot;, SetLastError = true)]static extern IntPtr SetWindowsHookEx(HookType hookType, HookProc lpfn, IntPtr hMod, uint dwThreadId);[DllImport(&quot;user32.dll&quot;)]static extern IntPtr CallNextHookEx(IntPtr hhk, int nCode, IntPtr wParam, IntPtr lParam);private delegate IntPtr HookProc(int nCode, IntPtr wParam, IntPtr lParam);public enum HookType : int{ WH_JOURNALRECORD = 0, WH_JOURNALPLAYBACK = 1, WH_KEYBOARD = 2, WH_GETMESSAGE = 3, WH_CALLWNDPROC = 4, WH_CBT = 5, WH_SYSMSGFILTER = 6, WH_MOUSE = 7, WH_HARDWARE = 8, WH_DEBUG = 9, WH_SHELL = 10, WH_FOREGROUNDIDLE = 11, WH_CALLWNDPROCRET = 12, WH_KEYBOARD_LL = 13, WH_MOUSE_LL = 14}SetWindowsHookExSetWindowsHookEx 的签名如下：HHOOK SetWindowsHookExA( int idHook, HOOKPROC lpfn, HINSTANCE hmod, DWORD dwThreadId); 当方法执行成功时，返回值是钩子处理函数的句柄，用于在钩子的消息处理中调用 CallNextHookEx 方法。当方法执行失败时，这里返回 0。 idHood 参数表示需要处理的消息类型（我们前面定义成了枚举类型 HookType） lpfn 是自己定义的钩子的消息处理方法（对应我们前面定义的委托） hmod 是模块的句柄，在本机代码中，对应 dll 的句柄（可在 dll 的入口函数中获取）；而我们是托管代码 dwThreadId 是线程 Id，传入 0 则为全局所有线程，否则传入特定的线程 Id需要注意的坑模块句柄传什么？本文一开始被注释掉的代码中，我使用 Marshal 直接从托管程序集中获取了模块句柄。这里需要说明，托管程序集不能注入到其他进程，因此也不可以挂接钩子。但有例外，WH_KEYBOARD_LL 或者 WH_MOUSE_LL 这两个是不需要注入 dll 的，因此可以挂接钩子。对于 WH_KEYBOARD_LL 和 WH_MOUSE_LL，SetWindowsHookEx 方法里面根本没有使用这个模块做什么真正的事情，它只是验证一下一个模块而已。只要存在于你的进程中。所以，传入其他的模块都是可以的：var hModule = LoadLibrary(&quot;user32.dll&quot;);传入口模块也是可以的：var hModule = Marshal.GetHINSTANCE(Assembly.GetEntryAssembly().GetModules()[0]);var hModule = GetModuleHandle(null);这也是一开始我在 P/Invoke 的方法里面预留了 LoadLibrary 和 GetModuleHandle 方法的原因。通过调试也能发现这两个的入口模块是相同的：至于为什么可以用 user32.dll。嗯，反正我们创建窗口监听消息都已经大量调用 user32.dll 的 API 了，这 dll 肯定已经加入到我们的进程中了，所以我们把这个传入到参数中是可以通过验证的。错误 126：找不到指定的模块。 The specified module could not be found.如果你只是拿代码做做 demo 可能一切顺利，但放到实际项目里面就挂得一塌糊涂：这也是我在一开始的 P/Invoke 里面加上了 SetLassError 的重要原因，因为这 API 容易挂。检查的错误码是 126（0x0000007E）。然而我的 dll 是存在的呀！让我们再来看我一开始预留的注释：// 下面代码在 .NET Core 3.x 以上可正常工作，在 .NET Framework 4.0 以下可正常工作。// 如果不满足此条件，你也可能可以正常工作，详情请阅读本文后续内容。var hModule = Marshal.GetHINSTANCE(Assembly.GetExecutingAssembly().GetModules()[0]);是的，你遇到这样的异常，多半意味着你落入 .NET Framework 4.x 版本的运行时了。.NET Framework 4.0 相比于之前的 CLR 发生了很大的更改，不再假装 JIT 代码存在一非托管模块中，因此 Marshal.GetHINSTANCE 将不再起作用。对于低级钩子来说，SetWindowsHookEx 需要一个有效的模块句柄进行检查，但实际上此 API 执行时根本没有使用这个模块。所以更推荐使用前一小节中提供的 LoadLibrary 函数来获取模块句柄，而不是获取当前托管模块的句柄。解决方法，两/三个： 方法一：使用 LoadLibrary(&quot;user32.dll&quot;) 获取模块句柄代替 Marshal.GetHINSTANCE 方法二：将获取句柄的模块改为入口程序集（exe），即 Assembly.GetEntryAssembly()。 方法三：升级成纯 .NET Core 程序错误 1428：没有模块句柄无法设置非本机的挂接。 Cannot set nonlocal hook without a module handle.对于前面说的 126 错误，你可能从 Assembly.GetExecutingAssembly 改成 Assembly.GetEntryAssembly() 之后会出现此异常。解决方法： 使用 LoadLibrary(&quot;user32.dll&quot;) 获取模块句柄代替 Marshal.GetHINSTANCE错误 1429：此挂接程序只可整体设置。 This hook procedure can only be set globally.估计找到这里的方式可能是搜索，因为这段中文读起来真的是太晦涩了。不过我把英文贴到上一行了，相信你差不多就知道是怎么回事了。因为你给 SetWindowsHookEx 方法中传入的 HookType 参数指定了低级类型（Low Level，HookType 枚举后面带了 LL 后缀的），这时只能全局设置钩子。意味着你的第四个参数必须传入 0。如何只处理特定窗口的消息？消息循环属于“线程”，而不是属于某个窗口或者进程。在 CreateWindowEx 创建窗口时传入的消息处理函数会仅处理特定窗口的消息，然而当通过钩子的方式来处理消息的话，无法精确定位到某个特定的窗口，只能针对消息循环所在的线程。因此，要处理特定窗口的消息，只能先拿到此窗口所在的线程。前面的 P/Invoke 中我也预留了获取窗口所在线程的方法。因此，可以直接使用以下调用来获取 hWnd 句柄窗口所在的线程。var threadId = GetWindowThreadProcessId(hWnd, out _);本来在 SetWindowsHookEx 最后一个参数传入 0 表示全局钩子的，那么现在传入 threadId 即仅监听此线程的消息。另外，如果只是打算处理单个窗口的消息，而不是这个线程里的所有消息，那么建议使用子类化的方式来实现。详情可阅读我的另一篇博客： 通过子类化窗口（SubClass）来为现有的某个窗口添加新的窗口处理程序（或者叫钩子，Hook） - walterlv为什么会导致其他进程闪退？你可能会发现，明明按照本文所述的方法挂接了钩子，但一运行起来后，其他程序（被挂接的程序）出现了闪退现象。接下来说明：在 HookType 的所有种类中，只有 WH_MOUSE_LL 和 WH_KEYBOARD_LL 是不需要注入到目标进程的，其他都必须将 dll 注入到目标进程才可以完成挂接。然而 .NET 程序集无法被注入到其他进程；随便用一个其他 dll 时，里面没有被挂接的函数地址，在注入后就会导致目标进程崩溃。所以： 如果需要挂接的进程就在本进程内（最后参数指定的线程是本进程内的线程），那么所有种类都可以挂接； 如果需要全局挂接，或者要挂接别的进程，那么 .NET 程序只能使用 WH_MOUSE_LL 和 WH_KEYBOARD_LL 两种挂接类型；如果就是要挂接其他类型的钩子怎么办？办法总还是有的： 可以考虑做非托管 dll，专门用来挂接； 可以考虑使用 SetWinEventHook，这个是不用注入到目标进程的； 可以考虑使用 System.Windows.Automation 抓取一部分有限的信息。其他问题如果你在各种折腾之后还是有问题，可考虑去 GitHub 上克隆我的源码，跑一跑试试。在这里：walterlv/Walterlv.Demo.SetWindowsHookEx。或者通过本文后面附带的联系方式与我联系。参考资料 SetWindowsHookExA function (winuser.h) - Win32 apps - Microsoft Docs Processing Global Mouse and Keyboard Hooks in C# - CodeProject c# - SetWindowsHookEx fails with error 126 - Stack Overflow winapi - How to pass window handle to wndproc? - Stack Overflow .net - Example of hooking a window? - Stack Overflow .net - SetWindowHookEx fails at runtime in C# application - Stack Overflow winapi - Is there a way to know when another hwnd has closed? - Stack Overflow" }, { "title": "WPF / Windows Forms 检测窗口在哪个屏幕", "url": "/post/detect-screen-that-contains-the-wpf-window.html", "categories": "", "tags": "wpf, dotnet, csharp", "date": "2020-06-11 18:39:48 +0800", "snippet": "使用 Windows Forms 自带的 System.Windows.Forms.Screen 类可以从一个窗口句柄获取到对应的屏幕。随后可以使用此 Screen 类获取各种屏幕信息。System.Windows.Forms.Screen通过句柄获取屏幕类：System.Windows.Forms.Screen.FromHandle(hWnd)这里我做了一个 DEMO 程序，画出了窗口的位置和大小，以及当前窗口所在的屏幕的位置和大小。附代码MainWindow.xaml&amp;lt;Window x:Class=&quot;Walterlv.Issues.Dpi.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:Walterlv.Issues.Dpi&quot; mc:Ignorable=&quot;d&quot; Title=&quot;欢迎阅读吕毅的博客 blog.walterlv.com&quot; Height=&quot;450&quot; Width=&quot;800&quot;&amp;gt; &amp;lt;Grid x:Name=&quot;RootPanel&quot;&amp;gt; &amp;lt;Canvas SnapsToDevicePixels=&quot;True&quot;&amp;gt; &amp;lt;UIElement.RenderTransform&amp;gt; &amp;lt;ScaleTransform ScaleX=&quot;0.2&quot; ScaleY=&quot;0.2&quot; /&amp;gt; &amp;lt;/UIElement.RenderTransform&amp;gt; &amp;lt;Border x:Name=&quot;ScreenBorder&quot; Background=&quot;#E4E4E6&quot;&amp;gt; &amp;lt;UIElement.RenderTransform&amp;gt; &amp;lt;TranslateTransform x:Name=&quot;ScreenTranslateTransform&quot; /&amp;gt; &amp;lt;/UIElement.RenderTransform&amp;gt; &amp;lt;TextBlock x:Name=&quot;ScreenTextBlock&quot; FontSize=&quot;240&quot; TextAlignment=&quot;Right&quot; /&amp;gt; &amp;lt;/Border&amp;gt; &amp;lt;Border x:Name=&quot;WindowBorder&quot; Background=&quot;#949499&quot;&amp;gt; &amp;lt;UIElement.RenderTransform&amp;gt; &amp;lt;TranslateTransform x:Name=&quot;WindowTranslateTransform&quot; /&amp;gt; &amp;lt;/UIElement.RenderTransform&amp;gt; &amp;lt;TextBlock x:Name=&quot;WindowTextBlock&quot; FontSize=&quot;240&quot; Margin=&quot;0 0 -1000 -1000&quot; /&amp;gt; &amp;lt;/Border&amp;gt; &amp;lt;/Canvas&amp;gt; &amp;lt;/Grid&amp;gt;&amp;lt;/Window&amp;gt;MainWindow.xaml.csusing System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Windows;using System.Windows.Controls;using System.Windows.Data;using System.Windows.Documents;using System.Windows.Input;using System.Windows.Interop;using System.Windows.Media;using System.Windows.Media.Imaging;using System.Windows.Navigation;namespace Walterlv.Issues.Dpi{ public partial class MainWindow : Window { public MainWindow() { InitializeComponent(); LocationChanged += MainWindow_LocationChanged; SizeChanged += MainWindow_SizeChanged; } private void MainWindow_LocationChanged(object sender, EventArgs e) { UpdateScreenInfo(this); } private void MainWindow_SizeChanged(object sender, SizeChangedEventArgs e) { UpdateScreenInfo(this); } private void UpdateScreenInfo(Window window) { var hwndSource = (HwndSource)PresentationSource.FromVisual(window); if (hwndSource is null) { return; } var hWnd = hwndSource.Handle; var screen = System.Windows.Forms.Screen.FromHandle(hWnd).Bounds; if (User32.GetWindowRect(hWnd, out var rect)) { ScreenTranslateTransform.X = screen.X; ScreenTranslateTransform.Y = screen.Y; ScreenBorder.Width = screen.Width; ScreenBorder.Height = screen.Height; ScreenTextBlock.Text = $@&quot;{rect.left},{rect.top}{screen.Width}×{screen.Height}&quot;; WindowTranslateTransform.X = rect.left; WindowTranslateTransform.Y = rect.top; WindowBorder.Width = rect.right - rect.left; WindowBorder.Height = rect.bottom - rect.top; WindowTextBlock.Text = $@&quot;{rect.left},{rect.top}{rect.right - rect.left}×{rect.bottom - rect.top}&quot;; } } }}" }, { "title": "准确判断一个 WPF 控件 / UI 元素当前是否显示在屏幕内", "url": "/post/detect-whether-a-wpf-visual-is-inside-screen.html", "categories": "", "tags": "wpf, csharp", "date": "2020-06-11 17:40:47 +0800", "snippet": "你的 WPF 窗口是可以拖到屏幕外面去的，所以拉几个元素到屏幕外很正常。你的屏幕可能有多个。你的多个屏幕可能有不同的 DPI。你检测的元素可能带有旋转。各种各样奇怪的因素可能影响你检查此元素是否在屏幕内，本文包你一次性解决，绝对准确判断。本文将说三种不同的判定方法，分偷懒版、日常版和苛刻版： 如果你只是写个 demo 啥的，用偷懒版就够了，代码少性能高。 如果你在项目/产品中使用，使用日常版就好。 如果你的用户群体天天喷你 bug 多，那么用苛刻版更好。偷懒版如果你只想写个 demo，那么此代码足以。判断 UI 元素的位置，其右侧是否在屏幕最左侧，其底部是否在屏幕最上面；或者其左侧是否在屏幕最右侧，其顶部是否在屏幕最下面。private static bool IsOutsideOfScreen(FrameworkElement target){ var topLeft = target.PointToScreen(new Point()); var bottomRight = target.PointToScreen(new Point(target.ActualWidth, target.ActualHeight)); return bottomRight.X &amp;lt; SystemParameters.VirtualScreenLeft || bottomRight.Y &amp;lt; SystemParameters.VirtualScreenTop || topLeft.X &amp;gt; SystemParameters.VirtualScreenLeft + SystemParameters.VirtualScreenWidth || topLeft.Y &amp;gt; SystemParameters.VirtualScreenTop + SystemParameters.VirtualScreenHeight;}日常版（推荐）如果你检测的元素自带了旋转，那么以上方法就不能准确判断了。现在，我们需要检查这个元素的整个边界区域，即便是旋转后。于是，现在，我们要判断元素边界点所在的矩形区域了。/// &amp;lt;summary&amp;gt;/// 判断一个可视化对象是否在屏幕外面无法被看见。/// &amp;lt;/summary&amp;gt;/// &amp;lt;param name=&quot;target&quot;&amp;gt;要判断的可视化元素。&amp;lt;/param&amp;gt;/// &amp;lt;returns&amp;gt;如果元素在屏幕外面，则返回 true；如果元素在屏幕里或者部分在屏幕里面，则返回 false。&amp;lt;/returns&amp;gt;private static bool IsOutsideOfScreen(FrameworkElement target){ try { var bounds = GetPixelBoundsToScreen(target); var screenBounds = GetScreenPixelBounds(); var intersect = screenBounds; intersect.Intersect(bounds); return intersect.IsEmpty; } catch (InvalidOperationException) { // 此 Visual 未连接到 PresentationSource。 return true; } Rect GetPixelBoundsToScreen(FrameworkElement visual) { var pixelBoundsToScreen = Rect.Empty; pixelBoundsToScreen.Union(visual.PointToScreen(new Point(0, 0))); pixelBoundsToScreen.Union(visual.PointToScreen(new Point(visual.ActualWidth, 0))); pixelBoundsToScreen.Union(visual.PointToScreen(new Point(0, visual.ActualHeight))); pixelBoundsToScreen.Union(visual.PointToScreen(new Point(visual.ActualWidth, visual.ActualHeight))); return pixelBoundsToScreen; } Rect GetScreenPixelBounds() { return new Rect(SystemParameters.VirtualScreenLeft, SystemParameters.VirtualScreenTop, SystemParameters.VirtualScreenWidth, SystemParameters.VirtualScreenHeight); }}苛刻版现在，更复杂的场景来了。如果用户有多台显示器，而且大小还不一样，那么依前面的判定方法，下图中 C 控件虽然人眼看在屏幕外，但计算所得是在屏幕内。更复杂的，是多台显示器还不同 DPI 时，等效屏幕尺寸的计算更加复杂。更恐怖的是，WPF 程序声明支持的 DPI 级别不同，计算也会有一些差别。想要写一种支持所有支持级别的代码更加复杂。但本文可以。/// &amp;lt;summary&amp;gt;/// 判断一个可视化对象是否在屏幕外面无法被看见。/// &amp;lt;/summary&amp;gt;/// &amp;lt;param name=&quot;target&quot;&amp;gt;要判断的可视化元素。&amp;lt;/param&amp;gt;/// &amp;lt;returns&amp;gt;如果元素在屏幕外面，则返回 true；如果元素在屏幕里或者部分在屏幕里面，则返回 false。&amp;lt;/returns&amp;gt;private bool IsOutsideOfScreen(FrameworkElement target){ var hwndSource = (HwndSource)PresentationSource.FromVisual(target); if (hwndSource is null) { return true; } var hWnd = hwndSource.Handle; var targetBounds = GetPixelBoundsToScreen(target); var screens = System.Windows.Forms.Screen.AllScreens; return !screens.Any(x =&amp;gt; x.Bounds.IntersectsWith(targetBounds)); System.Drawing.Rectangle GetPixelBoundsToScreen(FrameworkElement visual) { var pixelBoundsToScreen = Rect.Empty; pixelBoundsToScreen.Union(visual.PointToScreen(new Point(0, 0))); pixelBoundsToScreen.Union(visual.PointToScreen(new Point(visual.ActualWidth, 0))); pixelBoundsToScreen.Union(visual.PointToScreen(new Point(0, visual.ActualHeight))); pixelBoundsToScreen.Union(visual.PointToScreen(new Point(visual.ActualWidth, visual.ActualHeight))); return new System.Drawing.Rectangle( (int)pixelBoundsToScreen.X, (int)pixelBoundsToScreen.Y, (int)pixelBoundsToScreen.Width, (int)pixelBoundsToScreen.Height); }}在下面这段代码中，即便是 WPF 项目，我们也需要引用 Windows Forms，用于获取屏幕相关的信息。如果是 SDK 风格的项目，则在 csproj 中添加如下代码： &amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk.WindowsDesktop&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;OutputType&amp;gt;WinExe&amp;lt;/OutputType&amp;gt; &amp;lt;TargetFramework&amp;gt;net5.0&amp;lt;/TargetFramework&amp;gt; &amp;lt;UseWPF&amp;gt;true&amp;lt;/UseWPF&amp;gt;++ &amp;lt;UseWindowsForms&amp;gt;true&amp;lt;/UseWindowsForms&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;/Project&amp;gt;如果是传统风格的项目，则直接添加 System.Windows.Forms 程序集的引用就好。因为 WPF 的坐标单位是“设备无关单位”（我更倾向于叫有效像素，见 有效像素（Effective Pixels）），所以在系统对窗口有缩放行为的时候，多屏不同 DPI 的计算相当复杂，所以这里我们使用纯 Win32 / Windows Forms 方法在来计算屏幕与 UI 元素之间的交叉情况，并且避免在任何时候同时将多个屏幕的坐标进行加减乘除（避免单位不一致的问题）。所以这段代码对任何 WPF 的 DPI 配置都是有效且准确的。关于 DPI 感知设置的问题，可阅读我的其他博客： Windows 下的高 DPI 应用开发（UWP / WPF / Windows Forms / Win32） - walterlv 支持 Windows 10 最新 PerMonitorV2 特性的 WPF 多屏高 DPI 应用开发 - walterlv Windows 系统上使用任务管理器查看进程的各项属性（命令行、DPI、管理员权限等） - walterlv此代码的唯一的缺点是，在 WPF 项目里面要求引用 Windows Forms。功能比较不知道用哪个？看下表吧！ 代码版本 偷懒版 日常版 苛刻版 基础判断屏幕内外 ✔️ ✔️ ✔️ 高分屏（非 96 DPI） ✔️ ✔️ ✔️ 整齐排列的多屏 ✔️ ✔️ ✔️ 元素带有旋转 ❌ ✔️ ✔️ 多屏尺寸不统一 ❌ ❌ ✔️ 多屏有不同 DPI（WPF 感知系统 DPI） ❌ ❌ ✔️ 多屏有不同 DPI（WPF 感知屏幕 DPI） ❌ ❌ ✔️ 多屏有不同 DPI（WPF 感知屏幕 DPI V2） ❌ ❌ ✔️ 纯 WPF 代码（无需引用 Windows Forms） ✔️ ✔️ ❌ 元素形状不规则 ❌ ❌ ❌ 性能 好 较好 一般 " }, { "title": "Compare four different file (folder) links on Windows (NTFS hard links, junction points, symbolic links, and well-known shortcuts)", "url": "/post/ntfs-link-comparisons-en.html", "categories": "", "tags": "windows", "date": "2020-06-11 09:28:00 +0800", "snippet": "It is well-known that mklink is a command to create a variety of links on NTFS disk. But if you don’t know much about it or even never hear of it, it doesn’t matter because you know shortcuts at least. This post help you to lean more about mklink and know the differences among the difference command options.This post is written in multiple languages. Please select yours: 中文 English Different ways of linkingWindows Vista announced the NTFS symbolic links, Windows 2000 began to have NTFS Reparse Point, and earlier Windows 95 introduced the shortcut. Backing to Windows 3.5 There are hard links. All of them provide you the power to access a same folder or file in difference paths.mklinkUsing mklink command, you can create a “hard link”, “junction points” and “symbolic link”.&amp;gt; mklinkCreates a symbolic link.MKLINK [[/D] | [/H] | [/J]] Link Target /D Creates a directory symbolic link. Default is a file symbolic link. /H Creates a hard link instead of a symbolic link. /J Creates a Directory Junction. Link Specifies the new symbolic link name. Target Specifies the path (rele.g:mklink /J current %APPDATA%\\walterlv\\packages\\1.0.0That is to create a junction point linking to %APPDATA%\\walterlv\\packages\\1.0.0.ShortcutsShortcuts is a Windows feature which is different to those introduced by the NTFS.Shortcut is a file with a lnk file extension. This file contains the info indicates how to open the linking file or directory. Maybe most applications use this lnk file to execute their programs.OthersReparse Point has been in the Windows operating system since NTFS v3.0 (introduced with Windows 2000). In addition to our previously mentioned three types of reparse points made by mklink, there are other types: Volume Mount Ppoints Distributed Link Tracking（DLT） Data Deduplication Hierarchical Storage Management（HSM） Native Structured Storage（NSS） Unix Doman Socket（socket） System Compression OneDriveComparisonReading those words above, you may know the usage of mklink but don’t know the difference between them. Then I’ve post them below:   Hard Link Junction Point Symbolic Link Command mklink /H Link Target mklink /J Link Target mklink /D Link Target Description Create an alias for a file so that different paths correspond to the data of the same file.     Linking to files ✔️ ❌ ❌ Linking to directories ❌ ✔️ ✔️ Needs to run as Administrator Yes No Mostly Yes [Tip1] Supports linking across volumes ❌ ✔️(Local Machine only) ✔️(including remote path such as SMB) Introduced since Supports since Windows NT 3.1API supports since Windows 2000 by CreateHardLink()Supports since Windows NT 6.0 by command mklink /H Windows 2000+ Windows Vista+ Supports targets which is not exist ❌ ✔️ ✔️ Link to relative directory ❌ ❌(You can create one with relative path but it will change to absolute path automatically.) ✔️ How to remove del rd rd / del When the reparse point is removed Only after all hard links to the original file and the original file have been deleted will the file data be deleted. The original folder is not affected after Windows Vista but is will be deleted in Windows 2000 / XP / 2003. The original file/folder is not affected. When the original file/folder is removed The hard link can still access the data of the file normally. Directory connection failed, pointing to a directory that does not exist. The symbolic link is invalid and points to a directory that does not exist. [Tip1]: A post of Microsoft says, Starting with Windows 10 Insiders build 14972, symlinks can be created without needing to elevate the console as administrator. This will allow developers, tools and projects, that previously struggled to work effectively on Windows due to symlink issues, to behave just as efficiently and reliably as they do on Linux or OSX. (Below picture shows how to open the developer’s mode.)ExtrasIf you create shortcuts in your start menu, and the shortcuts are linking to files that are in junction points. All the shortcuts will disappear after a Windows 10 updates. I’m reporting this bug to Microsoft, but before Microsoft resolve this bug we have to work around to avoid this bug. See the bug in scoop below: After the windows 10 updates, all shortcuts of scoop will disappear. · Issue #3941 · lukesampson/scoopReferences NTFS reparse point - Wikipedia windows - What is the difference between NTFS Junction Points and Symbolic Links? - Stack Overflow Hard link - Wikipedia Create symbolic links (Windows 10) - Windows security - Microsoft Docs Symlinks in Windows 10! - Windows Developer Blog" }, { "title": "比较 Windows 上四种不同的文件（夹）链接方式（NTFS 的硬链接、目录联接、符号链接，和大家熟知的快捷方式）", "url": "/post/ntfs-link-comparisons.html", "categories": "", "tags": "windows", "date": "2020-06-11 09:27:34 +0800", "snippet": "可能有很多小伙伴已经知道通过 mklink 命令来创建 NTFS 磁盘上的各种链接；当然，就算不知道 mklink 的链接，快捷方式应该每个人都知道吧。mklink 的选项有很多种，但你可能在其他文章中难以找到对这些不同选项的不同效果和使用限制的准确和统一描述。本文将介绍 Windows 系统中所有的链接方式，它们的优缺点、使用条件和坑。This post is written in multiple languages. Please select yours: 中文 English 不同的链接方式Windows Vista 开始带来了 NTFS 符号链接（Symbolic Link），Windows 2000 开始就有了 NTFS 重解析点（Reparse Point），更早的 Windows 95 就有了快捷方式（Shortcut），再往前到 Windows 3.5 还有硬链接（Hard Link），他们都能实现给你不同的路径访问同一个文件或文件夹的功能。mklink使用 mklink 命令，你可以创建“硬链接（Hard Link）”、“目录联接（Junction Point）”和“符号链接（Symbolic Link）”。&amp;gt; mklink创建符号链接。MKLINK [[/D] | [/H] | [/J]] Link Target /D 创建目录符号链接。默认为文件 符号链接。 /H 创建硬链接而非符号链接。 /J 创建目录联接。 Link 指定新的符号链接名称。 Target 指定新链接引用的路径 (相对或绝对)。例如：mklink /J current %APPDATA%\\walterlv\\packages\\1.0.0即在当前目录创建了一个指向 %APPDATA%\\walterlv\\packages\\1.0.0 的目录联接。因为创建目录联接不需要管理员权限，所以特别适合给桌面应用程序用来按版本管理某些包/工具集。有关使用 .NET/C# 来创建目录联接的方法，可以阅读我的另一篇博客： .NET 实现 NTFS 文件系统的硬链接 mklink /J（Junction） - walterlv快捷方式快捷方式是一个单纯 Windows 操作系统用户层面的功能，与 NTFS 文件系统没有什么关系。不过其也能实现链接到另一个文件的功能。使用快捷方式的程序太多了，几乎每个安装包都会考虑往桌面或开始菜单扔几个快捷方式。快捷方式的本质是一个 lnk 后缀的文件，这个文件里面指向了如何打开目标文件或文件夹的一些参数，于是当在文件资源管理器中打开快捷方式时，就直接打开了目标文件或文件夹（当然，启动一个程序可能是大多数用法）。其他重解析点（Reparse Point）自 NTFS v3.0（随 Windows 2000 推出）开始便一直存在于 Windows 操作系统中。除了我们前面提到的可通过 mklink 创建的那三种外，还有其他种类： Volume Mount Ppoints Distributed Link Tracking（DLT） Data Deduplication Hierarchical Storage Management（HSM） Native Structured Storage（NSS） Unix Doman Socket（socket） System Compression OneDrive比较可能单单说名字，你不一定能明白什么时候要用哪一种。于是我将这些链接的不同整理了出来贴在下面。   硬链接（Hard Link） 目录联接（Junction Point） 符号链接（Symbolic Link） 命令 mklink /H Link Target mklink /J Link Target mklink /D Link Target 作用 为某文件创建别名，可让不同的路径对应同一个文件的数据。     链接到文件 ✔️ ❌ ❌ 链接到文件夹 ❌ ✔️ ✔️ 需要提升为管理员权限 需要 不需要 通常需要 [坑1] 跨驱动器卷（盘符） ❌ ✔️（仅本地计算机） ✔️（包括 SMB 文件或路径） 操作系统支持 Windows NT 3.1 开始支持Windows 2000 开始有 API CreateHardLink()Windows NT 6.0 开始能使用 mklink /H Windows 2000+ Windows Vista+ 可链接到不存在的目标 ❌ ✔️ ✔️ 可链接到相对目录 ❌ ❌（可以使用相对路径创建，但创建完即变绝对路径） ✔️ 删除方法 del rd rd / del 当链接被单独删除后 只有所有指向原始文件的硬链接和原始文件全部删除后文件数据才会被删除。 Windows Vista 之后原始文件夹不受影响；Windows 2000/XP/2003 会导致原始子文件夹被删除。 原始文件夹不受影响。 当原始文件被单独删除后 硬链接依然能正常访问到文件的数据。 目录联接失效，指向不存在的目录。 符号链接失效，指向不存在的目录。 [坑1]: 在微软的官方博客中已有说明：从 Windows 10 Insiders build 14972 开始，符号链接对开发者将不再需要管理员权限，这可以让开发者像在 Linux 或 macOS 上一样高效地工作。（通过如下图所示的开关来决定此操作是否需要管理员权限，打开则无需管理员权限。）额外的坑如果你在开始菜单里面有快捷方式指向了一个目录联接（Junction Point）中的文件，那么在 Windows 10 操作系统更新后这个快捷方式便会消失。目前正在调查消失的原因，如果确认是目录联接的 bug 或者开始菜单的 bug，就将进展报告给微软。关于这个 bug，详见： After the windows 10 updates, all shortcuts of scoop will disappear. · Issue #3941 · lukesampson/scoop一般来说，阅读本文应该就理解了 mklink 的正确用法，也不应该会出现我另一篇博客中的情况： 解决 mklink 使用中的各种坑（硬链接，软链接/符号链接，目录链接） - walterlv另外，附我使用目录联接/符号链接的一些用途： 通过 mklink 收集本地文件系统的所有 NuGet 包输出目录来快速调试公共组件代码 - walterlv参考资料 NTFS reparse point - Wikipedia windows - What is the difference between NTFS Junction Points and Symbolic Links? - Stack Overflow Hard link - Wikipedia Create symbolic links (Windows 10) - Windows security - Microsoft Docs Symlinks in Windows 10! - Windows Developer Blog" }, { "title": "支持 Windows 10 最新 PerMonitorV2 特性的 WPF 多屏高 DPI 应用开发", "url": "/post/windows-high-dpi-development-for-wpf.html", "categories": "", "tags": "windows, dotnet, wpf", "date": "2020-06-10 16:41:39 +0800", "snippet": "Windows 10 自 1703 开始引入第二代的多屏 DPI 机制（PerMonitor V2），而 WPF 框架可以支持此第二代的多屏 DPI 机制。本文将介绍 WPF 框架利用第二代多屏 DPI 机制进行高 DPI 适配的方法。同时，也介绍低版本的 WPF 或者低版本的操作系统下如何做兼容。添加应用程序清单文件在你现有 WPF 项目的主项目中需要添加两个文件以支持第二代的多屏 DPI 机制。 app.manifest (决定性文件) app.config (修复 Bug, .NET Framework 4.6.2 及以上可忽略)▲ 项目中新增的两个文件默认情况下，app.config 在你创建 WPF 项目的时候就会存在，而 app.manifest 则不是。如果你的项目中已经存在这两个文件，就不需要添加了。如果你没有 app.config，如何添加？打开项目属性，然后在属性中选择 .NET Framework 的版本，无论你选择哪个，app.config 都会自动为你添加。当然，正统的方法是跟下面的 app.manifest 的添加方法相同，你会在下面看到 Visual Studio 新建项中 app.manifest 和 app.config 文件是挨在一起的。如果你没有 app.manifest，如何添加？▲ 新建文件的时候选择应用程序清单文件（应用程序配置文件就在旁边）了解 WPF 清单文件中的 DPI 感知设置DpiAware在你打开了 app.manifest 文件后，找到以下代码，然后取消注释：&amp;lt;!-- Indicates that the application is DPI-aware and will not be automatically scaled by Windows at higher DPIs. Windows Presentation Foundation (WPF) applications are automatically DPI-aware and do not need to opt in. Windows Forms applications targeting .NET Framework 4.6 that opt into this setting, should also set the &#39;EnableWindowsFormsHighDpiAutoResizing&#39; setting to &#39;true&#39; in their app.config. --&amp;gt;&amp;lt;!--&amp;lt;application xmlns=&quot;urn:schemas-microsoft-com:asm.v3&quot;&amp;gt;&amp;lt;windowsSettings&amp;gt; &amp;lt;dpiAware xmlns=&quot;http://schemas.microsoft.com/SMI/2005/WindowsSettings&quot;&amp;gt;true&amp;lt;/dpiAware&amp;gt;&amp;lt;/windowsSettings&amp;gt;&amp;lt;/application&amp;gt;--&amp;gt;上面这一段代码是普通的 DPI 感知的清单设置，开启后获得系统 DPI 感知级别（System DPI Awareness）。如果要开启 Per-Monitor DPI 感知，将上面的 true 改成 true/pm（pm 表示 per-monitor）。不过这只是兼容性的设计而已，感谢老版本的系统使用字符串包含的方式，于是可以老版本的系统可以兼容新的 DPI 感知值： 什么都不填 如果你额外也没做什么 DPI 相关的操作，那么就是 Unaware。 如果你在程序启动的时候调用了 SetProcessDpiAwareness 或 SetProcessDPIAware 函数，那么就会按照调用此函数的效果来感知 DPI。 包含 true 字符串 当前进程设置为系统级 DPI 感知（System DPI Awareness）。 包含 false 字符串 在 Windows Vista / 7 / 8 中，与什么都不填的效果是一样的。 在 Windows 8.1 / 10 中，当前进程设置为不感知 DPI（Unaware），就算你调用了 SetProcessDpiAwareness 和 SetProcessDPIAware 也是没有用的。 包含 true/pm 字符串 在 Windows Vista / 7 / 8 中，当前进程设置为系统级 DPI 感知（System DPI Awareness）。 在 Windows 8.1 / 10 中，当前进程设置为屏幕级 DPI 感知（Per-Monitor DPI Awareness）。 包含 per monitor 字符串 在 Windows Vista / 7 / 8 中，与什么都不填的效果是一样的。 在 Windows 8.1 / 10 中，当前进程设置为屏幕级 DPI 感知（Per-Monitor DPI Awareness）。 其他任何字符串 在 Windows Vista / 7 / 8 中，与什么都不填的效果是一样的。 在 Windows 8.1 / 10 中，当前进程设置为不感知 DPI（Unaware），就算你调用了 SetProcessDpiAwareness 和 SetProcessDPIAware 也是没有用的。 说明一下，SetProcessDpiAwareness 是新 API，要求的最低系统版本是 Windows 8.1，调用这个才能指定为 Per-Monitor 的 DPI 感知。而 SetProcessDPIAware 是 Vista 开始引入的老 API，没有参数可以传。DpiAwareness&amp;lt;asmv3:application&amp;gt; &amp;lt;asmv3:windowsSettings xmlns=&quot;http://schemas.microsoft.com/SMI/2016/WindowsSettings&quot;&amp;gt; &amp;lt;dpiAwareness&amp;gt;PerMonitorV2, unaware&amp;lt;/dpiAwareness&amp;gt; &amp;lt;/asmv3:windowsSettings&amp;gt;&amp;lt;/asmv3:application&amp;gt;注意：只有 Windows 10 (1607) 及以上版本才会识别此节点的 DPI 设置。如果你设置了 dpiAwareness 节点，那么 dpiAware 就会被忽略。建议你可以两个节点都指定，这样既可以使用到 Windows 10 1607 的新特性，又可以兼容老版本的 Windows 操作系统。dpiAwareness 节点支持设置一个或多个 DPI 感知级别，用逗号分隔。如果你指定了多个，那么操作系统会从第一个开始识别，如果能识别就使用，否则会找第二个。用这种方式，未来的应用可以指定当前系统不支持的 DPI 感知级别。鉴于此，在目前 Windows 7 还大行其道的今天，为了兼容，dpiAwareness 和 dpiAware 都设置是比较靠谱的。dpiAwareness 节点目前支持的值有： 什么都不设置 按 dpiAware 节点的结果来 整个逗号分隔的序列都没有能识别的 DPI 感知级别 如果你额外也没做什么 DPI 相关的操作，那么就是 Unaware。 如果你在程序启动的时候调用了 SetProcessDpiAwareness 或 SetProcessDPIAware 函数，那么就会按照调用此函数的效果来感知 DPI。 第一个能识别的感知级别是 system 当前进程设置为系统级 DPI 感知（System DPI Awareness）。 第一个能识别的感知级别是 permonitor 当前进程设置为屏幕级 DPI 感知（Per-Monitor DPI Awareness）。 第一个能识别的感知级别是 permonitorv2 当前进程设置为第二代屏幕级 DPI 感知（Per-Monitor V2 DPI Awareness）。 仅在 Windows 10 (1703) 及以上版本才可被识别 第一个能识别的感知级别是 unaware 当前进程设置为不感知 DPI（Unaware），就算你调用了 SetProcessDpiAwareness 和 SetProcessDPIAware 也是没有用的。 使 WPF 程序支持 Per-Monitor V2 级 DPI 感知前面我们分析 App.Manifest 文件中 DPI 的设置后，几乎得到一个信息，dpiAware 和 dpiAwareness 都是要设置的，除非以后绝大多数用户的系统版本都到达 Windows 10 (1607) 及以上。以下是推荐的 DPI 感知级别设置：&amp;lt;application xmlns=&quot;urn:schemas-microsoft-com:asm.v3&quot;&amp;gt; &amp;lt;windowsSettings&amp;gt; &amp;lt;!-- The combination of below two tags have the following effect : 1. Per-Monitor for &amp;gt;= Windows 10 Anniversary Update 2. System &amp;lt; Windows 10 Anniversary Update --&amp;gt; &amp;lt;dpiAwareness xmlns=&quot;http://schemas.microsoft.com/SMI/2016/WindowsSettings&quot;&amp;gt;PerMonitorV2&amp;lt;/dpiAwareness&amp;gt; &amp;lt;dpiAware xmlns=&quot;http://schemas.microsoft.com/SMI/2005/WindowsSettings&quot;&amp;gt;true&amp;lt;/dpiAware&amp;gt; &amp;lt;/windowsSettings&amp;gt;&amp;lt;/application&amp;gt;需要注意：系统版本在 Windows 10 (1703) 或以上，V2 的感知级别才会生效，否则就直接使用系统级 DPI 感知。这里我们其实偷懒了，这种写法方便我们仅处理两种不同的 DPI 缩放规则： Windows 10 (1703) 之后的系统，全按最全支持来做兼容； 其他系统，全按 Windows 7 的支持级别来做兼容。你可能注意到本文文末的参考文章中有微软的官方博客，里面推荐的是支持所有级别的 DPI 感知。这看你的需求，因为部分 DPI 相关的模块如果你打算都支持，可能需要更加复杂的判定和计算。本文推荐的少一些，省一点开发量（反正 Windows 8.1 和 Windows 10 早期版本的用户量太少，这部分用户体验不比 Windows 7 差，又不是不能用）。第一代和第二代的 Per-Monitor 感知之间的差异，可以参考：Windows 下的高 DPI 应用开发（UWP / WPF / Windows Forms / Win32） - walterlv额外的，如果你的 .NET Framework 版本在 .NET Framework 4.6.2 以下，但操作系统在 Windows 10 及以上，你还需要修改 App.config 文件（在 &amp;lt;configuration /&amp;gt; 节点）。&amp;lt;runtime&amp;gt; &amp;lt;AppContextSwitchOverrides value = &quot;Switch.System.Windows.DoNotScaleForDpiChanges=false&quot;/&amp;gt;&amp;lt;/runtime&amp;gt;注意： 这个值要设为 false。（微软官方吐槽：Yes, set it to false. Double negative FTW!） AppContextSwitchOverrides 不能被设置两次，如果一已经设置了其他值，需要用分号分隔多个值。特别说明，当面向 .NET Framework 4.6.2 以下版本编译，但运行于 Windows 10 (1607) 和以上版本时，只需要添加 Switch.System.Windows.DoNotScaleForDpiChanges=false 即可让 WPF 程序处理 Dpi Change 消息，此时 WPF 程序就像高版本的 .NET Framework 中一样能够正常处理多屏下的 DPI 缩放。以上，划重点 你并不需要编译为高版本的 .NET Framework 即可获得 Per-Monitor 的 DPI 缩放支持。WPF 程序在特殊清单设置下的效果dpiAwareness 不设置，dpiAware 节点设置为 true/pm：▲ 100% DPI▲ 150% DPI注意到标题栏（非客户区）没有缩放，而 WPF 区域（客户区）清晰地缩放了。dpiAwareness 不设置，dpiAware 节点设置为 true：▲ 100% DPI▲ 150% DPI注意到标题栏（非客户区）被缩放了，而 WPF 区域（客户区）被 DPI 虚拟化进行了位图拉伸（模糊）。dpiAwareness 不设置，dpiAware 节点设置为 true/pm12345：此时，WPF 程序无法启动！！！而你只需要减少一位数字，例如写成 true/pm1234 即可成功启动，效果跟 true 是一样的，注意效果 不是 true/pm。也就是说，/pm 并没有显示出它的含义来。额外的，如果设为 false 但后面跟随那么长的字符串，WPF 程序是可以启动的。dpiAwareness 设置为 PerMonitorV2：▲ 150% DPI注意到标题栏（非客户区）被缩放了，而 WPF 区域（客户区）也能清晰地缩放（仅 Windows 10 1703 及以上系统才是这个效果）。低版本 .NET Framework 和 低版本 Windows 下的 WPF DPI 缩放由于 Windows 8.1 操作系统用户存量不多，主要是 Windows 7 和 Windows 10。所以我们要么兼容完全不支持 Per-Monitor 的 Windows 7，要么使用具有新特性的 Windows 10 即可获得最佳的开发成本平衡。使用以上的 DPI 缩放方法足以让你的 WPF 应用在任何一个 .NET Framework 版本下获得针对屏幕的 DPI 清晰缩放（Per-Monitor DPI Awareness）。所以仅针对 Windows 8.1 做特殊的 DPI 缩放是不值得的，把 Windows 8.1 当做 Windows 7 来做那种不支持 Per-Monitor 的处理就好了。当然你硬要支持也有相关文档可以看：Developing a Per-Monitor DPI-Aware WPF Application - Microsoft Docs 了解实现方法。具体是使用 DisableDpiAwareness 特性和 Windows Per-Monitor Aware WPF Sample 中的源码。参考资料 Developing a Per-Monitor DPI-Aware WPF Application - Microsoft Docs WPF-Samples/Developer Guide - Per Monitor DPI - WPF Preview.docx at master · Microsoft/WPF-Samples Application Manifests - Microsoft Docs High-DPI Scaling Improvements for Desktop Applications in the Windows 10 Creators Update (1703) - Windows Developer Blog" }, { "title": "VMware Workstation 与 Device/Credential Guard 不兼容。在禁用 Device/Credential Guard 后，可以运行 VMware Workstation", "url": "/post/vmware-wants-to-disable-credential-guard.html", "categories": "", "tags": "windows", "date": "2020-06-10 08:58:01 +0800", "snippet": "VMware Workstation 与 Device/Credential Guard 不兼容。在禁用 Device/Credential Guard 后，可以运行 VMware Workstation。有关更多详细信息，请访问 http://www.vmware.com/go/turnoff_CG_DG。我在系统升级到 Windows 10 2004 后，启动 VMware 的任一台虚拟机时会弹出错误提示框：嗯，图标题中的“lindexi”就是小伙伴林德熙；他在我的电脑上运行了一台虚拟机远程使用。然而怎么能随随便便就让虚拟机挂掉呢？得在他醒来之前偷偷修好。提示框中的 Device/Credential Guard 就是 Windows 10 系统的“内核隔离”。按照以下步骤逐一执行，直到修复。特别前提VMware 从 15.5.5 版本开始，已支持在启用了 Hyper-V 的 Windows 10 主机上运行： 使用 WSL 和 Device/Credential Guard 等功能时，用户仍可运行 VMware Workstation 虚拟机 需要 Windows 10 20H1 版本及以上系统因此，如果你觉得不想折腾，直接将 VMware 升级到 15.5.5 以上即可。图来自于 kkwpsv（李少珺）。第一步：关闭内核隔离，然后重启要找到“内核隔离”开关，直接在开始菜单搜索“内核隔离”或者“Credential Guard”即可。如果搜不到，去任务栏右下角找到“Windows 安全中心”双击打开。第二步：禁用设备防护打开“组策略”，进入 本地计算机策略 -&amp;gt; 计算机配置 -&amp;gt; 管理模板 -&amp;gt; 系统 -&amp;gt; Device Guard -&amp;gt; 基于虚拟化的安全性。选择已禁用。第三步：关闭 Hyper-V在“启用或关闭 Windows 功能”里，关闭掉 Hyper-V 虚拟机（也需要重启）。第四步：运行命令以管理员身份运行以下命令：bcdedit /set hypervisorlaunchtype off然后重启计算机。参考资料 Windows沙盒和vmware workstation似乎只能存在一个-远景论坛-微软极客社区" }, { "title": "Visual Studio 智能感知提示里的奇妙行为一览", "url": "/post/fantastic-intellisense-behavior-of-visual-studio.html", "categories": "", "tags": "visualstudio", "date": "2020-06-09 15:52:22 +0800", "snippet": "本文就是个吐槽，感兴趣一一去报给微软。自动完成与建议完成作为本文的背景，你可能需要了解 Visual Studio 有一个设置：“在建议完成模式和标准完成模式之间切换”。就是下面这个按钮，你可以在工具条上找到。你一定很差异，看着这翻译，你知道“选中”对应“建议完成模式”还是“标准完成模式”呢？你知道什么是建议完成模式，什么是标准完成模式吗？不要紧，这不是翻译的问题，因为英文原文也一样令人摸不着头脑。那么这件事就交给本文来处理吧！如上图所示，如果不选中那个图标，那么智能感知会更智能，默认回车即上屏，而不用再打字母了。所以我更倾向于不要选中那个图标。至于那个图标到底哪个是建议完成模式哪个是标准完成模式，已经不重要了（反正就算知道了，名字也不直观）。奇妙行为接下来我们的讨论中，前面所述的图标都不选中，这样能最大程度体现智能感知的智能程度。带星 V.S. 不带星大家知道 Visual Studio 2019 开始，微软开始基于机器学习来训练智能感知的建议。凡通过机器学习建议的项都会用“★”（星号）标注。然而，一旦没有任何项带星，那么就没有项被选中。奇妙行为：有机器学习带星的项才会自动选中，没有带星的项就不会自动选中。全小写 V.S. 部分大写注意看下面的图片中的提示：使用 preso 能自动选中 PresentationSource 而使用 Preso 则不会自动选中 PresentationSource。奇妙行为：如果完全用小写字母打字，则可以按词匹配前几位字母；如果出现了大写字母，那么出现的小写字母就默认不算做新单词。直接输入 V.S. 删除后输入看看下面的动图：注意到了什么？如果是输入单词，那么会默认选中；但删除了字母后再输入单词，就不会默认选中了。奇妙行为：直接输入和删除后再输入，默认选中的行为不同；删除后再输入不会默认选中。输入单词 V.S. 输入点从前面的示例可以看到，如果能满足 Visual Studio 的输入要求输入单词（鬼知道是什么要求），那么基本能直接选中。但按要求输入点“.”却不一定能直接选中。所以，如果你能熟练摸透 VS 单词的补全逻辑，那么可能仅在输入点“.”的时候才会遇到有时选中有时不选中的问题。奇妙行为：？不同种类的空格当即将输入的代码是枚举这种很封闭的语句时，直接自动选中（虽然自动提示的经常不是想要的）：然而当输入的代码是命名这种比较开放的语句时，不会自动选中（虽然自动提示的名字很想要）：奇妙行为：同样是空格，有时会自动选中，有时不会自动选中。吐槽可以发现，虽然 Visual Studio 提供了一个是否自动选中智能感知提示选项的开关，但这个开关的行为并不总能反映出实际的使用效果。 如果选中了按钮（见本文开头所述），则一定不会自动选中智能感知提示 如果没选中按钮，则是否自动选中智能感知提示简直随缘你要说，Visual Studio 猜得准的时候会自动选中，猜不准的时候不会自动选中。但实际使用效果却是，你自认为猜得准的时候，我却不需要你的提示；你自认为猜不准的时候，给出的建议却非常完美。不如直接按照开关来，简单利索，还不用在开发的时候琢磨到底该不该按上下来一轮选择。" }, { "title": "Chrome 窗口全黑了，不怕，有招", "url": "/post/how-to-fix-the-pure-black-window-of-chrome.html", "categories": "", "tags": "windows, web", "date": "2020-06-08 08:22:55 +0800", "snippet": "Chrome 的窗口偶尔会出现全黑掉的情况。从轻微的到严重的，本文都有解决方案。偶然全黑Chrome 全黑的状态看起来像下图这样：通常发生在这些时间点后： 锁屏解锁后 突然间显卡驱动崩溃了一下 显卡驱动刚刚升完级 远程桌面连接后这时，通常还伴随着基于 Chromium 内核的应用全部黑屏，比如： Visual Studio Code (VSCode) Microsoft Edge解决方法是： 开一个新窗口开的方法有（任选其一，适用与所有 Chromium 内核应用）： 在任务栏上右键，重新点开程序（看下图） 直接鼠标中键点击任务栏上的图标 去开始菜单或者其他入口处点开程序一直黑有时，前面的方法并不能帮你解决问题——新开程序也依然是黑屏的。通常发生在这些时间点后： Windows 10 系统更新完后这时，你可能发现其他基于 Chromium 内核的应用是正常的。也就说明此时的问题仅仅是 Chrome 浏览器的问题。解决方法是： 删除 %LOCALAPPDATA%\\Google\\Chrome\\User Data\\ShaderCache\\GPUCache 下的全部文件 重新启动 Chrome 浏览器例如，我的文件夹是 C:\\Users\\lvyi\\AppData\\Local\\Google\\Chrome\\User Data\\ShaderCache\\GPUCache，全部删除后重新启动即恢复。" }, { "title": "拿别人的 Program Files 文件夹？别忘了考虑 x86/x64 路径", "url": "/post/get-program-files-cross-x64-x86.html", "categories": "", "tags": "dotnet, win32", "date": "2020-06-03 08:13:44 +0800", "snippet": "要拿适用于自己进程的 Program Files 文件夹很简单，无脑拿就好了。不过，如果涉及到拿其他程序的，那么就会涉及到与其他程序不同架构时路径不同的问题。Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles) 即可用来获取 Program Files 文件夹的路径。从 .NET Framework 4.0 开始，还增加了一个 ProgramFilesX86 枚举可用。在官方文档中，ProgramFiles 枚举拿的是当前进程架构下的 Program Files 文件夹，ProgramFilesX86 拿的是 x86 进程架构下的 Program Files 文件夹。为了具体说明，可以用下面的示例程序：using System;namespace Walterlv.Demo{ class Program { static void Main(string[] args) { var is64Bit = Environment.Is64BitProcess; var pfx86 = Environment.GetFolderPath(Environment.SpecialFolder.ProgramFilesX86); var pf = Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles); Console.WriteLine($&quot;process = {(is64Bit ? &quot;x64&quot; : &quot;x86&quot;)}&quot;); Console.WriteLine($&quot;x86 = {pfx86}&quot;); Console.WriteLine($&quot;current = {pf}&quot;); } }}在 x64 系统下，输出是：process = x64x86 = C:\\Program Files (x86)current = C:\\Program Files在 x86 系统下，输出是：process = x86x86 = C:\\Program Files (x86)current = C:\\Program Files (x86)所以，只是通过此属性的话，x86 进程不能获取到 x64 进程的目录。参考资料 Environment.SpecialFolder Enum (System) - Microsoft Docs C# - How to get Program Files (x86) on Windows 64 bit - Stack Overflow" }, { "title": "在 .NET 对象和 JSON 互相序列化的时候，枚举类型如何设置成字符串序列化，而不是整型？", "url": "/post/newtonsoft-json-convert-enum-as-strings.html", "categories": "", "tags": "dotnet", "date": "2020-06-03 07:57:07 +0800", "snippet": "默认情况下，Newtonsoft.Json 库序列化和反序列化 JSON 到 .NET 类型的时候，对于枚举值，使用的是整数。然而，在公开 JSON 格式的 API 时，整数会让 API 不易于理解，也不利于扩展和兼容。那么，如何能使用字符串来序列化和反序列化 JSON 对象中的枚举呢？—— 使用转换器（JsonConverter）。Newtonsoft.Json 中自带了一些转换器，在 Newtonsoft.Json.Converters 命名空间下。其中枚举的转换是 StringEnumConverter，我们只需要将其标记在属性上即可。如下面的代码所示：using Newtonsoft.Json;using Newtonsoft.Json.Converters;namespace Walterlv.Models{ public class Foo { [JsonConverter(typeof(StringEnumConverter), true)] public DoubiLevel Level { get; set; } } public enum DoubiLevel { None, ABit, Normal, Very, Extreme, }}对于“逗比程度”枚举，增加了转换器后，这个对象的序列化和反序列化将成：{ &quot;Level&quot;: &quot;very&quot;}那个 StringEnumConverter 后面的参数 true 表示使用 camelCase 来格式化命名，即首字母小写。当然，如果你希望属性名也小写的化，需要加上额外的序列化属性：++ using System.Runtime.Serialization; using Newtonsoft.Json; using Newtonsoft.Json.Converters; ……++ [DataContract] public class Foo {++ [DataMember(Name = &quot;level&quot;)] [JsonConverter(typeof(StringEnumConverter), true)] public DoubiLevel Level { get; set; } } ……将序列化和反序列化成：{ &quot;level&quot;: &quot;very&quot;}" }, { "title": "如何在保留原本所有样式/绑定和用户设置值的情况下，设置和还原 WPF 依赖项属性的值", "url": "/post/change-and-restore-wpf-dependency-value-without-disabling-the-declared-use-of-the-property.html", "categories": "", "tags": "wpf, dotnet", "date": "2020-06-03 07:13:24 +0800", "snippet": "WPF 备份某控件的一些属性，做一些神奇的操作，然后再还原这些属性。多么司空见惯的操作呀！然而怎么备份却是值得研究的问题。直接赋值？那一定是因为你没踩到一些坑。场景和问题现在，我们假想一个场景（为了编代码方便）： 有一个窗口，设置了一些样式属性 现在需要将这个窗口设置为全屏，这要求修改一些原来的属性（WPF 自带那设置有 bug，我会另写一篇博客说明） 取消设置窗口全屏后，之前修改的那些属性要“完美”还原一般可能会这么写：private Window _window;private WindowStyle _oldStyle;private void OnEnterFullScreen(){ _oldStyle = _window.WindowStyle; _window.WindowStyle = WindowStyle.None;}private void OnExitFullScreen(){ _window.WindowStyle = _oldStyle;}然而： 如果某人在 WindowStyle 上设了个动态的样式怎么办？——那当然是不再动态了呀（因为覆盖了样式值） 如果某人在 WindowStyle 上设置了绑定怎么办？——那当然也是不再生效了呀（因为绑定被你覆盖了）解决方法和原理 因为各大 WPF 入门书籍都说到了 WPF 依赖项属性的优先级机制，所以大家应该基本都知道这个。不了解的，可以立刻去这里看看：[依赖项属性值优先级 - WPF Microsoft Docs](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/advanced/dependency-property-value-precedence#dependency-property-setting-precedence-list)。 是这样的优先级：强制 &amp;gt; 动画 &amp;gt; 本地值 &amp;gt; 模板 &amp;gt; 隐式样式 &amp;gt; 样式触发器 &amp;gt; 模板触发器 &amp;gt; 样式 &amp;gt; 默认样式 &amp;gt; 属性继承 &amp;gt; 元数据默认值。而我们通过在 XAML 或 C# 代码中直接赋值，设置的是“本地值”。因此，如果设置了本地值，那么更低优先级的样式当然就全部失效了。那么绑定呢？绑定在依赖项属性优先级中并不存在。绑定实际上是通过“本地值”来实现的，将一个绑定表达式设置到“本地值”中，然后在需要值的时候，会 ProvideValue 提供值。所以，如果再设置了本地值，那么绑定的设置就被覆盖掉了。但是，SetCurrentValue 就是干这件事的！SetCurrentValue 设计为在不改变依赖项属性任何已有值的情况下，设置属性当前的值。_window.SetCurrentValue(Window.WindowStyleProperty, WindowStyle.None);那么，只需要还原 SetCurrentValue 所做的修改，就还原了此依赖项属性的一切设置的值：_window.InvalidateProperty(Window.WindowStyleProperty);注意不是 ClearValue，那会清除本地值。然而还差一点，绑定如果在你应用 SetCurrentValue 期间有改变，那么这次的赋值并不会让绑定立即生效，所以我们还需要手工再让绑定重新更新值：BindingOperations.GetBindingExpression(_window, Window.WindowStyleProperty)?.UpdateTarget();那么，综合起来，本文一开始的代码将更新成如下形式：private Window _window;private void OnEnterFullScreen(){ _window.SetCurrentValue(Window.WindowStyleProperty, WindowStyle.None);}private void OnExitFullScreen(){ _window.InvalidateProperty(Window.WindowStyleProperty); BindingOperations.GetBindingExpression(_window, Window.WindowStyleProperty)?.UpdateTarget();}延伸将代码变得通用一点：static void ApplyTempProperty(DependencyObject d, DependencyProperty dp, object tempValue){ d?.SetCurrentValue(dp, tempValue);}static void RestoreProperty(DependencyObject d, DependencyProperty dp){ d.InvalidateProperty(dp); BindingOperations.GetBindingExpression(d, dp)?.UpdateTarget();}" }, { "title": "Unity3D 入门：如何管理 Unity 项目中的 NuGet 包？使用第三方 NuGet 包管理器——NuGetForUnity", "url": "/post/third-party-unity-nuget-management.html", "categories": "", "tags": "unity", "date": "2020-06-01 09:21:30 +0800", "snippet": "Unity 项目虽然可使用 C# 项目作为脚本，却并没有提供一种类似 NuGet 的第一方包管理器。不过，还是有第三方包管理器可以用，为 C# 脚本应用现有的库提供方便。NuGetForUnity第三方适用于 Unity 的 NuGet 包管理器推荐： GlitchEnzo/NuGetForUnity: A NuGet Package Manager for Unity去它的 Release 页面，可以下载到 NuGetForUnity.2.0.0.unitypackage 的 Unity 包文件。安装 NuGetForUnityNuGetForUnity 是按项目安装的，所以你需要先打开一个项目（否则双击安装只会进到项目选择界面）。打开了一个 Unity 的项目后，双击下载下来的 NuGetForUnity.2.0.0.unitypackage 文件，你会看到包导入界面：点击 Import 按钮即可将 NuGetForUnity 安装到你刚刚打开的项目中。使用 NuGetForUnity安装完 NuGetForUnity 后，你能在 Unity 编辑器的主菜单上面看到 NuGet 入口了。这很像是 Visual Studio 中自带的 NuGet 包管理器，不过这是适用于 Unity 的第三方 NuGet 包管理器。安装 NuGet 包就从上面所述的菜单那里打开，你可以进入 NuGet 包的搜索与安装界面。输入并找到你想安装的 NuGet 包，然后点击 Install 即可。还原 NuGet 包正常情况下，你打开别人上传到版本管理中的仓库后，仅仅启动 Unity 编辑器就可以完成 NuGet 包的还原。因为 NuGetForUnity 是安装到项目当中的，Unity 编辑器启动的时候也会运行 NuGetForUnity，这时就会自动还原项目当中所安装过的 NuGet 包了。还有没有其他包管理方案？在微软的 文档中，描述 NuGet 包安装的方法是手工的，对于普通的没有依赖的 NuGet 包来说问题不大，不过如果 NuGet 包包含依赖的话，那手工处理的工作量就有点大了，尤其是依赖有嵌套，出现层层嵌套的依赖的时候，几乎可以不用考虑手工安装 NuGet 包的方式了。关于手工安装 NuGet 包的方式，我在另一篇入门文档当中也有说到过： Unity3D 入门：为 Unity 的 C# 项目添加 dll 引用或安装 NuGet 包 - walterlv参考资料 GlitchEnzo/NuGetForUnity: A NuGet Package Manager for Unity" }, { "title": "Unity3D 入门：Unity 项目版本管理建议使用的 .gitignore 忽略文件和 .gitattributes 文件（2020年4月更新）", "url": "/post/unity-starter-git-ignore-and-git-attributes.html", "categories": "", "tags": "unity, csharp", "date": "2020-06-01 09:21:30 +0800", "snippet": "Unity3D 项目虽然说使用 C# 脚本开发，但毕竟不是 .NET/C# 项目。今天一位小伙伴告诉我说用错了 .gitignore 文件，结果管理仓库时丢了很多重要的文件。实际上，GitHub 官方提供了大量不同项目类型的 .gitignore 文件，并且有广大的社区支持时时更新，直接前往 GitHub 官网下载是最好的选择了。适用于 Unity 项目的 .gitignore 模板： gitignore/Unity.gitignore at master · github/gitignore# This .gitignore file should be placed at the root of your Unity project directory## Get latest from https://github.com/github/gitignore/blob/master/Unity.gitignore#/[Ll]ibrary//[Tt]emp//[Oo]bj//[Bb]uild//[Bb]uilds//[Ll]ogs//[Uu]ser[Ss]ettings/# MemoryCaptures can get excessive in size.# They also could contain extremely sensitive data/[Mm]emoryCaptures/# Asset meta data should only be ignored when the corresponding asset is also ignored!/[Aa]ssets/**/*.meta# Uncomment this line if you wish to ignore the asset store tools plugin# /[Aa]ssets/AssetStoreTools*# Autogenerated Jetbrains Rider plugin/[Aa]ssets/Plugins/Editor/JetBrains*# Visual Studio cache directory.vs/# Gradle cache directory.gradle/# Autogenerated VS/MD/Consulo solution and project filesExportedObj/.consulo/*.csproj*.unityproj*.sln*.suo*.tmp*.user*.userprefs*.pidb*.booproj*.svd*.pdb*.mdb*.opendb*.VC.db# Unity3D generated meta files*.pidb.meta*.pdb.meta*.mdb.meta# Unity3D generated file on crash reportssysinfo.txt# Builds*.apk*.unitypackage# Crashlytics generated filecrashlytics-build.properties# Packed Addressables/[Aa]ssets/[Aa]ddressable[Aa]ssets[Dd]ata/*/*.bin*# Temporary auto-generated Android Assets/[Aa]ssets/[Ss]treamingAssets/aa.meta/[Aa]ssets/[Ss]treamingAssets/aa/*注意到 sln 和 csproj 都是忽略的文件吗？这是 Unity 的项目，其他 .NET 项目经常使用的 sln 解决方案管理方式在这里只是辅助手段而已，你可以阅读我的另一篇博客了解更多： Unity3D 入门：使用 Visual Studio 开发 Unity C# 脚本，说说根目录的那些 sln 和 csproj 文件 - walterlv额外的，你可能注意到 Unity 项目里面有大量的 *.meta 文件，是自动生成的，这个要加入到版本管理吗？答案是需要。Unity 创建这些文件是为了给导入的文件添加额外的元数据信息的，毕竟不能直接修改原来的文件。这些信息包含： 描述如何导入这个资产文件 如何在项目中准备资产如果你删除了这些文件，那么 Unity 会用默认的元数据信息生成一个对应的 .meta 文件。其他类型的 .gitignore 文件前往 GitHub 的 gitignore 仓库： github/gitignore: A collection of useful .gitignore templates另外，开启一个新的 Unity 项目时，放一个适用于大多数场景的 .gitattributes 也可以一开始规避一些坑。你可以从下面这位大佬拿到他整理的一个 .gitattribute 文件。 .gitattributes for Unity3D with git-lfs参考资料 unity5 - What is a .meta file and why does Unity create them for all of my assets? - Stack Overflow" }, { "title": "解决包含 GitHub Actions Workflow 的分支无法推送的问题", "url": "/post/github-push-failed-without-workflow-scope.html", "categories": "", "tags": "github", "date": "2020-05-26 21:48:42 +0800", "snippet": "refusing to allow an OAuth App to create or update workflow {0} without workflow scope.GitHub 推送失败？试试本文方法。问题试图向 GitHub 推送一个分支的时候，出现错误 refusing to allow an OAuth App to create or update workflow {0} without workflow scope。这个错误是说，因为 OAuth 的应用没有指定 workflow 范围，所以无法推送带有更新 workflow 的分支。虽然我实际上没有对 workflow 做任何更新，但也被拒绝了。所以这个问题必须直接解决，绕不开。git.exe push self master:t/walterlv/triggerEnumerating objects: 17, done.Counting objects: 100% (17/17), done.Delta compression using up to 8 threadsCompressing objects: 100% (9/9), done.Writing objects: 100% (9/9), 754 bytes | 754.00 KiB/s, done.Total 9 (delta 8), reused 0 (delta 0), pack-reused 0remote: Resolving deltas: 100% (8/8), completed with 8 local objects.To https://github.com/dotnet-campus/HandyControl.git! [remote rejected] master -&amp;gt; t/walterlv/trigger (refusing to allow an OAuth App to create or update workflow `.github/workflows/build.yml` without `workflow` scope)error: failed to push some refs to &#39;https://github.com/dotnet-campus/HandyControl.git&#39;解决去 GitHub Personal Access Tokens 页面： Personal Access Tokens生成一个新的 Token。特别注意在生成的时候要勾选 workflow（如果不确定勾选哪些的话，就全部勾选）：然后复制新的 Token：打开凭据管理器：在 Windows 凭据标签下，找到 GitHub 的几个凭据，然后编辑： git:https://github.com git:https://walterlv@github.com把密码改成刚刚复制的那个 Token，然后保存：如果你那里有很多 GitHub 相关的凭据而不确定是哪一个的话，可以考虑全部删掉。这样下次推送的时候就会要求你输入账号密码，输入那个 Token 作为密码即可。现在，你就能推送成功了。" }, { "title": "杂谈 System.Drawing.Common 的跨平台性（关键词：libgdiplus / .NET Core / Mono / Win32 / Linux / ……）", "url": "/post/system-drawing-common.html", "categories": "", "tags": "dotnet, csharp", "date": "2020-05-25 09:00:15 +0800", "snippet": "经过 Mono 团队的不懈努力，原本专属于 Win32 平台的 GDI+ 终于可以跨平台了，不过这中间还有好多的故事和好多的坑。本文带你了解 System.Drawing 命名空间的跨平台。System.Drawing、System.Drawing.Common 以及 GDI+在了解本文的后续内容之前，你可能需要先了解一些基本的名词，不然后面极可能看得云里雾里。System.Drawing 有两个意思，第一个是 System.Drawing.dll 程序集，第二个是 System.Drawing 命名空间。如果进行 .NET Framework 项目的开发，那么对 System.Drawing 一定不陌生，框架自身对位图的处理基本都是用的这套库，很多第三方图像处理库也都基于 System.Drawing 程序集进行二次封装。比如 JimBobSquarePants/ImageProcessor 库实际上就是对 System.Drawing 的封装，AForge.NET 库作为计算机视觉库也对 System.Drawing 有较大的依赖。Mono 是一个诞生以来就为了让 .NET Framework 跨平台的开源项目。开发基于 Mono 运行时的项目时，使用的框架 API 也是兼容 .NET Framework 的，因此也可以在 Mono 中直接依赖 System.Drawing 程序集进行开发。System.Drawing 固然强大，但它却只是 Win32 GDI+ 的一层很薄很薄的封装。然而其他平台上没有原生对 GDI+ 的实现，所以跨平台是一个比较棘手的问题（本文后面会说到如何做到跨平台）。.NET Core 也是为跨平台而生，不过它走的路线与 Mono 有些不同。它从 API 级别就分离出 .NET Framework 中不跨平台的部分，然后把它们从 .NET 的核心仓库中移除，换成 .NET 的扩展框架（如 WPF / Windows Forms）。那么面对 System.Drawing 部分的 API 时 .NET Core 是怎么做的呢？一开始做了一个兼容库 CoreCompat.System.Drawing（仓库在这里和这里）做了一部分的兼容，而后由于 Mono 的努力做出了 GDI+ 在其他平台上的实现（mono/libgdiplus），.NET Core 就有幸将 System.Drawing 纳入 .NET Core 中作为一个扩展库存在。而这个库就是 System.Drawing.Common（仓库在 这里）。我们小结一下： GDI+ 是 Windows 上的图形设备接口（Graphics Device Interface），用来完成一些和绘制有关的工作，用以解决不同应用程序开发者需要面向具体的硬件绘图造成的兼容负担（类似的有 GTK 的 GDK/Xlib 还有 Mac 设备的 Quartz）。 System.Drawing 命名空间里包含了封装 GDI+ 的一层薄薄的封装，System.Drawing.dll 是 .NET Framework 下这层封装的实现，System.Drawing.Common 库是 .NET Core 下这层封装的实现。跨平台的关键 libgdipluslibgdiplus 是在非 Windows 操作系统上提供 GDI+ 兼容 API 的 Mono 库，而其跨平台图形绘制的大部分关键实现靠的是 Cairo 库。libgdiplus 的开源仓库： mono/libgdiplus: C-based implementation of the GDI+ API目前，其几乎就是为 System.Drawing 命名空间下的位图处理作为实现的。System.Drawing 的跨平台的能力几乎完全靠的是 libgdiplus 库。安装方法见仓库 README。目前 libgdiplus 还有一些没能完全实现的部分： 文本 libgdiplus 目前是自己实现的一套文本引擎，但 GDI+ 提供了 libgdiplus 不支持或不正确支持的许多（很少使用的）选项 目前也正考虑使用 pango 引擎来替代自己的实现，可通过 –with-pango 选项开启 pango 引擎，但没实现的功能更多 其他 还有其他一些没实现的功能 可在这里看到尚未实现的功能列表 libgdiplus/TODO at master · mono/libgdiplus Mono 官方欢迎社区广大小伙伴帮忙完成这些任务 System.Drawing 各平台目前的支持情况Mono 和 .NET Core 目前均已完成基于 libgdiplus 的 System.Drawing 命名空间的跨平台。当然，这个跨平台迁移的唯一目的是“兼容”，是为了让现有的基于 System.Drawing 的代码能够跨平台跑起来。仅此而已，不会有任何的性能优化或者设计优化。（想要优化的版本可以参考本文最后推荐的其他图形库）。但依然值得注意的是，这个跨平台依然不是完全的跨所有平台： 一是因为前面我们说到的 libgdiplus 尚未完全实现 GDI+ 的所有功能 二是因为 Windows 自己的 UWP 平台无法完成 System.Drawing 的实现这里将其他的基于 .NET / Windows 平台的图形实现放到一起来做对比：   Win32 UWP macOS Linux / 其他 .NET Framework (GDI+) ✔️ ❌ ❌ ❌ Direct2D / Win2D ✔️ ✔️ ❌ ❌ Mono / .NET Core (libgdiplus) ✔️ ❌ ✔️ ✔️ Xamarin (CoreGraphics) ❌ ❌ ✔️ ❌ 其他第三方 .NET 库 ✔️ ✔️ ✔️ ✔️ .NET Framework 中的实现也就是本文一直在说的重点，即 System.Drawing，即对 GDI+ 那非常薄的封装。 Direct2D / Win2D 只能在 Windows 平台使用；如果不使用 UWP 桥，那么 Win2D 也只能局限在 UWP 平台，而且要求系统版本 Windows 8 及以上。 Mono / .NET Core 基于 libgdiplus 实现跨平台，但需要注意在 Win32 平台上，它用的也是现成的 GDI+ 实现，而不是 libgdiplus。 Xamarin / CoreGraphics 这是使用原生系统组件做的图形实现，仅支持 macOS 平台。 其他第三方库因为不强依赖系统组件，所以能做到更好的跨平台特性。（可见本文末尾推荐的图像库。）选择 System.Drawing.dll 还是选择 System.Drawing.Common问题回到 System.Drawing 上，现在我们知道应该使用 System.Drawing.dll 还是使用 System.Drawing.Common 库了吗？盲猜应该使用 System.Drawing.Common 库吧？因为这个库里面既带了 Windows 平台下的实现（对 GDI+ 做一层很薄的封装），又带了 Linux 和 macOS 下的实现（使用 libgdiplus）。然而事情并没有那么简单！我来问几个问题： .NET Framework 里面已经自带了 System.Drawing.dll 了，那么 System.Drawing.Common 包里带的 System.Drawing.Common.dll 是否会与之冲突？ 例如是否会导致同一个类型分属两个不同的程序集导致分别依赖两个不同程序集的不同代码之前无法传递 System.Drawing 命名空间中的参数呢？ 所有种类的项目都能正常使用 System.Drawing.Common 库吗？ 例如 Unity3D 项目 首先来看看问题一。我们新建一个 .NET Framework 的项目，一个 .NET Core 的项目，两者都安装 System.Drawing.Common 包，然后调用一下这个包里面的方法：class Program{ private static void Main() { var bitmap = new Bitmap(@&quot;D:\\walterlv\\test.png&quot;); }}反编译会发现，两者都是可以正常运行的。将 net48 框架项目下引用的 System.Drawing.Common.dll 反编译来看，可以发现，这是一个空的程序集，里面几乎没有任何实质上的类型。里面所有的类型都通过 TypeForwardedTo 特性转移到 System.Drawing.dll 程序集了，现在剩下的只是一个垫片。关于 TypeForwarding 可以阅读这篇博客了解：C# dotnet TypeForwarding 的用法，微软也有其他通过此方式做的 NuGet 包，可参见 微软官方的 NuGet 包是如何做到同时兼容新旧框架的？ - walterlv。将 netcoreapp3.1 框架项目下引用的 System.Drawing.Common.dll 反编译来看，可以发现，这个程序集里面所有的类型所有的方法实现都是抛出 PlatformNotSupportedException。这就有些奇怪了，如果所有的方法都抛出 PlatformNotSupportedException 那如何才能正常运行呢？打开 netcoreapp3.1 输出目录下的 *.deps.json 文件，可以注意到，里面记录了在不同的运行目标下应该使用的真实的 System.Drawing.Common.dll 的文件路径：&quot;runtimeTargets&quot;: { &quot;runtimes/unix/lib/netcoreapp3.0/System.Drawing.Common.dll&quot;: { &quot;rid&quot;: &quot;unix&quot;, &quot;assetType&quot;: &quot;runtime&quot;, &quot;assemblyVersion&quot;: &quot;4.0.2.0&quot;, &quot;fileVersion&quot;: &quot;4.700.19.56404&quot; }, &quot;runtimes/win/lib/netcoreapp3.0/System.Drawing.Common.dll&quot;: { &quot;rid&quot;: &quot;win&quot;, &quot;assetType&quot;: &quot;runtime&quot;, &quot;assemblyVersion&quot;: &quot;4.0.2.0&quot;, &quot;fileVersion&quot;: &quot;4.700.19.56404&quot; }}去相应的路径下找，可以找到 win 版本的 System.Drawing.Common.dll 和 unix 版本的 System.Drawing.Common.dll。这些指定的依赖，在发布此程序之后会换成真实的依赖，而不再包含多个不同平台下的 dll 了：dotnet publish -c Release -f netcoreapp3.1 -r win10-x64 --self-contained true拆包我们去 nuget.org 上下载下来 System.Drawing.Common 包拆开来看，会发现这个包有两个很关键的文件夹： lib runtimes其中，lib 里面包含这些不同的目标框架： MonoAndroid10 MonoTouch10 net461 netstandard2.0 xamarinios10 xamarinmac20 xamarintvos10 xamarinwatchos10net461 里包含的 dll 就是前面我们说到的“垫片”，所有的类型都通过 TypeForwardedTo 转移到 .NET Framework 版本的 System.Drawing.dll。netstandard2.0 适用于 .NET Core 框架，里面包含的 dll 就是前面我们说到的所有方法都抛出 PlatformNotSupportedException 的版本。其他所有框架里都是 . 文件，是个空的文件，仅用来告诉 NuGet 这个包支持这些框架安装，但不引用任何 dll。另外，NuGet 包的 runtimes 文件夹里面包含了前面我们说到的 win 和 unix 不同实现版本的 System.Drawing.Common.dll。前面已经给出了反编译的截图，应该足够了解了。你也可以自己去解包，了解里面的目录结构，去反编译看。决定现在，是时候来决定应该使用 System.Drawing.dll 还是使用 System.Drawing.Common 包了。那么，这里我整理一张表：   System.Drawing.dll System.Drawing.Common .NET Framework 4.6 及以下版本 ✔️ ❌ .NET Framework 4.6.1 及以上版本 ✔️ ✔️ .NET Core 1.x ❌ ❌无法安装包 .NET Core 2.0 - .NET Core 2.1 ❌ ❌运行时抛出PlatformNotSupportedException .NET Core 3.0 及以上版本 ❌ ✔️ Mono / Xamarin ✔️ ❌ ✔️表示可以使用，没有问题；❌表示不支持此引用方式。另外，这里还要额外说一下 Unity 的支持情况。Unity 有两种不同的 C# 脚本后端可选：Mono 和 IL2CPP。然而 Unity 不能原生支持 NuGet 包，而 System.Drawing.Common 包要能够在编译时自动选择正确的 dll 去引用，是需要 3.4 版本以上的 NuGet 程序来支持的。如果不能完全实现此版本 NuGet 的功能，那么编译时是无法将正确的 dll 拷贝到输出目录的。不幸的是，目前流行于 Unity 的第三方 NuGet 管理器不能正确拷贝此包的 dll 到输出目录。更具体的，是受以下设置的影响（在编译设置里面）：   脚本后端 Api 兼容级别 System.Drawing.dll System.Drawing.Common 组合1 Mono .NET 4.x ✔️ ❌相当于没引用 组合2 Mono .NET Standard 2.0 ❌相当于没引用 ❌第三方 NuGet 包管理器会拷贝错误的 dll 组合3 IL2CPP .NET 4.x ❌可在编辑器运行，但打包后会出现异常 ❌未引用任何库 组合4 IL2CPP .NET Standard 2.0 ❌相当于没引用 ❌第三方 NuGet 包管理器会拷贝错误的 dll 是不是很悲惨？只有 Mono / .NET 4.x 这个组合可以正常使用 System.Drawing。当然，如果你愿意用部分手工或自己的脚本/工具来代替第三方 NuGet 包的部分功能，选择出正确的 dll 的话，那么对应的方案也是能行的。表中的“❌相当于没引用”指的是引用此 dll 相当于没引用 dll，安装此包相当于没有引用此包：// .NET 4.x 的 Api 兼容级别报此错误The type name &#39;{0}&#39; could not be found in the namespace &#39;System.Drawing&#39;. This type has been forwarded to assembly &#39;System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a&#39; Consider adding a reference to that assembly.// .NET Standard 2.0 的 Api 兼容级别报此错误The type or namespace name &#39;Imaging&#39; does not exist in the namespace &#39;System.Drawing&#39; (are you missing an assembly reference?)IL2CPP 里在编辑器里可以正常使用（当然能正常，因为编辑器又没用 IL2CPP），打包后出现的异常如下（所有的 System.Drawing 方法调用都有异常）：NotSupportedException: System.Drawing.Image::FromHbitmapSystem.Drawing.Image.FromHbitmap (System.IntPtr hbitmap) (at &amp;lt;00000000000000000000000000000000&amp;gt;:0)关于 Unity 的部分，本文不打算细说。如果你有其他疑问，我就挖个坑，再写一篇来填。不依赖 System.Drawing 的其他免费开源库如果你当前的开发平台依然无法使用到 System.Drawing 命名空间，那么可以考虑使用另外的一些替代品。这里给出一些推荐： SixLabors/ImageSharp: A modern, cross-platform, 2D Graphics library for .NET mono/SkiaSharp: SkiaSharp is a cross-platform 2D graphics API for .NET platforms based on Google’s Skia Graphics Library. It provides a comprehensive 2D API that can be used across mobile, server and desktop models to render images.如果你需要的是图像处理，而不需要与 Windows API 有太多关联的话，那么使用这些库会比使用 System.Drawing 带来更优秀的用法、更好的性能以及更现代化的维护方式。参考资料 Support Full System.Drawing Functionality on .NET Core · Issue #21980 · dotnet/runtime mono/libgdiplus: C-based implementation of the GDI+ API libgdiplus/TODO at master · mono/libgdiplus libgdiplus - Mono" }, { "title": "微软官方的 NuGet 包是如何做到同时兼容新旧框架的？例如 System.ValueTuple 是如何做到在新旧版本的框架都能使用的？", "url": "/post/microsoft-dotnet-packages-use-typeforwarded-to-keep-compatibility.html", "categories": "", "tags": "dotnet, nuget", "date": "2020-05-24 16:27:16 +0800", "snippet": "不知你是否好奇，System.ValueTuple 是新框架（.NET Core 3.0）开始引入的类型，但可以通过 NuGet 包向旧框架提供这些类型的使用。并且，这些包即便安装到本来就有此类型的新框架上也能正常运行而不会出现多处类型定义的问题。这些类型是如何做到框架内定义了，包里也定义了，却能像同一个类型一样作为参数和返回值传递？本文带你了解其中的奥秘。示例项目首先，我们需要有一个示例项目，用来观察 System.ValueTuple 在框架内和 NuGet 包内的一些行为。创建一个 .NET Core 控制台项目。然后我们需要修改两个地方： Program.cs 文件 项目文件（*.csproj）文件class Program{ static void Main() { var (a, b) = Foo(); System.Console.WriteLine($&quot;欢迎阅读{a}的博客 {b}&quot;); } static (string a, string b) Foo() =&amp;gt; (&quot;吕毅&quot;, &quot;blog.walterlv.com&quot;);}&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;OutputType&amp;gt;Exe&amp;lt;/OutputType&amp;gt; &amp;lt;TargetFrameworks&amp;gt;net462;net48;netstandard2.0;netcoreapp2.0;netcoreapp3.1&amp;lt;/TargetFrameworks&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;PackageReference Include=&quot;System.ValueTuple&quot; Version=&quot;4.5.0&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt;&amp;lt;/Project&amp;gt;接下来，我们的研究都将基于此项目。研究开始System.ValueTuple 对旧框架的支持体现在三个方面： 旧框架中也能写出新框架中的这种语法； 旧框架中也能正常使用此类型； 新框架中此类型不会与包中的类型冲突。我们分别来看看这三个都是如何实现的。语法支持C# 从 7.0 开始支持元组类型的语法，即可以写出这样的代码：var (a, b) = Foo();关于此新增功能，可以前往这里查看： C# 7.0 中的新增功能 - C# 指南 - Microsoft DocsC# 从 8.0 开始，各种原本需要实现特定接口才能写出的语法，现在也可以不用实现接口了，只要有对应的方法存在即可，比如： IDisposable IEnumerable Deconstruct另外，从 C# 5.0 开始引入的 async/await 也是如此，无需实现任何接口，有 GetAwaiter 方法就够了。也是一样的情况，详见： .NET 中什么样的类是可使用 await 异步等待的？ - walterlv也就是说，只要你的项目使用的 C# 版本在 7.0 以上，就可以使用元组解构这样的语法。即便在 C# 7.0 以下，也能使用 System.ValueTuple，只是不能使用此语法而已。旧框架兼容System.ValueTuple 对旧框架的兼容，单纯的就是通过 NuGet 包引入了这些类型，以及这些类型的实现而已。我们在示例项目的 net462 的输出目录下找到 System.ValueTuple.dll 进行反编译可以看出来这一点：新框架不冲突我们再去新框架里面看看 System.ValueTuple 的情况。例如先看看 net48 目录下的 System.ValueTuple.dll：可以发现，net48 下的 System.ValueTuple 已经全部使用 TypeForwardedTo 特性转移到了 mscorelib 程序集。.NET Core 3.1 版本和 .NET Standard 2.0 版本的输出目录里是没有 System.ValueTuple.dll 的，那么它们的依赖是如何决定的呢？答案是——不需要依赖！我们来拆开 System.ValueTuple 的 NuGet 包看看。可在这里下载：NuGet Gallery - System.ValueTuple 4.5.0。可发现它提供了这些不同框架的支持：其中： net47 框架使用的是 TypeForwardedTo 的垫片 net461 / netstandard1.0 / portable-net40+sl4+win8+wp8 框架使用的是完整版本的 System.ValueTuple netcoreapp2.0 / netstandard2.0 / mono 全系列 / xamarin 全系列 / uap 里面是 _._ 占位文件，表示支持此框架且无需任何引用（因为框架已经自带支持）原生支持 System.ValueTuple 的框架，其 NuGet 包中的框架内的文件是 _._，这个文件的出现仅仅是为了能让 zip 里面有一个对应框架的文件夹。而 zip 对空文件夹的支持并不好，所以加一个这样的文件可以避免文件夹消失，造成 NuGet 认为不支持这样的框架。结论 框架（.NET）和语言（C#）现在已是独立升级了，因此在使用旧框架的情况下，也可以使用新语言的特性； 旧框架使用的是完整功能的 dll（由 NuGet 包来决定使用正确的 dll）； 新框架使用的是 TypeForwardedTo 特性作为垫片，重定向类型到新框架中（由 NuGet 包来决定使用正确的 dll）。额外的，我写过另一个通过此方式获得新旧框架兼容的包： 杂谈 System.Drawing.Common 的跨平台性 - walterlv参考资料 What do mean . files in nuget packages? · Issue #744 · dotnet/aspnetcore" }, { "title": "Unity3D (Mono/IL2CPP) 中 P/Invoke 平台调用代码应该如何传委托", "url": "/post/unity3d-marshal-callback-must-be-static.html", "categories": "", "tags": "unity, csharp", "date": "2020-05-24 10:21:31 +0800", "snippet": "IL2CPP does not support marshaling delegates that point to instance methods to native code. 你可能平时在 .NET Core / Framework 的代码中写得很正常的托管代码的委托调用，在 Unity3D 中变得不可行。本文举个例子，并且将其改正。举例：查找所有可见窗口本文的例子会使用到 NuGet 包 Lsj.Util.Win32，这是个非常棒的 Win32 调用的 API 包装，可以免去大量自己可能写不对的 [DllImport]。引入命名空间：using Lsj.Util.Win32;using Lsj.Util.Win32.BaseTypes;然后查找所有的可见窗口。public static IReadOnlyList&amp;lt;HWND&amp;gt; FindVisibleWindows(){ var found = new List&amp;lt;HWND&amp;gt;(); User32.EnumWindows(OnWindowEnum, IntPtr.Zero); return found; BOOL OnWindowEnum(HWND hWnd, LPARAM lparam) { if (User32.GetParent(hWnd) == IntPtr.Zero &amp;amp;&amp;amp; User32.IsWindowVisible(hWnd)) { found.Add(HWND); } return true; }}Mono / IL2CPPUnity 编译的时候可以选择脚本后端是 Mono 还是 IL2CPP。不幸的是，没有 .NET Core 或者未来的 .NET 5/6，因此很多 .NET Core 的特性不能用。关于脚本后端的选择，可以参见我的另一篇博客： Unity3D 入门：为 Unity 的 C# 项目添加 dll 引用或安装 NuGet 包 - walterlv在编译时不会有什么问题，但是在运行时会发生异常（如果你去捕捉，或者用 VS 调试就可以看到）：NotSupportedException: IL2CPP does not support marshaling delegates that point to instance methods to native code. The method we&#39;re attempting to marshal is: Win32WindowExtensions+&amp;lt;&amp;gt;c__DisplayClass0_0::&amp;lt;FindVisibleWindows&amp;gt;g__OnWindowEnum|0 at Lsj.Util.Win32.User32.EnumWindows (Lsj.Util.Win32.User32+WNDENUMPROC lpEnumFunc, Lsj.Util.Win32.BaseTypes.LPARAM lParam) at Win32WindowExtensions.FindVisibleWindows () “IL2CPP 不支持封送实例方法到本机代码”。修正代码Mono/IL2CPP 要求封送到本机的代码必须是静态方法，且必须标 MonoPInvokeCallback 特性。因此，我们不得不把上面的代码改成这样：using System;using System.Collections.Generic;using System.Text;using AOT;using Lsj.Util.Win32;using Lsj.Util.Win32.BaseTypes;public class WindowsEnumerator{ private static List&amp;lt;HWND&amp;gt; _currentList; public IReadOnlyList&amp;lt;HWND&amp;gt; FindVisibleWindows() { _currentList = new List&amp;lt;HWND&amp;gt;(); User32.EnumWindows(OnWindowEnum, IntPtr.Zero); return _currentList; } [MonoPInvokeCallback(typeof(User32.WNDENUMPROC))] static BOOL OnWindowEnum(HWND hWnd, LPARAM lparam) { if (User32.GetParent(hWnd) == IntPtr.Zero &amp;amp;&amp;amp; User32.IsWindowVisible(hWnd)) { _currentList?.Add(HWND); } return true; }}当然上述代码不是线程安全的。所以如果你希望在多线程环境下使用，请自行修改为线程安全的版本。参考资料 MonoPInvokeCallbackAttribute Class (ObjCRuntime) - Microsoft Docs" }, { "title": "Windows/Linux 系统中获取端口被哪个应用程序占用", "url": "/post/get-port-owning-process.html", "categories": "", "tags": "windows, linux, powershell", "date": "2020-05-23 20:21:49 +0800", "snippet": "管理服务程序的时候，可能会查询某个端口当前被哪个进程占用。不仅能找出有问题的进程将其处理掉，也可以用来辅助检查某个程序是否开启了服务并在监听端口。Windows 系统Windows 系统上可以使用 PowerShell 命令来查询占用某个端口的程序。比如，我们需要查询 5000 端口被占用的进程是谁，可以在 PowerShell 中输入命令：Get-Process -Id (Get-NetTCPConnection -LocalPort 5000).OwningProcessLinux 系统在终端中输入命令 lsof 可以查询占用某个端口的进程。lsof -i:端口号比如，我们需要查询 5000 端口被占用的进程是谁，可以在中断中输入命令：walterlv@localhost:~# lsof -i:5000COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEdotnet_serve 731 root 3u IPv6 12890 0t0 TCP *:5000或者使用 netstat 查询。netstat -tunpl | grep 端口号举例：walterlv@localhost:~# netstat -tunpl | grep 35412tcp6 0 0 :::5000 :::* 731/dotnet_serve" }, { "title": "如何在 Unity3D 场景中显示帧率（FPS）", "url": "/post/unity-show-fps.html", "categories": "", "tags": "unity, csharp", "date": "2020-05-23 16:37:08 +0800", "snippet": "本文介绍如何在 Unity3D 场景中显示帧率。插入 UI：Text做 FPS 帧率显示需要用到 UI 对象 Text，因此你需要有一个 Canvas。关于在 Unity3D 中插入 UI 对象的方法可见我的另一篇博客： Unity3D 入门：如何为游戏添加 UI - walterlv当添加了 Canvas 后，再在 Canvas 里添加 Text：设置文本的属性和布局选中文本对象，在 Inspector 窗格中有很多需要设置的属性。如下图所示。锚点对齐上图中，我把点击对齐格子的弹出框放到了场景空间中（截图而已，实际不能放），不然会遮挡窗口中的其他属性。这里在水平和垂直方向上都分别可以设置 4 种对齐方式： 左/上 对齐 居中对齐 右/下 对齐 拉伸对齐默认是水平垂直居中，于是 UI 对象会以场景的中心为参考点布局。如果你强行把文本对象拉到左上角，那么你会失去分辨率自适应的特性。由于本文期望 FPS 显示到左上角，所以我把锚点设置成左上角。相对位置，大小接着，使用鼠标拖拽文本到合适的位置。也可以直接在 Inspector 窗口中设置 PosX 和 PosY 属性，这样更精确。也许你注意到还有一个 PosZ 属性可以设置。如果你在 2D 视图中，那么你会发现设置这个属性是“无效”的，但只要切回 3D 视图，你就能发现还是有深度变化的。不过，在设置 Canvas 的 Render Mode 属性之前（保持默认值），这个设置依然还是没有意义，因为默认情况下 UI 在最终显示的时候是始终保持 2D 视图的。可以拖拉鼠标调整文本框的大小，也可以设置 Width 和 Height 属性。设置文本的文字内容、字体大小和颜色在下面的 Text 组件里面，你还可以设置通常本文应该有的属性，调整到你觉得合适的值就好。添加帧率计算脚本接下来我们开始添加帧率计算脚本。创建脚本在 Inspector 窗口中添加 AddComponent 添加组件，选择新脚本，取个名字。设计脚本属性using UnityEngine;using UnityEngine.UI;public class FpsUpdater : MonoBehaviour{ public Text fpsText; void Update() { }}我们在脚本中公开一个属性 fpsText，用来在 Inspector 窗口中制定要更新的文本 UI。然后，将文本对象拖到脚本的 Fps Text 属性上，这样我们就可以在脚本中直接使用 fpsText 字段拿到要更新文本的 Text 对象了。当然，直接用 gameObject 也是可以的，不过需要自己再做类型转换。编写代码最简单的最简单的获取 FPS 的方式是直接用 1 除以当前帧所经历的时间。void Update(){ var fps = 1.0f / Time.deltaTime; fpsText.text = $&quot;FPS: {fps}&quot;;}然而当你实际使用的时候你就会觉得——嗯……眼睛会瞎的。你也有可能发现文字一时出现一时消失，那可能是因为你文本框的宽度设小了。于是当小数点后位数多了一些之后，显示不下去，文字就会消失。至少，取个整还是需要的吧，谁愿意看小数帧数呢？var fps = 1.0f / Time.deltaTime;fpsText.text = $&quot;FPS: {Mathf.Ceil(fps)}&quot;;更稳定的加了取整还是变化很快，看不清。那么可以如何更稳定呢？可以考虑累加多帧再一次性更新。比如这里 60 帧更新一次：using UnityEngine;using UnityEngine.UI;public class FpsUpdater : MonoBehaviour{ public Text fpsText; private int count; private float deltaTime; void Update() { count++; deltaTime += Time.deltaTime; if (count % 60 == 0) { count = 1; var fps = 60f/deltaTime; deltaTime = 0; fpsText.text = $&quot;FPS: {Mathf.Ceil(fps)}&quot;; } }}或者考虑 0.5 秒更新一次：public Text fpsText;private int count;private float deltaTime;void Update(){ count++; deltaTime += Time.deltaTime; if (deltaTime &amp;gt;= 0.5f) { var fps = count/deltaTime; count = 0; deltaTime = 0; fpsText.text = $&quot;FPS: {Mathf.Ceil(fps)}&quot;; }}更多脚本更多 FPS 帧数显示的脚本，可以从本文末尾的参考资料处找到。有很多不同需求的（比如帧率过低飘红的设定，比如要精确）。参考资料 how to see fps? (frames per second) - Unity Answers How do I find the frames per second of my game? - Unity Answers FramesPerSecond - Unify Community Wiki Accurate Frames Per Second Count - Unity Answers" }, { "title": "Unity3D 入门：如何为游戏添加 UI", "url": "/post/unity-starter-add-game-ui.html", "categories": "", "tags": "unity, csharp", "date": "2020-05-23 15:21:49 +0800", "snippet": "早期的 Unity3D 做 UI 并不容易，以至于大家习惯于使用 NGUI 插件来开发。后来 NGUI 的开发者加入开发了 Unity UI，现在就有了一套更好用的 Unity UI 可用了。本文简单介绍如何添加 UI 作为入门，不会深入介绍各种 UI 和细节。添加 CanvasUnity UI 都需要放到 Canvas 上才能工作。你可以像如下图这样插入一个 Canvas。当然，你也可以插入其他的 UI 对象，不过最终 Unity 编辑器都会帮你插入一个 Canvas，然后把你插入的对象放到这个 Canvas 里面。EventSystem当你开始向场景中插入 Unity 后，同时也会插入一个 EventSystem 游戏对象。EventSystem 的作用是接收系统中的输入事件，以便 UI 元素能够接受到这些事件处理用户的输入。Canvas 的属性在 Inspector 窗口中，表示 Canvas 在场景中位置的对象是 RectTransform 对象了，不再是 Transform 对象。这是定位 UI 的坐标而设计的新的类型。你无法修改 Canvas 的 RectTransform 对象的任何属性，这样 Unity 才可以让这个 Canvas 能根据分辨率自适应。其他 UI关于 Unity UI 的其他细节，我将在单独的博客中说明。 如何在 Unity3D 场景中显示帧率（FPS） - walterlv切换成 2D 视图在开发（2D）UI 的时候，建议将场景视图切换成 2D，这样比较容易做布局。当然，如果你不像我这样能看得到整个 Canvas 的话，可以考虑调整下视角或者直接双击 F。关于操作视角和快捷键，可以参考我的其他博客： Unity3D 入门：Unity Editor 编辑器常用快捷键 - walterlv" }, { "title": "Unity3D 入门：为 Unity 的 C# 项目添加 dll 引用或安装 NuGet 包", "url": "/post/unity-starter-reference-dlls-and-add-nuget-package-for-unity-csharp-projects.html", "categories": "", "tags": "unity, csharp", "date": "2020-05-23 14:38:45 +0800", "snippet": "因为 Visual Studio 有强大的包管理器插件，所以即便是不熟悉 NuGet 命令的小伙伴也能轻松安装和管理 NuGet 包。不过，对 Unity C# 项目来说，你并不能直接引用 dll，也不能直接使用自带的 NuGet 包管理器完成 NuGet 包安装。本文介绍原因和真正的引用方法。背景对于传统 .NET/C# 的开发者来说，在解决方案中管理 NuGet 包，在 C# 项目中引用 dll 或 NuGet 包是家常便饭。但在 Unity 项目里面，你可能要改变这一观念——因为 Unity 项目里面实际上并不存在 sln 和 csproj 文件。简单了解项目根目录的 sln 文件和 csproj 文件将有助于你理解为什么要像本文一样引用 dll 和安装 NuGet 包，因此如果你不了解，建议先阅读： Unity3D 入门：使用 Visual Studio 开发 Unity C# 脚本，说说根目录的那些 sln 和 csproj 文件 - walterlv如何引用 dll 或者安装 NuGet 包在 Unity 中，是给 C# 脚本引用 dll 或者安装 NuGet 包，而不能给 C# 项目做 dll 引用。Unity 中引用 dll 有两种官方途径： Assets\\csc.rsp 文件，用于指定引用 .NET 运行时的 dll Assets\\Plugins 文件夹，用于指定引用单独的 dll 文件当然，这两个能否正常使用，以及扔到 Plugins 文件夹中的 dll 应该是什么平台，取决于 Unity 项目的配置。当然，引用 NuGet 包的话更推荐非官方的方法，详见： 如何管理 Unity 项目中的 NuGet 包？使用第三方 NuGet 包管理器——NuGetForUnity配置运行时和 API 兼容性级别在 Unity 编辑器中，打开“Edit”-&amp;gt;“Project Settings…”-&amp;gt;“Player”-&amp;gt;“Other Settings”-&amp;gt;“Configuration”。这里我们关心脚本后端（相当于运行时部分），以及 API 兼容性级别。脚本后端设置的是脚本如何运行，而 API 兼容性级别设置的是编译时应该使用哪一套 API。选 Mono 那么使用 Mono 虚拟机运行，选 IL2CPP 那么会编译 IL 到静态的 cpp 文件不依靠 Mono VM。如果选 .NET 4.x 那么你能引用到 .NET Framework 4.x 子集的 API，如果是 .NET Standard 那么能引用到 .NET Standard 程序集。你可以通过 Unity将来时：IL2CPP是什么？ - 知乎 简单了解 IL2CPP 是什么。mcs.rsp如果你的 API 兼容性级别是 .NET Standard 2.0，那么你不应该使用此 mcs.rsp 文件。因为当你选择 .NET Standard 2.0 的 API 级别后，.NET Standard 2.0 中的所有依赖就全部引入了，如果还缺，那也不会在 .NET Standard 2.0 里面，你应该考虑后面“Plugins”的引用方式。接下来，我们说说当你使用 .NET 4.x 的 API 级别时，应该如何使用 mcs.rsp 来引用 dll。例如对于下图（图来自微软官方文档），希望使用 .NET 4.x 自带的 HttpClient 类型。向 Unity 项目的 Assets 文件夹新建一个 mcs.rsp 文件，里面添加以下内容：-r:System.Net.Http.dll这表示此 Unity 项目中的 C# 脚本引用 .NET Framework 中的 System.Net.Http 程序集。之后，你就能使用诸如 HttpClient 这些类型。你也可以使用同样的方式引用其他的 dll，每行一个。默认情况下，Unity 会帮我们引用这些 .NET 4.x 的程序集： mscorlib.dll System.dll System.Core.dll System.Runtime.Serialization.dll System.Xml.dll System.Xml.Linq.dll因此，你不需要手工将它们加入到 mcs.rsp 文件中。Plugins对于 .NET 4.x 或者 .NET Standard 2.0 中不带的类型，那么你应该使用 Plugins 文件夹来解决。在 Assets 文件夹中新建 Plugins 文件夹，然后将你希望引用的 dll 丢进去就完成了。引用 dll因此，如果你已经拥有了 dll 了，那么直接往 Plugins 文件夹扔就好了。但是你需要注意，扔进去的 dll 需要兼容目标运行时（如 Mono 虚拟机）以及目标平台（例如 iOS）。安装 NuGet 包原生 Unity 项目不能直接安装 NuGet 包，但可以通过第三方插件实现。原生原生 Unity 项目并不能直接安装 NuGet 包，所以实际上对于 NuGet 包的引用是通过把包里的 dll 丢到 Plugins 文件夹来实现的。既然如此，那就看如何丢进去更有效率了。微软官方文档的方法是直接从 nuget.org 上直接把包下载下来，解压，然后将对应平台的 dll 从 lib 文件夹中取出来（例如 API 兼容性级别是 .NET Standard 2.0 的项目，请拷贝 lib/netstandard2.0 中的 dll 出来）。因为 Unity 编辑器生成了 sln 和 csproj，所以在 Visual Studio 里安装也是可以的，不过这里的安装并不会真实生效，而是我们在 Unity 项目的根目录的 Packages 文件夹中能找到我们安装的 NuGet 包，也是从对应的文件夹中取出来 dll 丢到 Plugins 文件夹中。第三方更推荐非官方的方法，详见： 如何管理 Unity 项目中的 NuGet 包？使用第三方 NuGet 包管理器——NuGetForUnity特别注意：反射需要额外支持如果你前面的脚本后端（Script Backend）选择了 IL2CPP，那么小心 dll 的元数据会丢失，依赖于反射的功能也将崩溃。例如大量依赖于反射的 Newtonsoft.Json 库就会在此情况下无法正常工作。如果你需要用到反射，或者你用到的某库中需要依赖反射功能，那么请在 Assets 文件夹中添加 link.xml 文件，内容如下：&amp;lt;linker&amp;gt; &amp;lt;assembly fullname=&quot;System.Core&quot;&amp;gt; &amp;lt;type fullname=&quot;System.Linq.Expressions.Interpreter.LightLambda&quot; preserve=&quot;all&quot; /&amp;gt; &amp;lt;/assembly&amp;gt;&amp;lt;/linker&amp;gt;这将确保 Unity 的字节码剥离过程在导出到 IL2CPP 平台时不会删除必要的数据。参考资料 Unity - Manual: Referencing additional class library assemblies" }, { "title": "Win32/C# 应用使用 PrintWindow 对窗口截图（PrintWindow）", "url": "/post/win32-capture-window-using-print-window.html", "categories": "", "tags": "windows, dotnet, csharp", "date": "2020-05-23 14:32:26 +0800", "snippet": "相比于 Windows 2000 引入到 GDI+ 中的 BitBlt 方法截取窗口图片，Windows XP 时也引入了 PrintWindow 方法来专门截取窗口，截取的原理也不同。微软 Office 系列里的截取窗口，用的就是 PrintWindow 方法。开始截图相比于使用 BitBlt 方法，使用 PrintWindow 截取窗口的代码少得多。你需要引用如下命名空间：using System.Drawing;using System.Drawing.Imaging;using System.Drawing.Graphics;public static byte[] CaptureWindow(HWND hWnd, int width, int height){ using (var bmp = new Bitmap(width, height)) { using (Graphics memoryGraphics = Graphics.FromImage(bmp)) { IntPtr dc = memoryGraphics.GetHdc(); PrintWindow(hWnd, dc, 0); memoryGraphics.ReleaseHdc(dc); using (MemoryStream ms = new MemoryStream()) { bmp.Save(ms, ImageFormat.Png); ms.Seek(0, SeekOrigin.Begin); return ms.ToArray(); } } }}[DllImport(&quot;User32.dll&quot;, SetLastError = true)]static extern bool PrintWindow(IntPtr hwnd, IntPtr hdc, uint nFlags);原理、效果和问题使用 PrintWindow 来截图时，目标窗口会收到一次 WM_PRINT 或 WM_PRINTCLIENT 消息以完成一次绘图。并且，此过程是同步进行的，如果目标窗口在处理消息时没有返回，那么这里的调用将一直挂起。使用此方法截图时，DWM 绘制的窗口部分在真实窗口中和实际截出来的会不一样，是关掉了 Aero 效果时的窗口样式。当然，还有可能把目标窗口截挂：更多截窗口方法 Win32/C# 应用使用 GDI+ 对窗口截图（BitBlt） - walterlv Win32/C# 应用不依赖任何库使用纯 GDI+ 对窗口截图（BitBlt） - walterlv （本文）Win32/C# 应用使用 PrintWindow 对窗口截图（PrintWindow） - walterlv参考资料 PrintWindow function (winuser.h) - Win32 apps - Microsoft Docs office的截屏是用的什么技术？ - 知乎" }, { "title": "Win32/C# 应用不依赖任何库使用纯 GDI+ 对窗口截图（BitBlt）", "url": "/post/pure-win32-capture-window-to-bitmap.html", "categories": "", "tags": "windows, dotnet, csharp", "date": "2020-05-23 13:52:28 +0800", "snippet": "在 Windows 上有 GDI+ 来操作位图，不止能完成很多的位图操作，还提供了与 Win32 窗口的互操作，可以截到 Win32 窗口的图片。如果你希望对窗口截图，那么可使用本文提供的方法。没有依赖本文对窗口的截图几乎不需要任何额外的依赖（当然，都 GDI 了，Windows 系统还是要的）。不过，你可以考虑使用 Lsj.Util.Win32 来简化代码，所以如果不介意的话也推荐安装，避免手工写一大堆的 P/Invoke。如果打算自己写 P/Invoke 又不熟的话，你可以参考 使用 PInvoke.net Visual Studio Extension 辅助编写 Win32 函数签名 - walterlv。如果你的项目可以使用 System.Drawing.Bitmap 类的话，那更推荐直接使用 Bitmap，那样更简单。请参考 Win32/C# 应用不依赖任何库使用纯 GDI+ 对窗口截图（BitBlt） - walterlv。开始截图如果你使用了 Lsj.Util.Win32 库，那么需要引用一些命名空间：using Lsj.Util.Win32;using Lsj.Util.Win32.BaseTypes;using Lsj.Util.Win32.Enums;using Lsj.Util.Win32.Structs;这个命名空间中已经带了很多我们需要用到的 Win32 互操作需要用到的数据结构，所以本文代码中只会列出库中暂时没有的（不然代码太多了）。代码如下：public static byte[] CaptureWindow(HWND hWnd, int width, int height){ // 创建兼容内存 DC。 var wdc = User32.GetWindowDC(hWnd); var cdc = Gdi32.CreateCompatibleDC(wdc); // 创建兼容位图 DC。 var hBitmap = Gdi32.CreateCompatibleBitmap(wdc, width, height); // 关联兼容位图和兼容内存，不这么做，下面的像素位块（bit_block）转换不会生效到 hBitmap。 var oldHBitmap = Gdi32.SelectObject(cdc, (IntPtr)hBitmap); // 注：使用 GDI+ 截取“使用硬件加速过的”应用时，截取到的部分是全黑的。 var result = Gdi32.BitBlt(cdc, 0, 0, width, height, wdc, 0, 0, RasterCodes.SRCCOPY); try { // 保存图片。 if (result) { var data = GetImageFromHBitmap(wdc, hBitmap, width, height); return data; } else { var error = Kernel32.GetLastError(); throw new Win32Exception((int)error); } } finally { // 回收资源。 Gdi32.SelectObject(cdc, oldHBitmap); Gdi32.DeleteObject((IntPtr)hBitmap); Gdi32.DeleteDC(cdc); User32.ReleaseDC(hWnd, wdc); }}其中，GetImageFromHBitmap 方法的实现就比较麻烦了——我们需要手工写图片文件的文件头！分成三个部分写入： BMP 位图文件头 BMP 信息 位图数据实现如下：private static unsafe byte[] GetImageFromHBitmap(HDC hdc, HBITMAP hBitmap, int width, int height){ var data = new byte[sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER) + width * height * 3]; var bitmapInfoHeader = new BITMAPINFOHEADER { biSize = (uint)sizeof(BITMAPINFOHEADER), biWidth = width, biHeight = height, biPlanes = 1, biBitCount = 24, biCompression = Compression.BI_PNG, biSizeImage = 0, biXPelsPerMeter = 0, biYPelsPerMeter = 0, biClrUsed = 0, biClrImportant = 0, }; fixed (void* lpvBits = data) { var lpvBitsOnData = new IntPtr((long)lpvBits + sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER)); var got = Gdi32.GetDIBits(hdc, hBitmap, 0, height, lpvBitsOnData, new BITMAPINFO { bmiColors = new RGBQUAD[1], bmiHeader = bitmapInfoHeader }, (uint)DIBColorTableIdentifiers.DIB_RGB_COLORS); } var fileHeader = new BITMAPFILEHEADER { bfOffBits = (uint)sizeof(BITMAPFILEHEADER) + (uint)sizeof(BITMAPINFOHEADER), bfSize = (uint)data.Length, bfType = 0x4D42, // BM }; GetBytes(fileHeader).CopyTo(data, 0); GetBytes(bitmapInfoHeader).CopyTo(data, sizeof(BITMAPFILEHEADER)); return data;}private static byte[] GetBytes&amp;lt;T&amp;gt;(T @struct) where T : struct{ int size = Marshal.SizeOf(@struct); byte[] data = new byte[size]; IntPtr ptr = Marshal.AllocHGlobal(size); Marshal.StructureToPtr(@struct, ptr, true); Marshal.Copy(ptr, data, 0, size); Marshal.FreeHGlobal(ptr); return data;}[StructLayout(LayoutKind.Sequential, Pack = 2)]private struct BITMAPFILEHEADER{ public ushort bfType; public uint bfSize; public ushort bfReserved1; public ushort bfReserved2; public uint bfOffBits;}这里代代码不涉及到格式转换，因此你只能生成 BMP 格式。更多截窗口方法 Win32/C# 应用使用 GDI+ 对窗口截图（BitBlt） - walterlv （本文）Win32/C# 应用不依赖任何库使用纯 GDI+ 对窗口截图（BitBlt） - walterlv Win32/C# 应用使用 PrintWindow 对窗口截图（PrintWindow） - walterlv参考资料 Capturing an Image - Win32 apps - Microsoft Docs" }, { "title": "Win32/C# 应用使用 GDI+ 对窗口截图（BitBlt）", "url": "/post/win32-and-system-drawing-capture-window-to-bitmap.html", "categories": "", "tags": "windows, dotnet, csharp", "date": "2020-05-23 13:52:14 +0800", "snippet": "在 Windows 上有 GDI+ 来操作位图，不止能完成很多的位图操作，还提供了与 Win32 窗口的互操作，可以截到 Win32 窗口的图片。如果你希望对窗口截图，那么可使用本文提供的方法。依赖，或者没有依赖在本文的代码中，你可以考虑引用以下这些库来简化代码。对于 .NET Core： System.Drawing.Common Lsj.Util.Win32对于 .NET Framework / Mono： System.Drawing.dll Lsj.Util.Win32以上所有库都是可选的。如果你打算不引用 Lsj.Util.Win32，那么下面代码中涉及到的 Win32 API 调用你需要自己写 P/Invoke。如果你不熟悉 P/Invoke 的写法，你可以参考 使用 PInvoke.net Visual Studio Extension 辅助编写 Win32 函数签名 - walterlv。如果你不打算引用 System.Drawing.Common，那么可以考虑使用裸的 GDI+ 来完成，可以参考 Win32/C# 应用不依赖任何库使用纯 GDI+ 对窗口截图（BitBlt） - walterlv。开始截图如果你使用了 Lsj.Util.Win32 库，那么需要引用一些命名空间：using Lsj.Util.Win32;using Lsj.Util.Win32.BaseTypes;using Lsj.Util.Win32.Enums;using Lsj.Util.Win32.Structs;代码如下：public static byte[] CaptureWindow(HWND hWnd, int width, int height){ // 创建兼容内存 DC。 var wdc = User32.GetWindowDC(hWnd); var cdc = Gdi32.CreateCompatibleDC(wdc); // 创建兼容位图 DC。 var hBitmap = Gdi32.CreateCompatibleBitmap(wdc, width, height); // 关联兼容位图和兼容内存，不这么做，下面的像素位块（bit_block）转换不会生效到 hBitmap。 var oldHBitmap = Gdi32.SelectObject(cdc, (IntPtr)hBitmap); // 注：使用 GDI+ 截取“使用硬件加速过的”应用时，截取到的部分是全黑的。 var result = Gdi32.BitBlt(cdc, 0, 0, width, height, wdc, 0, 0, RasterCodes.SRCCOPY); try { // 保存图片。 if (result) { using (var bmp = Image.FromHbitmap(hBitmap)) { using (var ms = new MemoryStream()) { bmp.Save(ms, ImageFormat.Png); ms.Seek(0, SeekOrigin.Begin); var data = ms.ToArray(); return data; } } } else { var error = Kernel32.GetLastError(); throw new Win32Exception((int)error); } } finally { // 回收资源。 Gdi32.SelectObject(cdc, oldHBitmap); Gdi32.DeleteObject((IntPtr)hBitmap); Gdi32.DeleteDC(cdc); User32.ReleaseDC(hWnd, wdc); }}示例代码只是单纯返回 PNG 格式的位图数据。你还可以按你的需要改造成其他数据。更多截窗口方法 （本文）Win32/C# 应用使用 GDI+ 对窗口截图（BitBlt） - walterlv Win32/C# 应用不依赖任何库使用纯 GDI+ 对窗口截图（BitBlt） - walterlv Win32/C# 应用使用 PrintWindow 对窗口截图（PrintWindow） - walterlv参考资料 Capturing an Image - Win32 apps - Microsoft Docs" }, { "title": "提高使用 Visual Studio 开发效率的键盘快捷键", "url": "/post/keyboard-shortcuts-to-improve-the-efficiency-of-visual-studio.html", "categories": "", "tags": "visualstudio, csharp", "date": "2020-05-23 11:25:59 +0800", "snippet": "Visual Studio 的功能可谓真是丰富，再配合各种各样神奇强大的插件，Visual Studio 作为太阳系最强大的 IDE 名副其实。如果你能充分利用起 Visual Studio 启用这些功能的快捷键，那么效率也会很高。建议记住 功能 快捷键 建议修改成 重构 Ctrl + . Alt + Enter 转到所有 Ctrl + , Ctrl + N 重命名 F2   打开智能感知列表 Ctrl + J Alt + 右 注释 Ctrl + K, Ctrl + C   取消注释 Ctrl + K, Ctrl + U   保存全部文档 Ctrl + K, S   折叠成大纲 Ctrl + M, Ctrl + O   展开所有大纲 Ctrl + M, Ctrl + P   加入书签 Ctrl + K, Ctrl + K   上一书签 Ctrl + K, Ctrl + P   下一书签 Ctrl + K, Ctrl + N   切换自动换行 Alt + Z   万能重构你可以不记住本文的其他任何快捷键，但这个你一定要记住，那就是：当然，因为中文输入法会占用这个快捷键，所以我更喜欢将这个快捷键修改一下，改成：修改方法可以参见：如何快速自定义 Visual Studio 中部分功能的快捷键。它的功能是“快速操作和重构”。你几乎可以在任何代码上使用这个快捷键来快速修改你的代码。比如修改命名空间：比如提取常量或变量：比如添加参数判空代码：还有更多功能都可以使用此快捷键。而且因为 Roslyn 优秀的 API，有更多扩展可以使用此快捷键生效，详见：基于 Roslyn 同时为 Visual Studio 插件和 NuGet 包开发 .NET/C# 源代码分析器 Analyzer 和修改器 CodeFixProvider。转到所有不能每次都去解决方案里面一个个找文件，对吧！所以一个快速搜索文件和符号的快捷键也是非常能够提升效率的。Ctrl + , 转到所有（go to all）不过我建议将其改成：Ctrl + N 这是 ReSharper 默认的转到所有（Goto Everything）的快捷键这可以帮助你快速找到整个解决方案中的所有文件或符号，看下图：修改方法可以参见：如何快速自定义 Visual Studio 中部分功能的快捷键，下图是此功能的命令名称 编辑.转到所有（Edit.GoToAll）：有一些小技巧： 你可以无需拼写完整个单词就找到你想要的符号 例如输入 mw 就可以找到 MainWindow 对于两个以上单词拼成的符号，建议将每个单词的首字母输入成大写，这样可以提高目标优先级，更容易找到 例如 PrivateTokenManager，如果希望干扰少一些，建议输入 PTM 而不是 ptm；当然想要更少的干扰，可以打更多的字母，例如 priToM 等等 注意到上面的界面里面右上角有一些过滤器吗？这些过滤器有单独的快捷键。这样就直接搜索特定类型的符号，而不是所有了，可以提高查找效率。Ctrl + O 查找当前文件中的所有成员（只搜一个文件，这可以大大提高命中率）Ctrl + T 转到符号（只搜类型名称、成员名称）Ctrl + G 查找当前文件的行号（比如你在代码审查中看到一行有问题的代码，得知行号，可以迅速跳转到这一行）重构重命名F2如果你在一个标识符上直接重新输入改了名字，也可以通过 Ctrl + . 或者 Alt + Enter 完成重命名。其他这些都可以被最上面的 Ctrl + . 或者 Alt + Enter 替代，因此都可以忘记。Ctrl + R, Ctrl + E 封装字段Ctrl + R, Ctrl + I 提取接口Ctrl + R, Ctrl + V 删除参数Ctrl + R, Ctrl + O 重新排列参数IntelliSense 自动完成列表智能感知IntelliSense 以前有个漂亮的中文名字，叫做“智能感知”，不过现在大多数的翻译已经与以前的另一个平淡无奇的功能结合到了一起，叫做“自动完成列表”。Visual Studio 默认只会让智能感知列表发挥非常少量的功能，如果你不进行一些配置，使用起来会“要什么没什么”，想显示却不显示。请通过另一篇博客中的内容把 Visual Studio 的智能感知列表功能好好配置一下，然后我们才可以再次感受到它的强大（记得要翻到最后哦）： 通过设置启用 Visual Studio 默认关闭的大量强大的功能提升开发效率如果还有一些时机没有打开智能感知列表，可以配置一个快捷键打开它，我这边配置的快捷键是 Alt + 右。参数信息Ctrl + Shift + 空格显示方法的参数信息。默认在输入参数的时候就已经会显示了；如果错过了，可以在输入 , 的时候继续出现；如果还错过了，可以使用此快捷键出现。编写代码格式化Ctrl + K, Ctrl + E 全文代码清理（包含全文代码格式化以及其他功能）Shift + Alt + F 全文代码格式化Ctrl + K, Ctrl + F 格式化选定的代码关于代码清理，你可以配置做哪些事情：其他Ctrl + K, Ctrl + / 将当前行注释或取消注释Ctrl + K, Ctrl + C 将选中的代码注释掉Ctrl + K, Ctrl + U 或 Ctrl + Shift + / 将选定的内容取消注释Ctrl + U 将当前选中的所有文字转换为小写（请记得配合 F2 重命名功能使用避免编译不通过）Ctrl + ] 增加行缩进Ctrl + [ 减少行缩进Ctrl + S 保存文档Ctrl + K, S 保存全部文档（注意按键，是按下 Ctrl + K 之后所有按键松开，然后单按一个 S）导航Ctrl + F 打开搜索面板开始强大的搜索功能Ctrl + H 打开替换面板，或展开搜索面板为替换面板Ctrl + I 渐进式搜索（就像 Ctrl + F 一样，不过不会抢焦点，搜索完按回车键即完成搜索，适合键盘党操作）Ctrl + Shift + F 打开搜索窗口（与 Ctrl + F 虽然功能重合，但两者互不影响，意味着你可以充分这两套搜索来执行两套不同的搜索配置）Ctrl + Shift + H 打开替换窗口（与 Ctrl + H 虽然功能重合，但两者互不影响，意味着你可以充分这两套替换来执行两套不同的替换配置）Alt + 下 在当前文件中，将光标定位到下一个方法Alt + 上 在当前文件中，将光标定位到上一个方法Ctrl + M, Ctrl + M 将光标当前所在的类/方法切换大纲的展开或折叠Ctrl + M, Ctrl + L 将全文切换大纲的展开或折叠（如果当前有任何大纲折叠了则全部展开，否则全部折叠）Ctrl + M, Ctrl + P 将全文的大纲全部展开Ctrl + M, Ctrl + U 将光标当前所在的类/方法大纲展开Ctrl + M, Ctrl + O 将全文的大纲都折叠到定义那一层Ctrl + D 查找下一个相同的标识符，然后放一个新的脱字号（或者称作输入光标）（多次点按可以在相同字符串上出很多光标，可以一起编辑，如下图）Ctrl + Insert 查找所有相同的标识符，然后全部放置脱字号（如下图）脱字号 是 Visual Studio 中对于输入光标的称呼，对应英文的 Caret。书签Ctrl + K, Ctrl + K 为当前行加入到书签或从书签中删除Ctrl + K, Ctrl + P 切换到上一个书签Ctrl + K, Ctrl + N 切换到下一个书签Ctrl + K, Ctrl + L 删除所有书签（会有对话框提示的，不怕误按）如果配合书签面板，那么可以在调查问题的时候很方便在找到的各种关键代码处跳转，避免每次都寻找。另外，还有个任务列表，跟书签列表差不多的功能：Ctrl + K, Ctrl + H 将当前代码加入到任务列表中或者从列表中删除（效果类似编写 // TODO）显示Ctrl + R, Ctrl + W 显示空白字符Alt + Z 切换自动换行和单行模式鼠标最后提及一个，Ctrl + 鼠标点击 可以跳转到定义。不过这个功能有个 bug：我报给了微软： When text is selected, Ctrl+Click will not perform the GoTo Definition. - Developer Community" }, { "title": "Unity3D 入门：如何制作天空效果？天空盒的使用", "url": "/post/unity-starter-unity3d-skybox.html", "categories": "", "tags": "unity", "date": "2020-05-22 18:48:06 +0800", "snippet": "在 Unity 编辑器的主界面中我们可以很容易制作各种场景物体，但天空如何制作呢？了解和设置默认的天空盒在新建一个 Unity3D 项目之后，我们在空空如也的场景下看到的那蓝灰过渡的画面，其实就是 Unity3D 默认提供的“天空”，这个机制叫“天空盒”（Skybox）。你可以在 Window-&amp;gt;Rendering-&amp;gt;Lighting Settings（窗口-&amp;gt;渲染-&amp;gt;照明设置）中打开当前场景的照明设置，里面可以设置天空效果。如下图就是默认天空盒提供的各种参数：Unity 新建项目时默认的天空盒是程序天空盒（Procedural Skybox）。一般来说程序天空盒提供了众多可以设置的参数，用来后期调节天空的样式。默认的天空盒其实一个参数都不能直接设置，但可以通过其他游戏物体来间接设置。例如，你试试把一开始的那个定向光（Directional Light）调一下方向，你会发现默认天空中的太阳位置也变化了，跟着定向光的方向变化。如果你删过这个定向光，也可以通过新建一个到场景中，然后在上图的界面里面点击选择按钮把刚刚新建的定向光选中来再次创建太阳。在资源商店中下载天空盒作为入门的话，可以考虑在资源商店中搜索并使用大神们做好的现成的天空盒（关键词 Skybox）：找到喜欢的天空盒后，点击 Download-&amp;gt;Import 可以导入到当前的项目中。这里提一点，商店中的大部分资源，导入到项目中后都在 Assets 目录下。等待下载并导入完后，你可以看到最终导入的窗口：在这个最终的窗口中，点击右下角的“导入”即可最终添加到项目中。在这里，你可以注意到导入的资源中包含 back front top bottom left right 这些图片。这其实是另一种天空盒——六面天空盒（6 Sided Skybox）。（请原谅上图作者中那奇怪的缩写，因为这名字不重要。）我把刚刚下载的这款天空盒的六个面分别贴出来，就会像下图这样：我简单做了个动图，用来直观观看天空盒的贴图：依然在 Window-&amp;gt;Rendering-&amp;gt;Lighting Settings（窗口-&amp;gt;渲染-&amp;gt;照明设置）中打开当前场景的照明设置，然后点击选择“天空盒材质”，选择刚刚我们下载的“sky,startday”。于是，我们的场景就应用了商店下载下来的天空盒了。像这种六面天空盒，虽然依然可以设置太阳源，不过已经不再关联到天空中的太阳的位置了。总结本文没有介绍如何制作一个自己的天空盒，因为我也正在学习中。不过我们了解到： 如何下载并应用一个现成的天空盒 天空盒的种类（六面天空盒、程序天空盒）" }, { "title": "专业团队：推荐一个网站，生成巨幅文字注释", "url": "/post/patorjk-software-taag.html", "categories": "", "tags": "miscellaneous", "date": "2020-05-19 19:47:30 +0800", "snippet": "通过学习本文的知识，你将可以在你的项目代码里创造大量的注释。让你的注释闪瞎团队所有人的钛合金X眼，我们是专业团队。Console.WriteLine(@&quot;██╗ ██╗ █████╗ ██╗ ████████╗███████╗██████╗ ██╗ ██╗ ██╗██║ ██║██╔══██╗██║ ╚══██╔══╝██╔════╝██╔══██╗██║ ██║ ██║██║ █╗ ██║███████║██║ ██║ █████╗ ██████╔╝██║ ██║ ██║██║███╗██║██╔══██║██║ ██║ ██╔══╝ ██╔══██╗██║ ╚██╗ ██╔╝╚███╔███╔╝██║ ██║███████╗██║ ███████╗██║ ██║███████╗╚████╔╝ ╚══╝╚══╝ ╚═╝ ╚═╝╚══════╝╚═╝ ╚══════╝╚═╝ ╚═╝╚══════╝ ╚═══╝ &quot;);网址是：http://patorjk.com/software/taag/你可以在里面选参数，也可以在 URL 上自己补参数以便唯一确定一个样式。比如上图样式的网址是：http://patorjk.com/software/taag/#p=display&amp;amp;f=ANSI%20Shadow&amp;amp;t=walterlv还比如：Console.WriteLine(@&quot; ___ __ ________ ___ _________ _______ ________ ___ ___ ___ |\\ \\ |\\ \\|\\ __ \\|\\ \\ |\\___ ___\\\\ ___ \\ |\\ __ \\|\\ \\ |\\ \\ / /|\\ \\ \\ \\ \\ \\ \\ \\|\\ \\ \\ \\\\|___ \\ \\_\\ \\ __/|\\ \\ \\|\\ \\ \\ \\ \\ \\ \\ / / / \\ \\ \\ __\\ \\ \\ \\ __ \\ \\ \\ \\ \\ \\ \\ \\ \\_|/_\\ \\ _ _\\ \\ \\ \\ \\ \\/ / / \\ \\ \\|\\__\\_\\ \\ \\ \\ \\ \\ \\ \\____\\ \\ \\ \\ \\ \\_|\\ \\ \\ \\\\ \\\\ \\ \\____\\ \\ / / \\ \\____________\\ \\__\\ \\__\\ \\_______\\ \\__\\ \\ \\_______\\ \\__\\\\ _\\\\ \\_______\\ \\__/ / \\|____________|\\|__|\\|__|\\|_______|\\|__| \\|_______|\\|__|\\|__|\\|_______|\\|__|/ &quot;);尽情写到团队项目里面吧！我们是专业团队！" }, { "title": ".NET Framework 和 .NET Core 在默认情况下垃圾回收（GC）机制的不同（局部变量部分）", "url": "/post/dotnet-gc-behavior-of-local-variable.html", "categories": "", "tags": "dotnet", "date": "2020-05-15 21:50:57 +0800", "snippet": "垃圾回收机制有一些未定义部分，一般来说不要依赖于这些未定义部分编程，否则容易出现一些诡异的 bug 或者不稳定的现象。本文介绍局部变量这部分的细节，而这点在 .NET Framework 和 .NET Core 默认情况下的表现有差别。问题代码看看下面这段代码，你觉得会输出 Foo is collected 吗？class Program{ static void Main(string[] args) { new WeakReference&amp;lt;Foo&amp;gt;(new Foo()); GCTest(); } private static void GCTest() { while (true) { Thread.Sleep(500); GC.Collect(); } }}public class Foo{ ~Foo() { Console.WriteLine(&quot;Foo is collected&quot;); }}如果你没有修改默认的编译设置，那么答案应该是： 全部 .NET Framework 下都输出 Foo is collected .NET Core 2.x 及以下输出 Foo is collected .NET Core 3.x 及以上不会有任何输出额外的，.NET Core 2.1 - .NET Core 3.x 通过设置可以改变此行为，本文文末会说。然而所有这些平台编译后的 IL 都差不多。虽然引用的程序集不一样，但代码都是一样的。所以问题不在编译器，而在运行时。.method private hidebysig static void Main ( string[] args ) cil managed { // Header Size: 1 byte // Code Size: 17 (0x11) bytes .maxstack 8 .entrypoint /* (12,13)-(12,45) Program.cs */ /* 0x00000251 7305000006 */ IL_0000: newobj instance void Walterlv.Demo.Weak.Foo::.ctor() /* 0x00000256 730C00000A */ IL_0005: newobj instance void class [System.Runtime]System.WeakReference`1&amp;lt;class Walterlv.Demo.Weak.Foo&amp;gt;::.ctor(!0) /* 0x0000025B 26 */ IL_000A: pop /* (14,13)-(14,22) Program.cs */ /* 0x0000025C 2802000006 */ IL_000B: call void Walterlv.Demo.Weak.Program::GCTest() /* (15,9)-(15,10) Program.cs */ /* 0x00000261 2A */ IL_0010: ret} // end of method Program::Main这个问题我提在了 GitHub 上，大家可以去看看： GC.Collect: Object without reference will be collected in .NET Framework but will NOT been collected in .NET Core · Issue #36265 · dotnet/runtime原因当然，当变量脱离作用域后 GC 本应回收，但在同一个函数中定义的变量是否脱离作用域却是未定义的。你可以经常在 DEBUG 下发现依然可访问的变量，但在 RELEASE 下无法访问变量就体现了这种未定义带来的行为差异。.NET Core 3.0 开始引入了分层编译（Tiered Compilation）。在开启了分层编译的情况下，JIT 执行方法时先会快速编译，随后如果此方法访问频繁会在后台优化这个编译然后替换掉之前编译的方法，以提升后续的运行性能。在分层编译被启用的情况下，GC 的行为有改变，局部变量不再及时回收。当然以后有更优化的分层编译后，可能有新的行为改变。如果要关闭分层编译，可以在项目文件中设置 TieredCompilation 为 false，也可以设置环境变量 COMPlus_TieredCompilation=0。这两个是等价的。 &amp;lt;PropertyGroup&amp;gt; &amp;lt;OutputType&amp;gt;Exe&amp;lt;/OutputType&amp;gt; &amp;lt;TargetFrameworks&amp;gt;net48;netcoreapp3.1&amp;lt;/TargetFrameworks&amp;gt;+ &amp;lt;TieredCompilation&amp;gt;false&amp;lt;/TieredCompilation&amp;gt; &amp;lt;/PropertyGroup&amp;gt;关于分层编译，可以阅读林德熙的博客： dotnet core 2.1 使用分层编译本文一开始说的行为改变，指的就是开关分层编译。.NET Core 2.1 开始支持分层编译但默认关闭，而 .NET Core 3.0 开始默认开启。所以在支持的框架上你可以开启或关闭。参考资料 Compilation config settings - .NET Core - Microsoft Docs" }, { "title": ".NET/Windows：删除文件夹后立即判断，有可能依然存在", "url": "/post/file-or-directory-delete-is-not-completed-after-calling-delete.html", "categories": "", "tags": "windows, dotnet, csharp", "date": "2020-05-15 20:10:18 +0800", "snippet": "如果你不了解本文的内容，可能会在未来某个时候踩坑–你可能在判断文件夹是否存在的时候得到错误的返回值。删除文件（夹）使用 .NET 带的删除文件夹的方法：Directory.Delete(&quot;D:\\walterlv&quot;);或者使用其他删除文件（夹）的方法，大多数是以下 Windows API 的封装：BOOL DeleteFile( LPCTSTR lpFileName);BOOL RemoveDirectoryA( LPCSTR lpPathName);BOOL RemoveDirectoryW( LPCWSTR lpPathName);于是，大多数删除文件（夹）的代码都会遇到问题：文件或文件夹可能没有立即删除！测试程序using System;using System.IO;class Program{ static void Main(string[] args) { var dirPath = @&quot;C:\\Users\\lvyi\\Desktop\\Test&quot;; while (true) { Console.WriteLine(Directory.Exists(dirPath)); Directory.CreateDirectory(dirPath); Directory.Delete(dirPath); } }}你猜会输出什么？每一行都输出 False 吗？然而实际上是：嗯……会混入少量的 True 在里面。这是不是有点“不符合预期”？原因删除文件夹的本质方法 RemoveDirectory 在微软的官网中就已经解释了： The RemoveDirectory function marks a directory for deletion on close. Therefore, the directory is not removed until the last handle to the directory is closed. RemoveDirectory 函数将标记一个文件夹在关闭后删除。这意味着在最后一个此文件夹的句柄关闭之前，此文件夹将一直不会删除。所以调用完删除文件夹的方法后，仅仅只是标记这个文件夹要删除而已。那么随后立即获取此文件夹是否存在，将取决于前面调用删除后是否真的删除了文件夹。删除文件的本质方法 DeleteFile 也有类似的解释： The DeleteFile function marks a file for deletion on close. Therefore, the file deletion does not occur until the last handle to the file is closed. Subsequent calls to CreateFile to open the file fail with ERROR_ACCESS_DENIED. DeleteFile 函数将标记一个文件在关闭后删除。这意味着在最后一个文件句柄关闭之前，此文件将一直不会删除。如果随后立即调用 CreateFile 来打开一个文件的话可能会遭遇错误 ERROR_ACCESS_DENIED。解决方法因此，不要再依赖于判断文件夹是否存在来决定某个业务。例如，可以考虑创建文件夹之前不判断文件夹是否存在：-- if (Directory.Exists(path))-- { Directory.CreateDirectory(path);-- }注意，以上红色色块标记的代码应该删除！否则你可能会发现这段代码执行完成后，文件夹是不存在的。如果试图删除文件随后新建空白的文件或者其他文件的话，可以考虑我在另一篇博客中提到的创建或打开文件的方法，用来应对文件不存在的情况： .NET 中选择合适的文件打开模式（CreateNew, Create, Open, OpenOrCreate, Truncate, Append） - walterlv Win32 方法 CreateFile 中选择合适的文件打开模式（CREATE_NEW, CREATE_ALWAYS, OPEN_EXISTING, OPEN_ALWAYS, TRUNCATE_EXISTING） - walterlv发现 dotnet 职业技术学院另一小伙伴也遇到这个问题： 不要在Directory删除后立刻调用Directory.Exist - huangtengxiao参考资料 RemoveDirectoryA function (fileapi.h) - Win32 apps - Microsoft Docs DeleteFile function (winbase.h) - Win32 apps - Microsoft Docs" }, { "title": "在制作多框架项目的 NuGet 包时应该注意的问题（buildMultiTargeting/TargetFrameworks）", "url": "/post/build-multi-targeting-nuget-package.html", "categories": "", "tags": "nuget, dotnet, msbuild", "date": "2020-05-15 14:23:19 +0800", "snippet": "制作一个 dll 引用的 NuGet 包简直是一键完成，无论是不是多框架项目；制作 dotnet-tools 也是如此。但如果需要自定义一些编译步骤，那么就需要在制作 NuGet 包时做很多的特殊处理了。本文介绍制作适用于多框架项目的 NuGet 工具包时应该注意的问题。背景知识NuGet 包内的文件夹结构回顾一下 NuGet 包的文件夹结构：+ /+ lib/+ ref/+ runtimes/+ content/+ build/+ buildMultiTargeting/+ buildTransitive+ tools/由于涉及到自定义 NuGet 包的代码都写在 build buildMultiTargeting 和 buildTransitive 中，其他都不涉及到 NuGet 包在编译期间会做的事情，另外，buildTransitive 是用来处理包传递过程中的编译过程的，所以我们本文只说也只需要说 build 和 buildMultiTargeting。这里面的代码都是用 Target 写出来的，如果你对此不了解，建议阅读这些博客： 理解 C# 项目 csproj 文件格式的本质和编译流程 - walterlv 从零开始制作 NuGet 源代码包（全面支持 .NET Core / .NET Framework / WPF 项目） - walterlv制作有自定义功能的 NuGet 包我之前写过一些关于如何制作各种高级功能的 NuGet 包的博客： 如何创建一个基于命令行工具的跨平台的 NuGet 工具包 - walterlv 如何创建一个基于 MSBuild Task 的跨平台的 NuGet 工具包 - walterlv 从零开始制作 NuGet 源代码包（全面支持 .NET Core / .NET Framework / WPF 项目） - walterlv按照上面的博客制作出来的 NuGet 包其实是适用于单框架项目和多框架项目的，甚至也适用于传统的非 SDK 风格的项目。关于单框架和多框架项目，就是项目文件中这里的差别：&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;!-- 单框架项目 --&amp;gt; &amp;lt;TargetFramework&amp;gt;netcoreapp3.1&amp;lt;/TargetFramework&amp;gt; &amp;lt;/PropertyGroup&amp;gt;&amp;lt;/Project&amp;gt;&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;!-- 多框架项目 --&amp;gt; &amp;lt;TargetFrameworks&amp;gt;netcoreapp3.1;net48&amp;lt;/TargetFrameworks&amp;gt; &amp;lt;/PropertyGroup&amp;gt;&amp;lt;/Project&amp;gt;但是，有的小伙伴希望探索一些更高级的用法，所以可能会遇到在多框架项目中，NuGet 包自定义的功能不执行的问题。接下来，我们了解一下在单框架和多框架下 NuGet 包执行上的不同。执行时机我们打出这样的两种 NuGet 包，一种是仅包含 build 文件夹而不包含 buildMultiTargeting 文件夹；一种是包含 build 文件夹和 buildMultiTargeting 文件夹。我们的目标项目一种是单框架项目；一种是多框架项目。于是我们可以得到这样的四种不同的组合情况： 仅含 build 文件夹的 NuGet 包装到单框架项目中 仅含 build 文件夹的 NuGet 包装到多框架项目中 包含 build 和 buildMultiTargeting 文件夹的 NuGet 包装到单框架项目中 包含 build 和 buildMultiTargeting 文件夹的 NuGet 包装到多框架项目中1. 仅含 build 文件夹的 NuGet 包装到单框架项目中在这种情况下，build 文件夹中的 .props 和 .targets 文件在目标项目编译时正常执行。2. 仅含 build 文件夹的 NuGet 包装到多框架项目中在这种情况下，build 文件夹中的 .props 和 .targets 文件，会分别在目标项目编译每个框架的时候执行一次。例如这种项目：&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;!-- 多框架项目 --&amp;gt; &amp;lt;TargetFrameworks&amp;gt;netcoreapp3.1;net48&amp;lt;/TargetFrameworks&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;PackageReference Include=&quot;Walterlv.NullableAttributes.Source&quot; Version=&quot;0.15.0&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt;&amp;lt;/Project&amp;gt;那么，在编译 netcoreapp3.1 框架的时候会执行一次 Walterlv.NullableAttributes.Source 包中 build 文件夹中的编译任务；在编译 net48 框架的时候又会执行一次 Walterlv.NullableAttributes.Source 包中 build 文件夹中的编译任务。3. 包含 build 和 buildMultiTargeting 文件夹的 NuGet 包装到单框架项目中在这种情况下，buildMultiTargeting 中的任何编译任务相当于不存在。编译过程与情况 1 是完全一样的。4. 包含 build 和 buildMultiTargeting 文件夹的 NuGet 包装到多框架项目中从 NuGet 5.x 版本开始在这种情况下，build 中的内容和 buildMultiTargeting 中的编译任务会同时参与编译。依然举例这样的目标项目（不过使用了含 buildMultiTargeting 的 NuGet 包）：&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;!-- 多框架项目 --&amp;gt; &amp;lt;TargetFrameworks&amp;gt;netcoreapp3.1;net48&amp;lt;/TargetFrameworks&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;PackageReference Include=&quot;Walterlv.NullableAttributes.Source&quot; Version=&quot;2.1.1&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt;&amp;lt;/Project&amp;gt;编译一开始，会将 buildMultiTargeting 中的编译任务加入执行。在编译 netcoreapp3.1 框架的时候会执行一次 Walterlv.NullableAttributes.Source 包中 build 文件夹中的编译任务；在编译 net48 框架的时候又会执行一次 Walterlv.NullableAttributes.Source 包中 build 文件夹中的编译任务。而这两个单独框架的编译结束后，buildMultiTargeting 中的任务才会结束。也就是说，这两个编译任务文件夹中的编译任务是都会执行的。但是：两者参与编译的 Targets 不一样。下表中列出了在你没有编写任何扩展的任务或者干预已有 Target 执行的情况下，默认可以依赖的 Target（指的是可以通过 BeforeTargets=&quot;xx&quot; 或 AfterTargets=&quot;xx&quot; 的方式扩展编译任务： 可依赖的 Target build buildMultiTargeting BeforeCompile ✔ ❌ Compile ✔ ❌ CoreCompile ✔ ❌ AfterCompile ✔ ❌ BeforeBuild ✔ ❌ Build ✔ ✔ AfterBuild ✔ ❌ BeforeRebuild ❌ ❌ Rebuild ❌ ✔（如果强行执行） AfterRebuild ❌ ❌ BeforeClean ✔（如果强行执行） ❌ Clean ✔（如果强行执行） ✔（如果强行执行） AfterClean ✔（如果强行执行） ❌ 注：强制执行说的是一般编译时不会执行，你需要在命令中指定执行这个 Target。也对应到 Visual Studio 里的“重新编译”和“清理”的功能。为了更好理解上表，这里给出一个例子。下面的代码如果在 build 文件夹中则会在编译过程输出一堆星号，而如果在 buildMultiTargeting 文件夹中则不会执行。而无论目标项目是否是多框架的。但换成 AfterBuild 则会两个文件夹中都输出。&amp;lt;Target Name=&quot;WalterlvDemoTarget&quot; AfterTargets=&quot;Build&quot;&amp;gt; &amp;lt;Message Text=&quot;****************************************************************&quot; /&amp;gt;&amp;lt;/Target&amp;gt;当然，不要被这个第 4 种情况带歪了！如果你的 NuGet 包依然只有一个 build 文件夹，那么上面的所有 Targets 都是会执行的。参考资料 Create a NuGet package using nuget.exe CLI - Microsoft Docs Allow package authors to define build assets transitive behavior · NuGet/Home Wiki" }, { "title": "为 .NET 各种开发工具设置网络代理，提升在大陆的网络性能", "url": "/post/setting-up-proxies-for-development-tools.html", "categories": "", "tags": "dotnet", "date": "2020-05-13 10:09:47 +0800", "snippet": "git、nuget、scoop 如何设置网络代理提升网络访问速度呢？在下面的博客正文中，都假设我的本机搭设了代理服务，其中 SOCKS5 代理服务的端口号是 7777，HTTP 代理服务的端口号是 7778。git使用命令行设置git 支持设置 http 代理和 socks5 代理，http 的代理和 https 的代理是分开设置的。设置方法： 打开任意一个命令行工具； 在命令行中输入以下两个命令并回车。git config --global http.proxy http://127.0.0.1:7778git config --global https.proxy http://127.0.0.1:7778或者：git config --global http.proxy socks5://127.0.0.1:7777git config --global https.proxy socks5://127.0.0.1:7777在设置完成之后，你无需担心内网访问的问题，因为 Git 会自动在代理的时候过滤掉内网代理。直接修改配置文件git 全局配置文件的路径在： %USERPROFILE%\\.gitconfig在这个文件中，你需要添加以下几行： [user] name = walterlv email = walter.lv@qq.com+ [http]+ proxy = http://127.0.0.1:7778+ [https]+ proxy = http://127.0.0.1:7778或者： [user] name = walterlv email = walter.lv@qq.com+ [http]+ proxy = socks5://127.0.0.1:7777+ [https]+ proxy = socks5://127.0.0.1:7777添加完成之后，你的 git 访问就会走代理，对于 GitHub 的访问，快速克隆大型仓库是非常有帮助的。使用 TortoiseGit 设置以上命令行的方法是最简单的，然而你也可以使用其他的工具设置，比如 TortoiseGit。设置方法： 在任意的文件夹中打开 TortoiseGit 的设置页面，然后定位到网络一栏中，勾选“使用代理服务器”。 输入服务器地址和端口号，确定即可。NuGet使用 NuGet 直接拉取 的内容也是很慢的，如果有一个代理服务器的设置那么也能大大提速。在命令行中设置&amp;gt; nuget config -set http_proxy=http://127.0.0.1:7778直接修改配置文件git 全局配置文件的路径在： %APPDATA%\\NuGet\\NuGet.Config在这个文件中，你需要添加以下几行： &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;packageSources&amp;gt; &amp;lt;add key=&quot;nuget.org&quot; value=&quot;https://api.nuget.org/v3/index.json&quot; protocolVersion=&quot;3&quot; /&amp;gt; &amp;lt;/packageSources&amp;gt; &amp;lt;config&amp;gt;+ &amp;lt;add key=&quot;http_proxy&quot; value=&quot;http://127.0.0.1:7778&quot; /&amp;gt; &amp;lt;/config&amp;gt; &amp;lt;/configuration&amp;gt;如果这么设置了，那么 NuGet 会为所有的包源设置代理。然而内部部署的包源并不需要代理，于是还需要设置 no_proxy： &amp;lt;configuration&amp;gt; &amp;lt;config&amp;gt; &amp;lt;add key=&quot;http_proxy&quot; value=&quot;http://127.0.0.1:7778&quot; /&amp;gt;+ &amp;lt;add key=&quot;no_proxy&quot; value=&quot;localhost,127.0.0.1,*.walterlv.com&quot; /&amp;gt; &amp;lt;/config&amp;gt; &amp;lt;/configuration&amp;gt;ScoopScoop 是一款优秀的包管理工具，可以以绿色的方式安装各种工具。scoop config proxy 127.0.0.1:7778Chocolatey / ChocolateyGUIChocolatey 是 Windows 上非常著名的包管理工具。它支持的代理设置方法非常多，你可以去它的官网了解所有的设置代理的方法：Chocolatey Software - Proxy Settings for Chocolatey。这里简单搬运一下直接的设置方法。choco config set proxy 127.0.0.1:7778同时，它也支持 http_proxy https_proxy 和 no_proxy 这样全局的环境变量设置。另外，不喜欢命令行版的 choco 和命令行版代理设置的同学，可以考虑用 ChocolateyGUI： chocolatey/ChocolateyGUI: A delicious GUI for Chocolatey参考资料 nuget.config File Reference - Microsoft Docs no_proxy containing wildcard breaks nuget · Issue #3776 · NuGet/Home Using Scoop behind a proxy · lukesampson/scoop Wiki github - Only use a proxy for certain git urls/domains? - Stack Overflow Configure Git to use a proxy Chocolatey Software - Proxy Settings for Chocolatey" }, { "title": "Unity3D 入门：如何在脚本中找到游戏对象的父子级/祖孙级对象和它们的组件", "url": "/post/unity-starter-get-unity-game-objects-or-components-through-scene-hierarchy.html", "categories": "", "tags": "unity", "date": "2020-05-10 15:34:05 +0800", "snippet": "在真正能玩的游戏场景中，很多脚本的执行是在不确定的游戏对象上进项的，于是会考虑在父对象或者子对象上去写脚本。这时，可能需要查找游戏对象。那么如何在脚本中找到父子游戏对象（gameObject）呢？场景如下图所示，Windows 游戏对象下面可能有很多不确定数量和位置的游戏对象，需要操作它们。在为游戏对象创建脚本的时候，这个脚本中的类会继承自 MonoBehavior：using UnityEngine;public class WindowUpdater : MonoBehaviour{ void Start() { } void Update() { }}找父组件/子组件MonoBehavior 直接提供了查找父子组件的方法 GetComponent(s) / GetComponent(s)InParent 和 GetComponent(s)InChildren，因此直接调用即可。对于泛型方法，每个子对象只会找到一个组件，所以通常适用于子组件非常简单的场景。var renderers = GetComponentsInChildren&amp;lt;Renderer&amp;gt;();for (var i = 0; i &amp;lt; renderers.Length; i++){ var texture = textures[i]; renderers[i].material.mainTexture = texture;}找父对象/子对象MonoBehavior 并没有提供直接查找父子对象的方法。但是 Transform 有！所以，通过 Transform 可以间接获取到子对象。GetChild() GetChildCount。var transform = GetComponent&amp;lt;Transform&amp;gt;();for (int i = 0; 0 &amp;lt; renderers.Length; i++){ transform.GetChild(i).gameObject.SetActive(true);}" }, { "title": "WPF 中使用附加属性，将任意 UI 元素或控件裁剪成圆形（椭圆）", "url": "/post/clip-wpf-uielement-to-ellipse.html", "categories": "", "tags": "xaml, wpf", "date": "2020-05-06 08:15:56 +0800", "snippet": "不知从什么时候开始，头像流行使用圆形了，于是各个平台开始追逐显示圆形裁剪图像的技术。WPF 作为一个优秀的 UI 框架，当然有其内建的机制支持这种圆形裁剪。不过，内建的机制仅支持画刷，而如果被裁剪的元素支持交互，或者拥有普通画刷无法达到的显示效果，那么就需要本文介绍的更加通用的解决方法了。UWP 的圆形裁剪请左转参考：UWP 将图片裁剪成圆形（椭圆）。WPF 的 UIElement 提供了 Clip 依赖项属性，可以使用一个 Geometry 来裁剪任意的 UIElement。由于 Geometry 几乎可以表示任意形状，这意味着我们可以才建成任意想要的样子。于是，我们可以利用这一点，使用 EllipseGeometry 将任意 UIElement 裁剪成圆形或者椭圆形。比如，写成下面这样：&amp;lt;Grid&amp;gt; &amp;lt;Grid.Clip&amp;gt; &amp;lt;EllipseGeometry Center=&quot;120 180&quot; RadiusX=&quot;120&quot; RadiusY=&quot;180&quot; /&amp;gt; &amp;lt;/Grid.Clip&amp;gt; &amp;lt;Image Source=&quot;demo.jpg&quot; Stretch=&quot;Fill&quot; /&amp;gt; &amp;lt;TextBlock Text=&quot;https://walterlv.github.io&quot; Foreground=&quot;White&quot; Margin=&quot;171,172,51,21&quot;/&amp;gt;&amp;lt;/Grid&amp;gt;最终可以出现如下的效果。不过，稍微改变下窗口的大小，就会发现裁剪的范围不对了。因为我们写死了圆形裁剪的中心点和两个不同方向的半径（这里可不好说是长半轴还是短半轴啊）。我们需要一个可以自动修改裁剪圆形的一种机制，于是，我们想到了 Binding。为了使 XAML 的代码好看一点，我将 Binding 封装到了一个单独的类中处理，使用附加属性提供 API。我封装好的类如下：/// &amp;lt;summary&amp;gt;/// 提供将任意控件裁剪为圆形或椭圆的附加属性。/// &amp;lt;/summary&amp;gt;public static class EllipseClipper{ /// &amp;lt;summary&amp;gt; /// 标识 IsClipping 的附加属性。 /// &amp;lt;/summary&amp;gt; public static readonly DependencyProperty IsClippingProperty = DependencyProperty.RegisterAttached( &quot;IsClipping&quot;, typeof(bool), typeof(EllipseClipper), new PropertyMetadata(false, OnIsClippingChanged)); public static void SetIsClipping(DependencyObject element, bool value) =&amp;gt; element.SetValue(IsClippingProperty, value); public static bool GetIsClipping(DependencyObject element) =&amp;gt; (bool) element.GetValue(IsClippingProperty); private static void OnIsClippingChanged(DependencyObject d, DependencyPropertyChangedEventArgs e) { var source = (UIElement) d; if (e.NewValue is false) { // 如果 IsClipping 附加属性被设置为 false，则清除 UIElement.Clip 属性。 source.ClearValue(UIElement.ClipProperty); return; } // 如果 UIElement.Clip 属性被用作其他用途，则抛出异常说明问题所在。 var ellipse = source.Clip as EllipseGeometry; if (source.Clip != null &amp;amp;&amp;amp; ellipse == null) { throw new InvalidOperationException( $&quot;{typeof(EllipseClipper).FullName}.{IsClippingProperty.Name} &quot; + $&quot;is using {source.GetType().FullName}.{UIElement.ClipProperty.Name} &quot; + &quot;for clipping, dont use this property manually.&quot;); } // 使用 UIElement.Clip 属性。 ellipse = ellipse ?? new EllipseGeometry(); source.Clip = ellipse; // 使用绑定来根据控件的宽高更新椭圆裁剪范围。 var xBinding = new Binding(FrameworkElement.ActualWidthProperty.Name) { Source = source, Mode = BindingMode.OneWay, Converter = new HalfConverter(), }; var yBinding = new Binding(FrameworkElement.ActualHeightProperty.Name) { Source = source, Mode = BindingMode.OneWay, Converter = new HalfConverter(), }; var xyBinding = new MultiBinding { Converter = new SizeToClipCenterConverter(), }; xyBinding.Bindings.Add(xBinding); xyBinding.Bindings.Add(yBinding); BindingOperations.SetBinding(ellipse, EllipseGeometry.RadiusXProperty, xBinding); BindingOperations.SetBinding(ellipse, EllipseGeometry.RadiusYProperty, yBinding); BindingOperations.SetBinding(ellipse, EllipseGeometry.CenterProperty, xyBinding); } private sealed class SizeToClipCenterConverter : IMultiValueConverter { public object Convert(object[] values, Type targetType, object parameter, CultureInfo culture) =&amp;gt; new Point((double) values[0], (double) values[1]); public object[] ConvertBack(object value, Type[] targetTypes, object parameter, CultureInfo culture) =&amp;gt; throw new NotSupportedException(); } private sealed class HalfConverter : IValueConverter { public object Convert(object value, Type targetType, object parameter, CultureInfo culture) =&amp;gt; (double) value / 2; public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture) =&amp;gt; throw new NotSupportedException(); }}在 XAML 中只需要很简单的一个属性赋值即可达到圆形或椭圆形裁剪。&amp;lt;Grid local:EllipseClipper.IsClipping=&quot;True&quot;&amp;gt; &amp;lt;Image Source=&quot;fluentdesign-app-header.jpg&quot; Stretch=&quot;Fill&quot; /&amp;gt; &amp;lt;TextBlock Text=&quot;https://walterlv.github.io&quot; Foreground=&quot;White&quot; Margin=&quot;171,172,51,21&quot;/&amp;gt;&amp;lt;/Grid&amp;gt;而且在控件的大小改变的时候也能够正常更新裁剪范围。这篇博客的核心代码我也贴在了 StackOverflow 上：c# - WPF displaying a gif in an ellipse - Stack Overflow" }, { "title": "快速在 Windows 上搭建 Jekyll 开发环境", "url": "/post/setup-jekyll-in-windows.html", "categories": "", "tags": "site", "date": "2020-05-06 08:13:27 +0800", "snippet": "Jekyll 是一个不错的静态博客工具，本文将提供快速在 Windows 系统上搭建 Jekyll 开发环境的方法。For 老手其实所需的命令只有少数几个而已：# 全局命令：安装 Ruby 所需的依赖ridk install# 全局命令：安装 Jekyllgem install jekyll bundler# 工作目录命令：安装博客仓库中所需的依赖bundle install# 工作目录命令：将本地博客仓库跑起来jekyll serveFor 新手下载必要的软件考虑到我们的网络环境，为了提升本文的阅读效率，建议一边下载一边阅读。 Ruby（挑最新的下载即可） MSYS2（虽然这不是必要的，但能大大提高配置环境的成功率和速度）如果无法下载，可以考虑 Docker 或者 Windows 上的其他包管理器（如 scoop）。安装 Ruby 和 Jekyll 分别安装下载好的 Ruby 和 MSYS2 安装包，一路下一步，直到两者都安装结束； 一般安装完 Ruby 后会自动弹出一个新的命令行安装界面，我们需要在里面选择 3，然后回车。 如果上一步没有提前下载安装 MSYS2，那么这里会因为众所周知的网络原因速度奇慢无比，或者以失败告终。 如果没有弹出命令行安装界面或者把它关掉了，那么也可以在任意的命令行中输入 ridk install 来再次进入命令行安装界面。 如果网络状况良好，能够一次装成功。（如果不幸失败。则一直再次选 3 继续安装直到全部成功为止。） Install MSYS2 and MINGW development toolchain succeeded 再打开一个新的命令行窗口（cmd/powershell/bash/msys2 都行），输入以下命令安装 jekyll： gem install jekyll bundler 自此，Jekyll 开发环境就搭建完成了。让自己的博客跑起来如果你已经有了自己的 Jekyll 博客，希望在本地能够编译运行，那么就继续阅读本节。可能你的博客来源于这些地方： 从 Jekyll Themes 挑选并下载了一款主题； 克隆了自己或别人的博客站点，准备改改自己用；那么我们开始。首先在博客的根目录打开命令行，接下来的操作都在命令行中。 安装依赖包 bundle install 将 Jekyll 服务跑起来 jekyll serve 这就完成了！不过，如果上述第 2 个步骤发生了错误，通常是依赖包的版本不匹配所致，运行命令更新依赖包：bundle update随后再次 jekyll serve 即可。Ruby 跨版本升级的坑如果你之前安装过 Ruby 的旧版本，现在需要跨大版本号升级，那么你会遇到很多问题： ruby 命令对应新旧哪个版本是不明确的 如果你覆盖安装了 ruby，那么之前安装自动设置的那些环境变量（例如 gem）就会丢失这会导致你试图编译你的博客时遇到各种各样奇怪的错误。所以，你需要做的是： 卸载掉之前的 ruby 再次安装 ruby" }, { "title": "Unity3D 入门：Unity Editor 编辑器常用快捷键", "url": "/post/unity-starter-unity-editor-shortcut-keys.html", "categories": "", "tags": "unity", "date": "2020-05-05 19:35:25 +0800", "snippet": "本文为 Unity3D 入门小伙伴整理 Unity 编辑器中的常用快捷键。调节工具Unity 编辑器左上角的一组按钮，正好也对应着键盘左上角的字母： 图标 快捷键 Q W E R T Y 英文 Hand Tool Move Tool Rotate Tool Scale Tool Rect Tool Move, Rotate or Scale selected objects 中文 手形工具 移动工具 旋转工具 缩放工具 矩形工具 移动、旋转或缩放选定对象 功能 在整个场景中移动漫游 按坐标轴移动选定对象 按三个维度旋转对象 在三个维度上缩放对象 以矩形的方式调节对象的尺寸 综合前面所有对选定对象的调节工具 除了使用 Q 打开手形工具随后用鼠标左键漫游场景外，使用鼠标中键也可以在任意工具下漫游场景（按住鼠标中键然后移动鼠标）。按住鼠标右键移动可以以当前镜头处为轴心旋转视角，按住鼠标右键的同时按下 W A S D Q E 也可以前后左右下上移动镜头。按住 Alt 键的同时，也可以在任意工具下使用鼠标左键移动镜头，不过与前面不同的是，这是以目标物体为轴心来移动和旋转的。按住 Alt 键的同时，按住鼠标右键上下左右移动也可以移远和移近物体。按住 Ctrl 键的同时，使用以上所有工具移动、旋转或缩放对象的话，可以对齐网格。（Edit-&amp;gt;Grid and Snap Settings... 可以打开网格设置。）按住 V 键的同时，鼠标放到对象中心的移动格子上移动对象，可以让此对象对齐场景中的其他对象。（下图指示了鼠标拖哪里。）视图调节F（置于中心）：当在层级（Hierarchy）窗口或场景（Scene）窗口选中某个对象后，可按 F 将对象置于场景中心，并放大/缩小到合适的尺寸。窗口调整Shift + 空格（最大化/还原）：当你的焦点在 Unity 编辑器的任何子窗口中的时候，按下 Shift + Space 可以将此子窗口最大化或者还原。如下图是最大化后的场景窗口：进入退出播放模式Ctrl + P（进入退出播放模式）：相当于按下界面中的“播放”按钮。所有快捷键在 Edit-&amp;gt;Shortcuts... 中可以找到并编辑所有的快捷键。参考资料 Unity - Manual: Unity shortcuts" }, { "title": "Unity3D 入门：让 C# 脚本公开可在 Unity 编辑器中设置的属性", "url": "/post/unity-starter-public-fields-of-unity-script.html", "categories": "", "tags": "unity", "date": "2020-05-05 16:22:24 +0800", "snippet": "将一部分参数从 C# 脚本中抽离出来，可以让 C# 脚本在 Unity 项目中更通用，适用于更多游戏对象（gameObject）。本文介绍如何创建可在 Unity 编辑器中设置属性的 C# 脚本，并介绍如何在 Unity 编辑器中设置它们。简单的 C# 脚本本文的例子取自于我的另一篇博客： Unity3D 入门：最简单的控制视角，以及控制角色前进、转向的脚本 - walterlvusing UnityEngine;public class PlayerController : MonoBehaviour{ private Transform transform; public float moveSpeed = 5f; public float rotateSpeed = 50f; void Start() { transform = GetComponent&amp;lt;Transform&amp;gt;(); } void Update() { float adValue = Input.GetAxis(&quot;Horizontal&quot;); float wsValue = Input.GetAxis(&quot;Vertical&quot;); float mValue = Input.GetAxis(&quot;Mouse X&quot;); var moveDirection = (Vector3.forward * wsValue) + (Vector3.right * adValue); transform.Translate(moveDirection.normalized * moveSpeed * Time.deltaTime, Space.Self); transform.Rotate(Vector3.up * rotateSpeed * Time.deltaTime * mValue); }}公开字段只需要将脚本的字段设为 public，Unity 编辑器便能识别出这些字段以及它们的类型，然后允许你在 Inspector 中编辑它们。注意，Inspector 中不会识别属性，更不会识别方法。所以要公开，必须使用“字段”。在哪里修改值Unity 编辑器会在每次重新激活编辑器窗口的时候重新加载 Unity 项目。因此，当你在 Visual Studio 或其他编辑器中新编写了公开字段后，回到 Unity 编辑器中便会识别到这些字段，然后显示出来。值得注意的是，这个时候就已经记录了此脚本在此游戏对象中的值。也就是说，此后无论你如何在脚本中修改公开字段的值，运行游戏都不会有变化，因为游戏开始后，就会用你在编辑器中设置的值（虽然不是手工设的）覆盖脚本中编写的默认值。要修改，还是需要在 Inspector 中去修改值。有趣的名称按照 Unity C# 脚本的编写规范，公开的字段也是按 camelCase 命名的。当然，你也可以用 PascalCase 命名也不会有什么识别上的问题。不过，无论你用什么命名，Inspector 中都会将你的名称拆开成多个单词，并首字母大写。更有趣的是，如果你使用了一些预设的字段名称，那么 Inspector 中会显示成预设的名称。典型的是命名成 Name 的时候，Inspector 中会显示“名称”（如果你装了中文语言包的话）。" }, { "title": "Unity3D 入门：最简单的控制视角，以及控制角色前进、转向的脚本", "url": "/post/unity-starter-handle-base-player-input-for-movement.html", "categories": "", "tags": "unity", "date": "2020-05-05 15:58:46 +0800", "snippet": "本文依然是 Unity3D 的入门篇。作为 Unity3D 的入门读者，你可能希望迅速让你能在游戏中操作你的视角，或者让角色移动。创建脚本作为入门篇，可能需要讲一下如何创建脚本。按下图，在 Unity 编辑器中： 在 Hierarchy（层级）中选中主摄像机； 在 Inspector（检查器）中选择最后那个 Add Component（添加组件）； 选择 New Script（新建脚本）输入脚本名称，然后点击 Create and Add（创建并添加）。接下来，我们需要去 Visual Studio 中编辑这个脚本。点击菜单中的 Assets -&amp;gt; Open C# Project（资源 -&amp;gt; 打开 C# 项目）。于是可以转到 Visual Studio 中编辑你的脚本文件。最简代码在 Visual Studio 中找到我们刚刚创建的 PlayerController 脚本。其实就是脚本名加上 .cs 后缀。Unity 中 C# 脚本要求文件名必须匹配脚本的类名，因此，不要随便尝试改文件名或类名；就算改了，也要同步更新文件名和类名重新匹配，并重新在 Inspector 中添加新名称的脚本。在脚本中添加如下代码：using UnityEngine;public class PlayerController : MonoBehaviour{ private Transform transform; public float moveSpeed = 5f; public float rotateSpeed = 50f; void Start() { transform = GetComponent&amp;lt;Transform&amp;gt;(); } void Update() { float adValue = Input.GetAxis(&quot;Horizontal&quot;); float wsValue = Input.GetAxis(&quot;Vertical&quot;); float mValue = Input.GetAxis(&quot;Mouse X&quot;); var moveDirection = (Vector3.forward * wsValue) + (Vector3.right * adValue); transform.Translate(moveDirection.normalized * moveSpeed * Time.deltaTime, Space.Self); transform.Rotate(Vector3.up * rotateSpeed * Time.deltaTime * mValue); }}Start 消息会在游戏对象（也就是前面我们添加了脚本的那个主摄像机）创建后，第一个 Update 消息执行前调用，可以用来做一些初始化。这里，我们拿到我们需要做变换的 Transform 组件（这里的组件也就是 Unity 编辑器的“检查器”中看到的一个个组件）。而 Update 会尽量在每一帧执行一次，我们在这里执行一些需要每帧更新的逻辑。我们做了这些事情： 定义了公共的两个字段 moveSpeed 和 rotateSpeed 表示移动速度和转向速度。 通过 Input.GetAxis 获取不同种类的玩家输入。 通过玩家的输入计算 Transform 组件的更新差量，然后更新 Transform 组件。关于在脚本当中公开属性以在编辑器中设置的更多细节，可阅读我的另一篇 Unity3D 入门博客： Unity3D 入门：让 C# 脚本公开可在 Unity 编辑器中设置的属性 - walterlv可以看以下效果（gif 文件有点大，多等等）：" }, { "title": "Unity3D 入门：安装 Unity3D 并配置与 Visual Studio 的协作开发环境", "url": "/post/unity-starter-install-and-integrated-with-visual-studio.html", "categories": "", "tags": "unity, csharp, visualstudio", "date": "2020-05-05 15:22:45 +0800", "snippet": "实际上本文不看也罢，因为整个过程除了网速之外基本没啥坑。不过装完可能有一些配置，所以如果不知道的话可以参考本文。安装我们共需要安装两款应用： Visual Studio 2019 及 Unity 编辑器组件 Unity Hub这两款应用安装不分先后，不过建议全部都安装完后再启动，避免单独启动无法运行使用的问题。安装 Visual Studio 2019 的 Unity 编辑器组件。Visual Studio 2019 的安装包自带 Unity 编辑器的安装入口。在你的开始菜单中搜索并打开“Visual Studio Installer”。如果你没有安装 Visual Studio 的话，那么还是建议去下载安装一下的。启动完 Visual Studio Installer 之后，选择“修改”：在“单个组件”里面勾选两个： Unity 64 位编辑器 Visual Studio Tools for Unity点击右下角的“修改”后就等待。（可能部分运营商的速度会过慢，这时你可能需要考虑梯子。）安装 Unity Hub下载安装地址： Download - Unity获得授权如果没有 Unity 的授权，那么你将无法使用 Unity 编辑器，而 Unity 的授权在 Unity Hub 的应用中才能进行（这也是为什么一定要下一个 Unity Hub 的原因）。启动 Unity Hub。如果你没有许可证的话，那么打开 Unity Hub 的第一个界面就是 Unity Hub 的许可证的授权界面。如果没有打开这个界面，那么点击右上角的设置-&amp;gt;许可证管理可以进来。点击“激活新许可证”，然后按照你自己的需要选择许可证即可。我出于个人学习 Unity 的需要安装的 Unity，所以选择了个人授权。个人授权免费，不过有效期只有一天，过期需要手工再操作一次。配置 Visual Studio 集成使用 Visual Studio 解决方案在 Unity Hub 中新建一个项目，输入名称选择路径，你就可以开始使用 Unity 来制作你的程序了。新建或打开 Unity 的项目后，会启动 Visual Studio 2019 安装过程中安装的那个 Unity 编辑器。选择“Edit-&amp;gt;Preference…”打开 Unity 的设置。在设置中，打开 External Tools，然后在 External ScriptEditor 中选择“Browse…”，找到 Visual Studio 2019 的主程序确定，这时，这里就会变成“Visual Studio 2019”。下面是否勾选 Generate all .csproj files 的区别是生成的 Visual Studio 解决方案中是否包含其他所有的项目（后面会介绍）。Visual Studio 一般在这种地方： C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\Common7\\IDE C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\Common7\\IDE C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\Common7\\IDE设置完成之后，点击“打开 C# 项目”可以在 Visual Studio 中打开此项目的解决方案，你就可以在里面编写 C# 脚本了。后话，其实你什么都不配也依然能使用 Visual Studio 完成开发，不过配完后你将获得这些好处： 获得完整的 Visual Studio 项目，可以用 C#/.NET 的语法分析，可以管理项目（否则你只能以单纯的 C# 单个文件编辑代码）； 可以直接在 Visual Studio 中调试 Unity 程序，获得比较完整的 Visual Studio 的调试体验。如果你在前面勾选了“生成所有的 .csproj 文件”，那么在 Visual Studio 的解决方案中将可以看到所有的 Unity 辅助项目可供编辑。否则只有 Assembly-CSharp 一个项目。在 Visual Studio 中调试 Unity 程序正常你可以直接在项目原本的“启动”或“调试”按钮处看到“附加到 Unity”按钮，点击即可调试 Unity 程序。当然，Unity 编辑器这边也要运行起来才可以在 Visual Studio 里面进入断点：如果你没有找到“附加到 Unity”按钮，那么可以在 Visual Studio 的“调试”菜单中找到“附加 Unity 调试程序”。点击后可以自动查找当前正在运行的 Unity 编辑器，选择你希望调试的那一个即可开始调试。安装其他模块（语言/编译平台）实际上，按照以上步骤全部完成的话，编译和调试 Unity 项目已经没有问题了。如果你是出于学习目的安装的话，本文的操作到此结束。至此我们的 Unity 项目并不能发布，因为我们没有安装过任何目标平台的编译环境。请前往 Unity 的更新页面：https://unity3d.com/get-unity/update因为我们已经安装了 Unity Hub，所以可以选择： I already have Unity HubInstall version from Unity Hub这时会启动 Unity Hub 然后进入更新页面。如果打开了 Unity Hub 但没有进入更新页面，请去任务栏通知区域右键退出 Unity Hub，重新点击上面的那个 Install version from Unity Hub 按钮。于是可以选择安装哪些组件。随后点击右下角的“安装”以安装新版本并包含需要的编译组件。当然，如果你已经安装过新版本，那么也可以通过“添加组件”的方式来安装目标平台的编译环境。完成至此，Unity 的安装和基本配置已全部完成。" }, { "title": ".NET 程序如何获取图片的宽高（框架自带多种方法的不同性能）", "url": "/post/get-image-pixel-width-and-height-in-dotnet.html", "categories": "", "tags": "dotnet, wpf", "date": "2020-04-30 18:35:49 +0800", "snippet": "获取图片宽高的方法有很多种，本文介绍 .NET 中获取图片宽高的几种方法并评估其性能。如果你打算对大量图片进行一些处理，本文可能有用。本文即将评估的方法本文即将采用以下四种方法获取图片： System.Drawing.Imaging.Metafile System.Drawing.Bitmap System.Windows.Media.Imaging.BitmapImage System.Windows.Media.Imaging.BitmapDecoderSystem.Drawing.Imaging.Metafile实际上不要被这个名字误解了，Metafile 并不是“某个图片的元数据”，与之对应的 MetafileHeader 也不是“某个图片的元数据头”。Metafile 是微软 Windows 系统一种图片格式，也就是大家熟悉的 wmf 和 emf，分别是 Windows Metafile 和 Enhanced Metafile。所以指望直接读取图片元数据头来提升性能的的小伙伴们注意啦，这不是你们要找的方法。不过为什么这个也能拿出来说，是因为此类也可以读取其他格式的图片。var header = Metafile.FromFile(@&quot;D:\\blog.walterlv.com\\large-background-image.jpg&quot;);var witdh = header.Width;var height = header.Height;能拿到。System.Drawing.Bitmap这个实际上是封装的 GDI+ 位图，所以其性能最好也是 GDI+ 的性能，然而都知道 GDI+ 的静态图片性能不错，但比起现代的其他框架来说确实差得多。var bitmap = new Bitmap(@&quot;D:\\blog.walterlv.com\\large-background-image.jpg&quot;);var witdh = bitmap.Width;var height = bitmap.Height;System.Windows.Media.Imaging.BitmapImage这是 WPF 框架中提供的显示位图的方法，生成的图片可以直接被 WPF 框架显示。var bitmap = new BitmapImage(new Uri(@&quot;D:\\blog.walterlv.com\\large-background-image.jpg&quot;, UriKind.Absolute));var witdh = bitmap.Width;var height = bitmap.Height;System.Windows.Media.Imaging.BitmapDecoder这也是 WPF 框架中提供的方法，但相比完全加载图片到可以显示的 System.Windows.Media.Imaging.BitmapImage，此方法的性能会好得多。var decoder = new JpegBitmapDecoder(new Uri(@&quot;D:\\blog.walterlv.com\\large-background-image.jpg&quot;, UriKind.Absolute), BitmapCreateOptions.DelayCreation, BitmapCacheOption.OnDemand);var frame = decoder.Frames[0];var witdh = frame.PixelWidth;var height = frame.PixelHeight;性能对比为了测试性能，我使用下面这张非常大的图，同一张图运行多次：分别运行以上四个方法各 1 次：分别运行以上四个方法各 10 次：分别运行以上四个方法各 100 次（可以发现大量的 GC）：现在，使用不同的图片运行多次。分别运行以上四个方法各 10 张图片：分别运行以上四个方法各 100 张图片（可以发现大量的 GC）：做成图表，对于同一张图片运行不同次数： 消耗时间(ms) Metafile Bitmap BitmapImage BitmapDecoder 1次 175 107 71 2 10次 1041 1046 63 17 100次 10335 10360 56 122 对于不同图片运行不同次数： 消耗时间(ms) Metafile Bitmap BitmapImage BitmapDecoder 1次 175 107 71 2 10次 998 980 83 20 100次 10582 10617 255 204 1000次 127023 128627 3456 4015 可以发现，对于 .NET 框架中原生自带的获取图片尺寸的方法来说： System.Windows.Media.Imaging.BitmapDecoder 的整体性能是最好的 对于同一张图，System.Windows.Media.Imaging.BitmapImage 的运行时间不随次数的增加而增加，其内部有缓存参考资料 WMF - 维基百科，自由的百科全书" }, { "title": "在 CMD 里根据进程名杀掉进程", "url": "/post/kill-process-by-name-using-cmd.html", "categories": "", "tags": "windows", "date": "2020-04-30 11:31:27 +0800", "snippet": "任务管理器杀进程大家都会，不过如果你的系统被卡到任务管理器都无法操作了，怎么办？拿控制台 CMD 吧！系列博客： 在 CMD 里根据进程名杀掉进程 - walterlv 在 PowerShell 里根据进程名杀掉进程 - walterlvtaskkill 命令taskkill /f /t /im chrome.exe/f 表示强制终止进程。如果不指定，那么 taskkill 会给进程发送终止信号，但进程可以阻止退出（例如提示文档需要保存）。指定了，就会强杀进程。/t 表示结束此进程和其子进程。/im 用来指定进程的影映像名称（有 .exe 后缀）。更多使用方法可以直接输入 taskkill /?。❯ taskkill /?TASKKILL [/S system [/U username [/P [password]]]] { [/FI filter] [/PID processid | /IM imagename] } [/T] [/F]描述: 使用该工具按照进程 ID (PID) 或映像名称终止任务。参数列表: /S system 指定要连接的远程系统。 /U [domain\\]user 指定应该在哪个用户上下文执行这个命令。 /P [password] 为提供的用户上下文指定密码。如果忽略，提示 输入。 /FI filter 应用筛选器以选择一组任务。 允许使用 &quot;*&quot;。例如，映像名称 eq acme* /PID processid 指定要终止的进程的 PID。 使用 TaskList 取得 PID。 /IM imagename 指定要终止的进程的映像名称。通配符 &#39;*&#39;可用来 指定所有任务或映像名称。 /T 终止指定的进程和由它启用的子进程。 /F 指定强制终止进程。 /? 显示帮助消息。筛选器: 筛选器名 有效运算符 有效值 ----------- --------------- ------------------------- STATUS eq, ne RUNNING | NOT RESPONDING | UNKNOWN IMAGENAME eq, ne 映像名称 PID eq, ne, gt, lt, ge, le PID 值 SESSION eq, ne, gt, lt, ge, le 会话编号。 CPUTIME eq, ne, gt, lt, ge, le CPU 时间，格式为 hh:mm:ss。 hh - 时， mm - 分，ss - 秒 MEMUSAGE eq, ne, gt, lt, ge, le 内存使用量，单位为 KB USERNAME eq, ne 用户名，格式为 [domain\\]user MODULES eq, ne DLL 名称 SERVICES eq, ne 服务名称 WINDOWTITLE eq, ne 窗口标题 说明 ---- 1) 只有在应用筛选器的情况下，/IM 切换才能使用通配符 &#39;*&#39;。 2) 远程进程总是要强行 (/F) 终止。 3) 当指定远程机器时，不支持 &quot;WINDOWTITLE&quot; 和 &quot;STATUS&quot; 筛选器。例如: TASKKILL /IM notepad.exe TASKKILL /PID 1230 /PID 1241 /PID 1253 /T TASKKILL /F /IM cmd.exe /T TASKKILL /F /FI &quot;PID ge 1000&quot; /FI &quot;WINDOWTITLE ne untitle*&quot; TASKKILL /F /FI &quot;USERNAME eq NT AUTHORITY\\SYSTEM&quot; /IM notepad.exe TASKKILL /S system /U 域\\用户名 /FI &quot;用户名 ne NT*&quot; /IM * TASKKILL /S system /U username /P password /FI &quot;IMAGENAME eq note*&quot;参考资料 how to kill a program by process name using cmd in windows 8? - Stack Overflow" }, { "title": "在 PowerShell 里根据进程名杀掉进程", "url": "/post/kill-process-by-name-using-powershell.html", "categories": "", "tags": "powershell", "date": "2020-04-30 11:31:24 +0800", "snippet": "任务管理器杀进程大家都会，不过如果你的系统被卡到任务管理器都无法操作了，怎么办？直接在 PowerShell 中干掉！另外，这也非常容易集成到各种工具链中。系列博客： 在 CMD 里根据进程名杀掉进程 - walterlv 在 PowerShell 里根据进程名杀掉进程 - walterlvStop-Process / killPowerShell 脚本 Stop-Process 可以用来结束进程。结束进程名为 chrome 的进程：Stop-Process -Name chrome# kill 是 Stop-Process 的简写，ProcessName 是 Name 的别名。kill -ProcessName chrome如果除了关闭你正在看的博客，还顺便要把自己正在编写的代码关闭掉，可以传多个进程名：Stop-Process -Name chrome,codetaskkill 命令PowerShell 依然能使用 CMD 命令，于是以下命令依旧可以工作：taskkill /f /t /im chrome.exe详见： 在 CMD 里根据进程名杀掉进程 - walterlv其他间接玩法Process.KillGet-Process 能拿到进程对象，于是可以利用管道拿到对象将其关闭：Get-Process -Name chrome | Stop-Process更间接一点，遍历所有拿到的 Process 对象，然后杀掉：Get-Process -Name chrome | Foreach-Object { $_.Kill() }" }, { "title": "Linux Shell 中需要转义的字符", "url": "/post/linux-shell-escape.html", "categories": "", "tags": "linux", "date": "2020-04-30 11:12:46 +0800", "snippet": "本文整理 Linux Shell 中的转义字符。在 Linux Shell 中，有很多字符是有特殊含义的，如果期望把这个字符当作普通字符来处理，需要经过 \\ 的转义。在双引号中即可变普通字符的特殊字符` ` *空格 ‘\\ `这是转义空格。如果路径中包含空格，那么使用 \\ 转义可以避免路径被分割成 Shell 的两个参数。我有另一篇描述 Linux Shell 中路径空格转义相关的博客： 了解 Windows/Linux 下命令行/Shell 启动程序传参的区别，这下不用再担心 Windows 下启动程序传参到 Linux 下挂掉了 - walterlv星号 ‘*`如果单独使用 * 将会表示当前路径下枚举的所有文件或文件夹。如果希望保持 * 的原意，那么将其包裹在引号内，或者使用转义 \\*。井号 #表示注释。换行符在引号中，也可以直接换行。这样换行符就是字符串的一部分。即便在引号中也依然被 Shell 解释的特殊字符&quot; $ ` \\双引号 ‘&quot;’双引号的作用是避免空格将本来属于同一段参数的字符串分割成两部分。那么如果真的需要双引号的话就需要使用 \\ 来转义。echo &quot;Hello \\&quot;Walterlv\\&quot;&quot;这样才可以输出：Hello &quot;Walterlv&quot;。反引号 `跟引号一样的作用。在引号中也需要转义。美元符 \\$在 Linux Shell 中，这是变量的引用。例如 ${x} 就是引用 x 变量。$ echo &quot;上一个程序的返回值为：\\$? = $?&quot;上一个程序的返回值为：$? = 127在引号中也需要转义。反斜杠 \\因为 \\ 是转义字符，所以其本身的使用也必然需要转义。在引号中也需要转义。任意字符任意字符也可以使用 \\ 转义，虽然没用，但也是一个特性。$ echo \\H\\e\\l\\l\\o\\ \\&quot;\\W\\a\\l\\t\\e\\r\\l\\v\\&quot;Hello &quot;Walterlv&quot;参考资料 Escape Characters - Shell Scripting Tutorial How to enable linux support double backslashes “\\” as the path delimiter - Stack Overflow shell - Backslash in Path - Unix &amp;amp; Linux Stack Exchange shell - Which characters need to be escaped when using Bash? - Stack Overflow" }, { "title": "git 乱改你的换行符？一句话设置让 git 不再碰你某个文件的换行符", "url": "/post/fix-git-unexpected-line-end-changing.html", "categories": "", "tags": "git", "date": "2020-04-30 09:26:38 +0800", "snippet": "前些天有位小伙伴告诉我说 git 改了某个重要文件的换行符，导致文件的哈希变了，于是文件校验出现错误。之前一直没问题而最近才有问题是因为最近换了部署服务器，git 的换行符配置不一样。其实，我们不应该让代码仓库如此容易受到外界环境的影响。所以本文会解释 git 的全局配置如何影响了 git 对换行符的处理，然后说说如何彻底解决这个问题。关于换行符 \\r = CR = Carriage-Return = 回车 \\n = LF = Line-Feed = 换行 \\r\\n = CRLF = Carriage-Return Line-Feed = 回车换行Windows 下默认的文本换行符是 \\r\\n，Linux 下默认的换行符是 \\n，Mac 下默认的换行符是 \\r。因为这些差异，如果某部分文本文件会跨操作系统处理，那么换行符的处理就必须考虑了。git 允许开发者设置如何处理换行符在跨平台上的处理方式，不过不合适的设置可能带来文件发生不期望的修改。问题问题本身在本文一开始已经说得比较清楚了，现在疏理一下： 有个文本文件，被 git 改了换行符，导致哈希变化，文件校验出现了错误； 部署服务器以前 git 全局配置和现在不同，所以以前没问题，现在出了问题。解决当时，林德熙 小伙伴是负责部署服务器配置的，看到出事了立刻想到去服务器把配置改“正确”。然而我阻止了。因为现在因为换服务器出问题，将来也会因为换服务器出问题，更普遍的，换任何环境都可能出问题。所以这问题应该从仓库着手，避免此文件被修改换行符。于是我和小伙伴结对打开了 .gitattribute 文件，在末尾加了一行： *.bmp binary *.jpg binary++ *.inf binary这样，*.inf 文件会被 git 视为二进制文件，也就不会处理换行符了。当然，因为项目很小，所以直接改了位于项目根目录的 .gitattribute 文件。如果项目比较大，那么建议考虑在那个 .inf 文件所在的文件夹新建一个 .gitignore 文件，避免全局的设置对可能不需要生效的文件也起了作用。原因git 有个全局配置，在 %USERPROFILE%\\.gitconfig 文件里面，可以指定如何处理文本文件的换行符：[core] autocrlf = true有三个可选值： true false input在 Windows 系统上： true 表示在推送时转成 \\n，在拉取时转成 \\r\\n。这样的设置让 Windows 的开发者能兼容很多的开发工具（比如早期的记事本，新的已经支持 \\r\\n 了），不至于遇到很多换行符问题。 false 表示在推送时和拉取时都原样保留换行符。这样的设置在所有程序员都在同一个平台开发时很有用，git 完全不处理换行符，全部改由开发者自行解决。 input 表示在推送时转成 \\n，在拉取时原样保留换行符。注意到，这样的设置会让仓库里所有的换行符都变成 \\n 不再有什么时候有 \\r\\n 了，所以对 Windows 平台的开发者并不友好。以前的服务器全局配置没有问题，是因为服务器配置为 true，于是拉下来时一定都是 \\r\\n 哈希正确。而现在全局配置是 false，于是会原样把 git 仓库里的拉下来，哈希错误。是的，你没看错！远程 git 仓库里的是错的！这是因为有小伙伴使用了 true 或者 input 的配置，导致推送时统一把换行符改成了 \\r\\n。" }, { "title": ".NET 将混合了多个不同平台（Windows / Mac / Linux）的文件/目录的路径格式化成同一个平台下的路径", "url": "/post/format-mixed-path-seperators-to-platform-special.html", "categories": "", "tags": "dotnet, windows, linux", "date": "2020-04-30 09:24:04 +0800", "snippet": "Windows 下的路径分隔符是 \\ 而 Linux 和 Mac 下的路径分隔符是 \\。正常如果你的数据不跨 Windows 和 Linux 平台流通的话，不怎么会遇到多种换行符并存的问题的。但如果真发生了流通，那么如何将它们格式化为统一的当前平台认识的分隔符呢？现有方案没有原生方案（.NET）System.IO.Path 带了一堆方法用来处理路径。各大文档博客和书籍也都推荐大家使用 Path 来处理路径字符串的拼接、拆分和提取等，这可以很大程度避免不同遭遇不同平台下路径分隔字符串不一致导致的各种问题。不过，本文想告诉大家的是，Path 处理路径字符串也不是万能的，这体现在处理跨操作系统的路径字符串时。现在，我列举了 6 个不同的路径字符串：var part0 = @&quot;/mnt/d/walterlv/&quot;;var part1 = @&quot;D:\\walterlv\\&quot;;var part2 = @&quot;Foo/Bar.cs&quot;;var part3 = @&quot;Foo\\Bar.cs&quot;;var part4 = @&quot;/mnt/d/walterlv/Foo/Bar.cs&quot;;var part5 = @&quot;D:\\walterlv\\Foo\\Bar.cs&quot;;分成三组。前两个是路径的前半部分，中间两个是路径的后半部分，最后两个是完整路径。每组里面，前者是 Linux 风格的路径分隔符，后者是 Windows 风格的路径分隔符。现在，我将试图将以下几种混合情况下的路径拼接使用 Path 可能格式化的方法输出出来：// 看看 Linux 风格和 Windows 风格直接拼接的换行符使用 Path.Combine 能否格式化成功。var pathFromCombine0 = Path.Combine(part0, part3);var pathFromCombine1 = Path.Combine(part1, part2);Console.WriteLine($&quot;Path.Combine(part0, part3) = {pathFromCombine0}&quot;);Console.WriteLine($&quot;Path.Combine(part1, part2) = {pathFromCombine0}&quot;);// 通过 Path.GetFullPath 转相对路径到完整路径时，看看能否将路径格式化成当前平台。var pathFromFull0 = Path.GetFullPath(part2);var pathFromFull1 = Path.GetFullPath(part3);Console.WriteLine($&quot;Path.GetFullPath(part2) = {pathFromFull0}&quot;);Console.WriteLine($&quot;Path.GetFullPath(part3) = {pathFromFull1}&quot;);// 通过 new FileInfo(file).FullName 的一层转换看看能否将混合路径格式化成当前平台。var pathFromFileInfo0 = new FileInfo(pathFromCombine0).FullName;var pathFromFileInfo1 = new FileInfo(pathFromCombine1).FullName;Console.WriteLine($&quot;FileInfo(part0 + part3).FullName = {pathFromFileInfo0}&quot;);Console.WriteLine($&quot;FileInfo(part1 + part2).FullName = {pathFromFileInfo1}&quot;);// 通过 new FileInfo(file).FullName 的一层转换看看能否将非当前平台的路径格式化成当前平台。var pathFromFileInfo2 = new FileInfo(part4).FullName;var pathFromFileInfo3 = new FileInfo(part5).FullName;Console.WriteLine($&quot;Path.GetFullPath(part4) = {pathFromFileInfo2}&quot;);Console.WriteLine($&quot;Path.GetFullPath(part5) = {pathFromFileInfo3}&quot;);猜猜以上代码在 Windows 和 Linux 平台会输出什么？看图！图是拼接的，上面一半是 Windows 平台下的运行结果，下面一半是 Linux Ubuntu 18.04 发行版的运行结果。运行时是 .NET Core 3.1。可以发现这些点： Path.Combine 的路径拼接仅决定如何合并两段字符串，不会将已有的路径格式化成当前平台的路径分隔符。 Path.GetFullPath 在生成完整路径的时候，虽然补全的部分是当前平台的，但已有的部分依然是原本字符串。 new FileInfo().FullName 在 Windows 平台下可以完美将路径字符串统一成 Windows 平台的风格；但在 Linux 平台上不会统一，已有的 \\ 不会变成 /；无论是拼接的字符串，还是原本别的平台的字符串，都是一样的结论。为什么 .NET 原生不做统一化？看前面结论可知，在 Windows 平台下是可以将 / 和 \\ 全部格式化成 Windows 平台的 \\ 的，但 Linux 下却不行。这并不是因为 .NET 没去做，而是无法做！在 Linux 下，\\ 是合理的文件名！另外，路径经常使用在 Shell 中，而在 Shell 中，\\ 是个转义字符！例如，你可以有一个文件，名字是 foo\\bar.txt。所以，.NET 绝对不能擅自给你将 \\ 当作路径分隔符进行格式化！关于 \\ 在 Linux Shell 中的转义，你可以阅读我的另外两篇博客了解： 了解 Windows/Linux 下命令行/Shell 启动程序传参的区别，这下不用再担心 Windows 下启动程序传参到 Linux 下挂掉了 - walterlv自己实现知道了 Linux 是合理的文件名后，当然不能再指望有某个通用的解决方法了。因为通用代码不可能知道在你的上下文下，\\ 是否是合理的文件名。在信息不足的情况下，前面 .NET 的 new FileInfo().FullName 已经是最好的解决方案了。所以，如果你明确这些不同种类的路径字符串的来源你都清楚（没错，就是你自己挖出来的坑），拼接出来之后的后果你才能知道是否是符合业务的。这时你才应该决定是否真的要做路径的格式化。简单省事型var path = path .Replace(&#39;/&#39;, Path.DirectorySeparatorChar) .Replace(&#39;\\\\&#39;, Path.DirectorySeparatorChar);高性能型自己实现去。如何避免从前面的分析可以知道，如果每个框架、库还有业务开发者都不去作死把平台特定的路径传递到其他平台，那么根本就不会存在不同平台的路径会拼接的情况。另外，开发者也不应该随便在代码中写死 / 或者 \\\\ 作为路径的分隔符。就这样……参考资料 How to enable linux support double backslashes “\\” as the path delimiter - Stack Overflow" }, { "title": "如何在 Windows 10 中安装 WSL2 的 Linux 子系统", "url": "/post/how-to-install-wsl2.html", "categories": "", "tags": "windows, linux", "date": "2020-04-28 20:26:41 +0800", "snippet": "本文介绍如何在 Windows 10 中安装 WSL2 的 Linux 子系统第一步：启用虚拟机平台和 Linux 子系统功能以管理员权限启动 PowerShell，然后输入以下命令启用虚拟机平台：Enable-WindowsOptionalFeature -Online -FeatureName VirtualMachinePlatform以管理员权限启动 PowerShell，然后输入以下命令启用 Linux 子系统功能：Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux在以上每一步命令执行完之后，PowerShell 中可能会提示你重新启动计算机。按“Y”可以重新启动。当然，这个命令跟你在控制面板中启用“适用于 Windows 的 Linux 子系统”功能是一样的。第二步：安装一个 Linux 发行版打开微软商店应用，在搜索框中输入“Linux”然后搜索，你可以看到搜索结果中有很多的 Linux 发行版可以选择。选择一个你喜欢的 Linux 发行版本然后安装：选择一个 Linux 发行版本然后安装：需要注意，在商店中的安装并没有实际上完成 Linux 子系统的安装，你还需要运行一次已安装的 Linux 发行版以执行真正的安装操作。第三步：启用 WSL2重要：你的操作系统版本必须至少大于或等于 Windows 10.0.18917 ！使用 wsl -l 可以列出当前系统上已经安装的 Linux 子系统名称。注意这里的 -l 是列表“list”的缩写，是字母 l 不是其他字符。wsl -l如果提示 wsl 不是内部或外部命令，说明你没有启用“适用于 Windows 的 Linux 子系统”，请先完成本文第一步。如果提示没有发现任何已安装的 Linux，说明你没有安装 Linux 发行版，或者只是去商店下载了，没有运行它执行真正的安装，请先完成本文第二步。使用 wsl --set-version &amp;lt;Distro&amp;gt; 2 命令可以设置一个 Linux 发行版的 WSL 版本。命令中 &amp;lt;Distro&amp;gt; 替换为你安装的 Linux 发型版本的名称，也就是前面通过 wsl -l 查询到的名称。本文的示例使用的是小白门喜欢的 Ubuntu 发行版。wsl --set-version Ubuntu 2当然，使用以下命令可以在以后安装 Linux 的时候默认启用 WSL2：wsl --set-default-version 2参考资料 Install WSL 2 - Microsoft Docs" }, { "title": "Unity3D 入门：在 Visual Studio 里使用 Visual Studio Tools for Unity 全套工具", "url": "/post/unity-starter-config-visual-studio-tools-for-unity.html", "categories": "", "tags": "unity, csharp", "date": "2020-04-27 21:06:05 +0800", "snippet": "Visual Studio 安装过程中一起勾选的 Visual Studio Tools for Unity 提供了与 Unity 编辑器方便的交互功能，充分使用 Visual Studio Tools for Unity 可以提升一部分开发效率减少一点点坑。Visual Studio Tools for Unity我在 Unity3D 入门：安装 Unity3D 并配置与 Visual Studio 的协作开发环境 - walterlv 一文中提及了在安装 Unity 的开发环境时建议勾选了 Visual Studio Tools for Unity。如果你还没安装，可以阅读此博客安装。如果安装后没有设置 Unity 编辑器的关联，也可以阅读这篇博客了解如何设置关联。快速实现 Unity 消息在 MonoBehaviour 的类中输入 onXXX 可以在智能感知列表中看到 Unity 在游戏运行时给每个游戏对象广播的消息，直接回车输入可以插入这个方法。于是，你可以无需记忆所有的这些消息就可以在不同的消息中添加处理函数。或者，你也可以在类中按下 Ctrl+Shift+M 打开“实现 Unity 消息”对话框，通过勾选插入一堆处理函数。Unity 项目资源管理器我们在 Unity 编辑器中查看 Unity 项目的文件结构与 Visual Studio 解决方案资源管理器中看到的是完全不同的。实际上，Visual Studio 中的项目和解决方案对 Unity 资产来说是没有意义的，有用的其实是里面的 C# 脚本。于是就有了“Unity 项目资源管理器”的需要，它可以以跟 Unity 编辑器相同的视角看 Unity 项目中的资产。附加到 Unity 调试在安装了 Visual Studio Tools for Unity 后，打开 Unity 的项目你将看到平常的“调试”按钮变成了“附加到 Unity”按钮。在 Unity 编辑器也运行起来的情况下，可以在 Visual Studio 里面进入断点调试。当然，如果觉得每次都要单独去点“Play”比较麻烦的话，可以在调试按钮上下拉选择“附加到 Unity 并播放”。这样每次点击按钮的时候就直接会开始运行游戏了。如果你没有找到“附加到 Unity”按钮，那么可以在 Visual Studio 的“调试”菜单中找到“附加 Unity 调试程序”。点击后可以自动查找当前正在运行的 Unity 编辑器，选择你希望调试的那一个即可开始调试。参考资料 Getting Started with Visual Studio Tools for Unity - Visual Studio - Microsoft Docs" }, { "title": "Unity3D 入门：使用 Visual Studio 开发 Unity C# 脚本，说说根目录的那些 sln 和 csproj 文件", "url": "/post/unity-starter-the-sln-and-csproj-files.html", "categories": "", "tags": "unity, csharp", "date": "2020-04-27 21:04:09 +0800", "snippet": "本文介绍 Unity3D 项目根目录的 sln 和 csproj 文件，你将知道如何正确理解和使用它们。对于传统 .NET/C# 的开发者来说，在解决方案中管理 NuGet 包，在 C# 项目中引用 dll 或 NuGet 包是家常便饭。但在 Unity 项目里面，你可能要改变这一观念——因为 Unity 项目里面实际上并不存在 sln 和 csproj 文件。等等！那我们在根目录看到的那些 sln 和 csproj 文件是什么？那只是 Unity 编辑器为了让你方便写 C# 代码临时生成给你用的。默认 Unity 不指定外部脚本编辑器时，会单纯打开 .cs 文件而已。而如果指定了 Visual Studio 作为外部脚本编辑器，那么再从 Unity 中打开 C# 项目时，将会生成 sln 和 csproj 文件，然后调用 Visual Studio 打开生成的 sln 和 csproj 文件。这里就需要特别注意了：每次点击 Open C# Project 打开 C# 项目时，都会重新生成 sln 和 csproj 文件，所以实际上你对 sln 和 csproj 所做的任何改动都是无效的！这样的设计，有好处也有坏处： 有了 sln 和 csproj，Visual Studio 将能充分运行代码分析器，可以在类与其他符号之间跳转，可以有智能感知提示，可以实时发现编写中的代码错误（甚至是引用错误）。 但让 Visual Studio 的各种功能激活后就会让我们这样的入门开发者产生误会，认为这其实就是 C# 项目，会尝试真的对这些项目进行可能超出 Unity 功能范围的修改。真正在编译完成放到游戏中运行的，是 Assets 文件夹中的文件。而外面的 sln 和 csproj 文件，应该加入到 .gitignore 文件中，从版本管理中忽略掉。" }, { "title": "让你的程序置顶到比系统界面都更上层，就像任务管理器/放大镜一样绝对置顶", "url": "/post/run-desktop-application-above-windows-application.html", "categories": "", "tags": "wpf", "date": "2020-04-25 11:50:18 +0800", "snippet": "启动系统自带的放大镜程序，我们会发现即便进了 Windows 8 的开始屏幕，或打开了 Windows 10 的开始菜单和消息中心，它也依然显示在最顶层。如果你为任务管理器开启置顶效果，你会发现它也能显示到开始屏幕的顶层。这是怎么做到的呢？顺便解释下“桌面应用程序”，指的是传统 Win32 应用程序。解释下“Windows 应用”，指的是开始屏幕/开始菜单/UAP/UWP 甚至是锁屏界面这些。方法做到这些，需要四个步骤，缺一不可：第一步：修改 Manifest前往你程序的 App.Manifest 文件，设置 requestedExecutionLevel。&amp;lt;requestedExecutionLevel level=&quot;asInvoker&quot; uiAccess=&quot;true&quot; /&amp;gt;第二步：修改窗口属性这两个属性是必须设置的，否则无法达到目的。ShowInTaskbar=trueTopMost=true第三步：为程序签名参见此处 - 为程序签名第四步：将程序放到受信任的目录下C:\\program filesC:\\program files x86C:\\Windows\\system32可能遇到的问题从服务器返回了一个参照A referral was returned from the server.感谢 胡承 提供的错误和解决方法！你可能会在按照以上步骤操作后，在执行程序时遇到这样的错误，解决方法是“以管理员权限启动此程序”。参考资料How to make Windows 8 desktop apps shown in Metro UI (like Task Manager)?https://stackoverflow.com/questions/12873323/how-to-make-windows-8-desktop-apps-shown-in-metro-ui-like-task-managerCode Signing Noteshttp://techsupt.winbatch.com/webcgi/webbatch.exe?techsupt/nftechsupt.web+WinBatch/Manifest+Manifest~Faqs.txtUIAccess in Manifest Fileshttps://social.msdn.microsoft.com/Forums/windowsdesktop/en-US/4d2e1358-af95-4f4f-b239-68ec7e2525a9/uiaccess-in-manifest-filesDebug Applications with uiAccess Set to “True”http://blogs.techsmith.com/inside-techsmith/devcorner-debug-uiaccess/Debugging with uiAccess=truehttps://social.msdn.microsoft.com/forums/windowsdesktop/en-us/7a42efab-5ce8-456f-8a58-dfedbc2cefcb/debugging-with-uiaccesstrue" }, { "title": "C# 可空引用类型 Nullable 更强制的约束：将警告改为错误 WarningsAsErrors", "url": "/post/warning-as-errors-for-csharp-nullable-reference-types.html", "categories": "", "tags": "csharp, msbuild", "date": "2020-04-23 20:17:50 +0800", "snippet": "程序员不看警告！于是 C# 8.0 带来的可空引用类型由于默认以警告的形式出现，所以实际上约束力非常弱。本文将把 C# 8.0 的可空引用类型警告提升为错误，以提高约束力。启用可空引用类型你需要先在你的项目中启用可空引用类型的支持，才能修改警告到错误： C# 8.0 如何在项目中开启可空引用类型的支持 - 吕毅项目属性在项目属性中设置是比较快捷直观的方法。在项目上右键属性，打开“生成”标签。在这里，可以看到“将警告视为错误”一栏： 无 所有 特定警告可以看到默认选中的是“特定警告”且值是 NU1605。NU 是 NuGet 中发生的错误或者警告的前缀，NU1605 是大家可能平时经常见到的一个编译错误“检测到包降级”。关于这个错误的信息可以阅读官网：NuGet Warning NU1605 - Microsoft Docs，本文不需要说明。于是，我们将我们需要视为错误的错误代码补充到后面就可以，以分号分隔。NU1605;CS8600;CS8602;CS8603;CS8604;CS8618;CS8625这些值的含义可以参考我的另一篇博客： C# 8.0 可空引用类型中的各项警告和错误 - 吕毅记得在改之前，把前面的配置从“活动”改为“所有配置”，这样你就不用改完之后仅在 Debug 生效，完了还要去 Release 配置再改一遍。WarningsAsErrors前面使用属性面板指定时，有一个奇怪的默认值。实际上我们直接修改将固化这个默认值，这不利于将来项目跟随 Sdk 或者 NuGet 包的升级。所以，最好我们能直接修改到项目文件，以便更精细地控制这个属性的值。在上一节界面中设置实际上是生成了一个属性 WarningsAsErrors。那么我们现在修改 WarningsAsErrors 属性的值，使其拼接之前的值： &amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;OutputType&amp;gt;Exe&amp;lt;/OutputType&amp;gt; &amp;lt;TargetFramework&amp;gt;netcoreapp3.0&amp;lt;/TargetFramework&amp;gt; &amp;lt;LangVersion&amp;gt;latest&amp;lt;/LangVersion&amp;gt; &amp;lt;Nullable&amp;gt;enable&amp;lt;/Nullable&amp;gt;++ &amp;lt;WarningsAsErrors&amp;gt;$(WarningsAsErrors);CS8600;CS8601;CS8602;CS8603;CS8604;CS8609;CS8610;CS8614;CS8616;CS8618;CS8619;CS8622;CS8625&amp;lt;/WarningsAsErrors&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;/Project&amp;gt;这句话的含义是先获取之前的值，将其放到我们要设置的值的前面。这样可以跟随 Sdk 或者 NuGet 包的升级而更新此默认值。这些值的含义可以参考我的另一篇博客： C# 8.0 可空引用类型中的各项警告和错误 - 吕毅参考资料 Switch to errors instead of warnings for nullable reference types in C# 8 - tabs ↹ over ␣ ␣ ␣ spaces by Jiří {x2} Činčura NuGet Warning NU1605 - Microsoft Docs" }, { "title": "C# 8.0 如何在项目中开启可空引用类型的支持", "url": "/post/how-to-enable-nullable-reference-types.html", "categories": "", "tags": "csharp, msbuild, visualstudio", "date": "2020-04-23 20:17:25 +0800", "snippet": "C# 8.0 引入了可为空引用类型和不可为空引用类型。由于这是语法级别的支持，所以比传统的契约式编程具有更强的约束力。更容易帮助我们消灭 null 异常。本文将介绍如何在项目中开启 C# 8.0 的可空引用类型的支持。使用 Sdk 风格的项目文件如果你还在使用旧的项目文件，请先升级成 Sdk 风格的项目文件：将 WPF、UWP 以及其他各种类型的旧 csproj 迁移成 Sdk 风格的 csproj - 吕毅。本文会示例一个项目文件。由于现在 C# 8.0 还没有正式发布，所以如果要启用 C# 8.0 的语法支持，需要在项目文件中设置 LangVersion 属性为 8.0 而不能指定为 latest 等正式版本才能使用的值。&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;OutputType&amp;gt;Exe&amp;lt;/OutputType&amp;gt; &amp;lt;TargetFramework&amp;gt;netcoreapp3.0&amp;lt;/TargetFramework&amp;gt; &amp;lt;LangVersion&amp;gt;8.0&amp;lt;/LangVersion&amp;gt; &amp;lt;/PropertyGroup&amp;gt;&amp;lt;/Project&amp;gt;在项目文件中开启可空引用类型的支持在项目属性中添加一个属性 NullableContextOptions： &amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;OutputType&amp;gt;Exe&amp;lt;/OutputType&amp;gt; &amp;lt;TargetFramework&amp;gt;netcoreapp3.0&amp;lt;/TargetFramework&amp;gt; &amp;lt;LangVersion&amp;gt;latest&amp;lt;/LangVersion&amp;gt;++ &amp;lt;Nullable&amp;gt;enable&amp;lt;/Nullable&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;/Project&amp;gt;此属性可被指定为以下四个值之一： enable 所有引用类型均被视为不可为空，启用所有 null 相关的警告。 warnings 不会判定类型是否可空或不可为空，但启用局部范围内的 null 相关的警告。 annotations 所有引用类型均被视为不可为空，但关闭 null 相关的警告。 disable 与 8.0 之前的 C# 行为相同，即既不认为类型不可为空，也不启用 null 相关的警告。 这五个值其实是两个不同维度的设置排列组合之后的结果： 可为空注释上下文 用于告知编译器是否要识别一个类型的引用可为空或者不可为空。 可为空警告上下文 用于告知编译器是否要启用 null 相关的警告，以及警告的级别。 当仅仅启用警告上下文而不开启可为空注释上下文，那么编译器将仅仅识别局部变量中明显可以判定出对 null 解引用的代码，而不会对包括变量或者参数定义部分进行分析。将警告视为错误以上只是警告，如果你希望更严格地执行可空引用的建议，可以考虑使用编译错误： &amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;OutputType&amp;gt;Exe&amp;lt;/OutputType&amp;gt; &amp;lt;TargetFramework&amp;gt;netcoreapp3.0&amp;lt;/TargetFramework&amp;gt;++ &amp;lt;LangVersion&amp;gt;latest&amp;lt;/LangVersion&amp;gt;++ &amp;lt;Nullable&amp;gt;enable&amp;lt;/Nullable&amp;gt;++ &amp;lt;WarningsAsErrors&amp;gt;$(WarningsAsErrors);CS8600;CS8601;CS8602;CS8603;CS8604;CS8609;CS8610;CS8614;CS8616;CS8618;CS8619;CS8622;CS8625&amp;lt;/WarningsAsErrors&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;/Project&amp;gt;详见： C# 可空引用类型 NullableReferenceTypes 更强制的约束：将警告改为错误 WarningsAsErrors - walterlv C# 8.0 可空引用类型中的各项警告/错误的含义和示例代码 - walterlv可为空注释（Annotation）上下文当启动可为空注释上下文后，C# 编译器会将所有的类型引用变量识别为以下种类： 不可为空 可为空 未知于是，当你写出 string walterlv 的变量定义，那么 walterlv 就是不可为空的引用类型；当写出 string? walterlv 的变量定义，那么 walterlv 就是可为空的引用类型。对于类型参数来说，可能不能确定是否是可空引用类型，那么将视为“未知”。当关闭可为空注释上下文后，C# 编译器会将所有类型引用变量识别为以下种类： 无视于是，无论你使用什么方式顶一个一个引用类型的变量，C# 编译器都不会判定这到底是不是一个可为空还是不可为空的引用类型。可为空警告上下文例如以下代码：string walterlv = null;var value = walterlv.ToString();在将 null 赋值给 walterlv 变量时，是不会引发程序异常的；而在后面调用了 ToString() 方法则会引发程序异常。安全性区别就在这里。安全性警告仅会将编译期间可识别到可能运行时异常的代码进行警告（即下面的 walterlv.ToString()），而不会对没有异常的代码进行警告。如果是 enable，那么将 null 赋值给 walterlv 变量的那一句也会警告。在源代码文件中开启可空引用类型的支持除了在项目文件中全局开启可空引用类型的支持，也可以在 C# 源代码文件中覆盖全局的设定。 #nullable enable: 在源代码中启用可空引用类型并给出警告。 #nullable disable: 在源代码中禁用可空引用类型并关闭警告。 #nullable restore: 还原这段代码中可空引用类型和可空警告。 #nullable disable warnings: 在源代码中禁用可空警告。 #nullable enable warnings: 在源代码中启用可空警告。 #nullable restore warnings: 还原这段代码中可空警告。 #nullable disable annotations: 在源代码中禁用可空引用类型。 #nullable enable annotations: 在源代码中启用用可空引用类型。 #nullable restore annotations: 还原这段代码中可空引用类型。早期版本的属性在接近正式版的时候，开关才是 Nullable，而之前是 NullableContextOptions，但在 Visual Studio 2019 Preview 2 之前，则是 NullableReferenceTypes。现在，这些旧的属性已经废弃。ReSharper 支持ReSharper 从 2019.1.1 版本开始支持 C# 8.0，如果使用早期版本，就会到处报错。但是，由于 C# 8.0 可空引用类型的特性总在变，所以建议使用 2019.2.3 或以上版本，这是 C# 8.0 正式版本发布之后的 ReSharper。参考资料 Nullable reference types - Microsoft Docs c# - What is the difference between NullableContextOptions and NullableReferenceTypes? - Stack Overflow" }, { "title": "C# 8.0 可空引用类型中的各项警告/错误的含义和示例代码", "url": "/post/nullable-context-options-warnings.html", "categories": "", "tags": "csharp, visualstudio, msbuild", "date": "2020-04-23 20:16:44 +0800", "snippet": "C# 8.0 引入了可为空引用类型和不可为空引用类型。当你需要给你或者团队更严格的要求时，可能需要定义这部分的警告和错误级别。本文将介绍 C# 可空引用类型部分的警告和错误提示，便于进行个人项目或者团队项目的配置。开启可空引用类型以及配置警告和错误本文的内容本身没什么意义，但如果你试图进行一些团队配置，那么本文的示例可能能带来一些帮助。 C# 8.0 如何在项目中开启可空引用类型的支持 - 吕毅 C# 可空引用类型 NullableReferenceTypes 更强制的约束：将警告改为错误 WarningsAsErrors - 吕毅警告和错误CS8600将 null 文本或可能的 null 值转换为非 null 类型。string walterlv = null;CS8601可能的 null 引用赋值。string Text { get; set; }void Foo(string? text){ // 将可能为 null 的文本向不可为 null 的类型赋值。 Text = text;}CS8602null 引用可能的取消引用。// 当编译器判定 walterlv 可能为 null 时才会有此警告。var value = walterlv.ToString();CS8603可能的 null 引用返回。string Foo(){ return null;}CS8604将可能为 null 的引用作为参数传递到不可为 null 的方法中：void Foo(){ string text = GetText();; Bar(text);}string? GetText(){ return null;}CS8609返回类型中引用类型的为 Null 性与重写成员不匹配。比如你的基类中返回值不允许为 null，但是实现中返回值却允许为 null。protected virtual async Task&amp;lt;string&amp;gt; FooAsync(){}protected override async Task&amp;lt;string?&amp;gt; FooAsync(){}CS8610参数中引用类型的为 Null 性与重写成员不匹配。比如你的基类中方法参数值不允许为 null，但是实现中方法参数却允许为 null。protected virtual void FooAsync(string value){}protected override void FooAsync(string? value){}CS8614接口中定义的成员中的 null 性与实现中成员的 null 型不匹配。具体来说，你的接口中允许为 null，但是实现中却不允许为 null。CS8616接口中定义的成员中的 null 性与实现中成员的 null 型不匹配。具体来说，你的接口中不允许为 null，但是实现中却允许为 null。CS8618未初始化不可以为 null 的字段 “_walterlv”。如果一个类型中存在不可以为 null 的字段，那么需要在构造函数中初始化，如果没有初始化，则会发出警告或者异常。CS8619一个类型与构造这个类型的 null 性不匹配。例如：Task&amp;lt;object?&amp;gt; foo = new Task&amp;lt;object&amp;gt;(() =&amp;gt; new object());CS8622委托定义的参数中引用类型的为 null 性与目标委托不匹配。比如你定义了一个委托：void Foo(object? sender, EventArgs e);然而在订阅事件的时候，使用的函数 null 性不匹配，则会出现警告：void OnFoo(object sender, EventArgs e){ // 注意到这里的 object 本应该写作 object?}CS8625无法将 null 文本转换为非 null 引用或无约束类型参数。void Foo(string walterlv = null){}CS8653对于泛型 T，使用 default 设置其值。如果 T 是引用类型，那么 default 就会将这个泛型类型赋值为 null。然而并没有将泛型 T 的使用写为 T?。" }, { "title": "git subtree 的使用", "url": "/post/git-subtree-usage.html", "categories": "", "tags": "git", "date": "2020-04-17 15:01:24 +0800", "snippet": "本文收集 git subtree 的使用。将 B 仓库添加为 A 仓库的一个子目录在 A 仓库的根目录输入命令：$ git subtree add --prefix=SubFolder/B https://github.com/walterlv/walterlv.git master这样，B 仓库的整体，会被作为 A 仓库中一个 SubFolder/B 的子文件夹，同时保留 B 仓库中的整个日志记录。从 A 仓库中分离出一个子文件夹成为 B 仓库在 A 仓库的根目录输入命令：git subtree split --prefix=SubFolder/B -b b-branch这样，SubFolder/B 文件夹便会被分离到新创建的 b-branch 分支。随后，如果你需要将分离的子文件夹推送到新仓库的话，直接将这个分支推送过去就可以了。将 A 仓库中的 B 子目录推送回 B 仓库$ git subtree push --prefix=SubFolder/B https://github.com/walterlv/walterlv.git master当然，如果你经常需要使用 subtree 命令，还是建议将那个远端设置一个别名，例如设置 walterlv：$ git remote add walterlv https://github.com/walterlv/walterlv.git那么，上面的命令可以简单一点：$ git subtree push --prefix=SubFolder/B walterlv master后面，我们命令都会使用新的远端名称。将 B 仓库中的新内容拉回 A 仓库的子目录$ git subtree pull --prefix=SubFolder/B walterlv master" }, { "title": "通过子类化窗口（SubClass）来为现有的某个窗口添加新的窗口处理程序（或者叫钩子，Hook）", "url": "/post/hook-a-window-by-sub-classing-it.html", "categories": "", "tags": "win32, dotnet, csharp", "date": "2020-04-14 08:19:29 +0800", "snippet": "创建窗口的时候，可以传一个消息处理函数。然而如果窗口不是自己创建的，还能增加消息处理函数吗？答案是可以的，除了 SetWindowsHookEx 来添加钩子之外，更推荐用子类化的方式来添加。本文介绍如何通过子类化（SubClass）的方式来为窗口添加额外的消息处理函数。子类化子类化的本质是通过 SetWindowLong 传入 GWL_WNDPROC 参数。SetWindowLong 的 API 如下：LONG SetWindowLongA( HWND hWnd, int nIndex, LONG dwNewLong);nIndex 指定为 GWL_WNDPROC，在此情况下，后面的 dwNewLong 就可以指定为一个函数指针，返回值就是原始的消息处理函数。对于 .NET/C# 来说，我们需要拿到窗口句柄，拿到一个消息处理函数的指针。窗口句柄在不同的 UI 框架拿的方法不同，WPF 是通过 HwndSource 或者 WindowInteropHelper 来拿。而将委托转换成函数指针则可通过 Marshal.GetFunctionPointerForDelegate 来转换。你可别吐槽 WPF 另有它法来加消息处理函数啊！本文说的是 Win32，方法需要具有普适性。特别是那种你只能拿到一个窗口句柄，其他啥也不知道的窗口。var hWnd = new WindowInteropHelper(this).EnsureHandle();var wndProc = Marshal.GetFunctionPointerForDelegate&amp;lt;WndProc&amp;gt;(OnWndProc);_originalWndProc = SetWindowLongPtr(hWnd, GWL_WNDPROC, wndProc);IntPtr OnWndProc(IntPtr hWnd, uint msg, IntPtr wParam, IntPtr lParam){ // 在这里处理消息。}将完整的代码贴下来，大约是这样：public partial class MainWindow : Window{ public MainWindow() { InitializeComponent(); SourceInitialized += MainWindow_SourceInitialized; } private void MainWindow_SourceInitialized(object sender, EventArgs e) { var hWnd = new WindowInteropHelper(this).EnsureHandle(); _wndProc = OnWndProc; var wndProc = Marshal.GetFunctionPointerForDelegate&amp;lt;WndProc&amp;gt;(_wndProc); _originalWndProc = SetWindowLongPtr(hWnd, GWL_WNDPROC, wndProc); } private WndProc _wndProc; private IntPtr _originalWndProc; private IntPtr OnWndProc(IntPtr hWnd, uint msg, IntPtr wParam, IntPtr lParam) { switch (msg) { case WM_NCHITTEST: return CallWindowProc(_originalWndProc, hWnd, msg, wParam, lParam); default: return CallWindowProc(_originalWndProc, hWnd, msg, wParam, lParam); } }}其中，我将委托存成了一个字段，这样可以避免 GC 回收掉这个委托对象造成崩溃。在示例的消息处理函数中，我示例处理了一下 WM_NCHITTEST（虽然依然什么都没做）。最后，必须调用 CallWindowProc 以调用此前原来的那个消息处理函数。最后，如果你又不希望处理这个消息了，那么使用以下方法注销掉这个委托：// 嗯，没错，就是前面更换消息处理函数时返回的那个指针。SetWindowLongPtr(hWnd, GWL_WNDPROC, _originalWndProc);上面需要的所有的 P/Invoke 我都贴到了下面，需要的话放到你的代码当中。private static IntPtr SetWindowLongPtr(IntPtr hWnd, int nIndex, IntPtr dwNewLong){ if (IntPtr.Size == 8) { return SetWindowLongPtr64(hWnd, nIndex, dwNewLong); } else { return new IntPtr(SetWindowLong32(hWnd, nIndex, dwNewLong.ToInt32())); }}[DllImport(&quot;user32.dll&quot;, EntryPoint = &quot;SetWindowLong&quot;)]private static extern int SetWindowLong32(IntPtr hWnd, int nIndex, int dwNewLong);[DllImport(&quot;user32.dll&quot;, EntryPoint = &quot;SetWindowLongPtr&quot;)]private static extern IntPtr SetWindowLongPtr64(IntPtr hWnd, int nIndex, IntPtr dwNewLong);[DllImport(&quot;user32.dll&quot;)]static extern IntPtr CallWindowProc(IntPtr lpPrevWndFunc, IntPtr hWnd, uint Msg, IntPtr wParam, IntPtr lParam);private delegate IntPtr WndProc(IntPtr hWnd, uint msg, IntPtr wParam, IntPtr lParam);private const int GWL_WNDPROC = -4;private const int WM_NCHITTEST = 0x0084;private const int HTTRANSPARENT = -1;其他方法本文一开始说到了使用 SetWindowsHookEx 的方式来添加钩子，具体你可以阅读我的另一篇博客来了解如何实现： .NET/C# 使用 SetWindowsHookEx 监听鼠标或键盘消息以及此方法的坑 - walterlv参考资料 Using Window Procedures - Win32 apps - Microsoft Docs" }, { "title": "当无边框窗口被子窗口遮挡导致难以调节窗口大小时，可通过处理 NCHITTEST 消息重新支持调节窗口大小", "url": "/post/handle-nchittest-message-to-support-resize-even-if-window-is-covered-with-child-windows.html", "categories": "", "tags": "windows, dotnet, csharp", "date": "2020-04-11 20:32:30 +0800", "snippet": "做无边框窗口之后，我们有方法可以让窗口的标题栏区域和边缘调大小的区域继续正常工作，直到——这个窗口上面覆盖了其他的子窗口。这个子窗口会吃掉消息导致父窗口的边缘无法再继续处理这些消息。子窗口遮挡了父窗口看一下下面的动画，这个窗口的下半部分放了一个子窗口。然后尝试在边缘调节窗口尺寸，会发现被子窗口覆盖的部分是无法完成窗口大小调节的。究其原因，是子窗口处理掉了与调窗口大小相关的消息，导致父窗口完全不知道应该如何处理这个时候的操作。在子窗口处理消息循环在我的另一篇博客中，我有提到通过处理 WM_NCHITTEST 消息，返回 HT_RIGHT 等来实现支持 Windows 原生窗口功能的效果。然而那种方法是不适用于本文的场景的，如果你试试就会发现，那种方法会使得你只能调子窗口的大小，对父窗口无济于事。正确的处理方法是当鼠标划过原本应该处在非客户区部分的时候，将消息交给父窗口处理。于是，我们需要在消息循环的处理中返回 HTTRANSPARENT 来告诉操作系统这个区域子窗口不处理消息，请交给父窗口。这里，我以 WPF 的消息循环来写代码。因为只要是 Windows 平台的 UI 框架都有消息循环的处理，所以可以很容易迁移到其他框架甚至是其他语言。public partial class ChildWindow : Window{ public ChildWindow() { InitializeComponent(); SourceInitialized += ChildWindow_SourceInitialized; } private async void ChildWindow_SourceInitialized(object sender, EventArgs e) { var helper = new WindowInteropHelper(this); var source = HwndSource.FromHwnd(helper.Handle); source.AddHook(WndProc); } private IntPtr WndProc(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam, ref bool handled) { const int WM_NCHITTEST = 0x0084; const int HTTRANSPARENT = -1; switch (msg) { case WM_NCHITTEST: // 这里，我强行让所有区域返回 HTTRANSPARENT，于是整个子窗口都交给父窗口处理消息。 // 正常，你应该在这里计算窗口边缘。 handled = true; return new IntPtr(HTTRANSPARENT); default: break; } return IntPtr.Zero; }}上面的代码会比较简化，因为我让子窗口的所有区域都返回 HTTRANSPARENT，这会让整个子窗口区域的消息都不由子窗口处理。如果需要使用这段代码的话，你需要自己判断窗口的边缘。如果需要得到当前坐标的话，可以把下面的方法加入到你的项目中：public static (int lowOrder, int highOrder) GetOrderWord(IntPtr value){ int low = unchecked((short) (long) value); int high = unchecked((short) ((long) value &amp;gt;&amp;gt; 16)); return (low, high);}于是将消息循环中的 lParam 传入可以获得当前的坐标（屏幕坐标系）：// 获得当前基于屏幕坐标系的当前鼠标光标位置。var (x, y) = GetOrderWord(lParam);需要注意一些坑当你准备使用返回 HTTRANSPARENT 时，一定要保证你坐标所在的父子窗口在同一个线程！返回 HTTRANSPARENT 时，操作系统只会查找同线程的其他窗口，如果你的父窗口非同一个线程，那么操作系统处理消息循环时是找不到下一个处理消息的窗口的。如果你一定要在父窗口非同一个线程时返回 HTTRANSPARENT 那么你的整个窗口（顶层窗口和子窗口）将无法再操作！你可以阅读 HTTRANSPARENT is evil - virtualdub.org 了解相关的坑。参考资料 WM_NCHITTEST message (Winuser.h) - Win32 apps - Microsoft Docs multithreading - WM_NCHITTEST and HTTRANSPARENT blocks input from message loop - Stack Overflow WM_NCHITTEST and HTTRANSPARENT blocks input from message loop - multithreading Click through window with image (WPF) issues (HTTRANSPARENT isn’t working) HTTRANSPARENT is evil - virtualdub.org c++ - how to move parent window without border from child using WM_NCHITTEST - Stack Overflow winapi - Win api in C#. Get Hi and low word from IntPtr - Stack Overflow" }, { "title": "Windows 系统的默认字体是什么？应用的默认字体是什么？", "url": "/post/windows-default-font-family.html", "categories": "", "tags": "windows", "date": "2020-04-11 09:48:31 +0800", "snippet": "作为中文应用的开发者，我们多半会认为系统的默认字体是“微软雅黑”。然而如果真的产生了这种误解，则很容易在开发本地化应用的时候踩坑。于是本文带你了解 Windows 系统的默认字体。Windows 10/8.1/8/7/VistaWindows 操作系统的默认字体是 Segoe UI（发音为 see go 这两个单词），默认的字体大小为 9 点。Segoe UI 是 Segoe 字体家族中专为显示器显示而设计的一款字体。当然，Windows 系统中的其他字体也遵循这一命名规则，带 UI 后缀的适用于界面显示，而不带 UI 后缀的适用于打印和其他排版设计。Segoe UI包含拉丁（Latin），希腊（Greek），西里尔字母（Cyrillic）和阿拉伯（Arabic）字符，覆盖了基本的英文俄文字母、数字和一些常用符号。然而其他语言就没有了。其他语言的默认字体分别是： 语言 字体 日语（Japanese） Yu Gothic UI 韩语（Korean） Malgun Gothic 繁体中文（Chinese (Traditional)） Microsoft JhengHei 简体中文（Chinese (Simplified)） Microsoft YaHei 希伯来语（Hebrew） Gisha 泰语（Thai） Leelawadee [注] 经 神樹桜乃 指出，日语系统默认字体是 Yu Gothic UI 而不是 Meiryo。Windows 操作系统在启动应用程序的时候，会根据当前系统用户的地区决定默认字体应该采用哪一个。Windows XP 及更早系统早期版本的 Windows，默认字体是 Tahoma。简体中文下则是宋体。参考资料 Fonts - Win32 apps - Microsoft Docs" }, { "title": "如何给 GitHub Pages 配置多个域名？", "url": "/post/multiple-domains-for-github-pages.html", "categories": "", "tags": "github", "date": "2020-04-10 15:02:52 +0800", "snippet": "因为以前对域名进行了一些调整，所以实际上我的博客在历年来经历了两个域名 blog.walterlv.com（新）和 walterlv.com（旧）。然而 GitHub Pages 只支持一个自定义域名，所以为了兼容旧域名的访问，如何可以让多个域名对应同一个 GitHub Pages 呢？背景 （新） walterlv.com （旧）以前不会碰到这样的问题，是因为我并没有使用 GitHub Pages 服务来构建博客，然而现在是了。GitHub Pages 识别访问的是哪个站点的方式是识别 xxx.github.io 的 xxx 部分，比如默认我只能通过 来访问到我通过 GitHub Pages 搭建的博客。因此如果你使用反向代理服务器将一个其他的域名代理到 xxx.github.io 是会得到 404 的——GitHub Pages 不知道你想访问哪个站点。这时，在 GitHub Pages 设置里面，你就需要设置一个 Custom domain 来帮助 GitHub Pages 部署的时候知道某个域名实际上是你的，需要用来显示此仓库的 GitHub Pages。比如我在这里设置了 ，于是当我将反向代理服务器代理到 walterlv.github.io 时，GitHub Pages 便能正确得知这实际上是 walterlv.github.io 这个仓库的，这才能正确显示 GitHub Pages 页面。此设置会在你的仓库根目录生成 CNAME 文件，里面仅一行文本，即域名 。然而问题来了，我之前的域名实际上是 walterlv.com，这样，当我设置 DNS 时，如果直接将 walterlv.com 设置到 walterlv.github.io 依然会出现 404。接下来我们说说解决办法。通过中转仓库我们需要在 GitHub 上再新建一个仓库，用来中转旧域名中的访问到新的域名。第一步：新建随意名字的仓库我们新建一个仓库。新建的时候实际上可以无所谓命名，因为这个仓库里面不会真的有内容，多数时候访问实际上是 404 的。但我们创建它只是为了前面提到的那个 CNAME 文件，告诉 GitHub Pages 我们有两个域名而已。这里，我创建了一个名为 oldblog 的仓库，正常情况下，访问这个仓库 GitHub Pages 的域名前缀为 walterlv.github.io/oldblog。第二步：为此仓库添加 GitHub Pages 服务接着，按照平时去创建 GitHub Pages 服务的方法往这个仓库提交代码。例如可以在仓库根目录放一个 _config.yml 文件（这是 Jekyll 的配置文件），然后直接提交：title: walterlvauthor: walterlv当有了一个分支和 Jekyll 的配置文件后，就可以直接使用 GitHub Pages 服务了。在这里，我们将自定义域名填写成旧的域名 walterlv.com。这样，当我们在域名服务器中将 walterlv.com 设置到 walterlv.github.io 时，GitHub Pages 至少知道应该使用这个仓库里的 GitHub Pages 来显示。第三步：创建用于跳转的 404 页面然而我们并不打算在这个仓库里真的放代码/网页，于是在根目录放一个 404.html 文件：&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;utf-8&quot;&amp;gt; &amp;lt;title&amp;gt;正在重定向…… - walterlv&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt; &amp;lt;script language=&quot;javascript&quot;&amp;gt; var domain = &quot;blog.walterlv.com&quot;; var current = window.location.href; var target = current.substring(current.indexOf(&#39;/&#39;, current.indexOf(&#39;:&#39;) + 3)); window.location.href = &quot;//&quot; + domain + target; location.href = &quot;//&quot; + domain + target; &amp;lt;/script&amp;gt; &amp;lt;body&amp;gt; 正在重定向…… &amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;现在，仓库里面是这样的（walterlv/oldblog）：第四步：配置 DNS最后检查你的 DNS 配置： 旧域名：walterlv.com -&amp;gt; walterlv.github.io 新域名： -&amp;gt; walterlv.github.io到现在，就全部完成。不信你试试，点击链接 https://walterlv.com/post/multiple-domains-for-github-pages 会短暂进入一个“正在重定向……”的页面，然后随即跳转到新域名下相同的页面 https://blog.walterlv.com/post/multiple-domains-for-github-pages。原理一个 GitHub Pages 的仓库只能有一个 CNAME 文件，也即我们只能告知 GitHub 我们的一个合理域名。要让 GitHub Pages 支持两个域名，我们不得不建两个仓库，其中第二个仓库的地址为 xxx.walterlv.com/repo-name。在第二个仓库中，我们故意什么都不放，这样会触发 404，我们在 404 页面里面跳转到新的域名即完成了我们的目的。参考资料 多个域名映射同一个github pages - 守望的个人博客" }, { "title": "一点点从坑里爬出来：如何正确打开 WPF 里的 Popup？", "url": "/post/how-to-open-a-wpf-popup.html", "categories": "", "tags": "wpf, dotnet", "date": "2020-04-07 21:34:17 +0800", "snippet": "在 WPF 中打开一个 Popup 并没有想象当中容易。虽说提供了一个 IsOpen 属性用于显示 Popup，但实际上造成的 Bug 会让你解得死去活来。Win32 的 WS_POPUP 也坑，不过 WPF 会额外再带来一些，所以本文只说 WPF。先说结论本文一开始就贴出打开一个 Popup 的代码// 在以下代码中，我们假定 popup 是我们要显示出来的 Popup，而 textBox 是 Popup 中的文本框。private async void WalterlvDemoControl_MouseUp(object sender, MouseButtonEventArgs e){ // 必须延迟打开 Popup，如果在 MouseUp 中打开，会使得 Popup 无法获得焦点。 await Task.Yield(); popup.IsOpen = true; // 必须显式让 Popup 获得焦点，否则内部的 TextBox 输入时，IME 输入框无法跟随。 await Task.Yield(); var source = (HwndSource) PresentationSource.FromVisual(popup.Child); SetFocus(source.Handle); // 必须显式让文本框获得焦点（如果有的话）。 await Task.Yield(); Keyboard.Focus(textBox);}[DllImport(&quot;user32&quot;)]public static extern IntPtr SetFocus(IntPtr hWnd);如果你的 Popup 中没有文本框，那么最后的两段可以删除。接下来一一说明。不要在 MouseUp/Click 事件中打开 PopupPopup 有一个属性 StaysOpen，当设置为 false 时，我们期待的效果是失焦后 Popup 关闭。然而如果你是在任何控件的 MouseUp 事件中打开的，那么 Popup 就不会获得焦点。既然不会获得焦点，那么也就不存在失焦的问题。具体表现为，你打开了 Popup 后，Popup 不会自己再自动关闭了，除非你手动在 Popup 内部点一下让 Popup 获得焦点，随后才会自动关闭。无论你在后面如何写让 Popup 以及内部控件获得焦点的代码，实际上这种情况下弹出的 Popup 不会真正获得焦点，除非手动点击。所以我在以上代码中加上了 await Task.Yield() 这样可以让后续的代码不再在 MouseUp 事件中。如果你的 Popup 中没有文本框，那么这样做就够了；如果有，那么还需要做后续处理。需要显式为 Popup 设置焦点注意注意，如果你的 Popup 中包含文本框，那么一定需要加上 SetFocus 的调用。WPF 版本的设置焦点，无论是逻辑焦点（xx.Focus()）还是键盘焦点（Keyboard.Focus(xx)）都无法真正让 Popup 获得焦点。这时打字，IME 框是不会跟随文本框的。需要单独为 TextBox 再设置焦点只是为 Popup 设置焦点的话，Popup 中的文本框没有获得焦点，是不能直接打字的。当然你可能需求如此。这里就没有特别说明的点了。" }, { "title": "VSCode：当匹配到结果时，如何一次性全部选中操作（复制/删除）？", "url": "/post/how-to-select-all-matched-search-result-in-vscode.html", "categories": "", "tags": "vscode", "date": "2020-04-07 20:48:11 +0800", "snippet": "最近需要处理几十万行的文字，然后提取出数千行（嗯，我在做输入法词库）。在 VSCode 里我用正则匹配到了想要的结果后，如何能够快速把这些行提取出来呢？其实非常简单，Alt + Enter 即可选中所有已经匹配到的文字。来，我们看这个具体的例子：这里有一个几十万行的词库，我需要将其中的英文部分提取出来做成单独的词库。于是我使用正则表达式，匹配到所有英文词。接着，按下 Alt + Enter 我就可以复制出所有的已匹配的词。将其粘贴出来即形成新的纯英文词库。" }, { "title": "WPF：无法对元素“XXX”设置 Name 特性值“YYY”。“XXX”在元素“ZZZ”的范围内，在另一范围内定义它时，已注册了名称。", "url": "/post/cannot-set-name-attribute-value-on-element-using-wpf.html", "categories": "", "tags": "wpf, dotnet", "date": "2020-04-03 14:44:21 +0800", "snippet": "最近在改一段 XAML 代码时，我发现无论如何给一个控件添加 Name 或者 x:Name 属性时都会出现编译错误：无法对元素“XXX”设置 Name 特性值“YYY”。“XXX”在元素“ZZZ”的范围内，在另一范围内定义它时，已注册了名称。编译错误编译时，出现错误： 无法对元素“XXX”设置 Name 特性值“YYY”。“XXX”在元素“ZZZ”的范围内，在另一范围内定义它时，已注册了名称。 MC3093: Cannot set Name attribute value ‘X’ on element ‘Y’. ‘Y’ is under the scope of element ‘Z’, which already had a name registered when it was defined in another scope.这里的 XXX 是元素的类型，YYY 是指定的名称的值，ZZZ 是父容器的名称。我把出现错误的 XAML 简化后大约是这样的，XXX 是 TextBox，YYY 是 RenameTextBox，而 ZZZ 是 walterlv:Foo。&amp;lt;walterlv:Foo Background=&quot;White&quot;&amp;gt; &amp;lt;StackPanel Orientation=&quot;Horizontal&quot; Focusable=&quot;False&quot;&amp;gt; &amp;lt;TextBlock Text=&quot;名称：&quot; /&amp;gt; &amp;lt;TextBox x:Name=&quot;RenameTextBox&quot; /&amp;gt; &amp;lt;/StackPanel&amp;gt;&amp;lt;/walterlv:Foo&amp;gt;小心用户控件出现此问题的最大原因在那个 walterlv:Foo 上。实际上，这是一个用户控件，也就是继承自 UserControl 的大家通常用来写界面的东西。&amp;lt;UserControl x:Class=&quot;Walterlv.Foo&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;&amp;gt; &amp;lt;UserControl.Style&amp;gt; &amp;lt;!-- 省略 --&amp;gt; &amp;lt;/UserControl.Style&amp;gt;&amp;lt;/UserControl&amp;gt;别问我为什么会有以上这样诡异的代码。我也不知道，这只是偶然发现的代码，我简化后拿到博客中。于是需要提醒大家注意： 在 WPF 里，拥有直接的 XAML 文件的始终应该作为最终用户界面，不应该当作控件使用（不要试图在其他地方使用时还设置其 Content 属性）； 如果你确实希望做控件，请继承自 CustomControl 然后在 /Themes/Generic.xaml 里写样式。至于以上 XAML 代码中我看到用的是 &amp;lt;UserControl.Style&amp;gt; 来写样式，是因为踩到了当控件用的另一个坑：所有在控件的 XAML 中设置的 Content 属性都将被使用时覆盖。解决方法当然是考虑将以上诡异的用户控件定义方式改为正统的 CustomControl 啦！将 &amp;lt;UserControl.Style&amp;gt; 里定义的所有样式全部改到 /Themes/Generic.xaml 文件中。如果你不清楚如何编写一个自定义控件，那么请直接在 Visual Studio 中基于 WPF 自定义控件创建文件，你会发现 Visual Studio 为你写好了注释。using System;using System.Collections.Generic;using System.Text;using System.Windows;using System.Windows.Controls;using System.Windows.Data;using System.Windows.Documents;using System.Windows.Input;using System.Windows.Media;using System.Windows.Media.Imaging;using System.Windows.Navigation;using System.Windows.Shapes;namespace Walterlv.Demo{ /// &amp;lt;summary&amp;gt; /// 按照步骤 1a 或 1b 操作，然后执行步骤 2 以在 XAML 文件中使用此自定义控件。 /// /// 步骤 1a) 在当前项目中存在的 XAML 文件中使用该自定义控件。 /// 将此 XmlNamespace 特性添加到要使用该特性的标记文件的根 /// 元素中: /// /// xmlns:MyNamespace=&quot;clr-namespace:Walterlv.Demo&quot; /// /// /// 步骤 1b) 在其他项目中存在的 XAML 文件中使用该自定义控件。 /// 将此 XmlNamespace 特性添加到要使用该特性的标记文件的根 /// 元素中: /// /// xmlns:MyNamespace=&quot;clr-namespace:Walterlv.Demo;assembly=Walterlv.Demo&quot; /// /// 您还需要添加一个从 XAML 文件所在的项目到此项目的项目引用， /// 并重新生成以避免编译错误: /// /// 在解决方案资源管理器中右击目标项目，然后依次单击 /// “添加引用”-&amp;gt;“项目”-&amp;gt;[浏览查找并选择此项目] /// /// /// 步骤 2) /// 继续操作并在 XAML 文件中使用控件。 /// /// &amp;lt;MyNamespace:Foo/&amp;gt; /// /// &amp;lt;/summary&amp;gt; public class Foo : Control { static Foo() { DefaultStyleKeyProperty.OverrideMetadata(typeof(Foo), new FrameworkPropertyMetadata(typeof(Foo))); } }}/Themes/Generic.xaml 文件：&amp;lt;ResourceDictionary xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:local=&quot;clr-namespace:Walterlv.Demo&quot;&amp;gt; &amp;lt;Style TargetType=&quot;{x:Type local:Foo}&quot;&amp;gt; &amp;lt;Setter Property=&quot;Template&quot;&amp;gt; &amp;lt;Setter.Value&amp;gt; &amp;lt;ControlTemplate TargetType=&quot;{x:Type local:Foo}&quot;&amp;gt; &amp;lt;Border Background=&quot;{TemplateBinding Background}&quot; BorderBrush=&quot;{TemplateBinding BorderBrush}&quot; BorderThickness=&quot;{TemplateBinding BorderThickness}&quot;&amp;gt; &amp;lt;/Border&amp;gt; &amp;lt;/ControlTemplate&amp;gt; &amp;lt;/Setter.Value&amp;gt; &amp;lt;/Setter&amp;gt; &amp;lt;/Style&amp;gt;&amp;lt;/ResourceDictionary&amp;gt;" }, { "title": "在 Visual Studio 2019 (16.5) 中查看托管线程正在等待的锁被哪个线程占用", "url": "/post/view-which-managed-thread-is-holding-a-dotnet-object-lock-using-visual-studio.html", "categories": "", "tags": "dotnet, visualstudio", "date": "2020-04-02 17:44:31 +0800", "snippet": "Visual Studio 2019 (16.5) 版本更新中带来了一项很小很难注意到却非常实用的功能，查看哪一个托管线程正在持有 .NET 对象锁。如果你不了解这个功能如何使用，那么可以阅读本文。更新日志Visual Studio 的官方更新日志中对此功能的描述： View which managed thread is holding a .NET object lock即“查看托管线程正在持有 .NET 对象锁”。功能入口这个功能没有新的入口，你可以在“调用堆栈” (Call Stack) 窗口，“并行堆栈” (Parallel Stacks) 窗口，以及“线程”窗口的位置列中查看哪个托管线程正在持有 .NET 对象锁。Call Stack示例现在我们就实际看一下这个功能的用法和效果。于是我写了一点下面的代码。static void Main(string[] args){ var locker = new object(); Thread thread = new Thread(() =&amp;gt; { Console.WriteLine(&quot;后台线程尝试获得锁&quot;); lock (locker) { Console.WriteLine(&quot;后台线程成功获得锁&quot;); } }) { Name = &quot;walterlv thread&quot;, }; Console.WriteLine(&quot;主线程尝试获得锁&quot;); Monitor.Enter(locker); Console.WriteLine(&quot;主线程成功获得锁&quot;); thread.Start();}在这段代码中，主线程获得锁之后直接退出，而新线程“walterlv thread”则尝试获得锁。现在在 Visual Studio 2019 中运行这段代码，可以看到另一个线程是不可能获得锁的，于是不会输出最后那一句，其他都会输出。随后我们在 Visual Studio 中点击“全部中断”，也就是那个“暂停”图标的按钮。打开调用堆栈窗口（在“调试 -&amp;gt; 窗口 -&amp;gt; 调用堆栈”），可以看到堆栈最顶端显示了正在等待锁，并且指出了线程对象。然后在线程窗口（在“调试 -&amp;gt; 窗口 -&amp;gt; 线程“）的位置列，鼠标移上去可以看到与堆栈中相同的信息。当然，我们的主线程实际上早已直接退出了，所以正在等待的锁将永远不会释放（除非进程退出）。同样的信息，在并行堆栈（在“调试 -&amp;gt; 窗口 -&amp;gt; 并行堆栈”）中也能看到。参考资料 Visual Studio 2019 version 16.5 Release Notes - Microsoft Docs Visual Studio 2019 version 16.5 is now available - Visual Studio Blog" }, { "title": "WPF 中如何绑定附加属性？XAML 中记得加括号，C# 中记得不能用字符串", "url": "/post/how-to-bind-attached-properties-in-wpf.html", "categories": "", "tags": "wpf, dotnet", "date": "2020-04-01 20:35:51 +0800", "snippet": "在 XAML 中写绑定是 WPF 学习的必修课，进阶一点的，是用 C# 代码来写绑定。然而一旦绑定的属性是附加属性，好多小伙伴就会开始遇到坑了。本文将介绍如何在 XAML 和 C# 代码中绑定附加属性。背景代码开始遇到这个问题的背景是我定义了一个附加属性，然后试图通过绑定的方式完成一些业务。用附加属性来完成的很大一个好处在于不需要改动原有的代码破坏原来的类。例如我只需要在任何一个类中定义 IsDraggable 附加属性，就可以让我其他地方的 Grid Button 等支持拖拽。public class DraggableElement : FrameworkElement{ static TabViewItem() { DefaultStyleKeyProperty.OverrideMetadata(typeof(DraggableElement), new FrameworkPropertyMetadata(typeof(DraggableElement))); } public static readonly DependencyProperty IsDraggableProperty = DependencyProperty.RegisterAttached( &quot;IsDraggable&quot;, typeof(bool), typeof(TabViewItem), new PropertyMetadata(true)); public static bool GetIsDraggable(DependencyObject item) =&amp;gt; (bool) item.GetValue(IsDraggableProperty); public static void SetIsDraggable(DependencyObject obj, bool value) =&amp;gt; obj.SetValue(IsDraggableProperty, value);}在 XAML 中绑定附加属性在 XAML 中绑定附加属性的时候需要加上括号和类型的命名空间前缀：&amp;lt;ListViewItem Content=&quot;{Binding (local:DraggableElement.IsDraggable), RelativeSource={RelativeSource Self}}&quot; local:DraggableElement.IsDraggable=&quot;True&quot; /&amp;gt;对于 WPF 内置的命名空间（http://schemas.microsoft.com/winfx/2006/xaml/presentation 命名空间下），是不需要加前缀的。&amp;lt;TextBlock x:Name=&quot;DemoTextBlock&quot; Grid.Row=&quot;1&quot; Text=&quot;{Binding (Grid.Row), RelativeSource={RelativeSource Self}}&quot; /&amp;gt;跟其他的绑定一样，这里并不需要在 Binding 后面写 Path=，因为 Binding 的构造函数中传入的参数就是赋值给 Path 的。在 C# 代码中绑定附加属性上面在说明附加属性绑定的时候我特地额外写了一个不需要写命名空间的 XAML 绑定附加属性的代码，这是为了说明接下来写 C# 代码时的注意事项。是这样写吗？// 给不看全文的小伙伴：这段代码是无法工作的！正常工作的在后文。Binding binding = new Binding(&quot;(Grid.Row)&quot;){ Source = DemoTextBlock,}BindingOperations.SetBinding(DemoTextBlock, TextBox.TextProperty, binding);设想应该不是，因为 C# 代码中是没有命名空间前缀的，于是对于前面 XAML 中 (local:DraggableElement.IsDraggable) 的 local 部分就很不好处理。实际上，这里的字符串即便是写成 System.Windows.Grid.Row 和 Walterlv.BindingDemo.DraggableElement.IsDraggable 也依然会绑定失败。在 C# 代码中绑定附加属性，需要 使用依赖项属性，而不能使用字符串！Binding binding = new Binding{ Source = DemoTextBlock, Path = new PropertyPath(Grid.RowProperty),}BindingOperations.SetBinding(DemoTextBlock, TextBox.TextProperty, binding);Binding binding = new Binding{ Source = DemoDraggableElement, Path = new PropertyPath(DraggableElement.IsDraggableProperty),}BindingOperations.SetBinding(DemoDraggableElement, TextBox.TextProperty, binding);因此需要特别注意，附加属性的绑定不再能使用字符串，需要使用依赖项属性。参考资料 Binding to an Attached Property" }, { "title": "设置用户无需密码自动登录到 Windows 系统", "url": "/post/automatically-sign-in-windows.html", "categories": "", "tags": "windows", "date": "2020-03-23 11:36:48 +0800", "snippet": "你一定要为你的 Windows 用户账户设置密码，一来会安全一些，而来可以远程登录使用；但有时出于一些特殊的目的，不希望在每次开机后都必须输入密码才能进入系统。于是你可以使用本文提供的方法在每次开机的时候免密码登录到 Windows 操作系统。步骤 在 Windows 搜索框中输入 netplwiz，然后回车打开命令； 去掉“要使用本计算机，用户必须输入用户名和密码”的勾勾； 点击“确定”或“应用”后，输入自动登录账号的用户名和密码。注意，输入用户名和密码的时候，如果你使用了微软账号登录，那么需要输入你的微软账号，比如这样“walterlv@outlook.com”；而密码是你微软账号的密码，而不是 PIN 码。Windows 10 截图Windows 7 截图" }, { "title": "修复 Windows 10 设置界面里面混乱的语言翻译", "url": "/post/fix-chaotic-language-of-windows-10-settings.html", "categories": "", "tags": "windowes", "date": "2020-03-23 11:35:35 +0800", "snippet": "Windows 10 每次新发布一个版本都会遇到各种各样的新型 Bug。本文介绍的是 Windows 10 的设置界面里面，各种各样的语言文字都很混乱，就像统一错位了一样。本文也会同时介绍其修复方法。系统版本会出现此问题的系统是 Windows 10 英文版系统。注意，是 Windows 10 英文版系统，而不是中文版系统的英文语言。如果你想要识别这样的系统的话，也很简单，使用你的系统安装程序，安装程序中界面使用的语言就是此系统的原生语言。如果在安装完此英文版系统后再安装中文语言，就可能会出现中文语言混乱的问题。混乱的界面先看看下面的两张图：可以注意到，界面当中出现了很多本不应该出现在那个地方的文案。如果我们这个时候让设置界面弹出一个对话框出来，你还会看到对话框中的文字超出范围导致布局错乱呢：按钮都不知道被裁成什么样了。修复方法经过我的多次尝试，发现，英文版系统安装中文语言包，第一次几乎必定失败，然后出现本文所述的问题。解决方法是这样的： 将语言切换回英文 删除中文语言包 删除下载缓存文件 重新下载中文语言包下面详细说明。将语言切换回英文进入“系统设置 -&amp;gt; 时间和语言 -&amp;gt; 语言”，通过点击上箭头的方式将英语语言置顶，同时将显示语言切换成英语。删除中文语言包以管理员权限启动 PowerShell，然后输入 Get-WinUserLanguageList 命令，以获取我们要删除的语言的 LanguageTag。PS C:\\Windows\\system32&amp;gt; Get-WinUserLanguageListLanguageTag : en-USAutonym : English (United States)EnglishName : EnglishLocalizedName : English (United States)ScriptName : LatinInputMethodTips : {0409:00000409}Spellchecking : TrueHandwriting : FalseLanguageTag : zh-Hans-CNAutonym : 中文(中华人民共和国)EnglishName : ChineseLocalizedName : Chinese (Simplified, China)ScriptName : Chinese (Simplified)InputMethodTips : {0804:{81D4E9C9-1D3B-41BC-9E6C-4B40BF79E35E}{FA550B04-5AD7-411F-A5AC-CA038EC515D7}}Spellchecking : TrueHandwriting : True然后，依次输入以下四句命令，获取语言列表，筛选我们要删除的语言，删除筛选出的语言，设置回列表。PS C:\\Windows\\system32&amp;gt; $LangList = Get-WinUserLanguageListPS C:\\Windows\\system32&amp;gt; $ToDeletedLang = $LangList | where LanguageTag -eq &quot;zh-Hans-CN&quot;PS C:\\Windows\\system32&amp;gt; $LangList.Remove($ToDeletedLang)TruePS C:\\Windows\\system32&amp;gt; Set-WinUserLanguageList $LangList -Force删除下载缓存文件进入文件夹“C:\\Windows\\SoftwareDistribution\\Download”，删除里面的所有文件和文件夹。随后，重新启动计算机。重新下载中文语言包现在，按照正常的安装中文语言包的方式再安装一次语言包。即“Settings -&amp;gt; Time &amp;amp; Language -&amp;gt; Language -&amp;gt; Add a preferred language”，然后选择中文，下一步 -&amp;gt; 安装。等待安装结束。等安装进度条全部结束之后，再选择现实语言为“中文”即可。" }, { "title": "使用 SoftEther VPN 在 VPS 和个人电脑之间搭建 VPN 网络", "url": "/post/build-vpn-on-vps-using-soft-ether.html", "categories": "", "tags": "linux, network", "date": "2020-03-23 11:35:30 +0800", "snippet": "VPN 全称是 Virtual Private Network（虚拟专用网络），可以在多台设备之间建立安全的通信网络。VPS 是 Virtual Private Server，虚拟专用服务器，指的是一台虚拟的电脑，用于提供服务。注意，本文不会谈及科学上网相关的内容。本文建立 VPN 网络单纯是为了对外提供服务。VPN 虚拟专用网络为什么我们需要一个 VPS为了对公众提供服务，我们需要： 一台 24×7 小时不关机的计算机 一个可被互联网访问到的 IP（公网 IP）对个人家用电脑来说，你可以做到 24 小时不关机，但你拿不到一个稳定的公网 IP。中国电信可以在办网的时候提供公网 IP，但此 IP 会经常改变，因此几乎无法对外提供服务。虽然可以使用 DDNS（动态域名解析服务），但因为域名解析存在缓存，所以当 IP 改变的时候，你会有数分钟到数小时不等的时间无法访问到正确的 IP。因此，个人电脑是无法稳定对外提供服务的——我们需要一个 VPS——它有固定的公网 IP。反向代理实际上，只需要一个 VPS 我们就能直接对外提供服务了——将服务部署到 VPS 上就可以。但我们也可以将服务部署到另一台计算机上，甚至这台计算机可以没有公网 IP。于是 VPS 上只需要部署一个反向代理服务器即可。如果使用 FRP 这种反向代理服务器，那么不需要固定公网 IP 就能反向代理。然而 FRP 也有一些不能满足的要求，这时部署反向代理服务器，我们需要真实提供服务的计算机也具有固定的 IP。而 VPN 网络可以提供这一点。虚拟专用网络（VPN）如果我们将 VPS 和其他散布在内网或者非固定 IP 的公网计算机连接起来，组成一个专用的网络，那么这个就是“虚拟专用网络”（VPN）。这样，无论这些电脑散布在哪些地方，在哪些网络中，对于对方来说都是“内网”中的另一台电脑，这是可以有固定（内网）IP 的，于是可以做很多事情。我画了一张简单的图来描述一个简单的 VPN 网络。接下来，本文将介绍如何搭建一个如图所示的 VPN 网络。VPS 端 - 服务端以 Debian 系统的 VPS 为例，除了包管理工具和文本编辑工具，其他各种操作都是大同小异。我们要在 VPS 端安装一个 SoftEther 的服务端和一个客户端。服务端用于连接整个 VPN 网络，而客户端用于将此 VPS 主机组成此 VPN 网络中的第一台计算机。下载 SoftEther VPN下载地址 Download - SoftEther VPN Project下载有很多的种类可选。考虑到我们会部署到多台计算机上，所以建议选择最末尾的一个 ZIP CD-ROM Image Package of SoftEther VPN。这样，我们可以从一个文件夹中取出所有我们想要的运行环境。安装 SoftEther VPN Server在安装 SoftEther VPN 的服务端之前，我们需要确保你的 Linux 系统上有这些工具： make gcc net-tools如果是 Debian 系统，可以运行命令安装：apt-get install makeapt-get install gccapt-get install net-tools接下来的安装过程有编译步骤，所以需要用到以上工具。将我们下载下来的 \\VPN-CD-v4.30-9696-beta-2019.07.08\\Linux\\SoftEther_VPN_Server\\64bit_-_Intel_x64_or_AMD64\\softether-vpnserver-v4.30-9696-beta-2019.07.08-linux-x64-64bit\\vpnserver 文件夹上传到 Linux 系统中，建议 /opt/SoftEther 目录，如下：然后，进入 vpnserver 文件夹，运行 .install.sh：cd vpnserverbash .install.sh配置 SoftEther VPN Server 服务现在，前往 /etc/init.d 目录，这个目录存放了各种系统服务的启用和停用脚本。我们需要将 VPN Server 服务放到这个目录下。你可以在官方文档 7.3 Install on Linux and Initial Configurations - SoftEther VPN Project 找到服务脚本。记得将下面 DAEMON 中的路径改成你自己的路径。改好之后，命名成 vpnserver，放到 /etc/init.d 目录下。#!/bin/sh# chkconfig: 2345 99 01# description: SoftEther VPN ServerDAEMON=/opt/SoftEther/vpnserver/vpnserverLOCK=/var/lock/subsys/vpnservertest -x $DAEMON || exit 0case &quot;$1&quot; instart)$DAEMON starttouch $LOCK;;stop)$DAEMON stoprm $LOCK;;restart)$DAEMON stopsleep 3$DAEMON start;;*)echo &quot;Usage: $0 {start|stop|restart}&quot;exit 1esacexit 0请确保此文件的行尾符是 CL，而不是 Windows 系统中的 CLRF。将此文件放入 /etc/init.d 后，记得修改文件的属性：chmod 755 vpnserver配置 SoftEther VPN Server 开机启动Ubuntu 或者 Debian 系统的开机启动项脚本位于 /etc/rcN.d/ 目录中，我们可以使用以下命令设置其开机启动。update-rc.d vpnserver defaults启动 SoftEther VPN Server使用以下命令启动服务：/etc/init.d/vpnserver startVPS 端 - 客户端VPS 主机也需要安装运行 SoftEther VPN 客户端，这样这台主机才会成为 VPN 网络的其中一台主机。安装方法与服务端非常类似，所以下面的介绍会简略一些。安装 SoftEther VPN Client将我们下载下来的 \\VPN-CD-v4.30-9696-beta-2019.07.08\\Linux\\SoftEther_VPN_Client\\64bit_-_Intel_x64_or_AMD64\\softether-vpnclient-v4.30-9696-beta-2019.07.08-linux-x64-64bit\\vpnclient 文件夹上传到 Linux 系统中，建议 /opt/SoftEther 目录，如下：然后，进入 vpnclient 文件夹，运行 .install.sh：cd vpnclientbash .install.sh配置 SoftEther VPN Client 服务现在，前往 /etc/init.d 目录，这个目录存放了各种系统服务的启用和停用脚本。我们需要将 VPN Client 服务放到这个目录下。记得将下面 DAEMON 中的路径改成你自己的路径。改好之后，命名成 vpnclient，放到 /etc/init.d 目录下。#!/bin/sh# chkconfig: 2345 99 01# description: SoftEther VPN ClientDAEMON=/opt/SoftEther/vpnclient/vpnclientLOCK=/var/lock/subsys/vpnclienttest -x $DAEMON || exit 0case &quot;$1&quot; instart)$DAEMON starttouch $LOCK;;stop)$DAEMON stoprm $LOCK;;restart)$DAEMON stopsleep 3$DAEMON start;;*)echo &quot;Usage: $0 {start|stop|restart}&quot;exit 1esacexit 0将此文件放入 /etc/init.d 后，记得修改文件的属性：chmod 755 vpnclient配置 SoftEther VPN Client 开机启动使用以下命令设置其开机启动。update-rc.d vpnclient defaults启动 SoftEther VPN Client使用以下命令启动服务：/etc/init.d/vpnclient start启动后，会出现一些提示：The SoftEther VPN Server service has been started.Let&#39;s get started by accessing to the following URL from your PC:https://**.**.**.**:5555/ orhttps://**.**.**.**/Note: IP address may vary. Specify your server&#39;s IP address.A TLS certificate warning will appear because the server uses self signed certificate by default. That is natural. Continue with ignoring the TLS warning.这里会提示你 VPN 服务器的 IP 和端口号。我们接下来在配置客户端的时候会用到这个 IP 和端口号。个人电脑端这里个人电脑端我们使用 Windows 系统。安装将我们下载下来的 \\VPN-CD-v4.30-9696-beta-2019.07.08\\Windows\\SoftEther_VPN_Server_and_VPN_Bridge安装服务端管理工具 文件夹打开，运行里面的 exe 安装：▲ 我们将用这个工具来管理我们在 VPS 上部署的 VPN Server将我们下载下来的 \\VPN-CD-v4.30-9696-beta-2019.07.08\\Windows\\SoftEther_VPN_Client 文件夹打开，运行里面的 exe 安装：▲ 我们将用这个工具来管理我们在 VPS 上部署的 VPN Client 以及在本机上部署的 VPN Client配置 VPS 上的 VPN Server启动“SE-VPN Server Manager (Tools)”：我们将使用此工具配置我们在 VPS 上的 VPN Server。第一步：设置新连接，输入设置名、主机名和端口（就是我面前面在 VPS 上输出的 IP 和端口）。输入完之后点确定。第二步：连接这个设置，第一次连接会提示设置管理员密码，请自己设置一个。第三步：安装和配置 VPN Server设置过程是一步步来的，你可以考虑按照下图依次设置。▲ 远程访问 VPN Server▲ 设置好主机名后，直接点退出▲ 启用 L2TP 服务器功能，并设置好 IPsec 预共享密钥▲ 禁用 VPN Azure▲ 创建新用户至此，服务端就设置完毕。接下来我们设置客户端。配置本地的 VPN Client启动 SoftEther VPN Client 管理工具，我们即将使用此工具管理本机的客户端和刚刚配好的 VPS 主机上的客户端。点击“添加新的 VPN 连接”。首次点击的时候会提示创建虚拟网络适配器，点击“是”让它创建即可。随后，添加新的 VPN 连接：设置连接信息。 连接设置名：随便填写 主机名：前面我们启动 VPN Server 时输出的 IP 端口号：前面我们启动 VPN Server 时输出的端口号 虚拟 HUB 名：前面我们填完之后，这里就会自动出现了，选择即可 用户认证设置：我们前一步设置用户的时候设置的用户名和密码配置 VPS 上的 VPN Client启动“管理远程电脑上的 SoftEther VPN Client”程序：输入我们前面 VPS 上的 IP 地址：……" }, { "title": "推荐 .NET/C# 开发者安装的几款代码分析插件或对应的代码分析 NuGet 包", "url": "/post/recommend-some-code-analysis-extensions-or-nuget-packages.html", "categories": "", "tags": "dotnet, csharp", "date": "2020-03-23 11:31:59 +0800", "snippet": "如果你使用的是旧版本的 Visual Studio，那么默认的代码分析规则集是“最小建议规则集”。基于这个，写出来的代码其实只能说是能跑通过而已。随着 Roslyn 的发布，带来了越来越多更强大的代码分析器，可以为编写高质量的代码带来更多的帮助。作为 .NET/C# 开发者，强烈建议安装本文推荐的几款代码分析器。推荐 Visual Studio 2019 自带的分析器 Microsoft Code Analysis VS 扩展：Microsoft Code Analysis 2019 NuGet 包： Microsoft.CodeAnalysis.FxCopAnalyzers Roslynator VS 扩展：Roslynator 2019 VS Code 扩展：Roslynator NuGet 包：Roslynator.Analyzers Code Cracker VS 扩展：Code Cracker for C# NuGet 包：codecracker.CSharp Meziantou.Analyzer VS 扩展：Meziantou.Analyzer NuGet 包：Meziantou.Analyzer 类型这里的分析器分为 Visual Studio 扩展形式的分析器和 NuGet 包形式的分析器。Visual Studio 扩展形式的分析器可以让你一次安装对所有项目生效，但缺点是不能影响编译过程，只能作为在 Visual Studio 中编写代码时给出提示。NuGet 包形式的分析器可以让某个项目中的所有成员享受到同样的代码分析提示（无论是否安装插件），但缺点是仅针对单个项目生效。简介Visual Studio 2019 自带的分析器上图生效的分析器就是 Visual Studio 2019 自带的分析器。在可能有问题的代码上，Visual Studio 的代码编辑器会显示一些文字效果来提醒你代码问题。比如这张图就是提示私有成员 Foo 未使用。Visual Studio 2019 自带的分析器的诊断 ID 都是以 IDE 开头，因此你可以通过这个前缀来区分是否是 Visual Studio 2019 自带的分析器提示的。另外，自带的分析器可谓非常强大，除了以上这种提示之外，还可以提示一些重复代码的修改。比如你修改了某段代码，它会提示你相似的代码也可能需要修改。Microsoft Code AnalysisMicrosoft Code Analysis 分为两种用法，一个是 Visual Studio 扩展的形式，你可以去这里下载安装或者去 Visual Studio 的扩展管理界面搜索安装；另一个是 NuGet 包的形式，你可以直接在项目的 NuGet 管理界面安装 Microsoft.CodeAnalysis.FxCopAnalyzers。这款分析器也是微软主推的代码分析器，可以分析 API 设计问题、全球化与本地化问题、稳定性问题、性能问题、安全性问题、代码使用问题等非常多的种类。比如下图是稳定性的一个问题，直接 catch 了一个 Exception 基类：虽然你可以通过配置规则严重性来消除提示，但是这样写通常代码也比较容易出现一些诡异的问题而难以定位。Microsoft Code Analysis 分析器的诊断 ID 都是以 CA 开头，因此你可以通过这个前缀来区分是否是 Microsoft Code Analysis 分析器提示的。Microsoft.CodeAnalysis.FxCopAnalyzers 的 NuGet 包实际上是一组分析器的合集，包括： Microsoft.CodeAnalysis.FxCopAnalyzers 主分析器，分析各种代码问题 Microsoft.CodeQuality.Analyzers 专门分析代码质量的分析器（比如没有使用某个参数） Microsoft.NetCore.Analyzers 如果你在使用 .NET Core 或者 .NET Standard，那么此分析器会告诉你更恰当地使用框架提供的 API（如果 API 恰好与 .NET Framework 桌面应用相同，那么 .NET Framework 桌面应用也因此受益） Microsoft.NetFramework.Analyzers 如果你在使用 .NET Framework 开发桌面应用，那么此分析器会告诉你更恰当地使用框架提供的 API 如果你想安装这款 NuGet 包，并不需要特别去 NuGet 包管理器中安装，也不需要命令行，只需要去项目的属性页面，选择“安装”就好了。如下图：Roslynator是第三方开发者开发的，代码已在 GitHub 上开源，社区非常活跃： JosefPihrt/Roslynator: A collection of 500+ analyzers, refactorings and fixes for C#, powered by Roslyn.提供了 500 多个代码分析和重构。更值得推荐的一个原因是他为 Visual Studio 原本的很多报告了问题的代码提供了生成解决问题代码的能力。Code CrackerCode Cracker 是第三方开发者开发的，代码已在 GitHub 上开源： code-cracker/code-cracker: An analyzer library for C# and VB that uses Roslyn to produce refactorings, code analysis, and other niceties.由于这款分析器的出现比 Visual Studio 2019 早很多，所以待 Visual Studio 2019 出现的时候，他们已经出现了一些规则的重复（意味着你可能同一个问题会被 Visual Studio 报一次，又被 Code Cracker 报一次）。虽然部分重复，但 Code Cracker 依然提供了很多 Visual Studio 2019 和 Microsoft Code Analysis 都没有带的代码质量提示。比如，如果你代码中的文档注释缺少了某个参数的注释，那么它会给出提示：Code Cracker 支持的所有种类的代码分析都可以在这里查得到： All diagnostics - Code CrackerMeziantou.Analyzer这款插件是对其他几款分析器的重要补充。如果说其他几款分析器可以帮你解决一些基本设计问题或者 Bug 的话，这款分析器可以帮你发现更大范围的问题。最典型的，也是我推荐这款分析器的最大原因是 —— 区域和本地化！你的每一个 ToString()，每一个字符串比较，每一个字典的构造……他都提醒你需要考虑区域问题，然后提供给你区域问题的推荐代码！配置代码分析严重程度你的项目中对于某项规则严重性的看法也许跟微软或其他第三方分析器不一样，因此你需要自己配置规则集的严重性。关于如何配置代码分析严重程度，你可以阅读： 使用 .editorconfig 配置 .NET/C# 项目的规则严重性 - walterlv" }, { "title": "用命令行执行 .NET 单元测试时，如何仅执行符合某些条件的单元测试", "url": "/post/dotnet-test-with-filter.html", "categories": "", "tags": "dotnet", "date": "2020-03-11 17:59:23 +0800", "snippet": "本文介绍使用 dotnet test 命令进行单元测试的时候，过滤出被测项目中的一部分测试出来，仅测试这一部分。背景建一个 .NET Core 的单元测试项目，例如项目名字是 Walterlv.Demo.Tests。举例其中的一个测试类如下：using Microsoft.VisualStudio.TestTools.UnitTesting;namespace Walterlv.Demo.Tests{ [TestClass] public class FooTest { [TestCategory(&quot;CategoryA&quot;)] [Priority(1)] [TestMethod] public void TestMethod1() { } [Priority(2)] [TestMethod] public void TestMethod2() { } }}使用 Visual Studio 的话，直接在测试资源管理器中点击运行全部测试，或者选择想要测试的项点运行所选测试即可。而使用 GUI 工具的话不利于 CI 集成和自动化测试，所以必然需要用到命令：&amp;gt; dotnet test .\\Walterlv.Demo.Tests.dll有时为了调试方便或输出分类数据等，要求执行一部分单元测试，这就需要过滤了。dotnet test 的过滤使用 --filter 选项。过滤方法名查找方法名包含某字符串的单元测试并执行：dotnet test --filter TestMethod1或者：dotnet test --filter Name~TestMethod1如果是排除某方法，则是：dotnet test --filter FullyQualifiedName!=Walterlv.Demo.Tests.FooTest.TestMethod1类名查找类名等于某字符串的单元测试并执行：dotnet test --filter ClassName=Walterlv.Demo.Tests.FooTest类名必须包含命名空间，否则找不到。分类与优先级查找标记了 [TestCategory(&quot;CategoryA&quot;)] 的方法并执行单元测试：dotnet test --filter TestCategory=CategoryA查找标记了 [Priority(2)] 的方法并执行单元测试：dotnet test --filter Priority=2条件与或条件或（|）：dotnet test --filter Name~TestMethod1|TestCategory=CategoryA条件与（’&amp;amp;’）：dotnet test --filter Name~TestMethod1&amp;amp;TestCategory=CategoryA参考资料 Running selective unit tests - .NET Core - Microsoft Docs" }, { "title": ".NET WebClient 类下载部分文件会错误？可能是解压缩的锅", "url": "/post/dotnet-webclient-decompression-when-downloaded.html", "categories": "", "tags": "dotnet", "date": "2020-03-11 17:02:19 +0800", "snippet": "一直在使用 WebClient 下载文件，.NET 已经封装好，所以用起来代码非常简洁；但直到今天发现有一个文件一直不能正确下载下来。本文介绍这个问题的原因和解决方法，更重要的是给出调查方法。本文所涉及到的域名已经过敏感信息处理，所以实际上你是无法访问到的；但这不影响本文对调查方法的描述。问题我原本是使用如下的代码去下载任意文件的（参数经过简化）。private static async Task DownloadFileAsync(){ var url = &quot;http://localhost:5000/walterlv-icon.svg&quot;; var fileName = @&quot;C:\\Users\\lvyi\\Desktop\\TEST\\walterlv-icon.svg&quot;; using var webClient = new WebClient(); webClient.DownloadFile(new Uri(url), fileName);}现在，下载一个 svg 的时候，原本应该是如下的图片：然而实际上下载下来之后却是这样的：原本大小是 992 字节，实际下载下来后是 508 字节，而且固定是 508 字节。你可以通过右键复制图片地址，然后分别把两张图下载下来看。调查显然，WebClient 没有抛出任何异常，而且每次下载下来都是固定的 508 字节，说明肯定不是网络不通或程序提前退出导致的，也不是线程安全相关的问题。基本可以认定为问题出在服务器的配置，或者客户端的请求上。使用其他“正常”下载器尝试拿 Chrome 跑以上地址，拿专用下载工具跑以上地址，甚至是拿 Postman 跑以上地址，都可以成功显示或者下载到正确的图片。这几乎可以肯定，问题出在 .NET 的 WebClient 上，可能是请求不对，或者对响应的后续处理不对。使用 Postman 和 WebClient 对比测试为了对比请求和响应，我使用的是 Fiddler 抓包。WebClient 请求：GET http://localhost:5000/walterlv-icon.svg HTTP/1.1Host: localhost:5000Connection: Keep-AliveWebClient 响应（因为内含乱码，会让网页显示不正常，所以放截图）：Postman 请求：GET http://localhost:5000/walterlv-icon.svg HTTP/1.1Content-Type: application/jsonUser-Agent: PostmanRuntime/7.22.0Accept: */*Cache-Control: no-cachePostman-Token: 05bb3d80-d7a7-4c0d-bdd1-9cd65d79ecabHost: localhost:5000Accept-Encoding: gzip, deflate, brConnection: keep-alivePostman 响应（因为内含乱码，会让网页显示不正常，所以放截图）：请求和响应贴得很长，这可以让比较感兴趣的小伙伴仔细比较。但这里我直接给出我比较后的结论： Postman 的请求会发送比较多的头 两者的响应几乎相同（包括文件大小和内容）由于响应几乎相同，所以实际上前面请求头的不同可以忽略了（至少说明返回的内容没有因为请求的不同而有所变化），我们能够拿到完整的整个文件。那么问题基本确定就是在 WebClient 对这个响应的处理上了。可以注意到 Postman 的请求中有 Accept-Encoding，两折的响应中都有 Content-Encoding，指定了 gzip。然而这是 Linux 中用来压缩文件的命令。响应中指定了内容编码方式为 gzip 是否意味着我们下载下来的文件实际上是一个 gzip 压缩文件呢？于是我将下载下来的文件扩展名改为 gzip，用压缩文件打开，于是真的可以解压出来真实的图片。于是确认问题的原因是 WebClient 在处理响应的时候没有根据 Content-Encoding 的值解压缩下载下来的文件。解决解决的思路： 使 WebClient 支持下载文件后解压缩使 WebClient 支持下载文件后解压缩各种检查后发现，WebClient 竟然没有提供设置解压缩相关的属性。庆幸的是，在网上搜索 WebClient 和 gzip 关键字后，找到了这一篇答案：.net - Automatically decompress gzip response via WebClient.DownloadData - Stack Overflow。我们需要重写 WebClient.GetWebRequest 方法，然后改写 AutomaticDecompression 属性。此属性可以改成 gzip、deflate 和 br 或者它们的组合，这与 Postman 发请求时声明支持的值是完全一样的。class AutoDecompressionWebClient : WebClient{ protected override WebRequest GetWebRequest(Uri address) { var baseRequest = base.GetWebRequest(address); if (baseRequest is HttpWebRequest httpWebRequest) { httpWebRequest.AutomaticDecompression = DecompressionMethods.All; } return baseRequest; }}另外，也可以在拉取到响应的流后自己去做解压，可以参见： .net - How do you download and extract a gzipped file with C#? - Stack Overflow参考资料 .net - Automatically decompress gzip response via WebClient.DownloadData - Stack Overflow c# - WebClient.DownloadFile File Corrupt - Stack Overflow Download file using Webclient shows Wrong Data - CodeProject [Solved] WebClient DownloadFile method downloads damaged PDF files - CodeProject" }, { "title": "如何在终端和 PowerShell 中将一个命令自动重复执行多次", "url": "/post/run-a-command-multiple-times-in-terminal-and-powershell.html", "categories": "", "tags": "windows, powershell", "date": "2020-03-11 16:26:03 +0800", "snippet": "你可能有很多原因要将一个命令重复执行多次，本文介绍在多个平台下如何多次重复执行命令。背景最近遇到一个偶然复现的单元测试错误，于是在每次运行时，打算重复运行多次来调查问题是否已经解决。实际上，重复执行命令有更多用途： 通过重复执行来复现一些偶发的问题 执行一组命令，每次只有参数不同 大大减轻手工输入命令的工作量BashLinux 或者 Mac 系统的终端中，可以使用 for 来完成重复执行命令，使用 ${} 来引用定义的变量。for i in {1..10}; do echo ${i}; done这表示从 1 到 10（两端的值都会取到），依次输出这些数。比如，我们需要运行 100 次单元测试，那么：walterlv@localhost:~$ for i in {1..100}; do dotnet test ./Walterlv.Tests.dll; doneMicrosoft (R) 测试执行命令行工具版本 16.3.0版权所有 (C) Microsoft Corporation。保留所有权利。正在启动测试执行，请稍候...总共 1 个测试文件与指定模式相匹配。测试运行成功。测试总数: 238 通过数: 238总时间: 1.6384 秒Microsoft (R) 测试执行命令行工具版本 16.3.0版权所有 (C) Microsoft Corporation。保留所有权利。正在启动测试执行，请稍候...总共 1 个测试文件与指定模式相匹配。测试运行成功。测试总数: 238 通过数: 238总时间: 1.7138 秒...PowerShellPowerShell Core 是跨平台的配置框架，可以在 Windows/Linux/Mac 系统下使用。在 PowerShell 中，也可以使用 for：for ($i=1; $i -le 10; $i++) { echo $i }这表示从 1 到 10（两端的值都会取到），依次输出这些数。比如，我们需要运行 100 次单元测试，那么：PS C:\\Users\\lvyi&amp;gt; for ($i=1; $i -le 100; $i++) { dotnet test .\\Walterlv.Tests.dll }Microsoft (R) 测试执行命令行工具版本 16.3.0版权所有 (C) Microsoft Corporation。保留所有权利。正在启动测试执行，请稍候...总共 1 个测试文件与指定模式相匹配。测试运行成功。测试总数: 238 通过数: 238总时间: 1.6384 秒Microsoft (R) 测试执行命令行工具版本 16.3.0版权所有 (C) Microsoft Corporation。保留所有权利。正在启动测试执行，请稍候...总共 1 个测试文件与指定模式相匹配。测试运行成功。测试总数: 238 通过数: 238总时间: 1.7138 秒...参考资料 How To Run a Command Multiple Times in Terminal and PowerShell" }, { "title": "Linux 系统根目录下的文件夹", "url": "/post/linux-root-directories.html", "categories": "", "tags": "linux", "date": "2020-01-30 16:02:14 +0800", "snippet": "本文介绍 Linux 系统根目录下的各种文件夹及其用途，了解这些目录可以帮助你更好地管理你的 Linux 主机。Linux 系统根目录各个不同 Linux 发行版的根目录会有一些区别，但大多数发行版的主要的目录都是有的。 /bin binary 用于存放经常使用的命令 /boot boot 启动时的一些核心文件 /dev device 外部设备 /etc 用于存放各种系统配置和管理配置（名字来源于法语 et cetera，意思就是 etc…，表示还有一些其他的东西等等，其实就是指一堆杂项，不过现在就用来存放一堆配置文件了） /home 用户目录，里面按用户名命名了子文件夹 /lib library 存放系统最基本的动态链接共享库 /lib64 library 64bit 动态链接库的 64 位版本 /lost+found 一般情况下是空的，但在非法关闭后，这里就会存放一些文件 /media 识别出的 U 盘，光驱等会在这个目录下 /mnt mount 系统提供此文件夹用于给用户挂载其他的文件系统，例如光驱 /opt 用于安装软件的目录 /proc 是一个虚拟目录，是系统的内存映射，可通过访问此目录获取系统信息（这个目录的内容不在硬盘上而在内存里） /root 超级管理员 root 用户的主目录 /run 用于在系统启动时运行的程序 /sbin super binary 系统超集管理员使用的系统管理程序 /srv service 存放一些服务启动之后需要提取的数据。 /sys 存放 Linux 系统内核文件 /tmp 用于存放一些临时文件 /usr 用户的应用程序和文件都在此目录下，类似于 Windows 系统中的 Program Files 目录 /var 经常被修改的文件可以放到这个目录，比如说日志文件参考资料 Linux 系统目录结构 - 菜鸟教程 Linux中etc目录详解大全总汇详解_mianjunan的博客-CSDN博客" }, { "title": "收集的 Linux VPS 在线重装系统脚本", "url": "/post/collected-scripts-for-reinstalling-linux.html", "categories": "", "tags": "linux", "date": "2020-01-29 21:58:13 +0800", "snippet": "因为 VPS 上预装的操作系统我并不习惯，所以打算重装一个。有的 VPS 服务商提供了较多种类的系统选择，有的却没有。如果你发现你希望重装的系统服务商没有提供，可以考虑自己安装。重装脚本 - 来自萌咖以下是来自萌咖的一键重装脚本的发布贴： [ Linux VPS ] Debian(Ubuntu)网络安装/重装系统一键脚本 - 萌咖 [ Linux VPS ] CentOS 网络安装/重装系统一键脚本 纯净安装 - 萌咖CentOS -&amp;gt; Debian第一步：先确保安装所需的软件。yum install -y gawk sed grep[root@walterlv ~]# yum install -y gawk sed grepLoaded plugins: fastestmirrorDetermining fastest mirrorsepel/x86_64/metalink | 9.5 kB 00:00:00 * base: mirror.xtom.com.hk * epel: my.mirrors.thegigabit.com * extras: mirror.xtom.com.hk * updates: mirror.xtom.com.hkbase | 3.6 kB 00:00:00 epel | 5.3 kB 00:00:00 extras | 2.9 kB 00:00:00 updates | 2.9 kB 00:00:00 (1/7): base/7/x86_64/group_gz | 165 kB 00:00:01(2/7): extras/7/x86_64/primary_db | 159 kB 00:00:00(3/7): epel/x86_64/group_gz | 90 kB 00:00:01(4/7): epel/x86_64/updateinfo | 1.0 MB 00:00:03(5/7): base/7/x86_64/primary_db | 6.0 MB 00:00:04(6/7): updates/7/x86_64/primary_db | 5.9 MB 00:00:03(7/7): epel/x86_64/primary_db | 6.9 MB 00:06:01Package gawk-4.0.2-4.el7_3.1.x86_64 already installed and latest versionPackage sed-4.2.2-5.el7.x86_64 already installed and latest versionPackage grep-2.20-3.el7.x86_64 already installed and latest versionNothing to do第二步：下载脚本。wget --no-check-certificate -qO DebianNET.sh &#39;https://moeclub.org/attachment/LinuxShell/DebianNET.sh&#39; &amp;amp;&amp;amp; chmod a+x DebianNET.sh第三步：全自动安装 Debian 9bash DebianNET.sh -d 9 -v 64 -a这里的 -a 是自动安装。如果不指定或者指定为 -m 则需要去 VNC 手动安装。可以设置安装时 root 用户的密码：bash DebianNET.sh -d 9 -v 64 -a -p WalterlvPwd如果你希望设置更多的安装选项，也可以选择手动安装。第三步我们修改命令。第三步：手动安装系统 Debian 9[root@walterlv ~]# bash DebianNET.sh -d 9 -v 64安装过程和交互如下：# InstallDo you want to install os manually?[y/n] yManual Mode insatll [Debian] [stretch] [amd64] in VNC.[Debian] [stretch] [amd64] Downloading...It will reboot!Please connect VNC!Select Install OS [stretch amd64] to install system.在以上命令重启 Linux 后，前往 VNC 界面选择启动的操作系统：随后会进入安装和设置界面。" }, { "title": "为什么实现 .NET 的 ICollection 集合时需要实现 SyncRoot 属性？如何正确实现这个属性？", "url": "/post/sync-root-on-collections.html", "categories": "", "tags": "dotnet, csharp", "date": "2020-01-28 16:53:15 +0800", "snippet": "非泛型版本的 ICollection 中有 IsSynchronized 属性和 SyncRoot 属性，这两个属性被用来设计成以线程安全的方式访问和修改集合。不过这个设计让线程安全的访问由集合的实现方转嫁到了调用方，导致要么很难实现，要么很难调用。虽然泛型版本的 ICollection&amp;lt;T&amp;gt; 已经改进了设计，不再引入 SyncRoot 这样的属性到接口中，但如果我们在某些场景下需要实现 ICollection 非泛型集合时，如何正确实现 SyncRoot 模式（SyncRoot Pattern）呢？先上结论：—— 不可能正确实现 SyncRoot 模式在多线程程序设计中，为了在保证线程安全的同时避免死锁，不应该公开同步锁。而 ICollection 接口中的 SyncRoot 属性在接口中必然是公开的，于是没有任何途径可以保证调用方不会发生死锁。于是实现 SyncRoot 的正确方法应该是：—— 避免公开 SyncRoot 属性所以 SyncRoot 模式应该这样实现： 使用显式接口实现，避免公开暴露此属性 抛出异常，避免调用者使用此属性结合 .NET Core 源代码中的一些常用写法，我给出一个推荐的 SyncRoot 模式的写法：// Is this List synchronized (thread-safe)?bool ICollection.IsSynchronized =&amp;gt; false;// Synchronization root for this object.object ICollection.SyncRoot =&amp;gt; this;嗯，没错，返回了 this，这是各种同步时绝对不应该使用的对象。然而这个属性都是 public 了，不管返回什么，与 this 还有什么区别……关于为什么同步时不应该返回 this 或者返回公开的对象，原因可以看我的另一篇博客： 为什么不应该公开用来同步的加锁对象？为什么不应该 lock(this)/lock(string) 或者 lock 任何非私有对象？ - walterlv" }, { "title": "全民 https！使用 FreeSSL 申请免费的 https 证书", "url": "/post/apply-for-free-ssl-certificates-using-freessl.html", "categories": "", "tags": "web", "date": "2020-01-13 08:05:30 +0800", "snippet": "到现在还不为你的网站添加 https 的话，浏览器已经会非常显眼地显示“不安全”了。感谢 Let’s Encrypt，感谢 buypass，个人使用申请 https 证书的话已经可以免费了。关于域名我们使用 FreeSSL.org 申请的是域名证书，对一个或多个域名生效。所以，你至少需要拥有一个域名。如果没有，去 https://tld-list.com/ 输入你心仪的域名，然后找到最便宜的一家买一个吧！第一步：输入域名打开 https://freessl.org/，在输入框中输入你想要申请证书的域名，然后点击“创建免费的SSL证书”。下面有提供商的选择，选 Let’s Encrypt V2 的话，我们可以申请泛域名证书，但有效期只有 3 个月。也就是说 3 个月之后你需要重新申请（重新申请的步骤可以简化，后面会说）。选择 buypass 的话，不能申请泛域名证书，但一次申请可以管 6 个月，比较省事儿。可能需要解释一下泛域名。泛域名是带通配符的域名，例如 *.walterlv.com 就是一个泛域名。值得注意的是，这只能代表所有的二级域名。com 是一个顶级域名，walterlv.com 是一个一级域名， 是一个二级域名。而泛域名 `*.walterlv.com` 范围涵盖了二级域名 ，但是不包含一级域名 `walterlv.com` 和三级域名 `s.blog.walterlv.com`。所以你不能指望申请一个泛域名适用你的所有网站。但是！FreeSSL.org 自动为你的泛域名创建两个证书，对我们初学者来说非常友好，不容易出错！如下图所示。▲ 当输入了一个泛域名之后，点击“创建免费的SSL证书”，会自动把上一级域名也自动生成了。第二步：填写邮箱输入你自己的邮箱，然后点击“点击创建”。第三步：安装并用 KeyManager 打开推荐下载安装 KeyManager，这可以在接下来的步骤当中省去一堆手工配置，也为将来重新申请证书带来更高的效率。下载安装完成后，如果打开 KeyManager 的提示已经消失，可以点击“再次尝试启动KeyManager”打开：打开 KeyManager 后不需要任何操作，直接回到浏览器中刚刚的页面即可。（当然，如果提示登录或设置密码，则需要输入密码）回到浏览器后点击“继续”：第四步：验证域名FreeSSL.org 需要验证这个域名确实是你自己的，按照它的说明，去你的域名管理页面中配置一个或两个记录（取决于你申请几个证书）。你需要前往你购买域名的域名提供商的网页里去设置。如果你已经改了域名服务器，就需要去改了之后的域名服务商那里设置。设置方法是添加一个新的设置，类型是 TXT，名称是和值是上面页面中给你提供的值。第五步：点击验证回到 FreeSSL.org 页面，点击“点击验证”，如果通过，这时会继续提示进入 KeyManager 软件。如果没有通过，不要紧，等几分钟再试，不同的域名服务器生效的时间有差异。第六步：导出证书在 KeyManager 的证书管理页面，点击单个域名最右边的“…”按钮，点击“详情”，拉倒最下面点击“查看证书”，再点击“导出证书”。选择你希望导出的证书平台，决定是否要为证书设置密码，点击“导出”。我应该选择哪个平台？如果你使用 Nginx 或 frp 反向代理服务器，那么导出为 Nginx 平台。参见： 使用 Frp 为你的 Web 服务添加 https 支持 使用 Nginx 为你的 Web 服务添加 https 支持如果你使用 IIS 反向代理服务器，或者直接使用 Kestrel 对外提供 https 粉刷说，那么导出为 IIS 平台。参见： 使用 Kestrel 为你的 ASP.NET Core 服务添加 https 支持如果你使用 Apache 或者 Tomcat 作为 Web 服务器，则选择对应的平台。最后将证书用于你的 Web 服务器，参见： 三种方法为 ASP.NET Core 对外服务添加 https 支持（kestrel / frp / nginx）" }, { "title": "如何设置 ASP.NET Core 程序监听的 IP 和端口", "url": "/post/configure-urls-and-port-for-asp-dotnet.html", "categories": "", "tags": "dotnet, web", "date": "2020-01-13 08:04:22 +0800", "snippet": "Web 服务需要配置监听的 IP 和端口才可以对外提供真正的服务。本文介绍如何设置 ASP.NET Core 程序监听的 IP 和端口。ASP.NET Core 程序默认集成了 Kestrel 服务器，可以直接对外提供 Web 服务。虽然可以直接提供服务，但通常建议使用反向代理服务器来间接提供服务。因此，本文建议的大多数设置监听 IP 和端口的方法都是“临时方法”，即那种“配置出来”的方法，而不会直接写死在代码中。如何选择应该监听的 IP 和端口？一般来说，监听的 IP 可以选择本地回环地址，特定的 IP 以及任意 IP，分别是： 127.0.0.1 127.0.0.2 127.0.0.3…… 本地回环地址 101.199.96.22 特定的 IP 0.0.0.0 任意 IP监听本地回环地址时，则访问仅限于本机应用程序，不需要管理员权限来添加防火墙配置。如果在本地计算机配置了反向代理服务器，则强烈推荐使用本地回环地址。如果打算直接让服务对外公开提供，则需要设置为 0.0.0.0 任意 IP。一台计算机上不同的应用不能使用相同的端口，对于端口的选择只要不重复即可。如果希望让 ASP.NET Core 程序自动选择一个不重复的端口，则将其指定为 0。配置方法方法一：直接在项目中设置在项目上右击属性，在调试标签下可以修改应用的启动 URL。虽然这里修改的是项目的设置，最终生成的 ASP.NET Core 程序并不会使用这个设置，但每次通过项目打开时仍然可以使用这个设置。这种方式仅仅影响调试时候采用的域名 / IP 和端口号。因此，仅在调试期间生效，待发布后，可以直接接入到反向代理服务器中。方法二：使用 Kestrel 服务器的配置（不推荐）直接使用 Kestrel 服务器可以在没有反向代理服务器的情况下直接对外提供 ASP.NET Core 的 Web 服务。如果仅对外提供 http 服务，则设置非常简单： public static void Main(string[] args) { CreateHostBuilder(args).Build().Run(); } public static IHostBuilder CreateHostBuilder(string[] args) =&amp;gt; Host.CreateDefaultBuilder(args) .ConfigureWebHostDefaults(webBuilder =&amp;gt; {++ webBuilder.ConfigureKestrel(serverOptions =&amp;gt;++ {++ serverOptions.Listen(&quot;0.0.0.0&quot;, 5000);++ }) .UseStartup&amp;lt;Startup&amp;gt;(); });如果希望加上 https 的支持，可以阅读我的另一篇博客： 使用 Kestrel 为你的 ASP.NET Core 服务添加 https 支持方法三：使用命令行参数指定使用命令行参数 --urls 可以为 ASP.NET Core 程序指定监听的 URL。dotnet ./blog.walterlv.com.exe --urls http://0.0.0.0:13800这个 URL 中的几个信息都会用到：http 协议，监听任意 IP 地址，监听端口 13800。通常建议为反向代理的服务选用 http，让 https 的支持交给反向代理服务器去做，参见： 三种方法为 ASP.NET Core 对外服务添加 https 支持（kestrel / frp / nginx）方法四：设置环境变量设置环境变量 ASPNETCORE_URLS 即可为 ASP.NET Core 程序指定监听的 URL，格式与上面使用命令行参数是一样的。注意，这里说的环境变量是单独为某一个程序设置的环境变量，而不是为用户账户或者操作系统设置的环境变量（那样显然会让所有 ASP.NET Core 程序冲突）。所以通常都是用来在反向代理服务器中配置的。" }, { "title": "使用 Frp 为你的 Web 服务添加 https 支持", "url": "/post/add-https-support-for-web-service-using-frp.html", "categories": "", "tags": "web", "date": "2020-01-13 08:03:28 +0800", "snippet": " frp 是一个可用于内网穿透的高性能的反向代理应用，支持 tcp, udp 协议，为 http 和 https 应用协议提供了额外的能力，且尝试性支持了点对点穿透。在众多反向代理应用中，frp 的最大特点就在于内网穿透。所以，如果你有将内网对外提供 Web 服务的需求，就可以考虑使用 frp 为你的 Web 服务提供 https 支持。下载 frp前往 GitHub 下载 frp： Releases · fatedier/frp有适用于各种不同操作系统的 frp，如果你对外提供的公网服务器和实际提供 Web 服务的服务器不是同一台机器的话，需要为各自机器下载对应版本的 frp。准备好 Web 服务和 SSL 证书你可以用任何方式开发你的 Web 服务，注意你的 Web 服务需要监听一个本机端口。对于准备 SSL 证书，你可以参考我的另一篇博客： 使用 freessl.org 为你的域名申请免费的 SSL 证书对于本文的后续内容，你需要将证书导出成 Nginx 格式，即一个 crt 文件和一个 key 文件。配置 frp你需要准备运行一个 frp 服务端和一个 frp 客户端。它们可以运行在不同的机器上，也可以运行在同一台机器上。鉴于 frp 的内网穿透的优势，如果你将这两个端部署在不同的机器上，就能够实现 https 支持的同时也做到内网穿透——即你可以将 NAT 网络中的一台电脑对全球公开的互联网提供服务。当然，你也可以部署到同一台机器上，这样的优势就是一个端口可以服务很多的 Web 服务，同时支持 https。接下来的描述中，我用 A 机器表示 frp 服务端（也就是对公众开放服务的一端），B 机器表示 frp 客户端（提供 Web 服务的一端）。它们可以是同一台机器，也可以是不同的机器。反向代理服务端A 机器需要修改 frps.ini 文件：[common]bind_port = 7000vhost_http_port = 80vhost_https_port = 443▲ bind_port 是 frp 服务端口，客户端如果要使用 frp 服务则连接这个端口；vhost_http_port 是代理 http 的端口；vhost_https_port 是代理 https 的端口配置完成之后，运行 frp 程序：./frps -c ./frps.ini▲ 对于 Linux 系统./frps.exe -c ./frps.ini▲ 对于 Windows 系统于是，A 机器就配置好了。反向代理客户端B 机器的配置将是 https 支持的重点：[common]# 这里填写 A 机器的 IP 或者域名server_addr = 100.13.*.*# 填写 A 机器开放的 frp 服务端口，也就是 frps.ini 配置文件中 bind_port 的值server_port = 7000[walterlv_example_http]# 依然支持 http 访问type = http# 本地 Web 服务的端口local_port = 10000# 需要反向代理的域名（当访客通过此域名访问 A 机器时，才会将请求反向代理到此 Web 服务）custom_domains = example.walterlv.com[walterlv_example]# 配置 https 访问type = https# 本地 Web 服务的端口（与前面的配置一样，都对应同一个 Web 服务）local_port = 10000# 需要反向代理的域名（当访客通过此域名访问 A 机器时，才会将请求反向代理到此 Web 服务）custom_domains = example.walterlv.com# 接下来的配置是支持 https 的重点配置# 配置插件，将 https 请求转换成 http 请求后再发送给本地 Web 服务程序plugin = https2http# 转换成 http 后，发送到本机的 10000 端口plugin_local_addr = 127.0.0.1:10000# 可能是 frp 的 Bug？这里必须写成 127.0.0.1，稍后解释plugin_host_header_rewrite = 127.0.0.1# 指定代理方式为 frpplugin_header_X-From-Where = frp# 指定成你在前面部分导出的证书的路径plugin_crt_path = C:/Samples/_.walterlv.com_chain.crtplugin_key_path = C:/Samples/_.walterlv.com_key.key这就是 frp 的特色，重点配置都放到了反向代理的客户端中。这样的配置方式安全性自然成了问题，但也正因为如此，才可以真正实现带有内网穿透的反向代理。接下来介绍以下这个文件里面为什么是这样配置的。[Common] 节点是为了与 frp 服务端取得联系的。所以 server_addr 和 server_port 自然成了必要，毕竟连接一个 Web 服务这是两个必要的参数。如果你的两个端部署在同一台电脑上，那么这里可以填写 127.0.0.1。[walterlv_example_http] 节点和 [walterlv_example] 两个节点的名称是随便取的，不需要满足什么规律。唯一的要求是，连接到此 frp 服务端的所有客户端之间，这个名称都不能重复。frp 的服务端通过此名称来区分不同的客户端配置。因此，通常将这个名称命名成域名或者功能名。[walterlv_example_http] 节点配置来兼容 http 访问。如果不配置这一个节点，那么使用 http 访问的访客将得到 frp 服务器返回的 403 状态码。这里的三项配置表示，如果使用 http 协议访问此 frp 服务端，且访问域名是 example.walterlv.com（http 头里写的），那么将此请求转发到 frp 客户端本机的 10000 端口。[walterlv_example] 节点的前三项与 [walterlv_example_http] 一样，含义也是一样的。接下来就是启用 https2http 插件，将访问 frp 服务端的 https 流量全部转换成 http 流量，然后转发给本机的 http 服务。plugin_local_addr 就是指定转发到本机的 10000 端口。当然你也可以写成非本机的 http 服务，例如 walterlv.github.io:80，这样，https 流量转换成 http 流量后会发给对应的机器。plugin_host_header_rewrite 在目前（frp 0.31.1 版本），这个值必须写成 127.0.0.1，否则会出现错误的重定向（例如，如果指定成 example.walterlv.com 会导致流量回流到 frp 服务端，这绝对是反向代理的一个 Bug！）这个值的含义是修改 http 的请求头，将请求头中的域名部分改写成 127.0.0.1（在改写之前，头是 example.walterlv.com）。plugin_crt_path 和 plugin_key_path 指定为 SSL 证书的路径。plugin_header_X-From-Where 则不是必须的。工作原理使用 frp 让 Web 服务支持 https 的流程是一个典型的反向代理服务器的工作流程。访客在浏览器中输入网址 https://blog.walterlv.com 后，浏览器会查询 的 IP，查询到之后，向此 IP 的 443 端口发送 https 请求。frp 服务端收到此请求后检查访问的域名，发现曾经连接此 frp 服务端的一个客户端配置了此域名的反向代理。于是将请求转发给此客户端。frp 客户端在收到转发的 https 请求后，使用 SSL 证书将 https 解密成 http 请求，然后修改 http 头添加或修改额外的信息。最后，frp 客户端将修改后的 http 请求转发给本机的真正的 Web 服务程序。当 Web 服务程序处理完 Web 请求后，响应沿着原路返回。这里值得注意的是，由于 frp 反向代理系统中，使用 SSL 证书的一端在 frp 客户端，这意味着 frp 服务端完全无法得知此 https 请求的内容。于是在转发后也无法得知此请求的真实来源（访客 IP），这样，真实的 Web 服务将无法得知真实的访客信息。这也是 frp 在此设计下必然出现的缺陷。如果你希望你的 Web 服务在 https 下破除这些限制，那么建议使用其他的反向代理服务器。关于其他配置 https 的方法，你可以阅读： 三种方法为 ASP.NET Core 对外服务添加 https 支持（kestrel / frp / nginx） 使用 Kestrel 为你的 ASP.NET Core 服务添加 https 支持 使用 Nginx 为你的 Web 服务添加 https 支持除了 frp 以外的方法都可以获得真实的访客信息。参考资料 frp/README_zh.md at master · fatedier/frp" }, { "title": "为 ASP.NET Core 程序制作 URL 的 301/302 跳转", "url": "/post/redirect-middleware-for-asp-dotnet.html", "categories": "", "tags": "dotnet, web, blazor", "date": "2020-01-12 22:08:32 +0800", "snippet": "如果你有一些需要重定向网页 URL 的情况，可以返回 HTTP 状态码 301/302 告诉浏览器或者搜索引擎访问新的 URL。本文描述如何在 ASP.NET Core 中进行重定向。HTTP 状态码 301/302301 表示“Moved Permanently”，即永久移动。通过返回此状态码可以告知浏览器或者搜索引擎此 URL 已经永久移动到了新的 URL 地址。搜索引擎会使用新的 URL 来更新自己的搜索结果，而浏览器会将此 URL 重定向缓存起来，下次访问的时候直接使用新的 URL 来访问。302 表示“Found”，发现；原始描述为“Moved Temporarily”，即临时移动。通过返回此状态码可以告知浏览器或者搜索引擎此 URL 临时移动到了新的 URL 地址。搜索引擎会使用此新的 URL 来抓取页面的内容但不会更新此 URL，而浏览器会访问新的 URL 但不会缓存此 URL 重定向。还有其他的重定向的 HTTP 状态码： 303 See Other 307 Temporary Redirect 308 Permanent Redirect301/302 本来设计为移动资源的时候保持方法不变，但各大浏览器在实现的时候对于 POST 方法，有的实现成了 GET 方法，有的实现成了 POST 方法。于是在后来的 HTTP 标准中将浏览器的错误实现变成了标准，301 和 302 方法要求使用 GET 方法重定向。不过由于历史原因无法保证一定是改用 GET 方法，所以增加了 303 状态码要求一定使用 GET 方法重定向。随后将原来本应该正确实现的 301 和 302 重新定义成 307 和 308 状态码，要求重定向时不允许修改方法。ASP.NET CoreASP.NET Core 的 Blazor 框架生成的页面在路由的时候是不识别 .html 后缀的，而带有 .html 后缀的 URL 会被识别为静态文件。于是，如果创建了一个空的 Blazor 应用，当访问 https://blog.walterlv.com/post/redirect-middleware-for-asp-dotnet.html 网址的时候，会返回 404 Not Found，而不是路由到我的博客页面。如果我们将此 URL 重定向到不带后缀的 URL，则可以被 Blazor 框架识别并正确显示对应的博客页面。我们有两个不同的方式来实现这种 URL 的重定向： 做一个重定向的控制器 Controller，然后在控制器中重定向所有的博客页面 做一个重定向的中间件，对所有包含 .html 后缀的博客页面重定向到没有 .html 后缀的博客页面不过，写一个 Controller 会要求这个 Controller 路由到几乎所有的 URL 上，对其他功能很不利，所以中间件是最合适的方式。重定向中间件 public class Startup { public void Configure(IApplicationBuilder app, IWebHostEnvironment env) {++ app.UseAutoRemoveHtmlExtension(); app.UseEndpoints(endpoints =&amp;gt; { endpoints.MapBlazorHub(); endpoints.MapFallbackToPage(&quot;/_Host&quot;); }); app.UseStaticFiles(); } }在 Startup 类的 Configure 方法中可以添加中间件。为了实现去掉 .html 后缀的中间件，我添加了一个自己的扩展方法 UseAutoRemoveHtmlExtension。/// &amp;lt;summary&amp;gt;/// 自动移除所有的 .html 后缀，并永久重定向到没有 .html 后缀的网页。/// &amp;lt;/summary&amp;gt;/// &amp;lt;param name=&quot;app&quot;&amp;gt;&amp;lt;see cref=&quot;IApplicationBuilder&quot;/&amp;gt;。&amp;lt;/param&amp;gt;/// &amp;lt;returns&amp;gt;&amp;lt;see cref=&quot;IApplicationBuilder&quot;/&amp;gt;。&amp;lt;/returns&amp;gt;public static IApplicationBuilder UseAutoRemoveHtmlExtension(this IApplicationBuilder app) =&amp;gt; app.Use(async (context, next) =&amp;gt;{ var urlPath = context.Request.Path.HasValue ? context.Request.Path.Value : &quot;&quot;; if (urlPath.EndsWith(&quot;.html&quot;, StringComparison.OrdinalIgnoreCase)) { // 去掉 .html 后缀 var url = urlPath[0..^5]; context.Response.Redirect(url); context.Response.StatusCode = 301; return; } await next().ConfigureAwait(false);});实现自己的中间件实际上直接调用 IApplicationBuilder 中的 Use 方法即可，传入一个委托用来在 URL 处理过程中添加一个步骤。两个参数，context 中包含了本次请求的一些上下文，包括域名、URL 路径，返回的 HTTP 状态码。调用 context.Response.Redirect 方法可以进行 302 跳转。如果需要改成 301 跳转，则直接设置 context.Response.StatusCode 方法即可。接下来，对于不需要重定向的网址，我们直接交给后面的中间件处理，调用 await next()。重定向如果你希望做其他种类的跳转，你也可以添加新的中间件，比如： 将 HTTP 重定向到 HTTPS（谷歌建议使用 301 跳转） 你可以在打开某个网页之前要求登录，于是做一个 302 跳转到登录页面； 你可以将一些已经过时的网页进行 301 跳转到新的网页； 比如我将一些之前不太规范的博客 URL 重定向到统一的格式； 你可以在迁移服务的时候临时做一个 302 跳转。小心缓存请注意，301 重定向会被浏览器缓存。也就是说如果你重定向到了一个错误的网址，那么再次访问的话浏览器将直接访问这个错误的网址。如果希望浏览器停止重定向到这个错误的网址，需要清除浏览器的缓存。所以使用 301 的时候需要谨慎一些。参考资料 HTTP 302 - 维基百科，自由的百科全书" }, { "title": "使用 Kestrel 为你的 ASP.NET Core 服务添加 https 支持", "url": "/post/add-https-support-for-asp-dotnet-using-kestrel.html", "categories": "", "tags": "dotnet, web", "date": "2020-01-11 20:10:40 +0800", "snippet": "Kestrel 是一个跨平台的适用于 ASP.NET Core 的 Web 服务器。它内置集成在了 ASP.NET Core 项目模板中，所以编写和对外开放一个 Web 服务会非常简单。虽然不推荐直接使用 Kestrel 对外提供 Web 服务，但为了简单的话，临时使用也是非常不错的选择。Kestrel 是一个跨平台的适用于 ASP.NET Core 的 Web 服务器。Kestrel 只是一个 Web 服务器，能够提供对外的 Web 服务；但它没有反向代理功能。也就是说当你使用 Kestrel 指定了一个端口后，这个端口的所有流量将被 Kestrel 处理，不能再与其他 Web 服务程序共用端口了。当然还有一些其他的原因（比如 Web 安全防护），所以通常并不推荐直接使用 Kestrel 对外提供 Web 服务。但有一点——Kestrel 内置集成在了 ASP.NET Core 项目模板中，所以编写和对外开放一个 Web 服务会非常简单，这也使得 Kestrel 值得被临时使用一下。配置 Kestrel当你使用 dotnet 命令或者 Visual Studio 创建 ASP.NET Core 项目后，在 ConfigureWebHostDefaults 扩展方法的委托参数中，使用 webBuilder 对象可以用来配置 Kestrel 服务器。 public static void Main(string[] args) { CreateHostBuilder(args).Build().Run(); } public static IHostBuilder CreateHostBuilder(string[] args) =&amp;gt; Host.CreateDefaultBuilder(args) .ConfigureWebHostDefaults(webBuilder =&amp;gt; {++ webBuilder.ConfigureKestrel(serverOptions =&amp;gt;++ {++ // 在这里设置 Kestrel 的一些配置属性。++ }) .UseStartup&amp;lt;Startup&amp;gt;(); });配置 https配置 Kestrel 时，只需要调用 serverOptions 的 Listen 方法设置监听的 IP 和端口。并且，可以额外写一个委托用来设置监听参数。使用 listenOptions.UseHttps 即可使用 SSL 证书来支持 https 协议。 public static IHostBuilder CreateHostBuilder(string[] args) =&amp;gt; Host.CreateDefaultBuilder(args) .ConfigureWebHostDefaults(webBuilder =&amp;gt; { webBuilder.ConfigureKestrel(serverOptions =&amp;gt; {++ serverOptions.Listen(IPAddress.Any, 5000, listenOptions =&amp;gt;++ {++ listenOptions.UseHttps(++ @&quot;D:\\blog.walterlv.com\\ssl\\blog-walterlv-com.pfx&quot;,++ &quot;Hqh#Q*QqV%@aCnx41UB%M31H&quot;);++ }); }) .UseStartup&amp;lt;Startup&amp;gt;(); });这种把密码写在代码中的做法一定要拖出去打！不过我需要做博客中介绍以下这里是传入密码的，你可以采用其他的方式将密码存起来。比如放入 Windows 凭据管理器中，或者以其他加密的方式存在服务器/个人电脑上。如果不指定证书，也可以使用 https，不过这使用的是默认的配置，只能用在 localhost 中。另外，如果你还没有 SSL 证书，可以先阅读我的另一篇博客了解如何申请免费的 SSL 证书： 使用 freessl.org 为你的域名申请免费的 SSL 证书至此，你的 ASP.NET Core 服务已经可以通过 https 对外提供服务了。更多配置除了在 Startup 中使用上文提供的配置代码之外，还可以为 https 配置其他参数。webBuilder.ConfigureKestrel(serverOptions =&amp;gt;{ serverOptions.ConfigureEndpointDefaults(listenOptions =&amp;gt; { // 配置终结点 }); serverOptions.ConfigureHttpsDefaults(listenOptions =&amp;gt; { listenOptions.SslProtocols = SslProtocols.Tls12; });});如果你的 Kestrel 服务面向多个域名，那么也可以配置不同的域名使用不同的证书配置：webBuilder.ConfigureKestrel(serverOptions =&amp;gt;{ serverOptions.Listen(IPAddress.Any, 5000, listenOptions =&amp;gt; { listenOptions.UseHttps(httpsOptions =&amp;gt; { var certificates = new Dictionary&amp;lt;string, X509Certificate2&amp;gt;(StringComparer.OrdinalIgnoreCase) { { &quot;localhost&quot;, CertificateLoader.LoadFromStoreCert(&quot;localhost&quot;, &quot;My&quot;, StoreLocation.CurrentUser, true) }, { &quot;walterlv.com&quot;, CertificateLoader.LoadFromStoreCert(&quot;walterlv.com&quot;, &quot;My&quot;, StoreLocation.CurrentUser, true) }, { &quot;blog.walterlv.com&quot;, CertificateLoader.LoadFromStoreCert(&quot;blog.walterlv.com&quot;, &quot;My&quot;, StoreLocation.CurrentUser, true) } }; httpsOptions.ServerCertificateSelector = (connectionContext, name) =&amp;gt; name != null &amp;amp;&amp;amp; certificates.TryGetValue(name, out var cert) ? cert : certificates[&quot;walterlv.com&quot;]; }); });})使用更强大的方法配置 https其实我本不应该在博客后面贴上“更多配置”一章的，因为如果需要实现更强大的功能，配置带有反向代理功能的 Web 服务器会强大得多。可以阅读： 三种方法为 ASP.NET Core 对外服务添加 https 支持（kestrel / frp / nginx） 使用 Frp 为你的 Web 服务添加 https 支持 使用 Nginx 为你的 Web 服务添加 https 支持参考资料 ASP.NET Core 中的 Kestrel Web 服务器实现 - Microsoft Docs" }, { "title": "三种方法为 ASP.NET Core 对外服务添加 https 支持（kestrel / frp / nginx）", "url": "/post/add-https-support-for-asp-dotnet.html", "categories": "", "tags": "dotnet, web", "date": "2020-01-11 20:10:25 +0800", "snippet": "虽然使用 Visual Studio 创建 ASP.NET Core 程序的时候可以选择是否添加 https 支持，不过这种方式只添加了 localhost 的证书，只有本地访问时浏览器才会承认。真正对外公开服务的时候这样是绝对没法儿提供 https 服务的。本文介绍使用三种不同的方式添加 https 的支持，三种方法各有优劣，本文会进行比较并给出不同的适用场景。你自己选择就好。你需要有一个证书如果你还没有证书，可以考虑去 https://freessl.org/ 免费申请一个。可以为泛域名申请 3 个月有效期的证书（Let’s Encrypt），或者为单域名申请 6 个月有效期的证书（buypass）。如果不知道如何操作，可以参考我的另一篇博客： 使用 freessl.org 为你的域名申请免费的 SSL 证书你可以在以上博客中得到四种不同格式的证书（Nginx/Apache/IIS/Tomcat），下面的方法中每一种方法会使用到其中的一种证书。方法实际上，只要是一个 Web 服务器就可以为 ASP.NET Core 服务程序提供 https 的支持，不过本文只会介绍下面这三种方法： Kestrel 这是 ASP.NET Core 自带提供的 Web 服务器 Frp 这是一个开源即将收费的反向代理服务 Nginx 这是非常强大的 Web 服务器，同时也是强大的反向代理服务器 Kestrel 最简单，几句代码即可配完。Frp 相对来说也很简单。而 Nginx 非常强大，几乎适用于各种 Web 服务场景。Nginx 支持 http2，Kestrel 的 Windows 和 Linux 版本支持 http2。发现写成一篇博客会模糊这些方法之间的步骤，所以我将它们分别写成了几篇博客： 使用 Kestrel 为你的 ASP.NET Core 服务添加 https 支持 使用 Frp 为你的 Web 服务添加 https 支持 使用 Nginx 为你的 Web 服务添加 https 支持" }, { "title": ".NET 将多个程序集合并成单一程序集的 4+3 种方法", "url": "/post/how-to-merge-dotnet-assemblies.html", "categories": "", "tags": "dotnet, csharp", "date": "2020-01-10 21:52:41 +0800", "snippet": "编写 .NET 程序的时候，我们经常会在项目的输出目录下发现一大堆的文件。除了我们项目自己生成的程序集之外，还能找到这个项目所依赖的一大堆依赖程序集。有没有什么方法可以把这些依赖和我们的程序集合并到一起呢？本文介绍四种将程序集和依赖打包合并到一起的方法，每一种方法都有其不同的原理和优缺点。我将介绍这些方法的原理并帮助你决定哪种方法最适合你想要使用的场景。四种方法目前我已知的将 .NET 程序集与依赖合并到一起的方法有下面四种： 使用 .NET Core 3.0 自带的 PublishSingleFile 属性合并依赖 使用 Fody 使用 SourceYard 源代码包 使用 ILMerge（微软所写）或者 ILRepack（基于 Mono.Ceil） 其他方法如果你还知道有其他的方法，欢迎评论指出，非常感谢！上面的第五种方法我也会做一些介绍，要么是因为无法真正完成任务或者适用场景非常有限，要么是其原理我还不理解，因此只进行简单介绍。使用 .NET Core 3.0 自带的 PublishSingleFile 属性合并依赖.NET Core 3.0 自 Preview 5 开始，增加了发布成单一 exe 文件的功能。在你的项目文件中增加下面的两行可以开启此功能： &amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;OutputType&amp;gt;Exe&amp;lt;/OutputType&amp;gt; &amp;lt;TargetFramework&amp;gt;netcoreapp3.0&amp;lt;/TargetFramework&amp;gt;++ &amp;lt;RuntimeIdentifier&amp;gt;win10-x64&amp;lt;/RuntimeIdentifier&amp;gt;++ &amp;lt;PublishSingleFile&amp;gt;true&amp;lt;/PublishSingleFile&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;/Project&amp;gt;第一行 RuntimeIdentifier 一定需要指定，因为发布的单一文件是特定于架构的。这里，我们指定了 win10-x64，你也可以指定为其他的值。可以使用的值你可以在这篇文章中查询到： .NET Core Runtime IDentifier (RID) catalog - Microsoft Docs第二行 PublishSingleFile 即开启发布时单一文件的功能。这样，你在发布你的程序的时候可以得到一个单一的可执行程序。发布一个 .NET Core 项目的方法是在命令行中输入：dotnet publish当然，如果你没有更改任何你的项目文件（没有增加上面的那两行），那么你在使用发布命令的时候就需要把这两个属性再增加上。因此完整的发布命令是下面这样的：dotnet publish -r win10-x64 /p:PublishSingleFile=true这里的 -r 就等同于在项目中指定 RuntimeIdentifier 持续。这里的 /p 是在项目中增加一个属性，而增加的属性名是 PublishSingleFile，增加的属性值是 true。使用 .NET Core 3.0 这种自带的发布单一 exe 的方法会将你的程序的全部文件（包括所有依赖文件，包括非托管程序集，包括各种资源文件）全部打包到一个 exe 中。当运行这个 exe 的时候，会首先将所有这些文件生成到本地计算机中一个临时目录下。只有第一次运行这个 exe 的时候才会生成这个目录和其中的文件，之后的运行是不会再次生成的。下面说一些 .NET Core 3.0 发布程序集的一点扩展——.NET Core 3.0 中对于发布程序集的三种处理方式可以放在一起使用： 裁剪程序集（Assembly Trimmer） 提前编译（Ahead-of-Time compilation，通过 crossgen）后面马上会说到 Microsoft.DotNet.ILCompiler 单一文件打包（Single File Bundling）本小节关于 .NET Core 3.0 中发布仅一个 exe 的方法、原理和实践，可以参见林德熙的博客： dotnet core 发布只有一个 exe 的方法.NET Core 在 GitHub 上开源： .NET Foundation使用 Fody在你的项目中安装一个 NuGet 包 Costura.Fody。一般来说，安装完之后，你编译的时候就会生成仅有一个 exe 的程序集了。如果你继续留意，可以发现项目中多了一个 Fody 的专属配置文件 FodyWeavers.xml，内容如下：&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;&amp;lt;Weavers&amp;gt; &amp;lt;Costura/&amp;gt;&amp;lt;/Weavers&amp;gt;仅仅到此为止你已经足够利用 Fody 完成程序集的合并了。但是，如果希望对 Fody 进行更精细化的配置，可以阅读叶洪的博客： .NET 合并程序集（将 dll 合并到 exe 中） - Iron 的博客 - CSDN博客Fody 在 GitHub 上开源： Fody/Fody: Extensible tool for weaving .net assemblies使用 SourceYard 源代码包SourceYard 源代码包在程序集合并上是另辟蹊径的一种合并方式。它不能帮助你将所有的依赖全部合并，但足以让你在发布一些简单应用的时候不至于引入大量的依赖。例如，你可以考虑新建一个项目，然后安装下面的 NuGet 包： lindexi.src.MacAddress.Source安装完成之后，你就可以在你的项目中使用到此 NuGet 包为你带来的获取 MAC 地址的工具类了。using System;using lindexi.src;namespace Walterlv.Demo{ internal static class Program { static void Main() { var macList = MacAddress.GetActiveMacAddress(); foreach (var mac in macList) { Console.WriteLine(mac); } } }}编译完你的项目，你会发现你的项目没有携带任何依赖。你安装的 NuGet 包并没有成为你的依赖，反而成为你正在编译的程序集的一部分。如果你要制作一个像上面那样的源代码包，只需要在你要制作 NuGet 包的项目安装上 dotnetCampus.SourceYard，在你打包成 NuGet 包的时候，就会生成一个普通的 NuGet 包以及一个 *.Source.nupkg 的源代码包。将源代码包上传到 nuget.org 上，其他人便可以安装你制作的源代码包了。关于如何使用 SourceYard 制作一个源代码包的方法可以阅读林德熙的博客： SourceYard 制作源代码包关于能够做出源代码包的原理，可以阅读我的博客： 入门篇：将 .NET Core 项目打一个最简单的 NuGet 源码包，安装此包就像直接把源码放进项目一样 进阶篇：从零开始制作 NuGet 源代码包（全面支持 .NET Core / .NET Framework / WPF 项目）SourceYard 在 GitHub 上开源： dotnet-campus/SourceYard: Add a NuGet package only for dll reference? By using dotnetCampus.SourceYard, you can pack a NuGet package with source code. By installing the new source code package, all source codes behaviors just like it is in your project.使用 ILMerge 或者 ILRepack 等工具ILMerge 和 ILRepack 的合并就更加富有技术含量——当然坑也更多。这两个都是工具，因此，你需要将工具下载下来使用。你有很多种方法下载到工具使用，因此我会推荐不同的人群使用不同的工具。ILMergeILMerge 命令行工具是微软官方出品，下载地址： Download ILMerge from Official Microsoft Download Center其使用方法请参见我的博客： .NET 使用 ILMerge 合并多个程序集，避免引入额外的依赖 - walterlvILRepackILRepack 基于 Mono.Ceil 来进行 IL 合并，其使用方法可以参见我的博客： .NET 使用 ILRepack 合并多个程序集（替代 ILMerge），避免引入额外的依赖 - walterlvILMerge-GUI 工具（已过时，但适合新手随便玩玩）你可以在以下网址中找到 ILMerge-GUI 的下载链接： wvd-vegt / ilmergegui / Downloads — BitbucketILMerge-GUI 工具在 Bitbucket 上开源： wvd-vegt / ilmergegui — Bitbucket其他方法使用 Microsoft.DotNet.ILCompiler可以将 .NET Core 编译为单个无依赖的 Native 程序。你需要先安装一个预览版的 NuGet 包 Microsoft.DotNet.ILCompiler关于 Microsoft.DotNet.ILCompiler 的使用，你可以阅读林德熙的博客： dotnet core 使用 CoreRT 将程序编译为 Native 程序使用 dnSpydnSpy 支持添加一个模块到程序集，也可以创建模块，还可以将程序集转换为模块。因此，一个程序集可以包含多个模块的功能就可以被充分利用起来。使用 WarpWarp 在 GitHub 上开源： dgiagio/warp: Create self-contained single binary applications其使用可以参见林德熙的博客： dotnet core 发布只有一个 exe 的方法各种方法的原理和使用场景比较原理使用 .NET Core 3.0 自带的 PublishSingleFile 属性合并依赖，其原理是生成一个启动器容器程序。最终没有对程序进行任何修改，只是单纯的打包而已。使用 Fody，是将程序集依赖放到了资源里面。当要加载程序集的时候，会直接将资源中的程序集流加载到内存中。使用 SourceYard 源代码包，是直接将源代码合并到了目标项目里面。使用 ILMerge / ILRepack，是在 IL 级别对程序集进行了合并。我们可以通过下面一张图来感受一下后三种原理上的不同。这是一个分别通过 Fody、SourceYard 和 ILMerge / ILRepack 生成的程序集的反编译图。可以看到，对于 ILRepack / ILMerge 和 SourceYard，反编译后看到的源代码都在目标程序集中，而对于 Fody，依赖仅仅出现在资源中。适用范围由于其原理不同，所以其适用范围和造成的副作用也不同。如果你基于 .NET Core 3.0 开发，并且也不在意在目标计算机上生成的临时文件夹，那么可以考虑使用 PublishSingleFile 属性合并依赖。如果你不在乎启动性能以及内存消耗，那么可以考虑 Fody（这意味着小型程序比较适合采用）。如果你的程序非常在乎启动性能，那么就需要考虑 SourceYard、ILMerge / ILRepack 了。对于 ILMerge / ILRepack 和 SourceYard 的比较，可以看下面这张表格： 方案 ILRepack / ILMerge SourceYard 适用于 任意 .NET 程序集 通过 SourceYard 发布的 NuGet 包 WPF ILRepack 支持，ILMerge 不支持 支持 调试（支持） 仅支持一般方法的调试 支持一般程序集支持的所有调试方法 调试（不支持） 不支持异步方法调试，不支持显示局部变量 没有不支持的 隐藏 API internal 的类型和成员可以隐藏 必须是 private 类型和成员才可隐藏 可以发现，如果我们能够充分将我们需要的包通过 SourceYard 发布成 NuGet，那么我们将可以获得比 ILRepack / ILMerge 更好的编写和调试体验。表格之外还有一些特别需要说明的： ILRepack 额外支持修改 WPF 编译生成的 Baml 文件，将资源的引用路径修改成新程序集的路径。 SourceYard 的类型需要写成 private 才可以隐藏，但是只有内部类才可以写 private，因此如果特别需要隐藏，请首先写一个内部类。（因此，你可能会发现有一个类型有很多个分部类，每一个分部类中都是一个私有的内部类）开源社区最后说一下，以上所说的所有方法全部是开源的，有问题欢迎在社区讨论一起解决： .NET Foundation Fody/Fody dotnet-campus/SourceYard dotnet/ILMerge gluck/il-repack 0xd4d/dnSpy dgiagio/warp corert/pkg/Microsoft.DotNet.ILCompiler" }, { "title": ".NET 中选择合适的文件打开模式（CreateNew, Create, Open, OpenOrCreate, Truncate, Append）", "url": "/post/dotnet-file-open-modes.html", "categories": "", "tags": "dotnet, csharp, windows", "date": "2020-01-08 15:05:41 +0800", "snippet": ".NET 中文件打开的 API File.Open 提供了多种不同的文件打开方式，这些方式大多数与 Windows 文件 API 中的模式是对应的，但也有一些 .NET 层面的判断以及名称的变化。在 .NET 层你可以选择适合你业务场景需要的文件打开方式。文件打开方式文件打开的多个重载方法中，除了封装好的 OpenRead / OpenWrite 之外，其他都是需要指定 FileMode 参数的。public static FileStream Open(string path, FileMode mode);FileModeFileMode 枚举有 6 种不同的值：public enum FileMode{ CreateNew = 1, Create = 2, Open = 3, OpenOrCreate = 4, Truncate = 5, Append = 6,}为了方便查阅，我先将大家可能关心的内容做一个表格： FileMode 如果文件存在 如果文件不存在 CreateNew IOException 新建 Create 截断 新建 Open 打开 FileNotFoundException OpenOrCreate 打开 新建 Truncate 截断 FileNotFoundException Append 追加 新建 所有这些打开模式都不会修改到文件的属性（Attribute），包括创建时间、针对用户的权限设置。所以如果你希望连这些属性都不需要，而是完完全全创建新的文件，那么请先将原来的文件删除。注意，在 File.Open 方法中传入以下这些参数的含义描述中可能有一些包含过程和判断的语句，但实际上这些真正的判断和过程发生在 Windows 内核（虽然 .NET 也有一些判断，但是一些参数预判断和参数转换），所以实际拿到文件流（对应 Win32 中拿到句柄）是一个原子操作，不会因为中间加了判断导致与其他线程发生竞争。CreateNew如果文件不存在，则创建一个新的文件并返回新文件的文件流。如果文件已经存在，则抛出 IOException。Create如果文件不存在，则创建一个新的文件并返回新文件的文件流。如果文件已经存在，则打开文件并返回此文件的文件流。基于此文件流的修改会完全复写文件。也就是说，如果原文件内容是 walterlv，通过此文件流写入 111，那么最终文件内容是 111。Open如果文件存在，则打开文件并返回此文件的文件流。如果文件不存在，则抛出 FileNotFoundException。基于此文件流的修改不会截断文件。也就是说，如果原文件内容是 walterlv，通过此文件流写入 111，那么最终文件内容是 111terlv。OpenOrCreate如果文件存在，则打开文件并返回此文件的文件流。如果文件不存在，则创建一个文件并返回新文件的文件流。基于此文件流的修改不会截断文件。也就是说，如果原文件内容是 walterlv，通过此文件流写入 111，那么最终文件内容是 111terlv。Truncate如果文件存在，则打开后文件的长度直接变为 0，随后返回此文件的文件流。如果文件不存在，则会抛出 FileNotFoundException。由于在打开文件时就已经将文件设置为 0 字节，所以对应到上面截断的描述是一定会截断的。写入任何新内容到文件候，文件中都不会存在旧文件中的内容。Append如果文件不存在，则创建一个新的文件并返回新文件的文件流。如果文件已经存在，则创建一个可以往文件的结尾处开始写的文件流。如果试图从文件流中往前倒推找到此前的文件内容，会抛出 IOException。配合文件打开权限在以上这些 FileMode 中，CreateNew、Create、Truncate、Append 都是需要写文件的权限的，OpenOrCreate 是否需要写权限则取决于文件是否存在。附源码以下是 FileStream 中的 Open 方法最终调用处。可以发现，此方法将传入的 FileMode 转换成了 Win32 中的值，并且最终调用了 Windows API CreateFile。你可以阅读我的另一篇博客了解 Win32 API 中的 CreateFile： Win32 方法 CreateFile 中选择合适的文件打开模式（CREATE_NEW, CREATE_ALWAYS, OPEN_EXISTING, OPEN_ALWAYS, TRUNCATE_EXISTING） - walterlvprivate unsafe SafeFileHandle CreateFileOpenHandle(FileMode mode, FileShare share, FileOptions options){ Interop.Kernel32.SECURITY_ATTRIBUTES secAttrs = GetSecAttrs(share); int fAccess = ((_access &amp;amp; FileAccess.Read) == FileAccess.Read ? Interop.Kernel32.GenericOperations.GENERIC_READ : 0) | ((_access &amp;amp; FileAccess.Write) == FileAccess.Write ? Interop.Kernel32.GenericOperations.GENERIC_WRITE : 0); // Our Inheritable bit was stolen from Windows, but should be set in // the security attributes class. Don&#39;t leave this bit set. share &amp;amp;= ~FileShare.Inheritable; // Must use a valid Win32 constant here... if (mode == FileMode.Append) mode = FileMode.OpenOrCreate; int flagsAndAttributes = (int)options; // For mitigating local elevation of privilege attack through named pipes // make sure we always call CreateFile with SECURITY_ANONYMOUS so that the // named pipe server can&#39;t impersonate a high privileged client security context // (note that this is the effective default on CreateFile2) flagsAndAttributes |= (Interop.Kernel32.SecurityOptions.SECURITY_SQOS_PRESENT | Interop.Kernel32.SecurityOptions.SECURITY_ANONYMOUS); using (DisableMediaInsertionPrompt.Create()) { Debug.Assert(_path != null); return ValidateFileHandle( Interop.Kernel32.CreateFile(_path, fAccess, share, ref secAttrs, mode, flagsAndAttributes, IntPtr.Zero)); }}// Contains constants for specifying how the OS should open a file.// These will control whether you overwrite a file, open an existing// file, or some combination thereof.//// To append to a file, use Append (which maps to OpenOrCreate then we seek// to the end of the file). To truncate a file or create it if it doesn&#39;t// exist, use Create.//public enum FileMode{ // Creates a new file. An exception is raised if the file already exists. CreateNew = 1, // Creates a new file. If the file already exists, it is overwritten. Create = 2, // Opens an existing file. An exception is raised if the file does not exist. Open = 3, // Opens the file if it exists. Otherwise, creates a new file. OpenOrCreate = 4, // Opens an existing file. Once opened, the file is truncated so that its // size is zero bytes. The calling process must open the file with at least // WRITE access. An exception is raised if the file does not exist. Truncate = 5, // Opens the file if it exists and seeks to the end. Otherwise, // creates a new file. Append = 6,}参考资料 FileMode Enum (System.IO) - Microsoft Docs" }, { "title": "Win32 方法 CreateFile 中选择合适的文件打开模式（CREATE_NEW, CREATE_ALWAYS, OPEN_EXISTING, OPEN_ALWAYS, TRUNCATE_EXISTING）", "url": "/post/win32-file-open-modes.html", "categories": "", "tags": "windows, dotnet, csharp", "date": "2020-01-08 15:05:12 +0800", "snippet": "Windows 打开文件的 API 中提供了多种不同的文件打开方式。你可以根据你的业务场景选择适合你的文件打开方式。Windows APIOpenFile 方法只能打开已经存在的文件，而使用 CreateFile 则可以在打开文件的同时应对不存在文件时的创建。HANDLE CreateFileW( LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);其中 dwCreationDisposition 参数用来指定文件打开的时候如何处理文件的创建和追加行为。dwCreationDispositiondwCreationDisposition 可以传入 5 种不同的值。 CREATE_NEW CREATE_ALWAYS OPEN_EXISTING OPEN_ALWAYS TRUNCATE_EXISTING为了方便查阅，我先将大家可能关心的内容做一个表格： dwCreationDisposition 如果文件存在 如果文件不存在 CREATE_NEW ERROR_FILE_EXISTS 新建 CREATE_ALWAYS 截断 新建 OPEN_EXISTING 打开 ERROR_FILE_NOT_FOUND OPEN_ALWAYS 打开 新建 TRUNCATE_EXISTING 截断 ERROR_FILE_NOT_FOUND 所有这些打开模式都不会修改到文件的属性（Attribute），包括创建时间、针对用户的权限设置。所以如果你希望连这些属性都不需要，而是完完全全创建新的文件，那么请先将原来的文件删除。CREATE_NEW如果文件不存在，则创建一个文件。如果文件不存在，则执行失败，通过 GetLastError 可以得到错误码 ERROR_FILE_EXISTS (80)。CREATE_ALWAYS如果文件不存在，则创建一个新的文件。如果文件已经存在，则此文件将完全被复写。基于此文件流的修改会完全复写文件。也就是说，如果原文件内容是 walterlv，通过此文件流写入 111，那么最终文件内容是 111。OPEN_EXISTING如果文件存在，则打开文件。如果文件不存在，通过 GetLastError 可以得到错误码 ERROR_FILE_NOT_FOUND (2)。基于此文件流的修改不会截断文件。也就是说，如果原文件内容是 walterlv，通过此文件流写入 111，那么最终文件内容是 111terlv。OPEN_ALWAYS如果文件存在，那么会成功打开文件；并且也可以通过 GetLastError 可以得到状态 ERROR_ALREADY_EXISTS (183)。如果文件不存在，新建一个文件。基于此文件流的修改不会截断文件。也就是说，如果原文件内容是 walterlv，通过此文件流写入 111，那么最终文件内容是 111terlv。TRUNCATE_EXISTING如果文件存在，则打开后文件的长度直接变为 0。如果文件不存在，通过 GetLastError 可以得到错误码 ERROR_FILE_NOT_FOUND (2)。参考资料 CreateFileW function (fileapi.h) - Win32 apps - Microsoft Docs" }, { "title": "WPF 中如何创建忽略 DPI 属性的图片", "url": "/post/create-wpf-image-source-ignoring-dpi.html", "categories": "", "tags": "wpf, dotnet, csharp", "date": "2020-01-08 12:57:02 +0800", "snippet": "WPF 框架设计为与 DPI 无关，但你依然可能遇到 DPI 问题。尤其是 Image 控件显示的图片会根据图片 EXIF 中的 DPI 信息和屏幕 DPI 自动缩放图片。对于 UI 用图来说这是好事，但对于软件用户随便插入的图片来说就不是了——用户传入的图片可能是各种各样不统一的 DPI。因此这种 DPI 我们应该忽略。解决方法直接设置 Image 控件的大小是一个不错的方案，这在允许设置 Image 控件大小的场合下是可以使用的。如果你能设置，那么直接设置，这是最好的方法了。除此之外，我们还可能可以尝试这些方法： 创建 BitmapImage 对象，根据当前屏幕的 DPI 值计算 DecodePixelWidth 和 DecodePixelHeight； 创建 DrawingImage 对象，直接按照 WPF 的坐标单位绘制图片原始像素大小的图片； 创建 Bitmap / WriteableBitmap 对象，重新创建一张 96 DPI 的图片。以下的代码中，都假设当前 DPI 的值为 monitorDpi。DrawingImageDrawingImage 可以使用 WPF 的方式来绘制，不过如果要绘制位图，也需要一个 BitmapImage 对象，不过这个时候我们可以按照我们需要的尺寸进行绘制而不用关心 DPI 的问题。由于尺寸是在绘制的时候确定的，所以不需要 Image 控件也设置尺寸。private static ImageSource CreateBitmapImage(Stream sourceStream){ var bitmap = new BitmapImage(); bitmap.BeginInit(); bitmap.StreamSource = sourceStream; bitmap.EndInit(); var image = new ImageDrawing( bitmap, new Rect(0, 0, bitmap.PixelWidth / monitorDpi.FactorX, bitmap.PixelHeight / monitorDpi.FactorY)); var drawing = new DrawingImage(image); return drawing;}" }, { "title": "为什么不应该公开用来同步的加锁对象？为什么不应该 lock(this)/lock(string) 或者 lock 任何非私有对象？", "url": "/post/why-making-the-sync-root-public-is-dangerous.html", "categories": "", "tags": "dotnet, csharp", "date": "2020-01-07 09:29:31 +0800", "snippet": "如果你编写线程安全代码时为了省事儿直接 lock(this)，或者早已听说不应该 lock(this)，只是不知道原因，那么阅读本文可以帮助你了解原因。原因不应该 lock(this) 是因为你永远不知道别人会如何使用你的对象，永远不知道别人会在哪里加锁。于是稍不注意就可能死锁！实例看看下面的两段代码。第一段是定义好的一个类，其中某个方法为了线程安全加了锁，但加锁的是 this 对象。public class Foo{ public void DoSafety() { lock (this) { // 执行一些线程安全的事情。 } }}第二段代码使用了这个类的一个实例。为了响应放到了后台线程中，但为了线程安全，加了锁。public class Bar{ private readonly Foo _foo = new Foo(); public async void DouB_Walterlv() { lock (_foo) { await Task.Run(() =&amp;gt; _foo.DoSafety()); } }}仔细看看这段代码，如果 DouB_Walterlv 方法执行，会发生什么？—— 死锁在 DouB_Walterlv 方法中完全看不出来为什么死锁，只能进入到 DoSafety 中才发现试图 lock 的 this 对象刚刚在另一个线程被 lock (_foo) 了。扩展从以上的例子可以看出，不止是 lock (this) 会出现“难以捉摸”的死锁问题，lock 任何公开对象都会这样。lock 公开的属性public class Foo{ public object SyncRoot { get; } = new object();}只要在 A 处 lock 这个对象的同时，在另一个线程调用了同样 lock 这个对象的 B 处的代码，必然死锁。如果你试图实现某些接口中的 SyncRoot 属性，却遇到了上述矛盾（这样的写法不安全），那么可以阅读我的另一篇博客了解如何实现这样的“有问题”的接口： 为什么实现 .NET 的 ICollection 集合时需要实现 SyncRoot 属性？如何正确实现这个属性？lock 字符串你可以定义一个私有的字符串，但你永远不知道这个字符串是否与其他字符串是同一个实例。因此这也是不安全的。 .NET/C# 的字符串暂存池 - walterlv .NET/C# 编译期间能确定的相同字符串，在运行期间是相同的实例 - walterlv .NET/C# 编译期能确定的字符串会在字符串暂存池中不会被 GC 垃圾回收掉 - walterlvlock 其他任何可能被其他对象获取的公开对象比如 Type 对象，比如其他公共静态对象。结论所以，一旦你决定 lock，那么这个对象请做成 private。" }, { "title": "如何在旧版本的 .NET Core / Framework 中使用 C# 8 的异步流（IAsyncDisposable / IAsyncEnumerable / IAsyncEnumerator）", "url": "/post/use-async-streams-in-old-dotnet.html", "categories": "", "tags": "dotnet, csharp", "date": "2020-01-03 17:17:34 +0800", "snippet": "C# 8.0 为我们带来了异步流，可以使用 async foreach，不过使用此语法需要 IAsyncEnumerable / IAsyncEnumerator 类型。本文介绍如何在旧版本的 .NET Framework 和旧版本的 .NET Core 中获得此类型。异步流所需版本异步流需要 .NET Core 3.0 及以上版本才能直接支持。而如果是 .NET Framework，则是任何版本都不直接支持。如果需要在早期版本使用异步流，需要安装 Microsoft.Bcl.AsyncInterfaces 这个 NuGet 包。这就像在早期版本中使用 ValueTuple 需要安装 System.ValueTuple 一样。安装 Microsoft.Bcl.AsyncInterfaces需要先在你的项目中安装 NuGet 包：Microsoft.Bcl.AsyncInterfaces&amp;lt;PackageReference Include=&quot;Microsoft.Bcl.AsyncInterfaces&quot; Version=&quot;1.1.0&quot; /&amp;gt;安装此包之后，即可在你的项目当中开启异步流的支持。一点说明：异步流中使用到了 ValueTask，此类型需要 System.Threading.Tasks.Extensions 包的支持。在 .NET Framework 4.8 以下会自动额外引入此包。使用异步流定义支持异步流的方法private async IAsyncEnumerable&amp;lt;string&amp;gt; EnumerateTestsAsync(){ for (var i = 0; i &amp;lt; 3; i++) { await Task.Delay(100).ConfigureAwait(false); yield return $&quot;欢迎访问吕毅的博客，第 {i} 页&quot;; }}使用 await foreach直接使用 await foreach 即可使用 C# 8.0 带来的异步流。var verify = 0;await foreach (var i in EnumerateTestsAsync()){ Assert.AreEqual(verify, i); verify++;}Assert.AreEqual(3, verify);额外说明记得如果你在 .NET Framework 4.8 或以下版本，.NET Core 3.0 以下版本编写代码时，自动启用的 C# 语言版本是 7.3，所以你需要额外为你的项目启用 C# 8.0 才行。&amp;lt;LangVersion&amp;gt;latest&amp;lt;/LangVersion&amp;gt;另外，由于 ValueTask 要求的最低 .NET Framework 版本为 4.5.2，所以如果使用更低版本的 .NET Framework，将无法使用异步流。参考资料 Async streams - C# 8.0 specification proposals - Microsoft Docs Using async disposable and async enumerable in frameworks older than .NET Core 3.0 - StrathWeb. A free flowing web tech monologue." }, { "title": ".NET/C# 解压 Zip 文件时出现异常：System.IO.InvalidDataException: 找不到中央目录结尾记录。", "url": "/post/zip-extracting-with-invalid-data-exception.html", "categories": "", "tags": "dotnet, csharp", "date": "2020-01-03 17:12:52 +0800", "snippet": "在解压 Zip 文件时出现异常：System.IO.InvalidDataException: 找不到中央目录结尾记录。。其原因是所解压的文件并非 zip 文件。异常在解压 Zip 文件时出现异常：System.IO.InvalidDataException: 找不到中央目录结尾记录。 在 System.IO.Compression.ZipArchive.ReadEndOfCentralDirectory() 在 System.IO.Compression.ZipArchive.Init(Stream stream, ZipArchiveMode mode, Boolean leaveOpen) 在 System.IO.Compression.ZipArchive..ctor(Stream stream, ZipArchiveMode mode, Boolean leaveOpen, Encoding entryNameEncoding) 在 System.IO.Compression.ZipFile.Open(String archiveFileName, ZipArchiveMode mode, Encoding entryNameEncoding) 在 System.IO.Compression.ZipFile.ExtractToDirectory(String sourceArchiveFileName, String destinationDirectoryName, Encoding entryNameEncoding) 在 System.IO.Compression.ZipFile.ExtractToDirectory(String sourceArchiveFileName, String destinationDirectoryName)原因如果一个文件并非 zip 文件，那么在解压的时候就会出现此异常。例如，它下载不全，是损坏的；或者，它实际上是一个 rar 文件或者 7z 文件。验证也非常简单，直接使用其他任何成熟的解压缩工具试着解压以下这个文件就可以。如果其他工具也不能解压，通常说明文件下载不全或者已损坏，或者下载的是一个被重定向了的 html 文件。如果其他工具能够正常解压，说明这可能是其他格式的压缩包，而不是 zip。" }, { "title": "Windows 系统文件资源管理器的命令行参数（如何降权打开程序，如何选择文件）", "url": "/post/command-line-usage-of-windows-explorer.html", "categories": "", "tags": "windows", "date": "2020-01-02 11:05:18 +0800", "snippet": "大多数用户还是习惯使用 Windows 自带的文件资源管理器来管理文件，于是我们可以利用它的命令行参数来帮助我们做一些与之相关的交互。本文会以实际的例子来说明如何使用 explorer.exe 的命令行参数。打开文件在命令行中输入 explorer D:\\Services\\blog.walterlv.com\\test.txt 即可打开 test.txt 文件。不过，这个时候是间接使用文件资源管理器打开的文件，效果跟我们直接在文件资源管理器中双击打开这个文件的效果是一样的。启动程序实际上利用文件资源管理器启动程序和前面的打开文件是同一种命令，不过我特别拿出来说，是因为使用这种方式来启动程序还有一种特别的功效： 可以降权执行使用方法：explorer D:\\Services\\blog.walterlv.com\\Walterlv.Blog.Home.exe如果你当前进程是管理员权限，那么可以通过 explorer 间接启动将新启动的进程降低到与 explorer 同级别的权限。不过，有几点需要注意的： 如果用来降权，那么只会降到与文件资源管理器同级别的权限 而文件资源管理器是什么权限在 Windows 7 上和 Windows 8/8.1/10 上不同 Windows 8/8.1/10 无论开关 UAC 都是普通用户权限，除非你特别使用任务管理器（Task Manager）以管理员权限启动文件资源管理器 Windows 7 在开启 UAC 的情况下，文件资源管理器是以普通用户权限运行的 Windows 7 在关闭 UAC 的情况下，文件资源管理器是以管理员权限运行的 不允许给间接启动的程序携带命令行参数 如果你试图传入额外的参数，那么最终不会执行这个程序，只会打开一个根你的程序毫无关系的文件管理器的新窗口而已 explorer 必须是已经启动的状态（大多数时候都是这样）关于利用文件资源管理器降权执行程序的内容，可以阅读我的另一篇博客： 在 Windows 系统上降低 UAC 权限运行程序（从管理员权限降权到普通用户权限） - walterlv关于 UAC 权限相关的内容，可以阅读我的另一篇博客： Windows 中的 UAC 用户账户控制 - walterlv Windows 的 UAC 设置中的通知等级实际上只有两个档而已 - walterlv如果你使用 .NET 程序来完成启动程序的话，可能需要关注 UseShellExecute。不过利用 explorer 间接启动就无所谓了，无脑设置为 false 就好，因为它自己就相当于 Shell。 C#/.NET 中启动进程时所使用的 UseShellExecute 设置为 true 和 false 分别代表什么意思？ - walterlv打开某个文件夹explorer D:\\Services\\blog.walterlv.com选择某个文件在与其他工具集成的时候，如果有需求要打开某个文件夹，并自动滚动到希望看到的文件选中它，那么这个命令非常有用：explorer /select,&quot;D:\\Services\\blog.walterlv.com\\Walterlv.Blog.Home.exe&quot;这可以在打开文件资源管理器的同时，选中 Walterlv.Blog.Home.exe 文件，并将它滚动到可视区域。其他命令行参数在以上这些命令的基础上，可以添加一些可选参数用来控制如何执行这些命令。 /separate 让文件资源管理器在一个新的进程中打开 一些特殊文件夹的命令打开当前工作路径的根目录：&amp;gt; explorer \\打开“文档”文件夹：&amp;gt; explorer \\\\# 或者explorer /打开“计算机”文件夹：# 注意，此命令在 CMD 中可以直接执行，在 PowerShell 中需要加上引号，即 &quot;,&quot;explorer ,参考资料 How to run Windows Explorer as a different user (so I can do admin work) – Florin Lazar – Consistency Checkpoint How to launch Windows Explorer with the privileges of a different domain user? - Super User" }, { "title": "如何在 MSBuild 中正确使用 % 来引用每一个项（Item）中的元数据", "url": "/post/how-to-reference-msbuild-item-metadata.html", "categories": "", "tags": "msbuild, dotnet", "date": "2019-12-27 17:45:37 +0800", "snippet": "MSBuild 中写在 &amp;lt;ItemGroup /&amp;gt; 中的每一项是一个 Item，Item 除了可以使用 Include/Update/Remove 来增删之外，还可以定义其他的元数据（Metadata）。使用 % 可以引用 Item 的元数据，本文将介绍如何正确使用 % 来引用每一个项中的元数据。定义 Item 的元数据就像下面这样，当引用一个 NuGet 包时，可以额外使用 Version 来指定应该使用哪个特定版本的 NuGet 包。这里的 Version 和 PrivateAssets 就是 PackageReference 的元数据。&amp;lt;ItemGroup&amp;gt; &amp;lt;PackageReference Include=&quot;dotnetCampus.Configurations.Source&quot; Version=&quot;1.0.0&quot; PrivateAssets=&quot;All&quot; /&amp;gt; &amp;lt;PackageReference Include=&quot;dotnetCampus.CommandLine.Source&quot; Version=&quot;1.2.1&quot; PrivateAssets=&quot;All&quot; /&amp;gt; &amp;lt;PackageReference Include=&quot;Walterlv.Win32.Source&quot; Version=&quot;0.12.2-alpha&quot; PrivateAssets=&quot;All&quot; /&amp;gt; &amp;lt;PackageReference Include=&quot;Walterlv.IO.PackageManagement.Source&quot; Version=&quot;0.13.2-alpha&quot; PrivateAssets=&quot;All&quot; /&amp;gt;&amp;lt;/ItemGroup&amp;gt;我们随便创建一个新的 Item，也可以定义自己的元数据。&amp;lt;ItemGroup&amp;gt; &amp;lt;_WalterlvItem Include=&quot;欢迎访问&quot; Url=&quot;https://&quot; /&amp;gt; &amp;lt;_WalterlvItem Include=&quot;吕毅的博客&quot; Url=&quot;blog.walterlv.com&quot; /&amp;gt;&amp;lt;/ItemGroup&amp;gt;引用元数据引用元数据使用的是 % 符号。&amp;lt;Target Name=&quot;_WalterlvDemo&quot; AfterTargets=&quot;AfterBuild&quot;&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;_WalterlvItem Include=&quot;欢迎访问&quot; Url=&quot;https://&quot; /&amp;gt; &amp;lt;_WalterlvItem Include=&quot;吕毅的博客&quot; Url=&quot;blog.walterlv.com&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;Message Text=&quot;@(_WalterlvItem)：%(Url)&quot; /&amp;gt;&amp;lt;/Target&amp;gt;虽然这里我们只写了一个 Message Task，但是最终我们会输出两次，每一个 _WalterlvItem 项都会输出一次。下面是这段代码的输出：_WalterlvDemo: 欢迎访问：https:// 吕毅的博客：blog.walterlv.com当你使用 % 的时候，会为每一个项执行一次这行代码。当然，如果某个 Task 支持传入集合，那么则可以直接收到集合。如果你不是用的 Message，而是定义一个其他的属性，使用 @(_WalterlvItem)：%(Url) 作为属性的值，那么这个属性也会为每一个项都计算一次值。当然最终这个属性的值就是最后一项计算所得的值。也许可以帮你回忆一下，如果我们不写 %(Url) 会输出什么。当只输出 @(WalterlvItem) 的时候，会以普通的分号分隔的文字。&amp;lt;Target Name=&quot;_WalterlvDemo&quot; AfterTargets=&quot;AfterBuild&quot;&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;_WalterlvItem Include=&quot;欢迎访问&quot; Url=&quot;https://&quot; /&amp;gt; &amp;lt;_WalterlvItem Include=&quot;吕毅的博客&quot; Url=&quot;blog.walterlv.com&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;Message Text=&quot;@(_WalterlvItem)&quot; /&amp;gt;&amp;lt;/Target&amp;gt;会输出：_WalterlvDemo: 欢迎访问;吕毅的博客使用元数据如果你希望自己处理编译过程，那么可能会对元数据做更多的处理。为了简单说明 % 的用法，我将已收集到的所有的元数据和它的本体一起输出到一个文件中。这样，后续的编译过程可以直接使用这个文件来获得所有的项和你希望关心它的所有元数据。&amp;lt;PropertyGroup&amp;gt; &amp;lt;_WalterlvContentArgsFilePath&amp;gt;$(IntermediateOutputPath)Args\\Content.txt&amp;lt;/_WalterlvContentArgsFilePath&amp;gt; &amp;lt;_WalterlvToolFile&amp;gt;$(MSBuildThisFileDirectory)..\\bin\\compile.exe&amp;lt;/_WalterlvContentArgsFilePath&amp;gt;&amp;lt;/PropertyGroup&amp;gt;&amp;lt;Target Name=&quot;_WalterlvDemo&quot; AfterTargets=&quot;AfterBuild&quot;&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;_WalterlvContentFileLine Include=&quot;@(Content)&quot; Line=&quot;@(Content)|%(Content.PublishState)|%(Content.CopyToOutputDirectory)&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;WriteLinesToFile File=&quot;$(_WalterlvContentArgsFilePath)&quot; Lines=&quot;%(_WalterlvContentFileLine.Line)&quot; Overwrite=&quot;True&quot; /&amp;gt; &amp;lt;Exec ConsoleToMSBuild=&quot;True&quot; Command=&quot;&amp;amp;quot;$(_WalterlvToolFile)&amp;amp;quot; PackContent --content-file &amp;amp;quot; $(_WalterlvContentArgsFilePath) &amp;amp;quot;&quot; /&amp;gt;&amp;lt;/Target&amp;gt;这段代码的含义是： 定义一个文件路径，这个路径即将用来存放所有 Content 项和它的元数据； 定义一个工具路径，我们即将运行这个路径下的命令行程序来执行自定义的编译； 收集所有的 Content 项，然后把所有项中的 PublishState 和 CopyToOutputDirectory 一起拼接成这个样子： Content|PublishState|CopyToOutputDirectory 写文件，将以上拼接出来的每一项写入到文件中的每一行； 执行工具程序，这个程序将使用这个文件来执行自定义的编译。关于使用 exe 进行自定义编译的部分可以参考我的另一篇博客： 如何创建一个基于命令行工具的跨平台的 NuGet 工具包 - walterlv关于写文件的部分可以参考我的另一篇博客： 在 MSBuild 编译过程中操作文件和文件夹（检查存在/创建文件夹/读写文件/移动文件/复制文件/删除文件夹） - walterlv关于项元数据的其他信息一些已知的元数据： MSBuild Well-known Item Metadata - Visual Studio - Microsoft Docs参考资料 MSBuild Items - Visual Studio - Microsoft Docs" }, { "title": "在 MSBuild 编译过程中操作文件和文件夹（检查存在/创建文件夹/读写文件/移动文件/复制文件/删除文件夹）", "url": "/post/msbuild-file-and-directory-operations.html", "categories": "", "tags": "msbuild, dotnet", "date": "2019-12-27 17:34:18 +0800", "snippet": "本文整理 MSBuild 在编译过程中对文件和文件夹处理的各种自带的编译任务（Task）。Exists 检查文件存在使用 Exists 可以判断一个文件或者文件夹是否存在。注意无论是文件还是文件夹，只要给定的路径存在就返回 true。可以作为 MSBuild 属性、项和编译任务的执行条件。&amp;lt;PropertyGroup Condition=&quot; Exists( &#39;$(MSBuildThisFileDirectory)..\\build\\build.xml&#39; ) &quot;&amp;gt; &amp;lt;_WalterlvPackingDirectory&amp;gt;$(MSBuildThisFileDirectory)..\\bin\\$(Configuration)\\&amp;lt;/_WalterlvPackingDirectory&amp;gt;&amp;lt;/PropertyGroup&amp;gt;MakeDir 创建文件夹下面的例子演示创建一个文件夹：&amp;lt;Target Name=&quot;_WalterlvCreateDirectoryForPacking&quot;&amp;gt; &amp;lt;MakeDir Directories=&quot;$(MSBuildThisFileDirectory)..\\bin\\$(Configuration)\\&quot; /&amp;gt;&amp;lt;/Target&amp;gt;下面是使用到 MakeDir 全部属性的例子，将已经成功创建的文件夹提取出来。&amp;lt;Target Name=&quot;_WalterlvCreateDirectoryForPacking&quot;&amp;gt; &amp;lt;MakeDir Directories=&quot;$(MSBuildThisFileDirectory)..\\bin\\$(Configuration)\\&quot;&amp;gt; &amp;lt;Output TaskParameter=&quot;DirectoriesCreated&quot; PropertyName=&quot;CreatedPackingDirectory&quot; /&amp;gt; &amp;lt;/MakeDir&amp;gt;&amp;lt;/Target&amp;gt;Move 移动文件下面的例子是将输出文件移动到一个专门的目录中，移动后，所有的文件将平级地在输出文件夹中（即所有的子文件夹中的文件也都被移动到同一层目录中了）。&amp;lt;PropertyGroup&amp;gt; &amp;lt;_WalterlvPackingDirectory&amp;gt;$(MSBuildThisFileDirectory)..\\bin\\$(Configuration)\\&amp;lt;/_WalterlvPackingDirectory&amp;gt;&amp;lt;/PropertyGroup&amp;gt;&amp;lt;Target Name=&quot;_WalterlvMoveFilesForPacking&quot;&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;_WalterlvToMoveFile Include=&quot;$(OutputPath)**&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;Move SourceFiles=&quot;@(_WalterlvToMoveFile)&quot; DestinationFolder=&quot;$(_WalterlvPackingDirectory)&quot; SkipUnchangedFiles=&quot;True&quot; /&amp;gt;&amp;lt;/Target&amp;gt;你可以通过下面的例子了解到 Move 的其他大多数属性及其用法：&amp;lt;PropertyGroup&amp;gt; &amp;lt;_WalterlvPackingDirectory&amp;gt;$(MSBuildThisFileDirectory)..\\bin\\$(Configuration)\\&amp;lt;/_WalterlvPackingDirectory&amp;gt;&amp;lt;/PropertyGroup&amp;gt;&amp;lt;Target Name=&quot;_WalterlvMoveFilesForPacking&quot;&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;_WalterlvToMoveFile Include=&quot;$(OutputPath)**&quot; /&amp;gt; &amp;lt;_WalterlvTargetFile Include=&quot;$(_WalterlvPackingDirectory)\\%(_WalterlvToMoveFile.RecursiveDir)&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;Move SourceFiles=&quot;@(_WalterlvToMoveFile)&quot; DestinationFiles=&quot;$(_WalterlvTargetFile)&quot; OverwriteReadOnlyFiles=&quot;True&quot;&amp;gt; &amp;lt;Output TaskParameter=&quot;MovedFiles&quot; PropertyName=&quot;MovedOutputFiles&quot; /&amp;gt; &amp;lt;/Copy&amp;gt;&amp;lt;/Target&amp;gt;这段代码除了没有使用 DestinationFolder 之外，使用到了所有 Move 能用的属性： 将所有的 _WalterlvToCopyFile 一对一地复制到 _WalterlvTargetFile 指定的路径上。 即便目标文件是只读的，也会覆盖。Copy 复制文件下面的例子是将输出文件拷贝到一个专门的目录中，保留原来所有文件之间的目录结构，并且如果文件没有改变则跳过。&amp;lt;PropertyGroup&amp;gt; &amp;lt;_WalterlvPackingDirectory&amp;gt;$(MSBuildThisFileDirectory)..\\bin\\$(Configuration)\\&amp;lt;/_WalterlvPackingDirectory&amp;gt;&amp;lt;/PropertyGroup&amp;gt;&amp;lt;Target Name=&quot;_WalterlvCopyFilesForPacking&quot;&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;_WalterlvToCopyFile Include=&quot;$(OutputPath)**&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;Copy SourceFiles=&quot;@(_WalterlvToCopyFile)&quot; DestinationFolder=&quot;$(_WalterlvPackingDirectory)\\%(RecursiveDir)&quot; SkipUnchangedFiles=&quot;True&quot; /&amp;gt;&amp;lt;/Target&amp;gt;如果你希望复制后所有的文件都在同一级文件夹中，不再有子文件夹，那么去掉 \\%(RecursiveDir)。你可以通过下面的例子了解到 Copy 的其他大多数属性及其用法：&amp;lt;PropertyGroup&amp;gt; &amp;lt;_WalterlvPackingDirectory&amp;gt;$(MSBuildThisFileDirectory)..\\bin\\$(Configuration)\\&amp;lt;/_WalterlvPackingDirectory&amp;gt;&amp;lt;/PropertyGroup&amp;gt;&amp;lt;Target Name=&quot;_WalterlvCopyFilesForPacking&quot;&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;_WalterlvToCopyFile Include=&quot;$(OutputPath)**&quot; /&amp;gt; &amp;lt;_WalterlvTargetFile Include=&quot;$(_WalterlvPackingDirectory)\\%(_WalterlvToCopyFile.RecursiveDir)&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;Copy SourceFiles=&quot;@(_WalterlvToCopyFile)&quot; DestinationFiles=&quot;@(_WalterlvTargetFile)&quot; OverwriteReadOnlyFiles=&quot;True&quot; Retries=&quot;10&quot; RetryDelayMilliseconds=&quot;10&quot; SkipUnchangedFiles=&quot;True&quot; UseHardlinksIfPossible=&quot;True&quot;&amp;gt; &amp;lt;Output TaskParameter=&quot;CopiedFiles&quot; PropertyName=&quot;CopiedOutputFiles&quot; /&amp;gt; &amp;lt;/Copy&amp;gt;&amp;lt;/Target&amp;gt;这段代码除了没有使用 DestinationFolder 之外，使用到了所有 Copy 能用的属性： 将所有的 _WalterlvToCopyFile 一对一地复制到 _WalterlvTargetFile 指定的路径上。 即便目标文件是只读的，也会覆盖。 如果复制失败，则重试 10 次，每次等待 10 毫秒 如果文件没有改变，则跳过复制 如果目标文件系统支持硬连接，则使用硬连接来提升性能Delete 删除文件下面这个例子是删除输出目录下的所有的 pdb 文件（适合 release 下发布软件）。&amp;lt;Target Name=&quot;_WalterlvDeleteFiles&quot;&amp;gt; &amp;lt;Delete Files=&quot;$(OutputPath)*.pdb&quot; /&amp;gt;&amp;lt;/Target&amp;gt;也可以把此操作已经删除的文件列表拿出来。使用全部属性的 Delete 的例子：&amp;lt;Target Name=&quot;_WalterlvDeleteFiles&quot;&amp;gt; &amp;lt;Delete Files=&quot;$(OutputPath)*.pdb&quot; TreatErrorsAsWarnings=&quot;True&quot;&amp;gt; &amp;lt;Output TaskParameter=&quot;DeletedFiles&quot; PropertyName=&quot;DeletedPdbFiles&quot; /&amp;gt; &amp;lt;/Delete&amp;gt;&amp;lt;/Target&amp;gt;ReadLinesFromFile 读取文件在编译期间，可以从文件中读出文件的每一行：&amp;lt;PropertyGroup&amp;gt; &amp;lt;_WalterlvToWriteFile&amp;gt;$(OutputPath)walterlv.md&amp;lt;/_WalterlvToWriteFile&amp;gt;&amp;lt;/PropertyGroup&amp;gt;&amp;lt;Target Name=&quot;_WalterlvReadFilesToLines&quot;&amp;gt; &amp;lt;ReadLinesFromFile File=&quot;$(_WalterlvToWriteFile)&quot;&amp;gt; &amp;lt;Output TaskParameter=&quot;Lines&quot; PropertyName=&quot;TheLinesThatRead&quot; /&amp;gt; &amp;lt;/ReadLinesFromFile&amp;gt;&amp;lt;/Target&amp;gt;WriteLinesToFile 写入文件可以在编译期间，将一些信息写到文件中以便后续编译的时候使用，甚至将代码写到文件中以便动态生成代码。&amp;lt;PropertyGroup&amp;gt; &amp;lt;_WalterlvBlogSite&amp;gt;https://blog.walterlv.com&amp;lt;/_WalterlvBlogSite&amp;gt; &amp;lt;_WalterlvToWriteFile&amp;gt;$(OutputPath)walterlv.md&amp;lt;/_WalterlvToWriteFile&amp;gt;&amp;lt;/PropertyGroup&amp;gt;&amp;lt;ItemGroup&amp;gt; &amp;lt;_WalterlvToWriteLine Include=&quot;This is the first line&quot; /&amp;gt; &amp;lt;_WalterlvToWriteLine Include=&quot;This is the second line&quot; /&amp;gt; &amp;lt;_WalterlvToWriteLine Include=&quot;My blog site is: $(_WalterlvBlogSite)&quot; /&amp;gt;&amp;lt;/ItemGroup&amp;gt;&amp;lt;Target Name=&quot;_WalterlvWriteFilesForPacking&quot;&amp;gt; &amp;lt;WriteLinesToFile File=&quot;$(_WalterlvToWriteFile)&quot; Lines=&quot;@(_WalterlvToWriteLine)&quot; /&amp;gt;&amp;lt;/Target&amp;gt;▲ 注意，默认写入文件是不会覆盖的，会将内容补充到原来文件的后面。&amp;lt;Target Name=&quot;_WalterlvWriteFilesForPacking&quot;&amp;gt; &amp;lt;WriteLinesToFile File=&quot;$(_WalterlvToWriteFile)&quot; Lines=&quot;@(_WalterlvToWriteLine)&quot; Overwrite=&quot;True&quot; Encoding=&quot;Unicode&quot; WriteOnlyWhenDifferent=&quot;True&quot; /&amp;gt;&amp;lt;/Target&amp;gt;RemoveDir 删除文件夹在编写编译命令的时候，可能会涉及到清理资源。或者为了避免无关文件的影响，在编译之前删除我们的工作目录。&amp;lt;Target Name=&quot;_WalterlvRemoveDirectoryForPacking&quot;&amp;gt; &amp;lt;RemoveDir Directories=&quot;$(MSBuildThisFileDirectory)..\\bin\\$(Configuration)\\&quot; /&amp;gt;&amp;lt;/Target&amp;gt;下面是使用到 MakeDir 全部属性的例子，将已经成功创建的文件夹提取出来。&amp;lt;Target Name=&quot;_WalterlvRemoveDirectoryForPacking&quot;&amp;gt; &amp;lt;RemoveDir Directories=&quot;$(MSBuildThisFileDirectory)..\\bin\\$(Configuration)\\&quot;&amp;gt; &amp;lt;Output TaskParameter=&quot;RemovedDirectories&quot; PropertyName=&quot;RemovedPackingDirectory&quot; /&amp;gt; &amp;lt;/RemoveDir&amp;gt;&amp;lt;/Target&amp;gt;" }, { "title": "如何在 .NET/C# 代码中安全地结束掉一个控制台应用程序？通过发送 Ctrl+C 信号来结束", "url": "/post/shutdown-a-console-program-safely-using-ctrl-c.html", "categories": "", "tags": "dotnet, csharp", "date": "2019-12-26 14:16:11 +0800", "snippet": "我的电脑上每天会跑一大堆控制台程序，于是管理这些程序的运行就成了一个问题。或者说你可能也在考虑启动一个控制台程序来完成某些特定的任务。如果我们需要结束掉这个控制台程序怎么做呢？直接杀进程吗？这样很容易出问题。我正在使用的一个控制台程序会写文件，如果直接杀进程可能导致数据没能写入到文件。所以本文介绍如何使用 .NET/C# 代码向控制台程序发送 Ctrl+C 来安全地结束掉程序。用 Ctrl+C 结束控制台程序如果直接用 Process.Kill 杀掉进程，进程可能来不及保存数据。所以无论是窗口程序还是控制台程序，最好都让控制台程序自己去关闭。▲ 使用 Process.Kill 结束程序，程序退出代码是 -1▲ 使用 Ctrl+C 结束程序，程序退出代码是 0Ctrl+C 信号Windows API 提供了方法可以将当前进程与目标控制台进程关联起来，这样我们便可以向自己发送 Ctrl+C 信号来结束掉关联的另一个控制台进程。关联和取消关联的方法是下面这两个，AttachConsole 和 FreeConsole：[DllImport(&quot;kernel32.dll&quot;)]private static extern bool AttachConsole(uint dwProcessId);[DllImport(&quot;kernel32.dll&quot;)]private static extern bool FreeConsole();不过，当发送 Ctrl+C 信号的时候，不止我们希望关闭的控制台程序退出了，我们自己程序也是会退出的（即便我们自己是一个 GUI 程序）。所以我们必须先组织自己响应 Ctrl+C 信号。需要用到另外一个 API：[DllImport(&quot;kernel32.dll&quot;)]private static extern bool SetConsoleCtrlHandler(ConsoleCtrlDelegate? HandlerRoutine, bool Add);enum CtrlTypes : uint{ CTRL_C_EVENT = 0, CTRL_BREAK_EVENT, CTRL_CLOSE_EVENT, CTRL_LOGOFF_EVENT = 5, CTRL_SHUTDOWN_EVENT}private delegate bool ConsoleCtrlDelegate(CtrlTypes CtrlType);不过，因为我们实际上并不需要真的对 Ctrl+C 进行响应，只是单纯临时禁用以下，所以我们归这个委托传入 null 就好了。最后，也是最关键的，就是发送 Ctrl+C 信号了：[DllImport(&quot;kernel32.dll&quot;)][return: MarshalAs(UnmanagedType.Bool)]private static extern bool GenerateConsoleCtrlEvent(CtrlTypes dwCtrlEvent, uint dwProcessGroupId);下面，我将完整的代码贴出来。全部源代码using System;using System.Diagnostics;using System.Runtime.InteropServices;namespace Walterlv.Fracture.Utils{ /// &amp;lt;summary&amp;gt; /// 提供与控制台程序的交互。 /// &amp;lt;/summary&amp;gt; public class ConsoleInterop { /// &amp;lt;summary&amp;gt; /// 关闭控制台程序。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;process&quot;&amp;gt;要关闭的控制台程序的进程实例。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&quot;timeoutInMilliseconds&quot;&amp;gt;如果不希望一直等待进程自己退出，则可以在此参数中设置超时。你可以在超时未推出候采取强制杀掉进程的策略。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;如果进程成功退出，则返回 true；否则返回 false。&amp;lt;/returns&amp;gt; public static bool StopConsoleProgram(Process process, int? timeoutInMilliseconds = null) { if (process is null) { throw new ArgumentNullException(nameof(process)); } if (process.HasExited) { return true; } // 尝试将我们自己的进程附加到指定进程的控制台（如果有的话）。 if (AttachConsole((uint)process.Id)) { // 我们自己的进程需要忽略掉 Ctrl+C 信号，否则自己也会退出。 SetConsoleCtrlHandler(null, true); // 将 Ctrl+C 信号发送到前面已关联（附加）的控制台进程中。 GenerateConsoleCtrlEvent(CtrlTypes.CTRL_C_EVENT, 0); // 拾前面已经附加的控制台。 FreeConsole(); bool hasExited; // 由于 Ctrl+C 信号只是通知程序关闭，并不一定真的关闭。所以我们等待一定时间，如果仍未关闭，则超时不处理。 // 业务可以通过判断返回值来角是否进行后续处理（例如强制杀掉）。 if (timeoutInMilliseconds == null) { // 如果没有超时处理，则一直等待，直到最终进程停止。 process.WaitForExit(); hasExited = true; } else { // 如果有超时处理，则超时候返回。 hasExited = process.WaitForExit(timeoutInMilliseconds.Value); } // 重新恢复我们自己的进程对 Ctrl+C 信号的响应。 SetConsoleCtrlHandler(null, false); return hasExited; } else { return false; } } [DllImport(&quot;kernel32.dll&quot;)] private static extern bool AttachConsole(uint dwProcessId); [DllImport(&quot;kernel32.dll&quot;)] private static extern bool FreeConsole(); [DllImport(&quot;kernel32.dll&quot;)] private static extern bool SetConsoleCtrlHandler(ConsoleCtrlDelegate? HandlerRoutine, bool Add); [DllImport(&quot;kernel32.dll&quot;)] [return: MarshalAs(UnmanagedType.Bool)] private static extern bool GenerateConsoleCtrlEvent(CtrlTypes dwCtrlEvent, uint dwProcessGroupId); enum CtrlTypes : uint { CTRL_C_EVENT = 0, CTRL_BREAK_EVENT, CTRL_CLOSE_EVENT, CTRL_LOGOFF_EVENT = 5, CTRL_SHUTDOWN_EVENT } private delegate bool ConsoleCtrlDelegate(CtrlTypes CtrlType); }}如何使用现在，我们可以通过调用 ConsoleInterop.StopConsoleProgram(process) 来安全地结束掉一个控制台程序。当然，为了处理一些意外的情况，我把超时也加上了。下面的用法演示超时 2 秒候程序还没有退出，则强杀。if (!ConsoleInterop.StopConsoleProgram(process, 2000)){ try { process.Kill(); } catch (InvalidOperationException e) { }}参考资料 signals - Can I send a ctrl-C (SIGINT) to an application on Windows? - Stack Overflow Stopping command-line applications programatically with Ctrl-C event from .Net – a working demo - Nemo’s Realms AttachConsole function - Windows Console - Microsoft Docs SetConsoleCtrlHandler function - Windows Console - Microsoft Docs" }, { "title": "如何将一个 .NET 对象序列化为 HTTP GET 的请求字符串", "url": "/post/serialize-object-to-http-get-query-string.html", "categories": "", "tags": "dotnet, csharp", "date": "2019-12-23 18:45:19 +0800", "snippet": "HTTP GET 请求时携带的参数直接在 URL 中，形式如 ?key1=value&amp;amp;key2=value&amp;amp;key3=value。如果是 POST 请求时，我们可以使用一些库序列化为 json 格式作为 BODY 发送，那么 GET 请求呢？有可以直接将其序列化为 HTTP GET 请求的 query 字符串的吗？HTTP GET 请求一个典型的 HTTP GET 请求带参数的话大概是这样的：https://s.blog.walterlv.com/api/example?key1=value&amp;amp;key2=value&amp;amp;key3=value于是我们将一个类型序列化为后面的参数：[DataContract]public class Foo{ [DataMember(Name = &quot;key1&quot;)] public string? Key1 { get; set; } [DataMember(Name = &quot;key2&quot;)] public string? Key2 { get; set; } [DataMember(Name = &quot;key3&quot;)] public string? Key3 { get; set; }}库？可能是这个需求太简单了，所以并没有找到单独的库。所以我就写了一个源代码包放到了 nuget.org 上。在这里下载源代码包： Walterlv.Web.Source你不需要担心引入额外的依赖，因为这是一个源代码包。关于源代码包不引入额外依赖 dll 的原理，可以参见： .NET 将多个程序集合并成单一程序集的 4+3 种方法 - walterlv方法我们需要做的是，将一个对象序列化为 query 字符串。假设这个对象的局部变量名称是 query，于是我们需要： 取得此对象所有可获取值的属性 query.GetType().GetProperties() 获取此属性值的方法 property.GetValue(query, null) 将属性和值拼接起来 string.Join(&quot;&amp;amp;&quot;, properties) 然而真实场景可能比这个稍微复杂一点： 我们需要像 Newtonsoft.Json 一样，对于标记了 DataContract 的类，按照 DataMember 来序列化 URL 中的值需要进行转义所以，我写出了下面的方法：var isContractedType = query.GetType().IsDefined(typeof(DataContractAttribute));var properties = from property in query.GetType().GetProperties() where property.CanRead &amp;amp;&amp;amp; (isContractedType ? property.IsDefined(typeof(DataMemberAttribute)) : true) let memberName = isContractedType ? property.GetCustomAttribute&amp;lt;DataMemberAttribute&amp;gt;().Name : property.Name let value = property.GetValue(query, null) where value != null &amp;amp;&amp;amp; !string.IsNullOrWhiteSpace(value.ToString()) select memberName + &quot;=&quot; + HttpUtility.UrlEncode(value.ToString());var queryString = string.Join(&quot;&amp;amp;&quot;, properties);return string.IsNullOrWhiteSpace(queryString) ? &quot;&quot; : prefix + queryString;完整的代码如下：using System.Diagnostics.CodeAnalysis;using System.Linq;using System.Reflection;using System.Runtime.Serialization;using System.Web;namespace Walterlv.Web.Core{ internal class QueryString { [return: NotNullIfNotNull(&quot;query&quot;)] public static string? Serialize(object? query, string? prefix = &quot;?&quot;) { if (query is null) { return null; } var isContractedType = query.GetType().IsDefined(typeof(DataContractAttribute)); var properties = from property in query.GetType().GetProperties() where property.CanRead &amp;amp;&amp;amp; (isContractedType ? property.IsDefined(typeof(DataMemberAttribute)) : true) let memberName = isContractedType ? property.GetCustomAttribute&amp;lt;DataMemberAttribute&amp;gt;().Name : property.Name let value = property.GetValue(query, null) where value != null &amp;amp;&amp;amp; !string.IsNullOrWhiteSpace(value.ToString()) select memberName + &quot;=&quot; + HttpUtility.UrlEncode(value.ToString()); var queryString = string.Join(&quot;&amp;amp;&quot;, properties); return string.IsNullOrWhiteSpace(queryString) ? &quot;&quot; : prefix + queryString; } }}你可能会遇到 [return: NotNullIfNotNull(&quot;query&quot;)] 这一行编译不通过的情况，这个是 C# 8.0 带的可空引用类型所需要的契约类。你可以将它删除，或者安装我的另一个 NuGet 包来获得更多可空引用类型契约的支持，详见： C# 8.0 的可空引用类型，不止是加个问号哦！你还有很多种不同的可空玩法 - walterlv" }, { "title": "屏幕边缘上有趣的 1 个像素，看不见、摸不到", "url": "/post/the-fantastic-one-pixel-of-the-touch-screen.html", "categories": "", "tags": "windows, dotnet, wpf", "date": "2019-12-23 16:00:30 +0800", "snippet": "如果你的屏幕分辨率是 1920×1080，那么一个全屏的窗口程序尺寸是多少呢？想都不用想，是 1920×1080。那么输入设备输入的坐标是多少呢？是 X∈[0, 1919] ？还是 X∈[1, 1920] ？还是 X∈[0, 1920] ？鼠标输入与触摸输入一个有趣的问题，因为 1920×1080 分辨率的屏幕，其横向只有 1920 个像素，也就是说如果需要区分一个像素，那么只需要 1920 个数值就够了。这意味着 X∈[0, 1919] 或者 X∈[1, 1920] 的取值范围就能表示横向的所有像素了。那么实际上最左侧的点的输入数值是多少呢？最右侧的点的输入数值是多少呢？我写了一个最大化全屏的程序专门用来测试鼠标和触摸输入的数值是多少。▲ 在鼠标输入的情况下，最右侧其实是 1919（我的屏幕是 2560×1080，所以最右侧是 2559）测量的时候，鼠标是直接往右移动到底，移到不能动为止。那么在触摸输入的时候又如何？▲ 在触摸输入的情况下，最右侧是 1920（我的屏幕是 2560×1080，所以最右侧是 2560）测量的时候，是让手指近乎在屏幕外触摸，不断触摸到能够在屏幕上看到的最小或最大值为止。有趣的 1 像素发现上面实验中有趣的现象了吗？明明只有 1920×1080 的屏幕分辨率，窗口明明只有 1920×1080 那么大，鼠标下收到正常范围内的输入坐标，而触摸下我们能收到超出我们窗口大小 1 像素的触摸事件！问题并没有完——如果说，触摸给了你超出窗口大小的坐标，那么你能如何使用这个坐标呢？虽然程序里收到什么坐标都无所谓（至少不崩），但如果你真拿它来渲染，就会在屏幕之外。更有趣的是，虽然你能收到这个“在屏幕边缘之外”的坐标，但这个消息并不总会发送到你的程序里。更多的时候，你的程序根本就不会收到这个触摸事件，于是我们也就不能在程序里面更新窗口上显示的坐标到 1920 了，就像鼠标一样。于是，你可能遇到的问题是： 如果你在屏幕的左侧边缘触摸，你的程序可以一直收到触摸事件，你能够得到正确的响应； 如果你在屏幕的右侧边缘触摸，你将仅能偶尔收到零星的刚好超出窗口大小的触摸坐标，大多数时候收不到触摸事件，于是你可能无法获知用户在屏幕右侧边缘进行触摸。防踩坑秘籍林德熙小伙伴告诉我说可以特意把窗口的尺寸做大一个像素。我试过了，确实能够让触摸在整个屏幕上生效，但对于双屏用户来说，就能在另外一个屏幕上看到“露馅儿”了的窗口，对于我这种强迫症患者来说，显然是不能接受的。我的建议是，并不需要对这种情况进行什么特殊的处理。" }, { "title": "使用 MSBuild Target 复制文件的时候如何保持文件夹结构不变", "url": "/post/copy-all-files-with-directory-hierarchy-using-msbuild.html", "categories": "", "tags": "msbuild, dotnet", "date": "2019-12-17 16:36:39 +0800", "snippet": "使用 MSBuild 中的 Copy 这个编译目标可以在 .NET 项目编译期间复制一些文件。不过使用默认的参数复制的时候文件夹结构会丢失，所有的文件会保留在同一级文件夹下。那么如何在复制文件的时候保持文件夹结构与原文件夹结构一样呢？Copy下面是一个典型的使用 MSBuild 在编译期间复制文件的一个编译目标。&amp;lt;Target Name=&quot;_WalterlvCopyDemo&quot; AfterTargets=&quot;AfterBuild&quot;&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;_WalterlvToCopyFile Include=&quot;$(OutputPath)**&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;Copy SourceFiles=&quot;@(_WalterlvToCopyFile)&quot; DestinationFolder=&quot;bin\\Debug\\Test&quot; SkipUnchangedFiles=&quot;True&quot; /&amp;gt;&amp;lt;/Target&amp;gt;这样复制的文件是不会保留文件夹结构的。复制之后，所有的文件夹将不存在，所有文件覆盖地到同一层级。RecursiveDir如果希望保留文件夹层级，可以在 DestinationFolder 中使用文件路径来替代文件夹路径。 &amp;lt;Target Name=&quot;_WalterlvCopyDemo&quot; AfterTargets=&quot;AfterBuild&quot;&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;_WalterlvToCopyFile Include=&quot;$(OutputPath)**&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt;- &amp;lt;Copy SourceFiles=&quot;@(_WalterlvToCopyFile)&quot; DestinationFolder=&quot;bin\\Debug\\Test&quot; SkipUnchangedFiles=&quot;True&quot; /&amp;gt;+ &amp;lt;Copy SourceFiles=&quot;@(_WalterlvToCopyFile)&quot; DestinationFolder=&quot;bin\\Debug\\Test\\%(RecursiveDir)&quot; SkipUnchangedFiles=&quot;True&quot; /&amp;gt; &amp;lt;/Target&amp;gt;" }, { "title": "使用正则表达式尽可能准确匹配域名/网址", "url": "/post/match-web-url-using-regex.html", "categories": "", "tags": "dotnet, csharp", "date": "2019-12-09 16:58:13 +0800", "snippet": "你可能需要准确地知道一段字符串是否是域名/网址/URL。虽然可以使用 .、/ 这些来模糊匹配，但会造成误判。实际上单纯使用正则表达式来精确匹配也是非常复杂的，通过代码来判断会简单很多。不过本文依然从域名的定义出发来尽可能匹配一段字符串是否是域名或者网址，在要求不怎么高的场合，使用本文的正则表达式写的代码会比较简单。网址网址实际上是 URL（统一资源定位符），它是由协议、主机名和路径组成。不过我们通常所说的网址中的主机名通常是域名，因此我们在匹配的时候主要考虑域名。域名维基百科 中关于域名的描述： 域名由一或多个部分组成，这些部分通常连接在一起，并由点分隔。最右边的一个标签是顶级域名，例如zh.wikipedia.org的顶级域名是org。一个域名的层次结构，从右侧到左侧隔一个点依次下降一层。每个标签可以包含1到63个八字节。域名的结尾有时候还有一点，这是保留给根节点的，书写时通常省略，在查询时由软件内部补上。 域名里的英文字母不区分大小写。 完整域名的所有字符加起来不得超过253个ASCII字符的总长度。因此，当每一级都使用单个字符时，限制为127个级别：127个字符加上126个点的总长度为253。但实际上，某些域名可能具有其他限制；也没有只有一个字符的域名后缀。 后面关于非 ASCII 字符的描述我没有贴出来。这种域名例如“.中国”。在 中国电信网站备案自助管理系统 中，我们可以找到关于域名的描述： 域名中的标号都由英文字母和数字组成，每一个标号不超过63个字符，也不区分大小写字母。标号中除连字符（-）外不能使用其他的标点符号。级别最低的域名写在最左边，而级别最高的域名写在最右边。由多个标号组成的完整域名总共不超过255个字符。路径路径是使用 / 分隔的一段一段字符串。正则表达式匹配在确认了完整的网址 URL 的规范之后，使用正则表达式来匹配就会比较精确了。域名现在，我们来尝试匹配一下域名 。 每个标签可组成的字符是 - a-z A-Z 0-9，但是 - 不可作为开头，标签总长度 1-63 个字符，于是 [a-zA-Z0-9][-a-zA-Z0-9]{0,62} 即首字不含 -，后面的字可以包含 - 允许多个标签，于是 (\\.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+ 除了标签内容和前面一样，但我们加了个 . 别忘了，我们还有总长度限制，于是考虑加上零宽断言 ^.{3,255}$，匹配开头和结尾，中间任意字符但长度在 3-255 之间。通过零宽断言，我们可以在不捕获匹配字符串的情况下对后面的字符串增加限制条件。现在，把整个正则表达式拼出来：^(?=^.{3,255}$)[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(\\.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+$URL对于不同的业务需求，可能有严格匹配或者宽松的匹配方式。比如你要做一些比较精准的检查时需要进行严格的检查，那么选择严格匹配；这时，稍微出现一些不符合要求的字符都将认定为不是 URL。如果你只是打算做一些简单的检查（例如只是语法高亮），那么简单匹配即可；因为当你使用 Chrome 浏览器访问这些 URL 的时候，依然可以正常访问，Chrome 会帮你格式化一下这个 URL。 https://blog.walterlv.com/post/read-32bit-registry-from-x64-process.html 严格匹配和宽松匹配都会成功匹配 https://blog.lindexi.com/post/dotnet-配置-github-自动打包上传-nuget-文件.html 里面有 Unicode 字符，宽松匹配才可以匹配此 URL 你把这个 URL 复制到 Chrome 中可以正常打开，但从 Chrome 里把这个复制出来的话，就会被转义成 https://blog.lindexi.com/post/dotnet-%E9%85%8D%E7%BD%AE-github-%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85%E4%B8%8A%E4%BC%A0-nuget-%E6%96%87%E4%BB%B6.html。 https://[2001:4860:4860::8888]:53/favicon.svg 因为我偷懒了，所以只有宽松匹配才可以匹配此 IPv6 地址下的 URL https://域名.中国 因为我偷懒了，所以只有宽松匹配才可以匹配此 IPv6 地址下的 URL URL（严格）匹配 URL 跟匹配域名不一样，URL 复杂得多。严格匹配的要求是准确反应出 URL 的标准，但实际上如实反应标准编写的正则表达式会非常复杂，因此相比于 100% 准确匹配，我们还是从简了。所以如果不是有特别要求，建议还是跳到后面的“宽松”部分来阅读吧！我们以下面这个网址为例说明。https://blog.walterlv.com/post/read-32bit-registry-from-x64-process.html 前面是可选的协议名，于是 (http(s)?:\\/\\/) 然而既然可选，而且是行首，那么加一个 ? 和什么都不加的效果是一样的 随后是域名，于是 [a-zA-Z0-9][-a-zA-Z0-9]{0,62}(\\.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+ 这里我们没有把总长度限制算上去 别忘了有个可选的端口号 (:[0-9]{1,5})? 端口号的范围是 0-65535，但 0 是保留端口，49152 到 65535 也是保留端口，因此可以作为网址访问的范围也就是 1-49151，因此我们限制 1-5 位长度。 接下来是资源路径 资源路径可以使用的字符也是有限制的，我们接下来详细说明。 组合整个正则表达式：^[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(\\.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+(:[0-9]{1,5})?[-a-zA-Z0-9()@:%_\\\\\\+\\.~#?&amp;amp;//=]*$顺便一提，不同于域名，我们这里去掉了长度限制，因为 URL 真的可以“很长”。另外，这里的现在，我们补充说明一下资源路径可以使用的字符问题。; / ? : @ &amp;amp; = + $ , 这些字符应该被转义。转义使用的字符是 &amp;amp;xxx;，因此在转义之后，依然还可能在网址中看到 &amp;amp; 和 ;，不过没有其他字符了。- _ . ! ~ * &#39; ( ) 这些字符可以不进行转义，但也不建议在 URL 中使用。对于这部分，我们考虑将其匹配。{ } | \\ ^ [ ] ` 这部分字符可能被网关当作分隔符使用，因此不建议出现在 URL 中。对于这部分，我们考虑将其匹配。&amp;lt; &amp;gt; # % &quot; 控制字符。使用 % 可以组成其他 Unicode 字符，使用 # 用来指代网址中的某个部分。因此，我们最终总结应该匹配的特殊字符有 @ : % _ \\ + . ~ # ? &amp;amp; / =。URL（宽松）宽松一点的话，正则表达式就好写多了。这个正则表达式可以不写 https 协议前缀：^\\w+[^\\s]+(\\.[^\\s]+){1,}$如果上下文中要求必须匹配 https，则可以写：^(http(s)?:\\/\\/)\\w+[^\\s]+(\\.[^\\s]+){1,}$ https://blog.walterlv.com/post/read-32bit-registry-from-x64-process.html#content) 期望不匹配（主要是不能匹配末尾的括号），实际匹配 在 URL 中，如果括号是成对的，则此 URL 允许以 ) 结尾，如果 URL 中括号不成对，则此 URL 不能以 ) 结尾；&amp;gt; 同理 https://blog.walterlv.com/post/read-32bit -registry-from-x64-process.html 期望不匹配，实际不匹配 https://blog.lindexi.com/post/dotnet-配置-github-自动打包上传-nuget-文件.html 期望匹配，实际匹配 https://域名.中国 期望匹配，实际匹配 blog.walterlv.com/post/read-32bit-registry-from-x64-process.html 期望匹配，实际匹配 x&amp;lt;blog.walterlv.com/post/read-32bit-registry-from-x64-process.html 期望不匹配，实际匹配 这里的宽松正则表达式请小心！此正则表达式会将一段话中 URL 后面非空格的部分都算作 URL 的一部分。更多大牛匹配 URL 的正则表达式在 GitHub 上还有很多大牛们在写各种匹配 URL 的正则表达式： regex-weburl.js最长的一个写了 1347 个字符，最短的有 38 个字符。有人将其整理成一张表格，一图说明各种正则表达式能匹配到什么程度： In search of the perfect URL validation regex参考资料 In search of the perfect URL validation regex 域名 - 维基百科，自由的百科全书 中国电信网站备案自助管理系统" }, { "title": "C# 8.0 的可空引用类型，不止是加个问号哦！你还有很多种不同的可空玩法", "url": "/post/csharp-nullable-analysis-attributes.html", "categories": "", "tags": "csharp, dotnet", "date": "2019-12-08 15:29:27 +0800", "snippet": "C# 8.0 引入了可空引用类型，你可以通过 ? 为字段、属性、方法参数、返回值等添加是否可为 null 的特性。但是如果你真的在把你原有的旧项目迁移到可空类型的时候，你就会发现情况远比你想象当中复杂，因为你写的代码可能只在部分情况下可空，部分情况下不可空；或者传入空时才可为空，传入非空时则不可为空。C# 8.0 可空特性在开始迁移你的项目之前，你可能需要了解如何开启项目的可空类型支持： C# 8.0 如何在项目中开启可空引用类型的支持 - walterlv可空引用类型是 C# 8.0 带来的新特性。你可能会好奇，C# 语言的可空特性为什么在编译成类库之后，依然可以被引用它的程序集识别。也许你可以理解为有什么特性 Attribute 标记了字段、属性、方法参数、返回值的可空特性，于是可空特性就被编译到程序集中了。确实，可空特性是通过 NullableAttribute 和 NullableContextAttribute 这两个特性标记的。但你是否好奇，即使在古老的 .NET Framework 4.5 或者 .NET Standard 2.0 中开发的时候，你也可以编译出支持可空信息的程序集出来。这些古老的框架中没有这些新出来的类型，为什么也可以携带类型的可空特性呢？实际上反编译一下编译出来的程序集就能立刻看到结果了。看下图，在早期版本的 .NET 框架中，可空特性实际上是被编译到程序集里面，作为 internal 的 Attribute 类型了。所以，放心使用可空类型吧！旧版本的框架也是可以用的。更灵活控制的可空特性阻碍你将老项目迁移到可空类型的原因，可能还有你原来代码逻辑的问题。因为有些情况下你无法完完全全将类型迁移到可空。例如： 有些时候你不得不为非空的类型赋值为 null 或者获取可空类型时你能确保此时一定不为 null（待会儿我会解释到底是什么情况）； 一个方法，可能这种情况下返回的是 null 那种情况下返回的是非 null； 可能调用者传入 null 的时候才返回 null，传入非 null 的时候返回非 null。为了解决这些情况，C# 8.0 还同时引入了下面这些 Attribute： AllowNull: 标记一个不可空的输入实际上是可以传入 null 的。 DisallowNull: 标记一个可空的输入实际上不应该传入 null。 MaybeNull: 标记一个非空的返回值实际上可能会返回 null，返回值包括输出参数。 NotNull: 标记一个可空的返回值实际上是不可能为 null 的。 MaybeNullWhen: 当返回指定的 true/false 时某个输出参数才可能为 null，而返回相反的值时那个输出参数则不可为 null。 NotNullWhen: 当返回指定的 true/false 时，某个输出参数不可为 null，而返回相反的值时那个输出参数则可能为 null。 NotNullIfNotNull: 指定的参数传入 null 时才可能返回 null，指定的参数传入非 null 时就不可能返回 null。 DoesNotReturn: 指定一个方法是不可能返回的。 DoesNotReturnIf: 在方法的输入参数上指定一个条件，当这个参数传入了指定的 true/false 时方法不可能返回。想必有了这些描述后，你在具体遇到问题的时候应该能知道选用那个特性。但单单看到这些特性的时候你可能不一定知道什么情况下会用得着，于是我可以为你举一些典型的例子。输入：AllowNull设想一下你需要写一个属性：public string Text{ get =&amp;gt; GetValue() ?? &quot;&quot;; set =&amp;gt; SetValue(value ?? &quot;&quot;);}当你获取这个属性的值的时候，你一定不会获取到 null，因为我们在 get 里面指定了非 null 的默认值。然而我是允许你设置 null 到这个属性的，因为我处理好了 null 的情况。于是，请为这个属性加上 AllowNull。这样，获取此属性的时候会得到非 null 的值，而设置的时候却可以设置成 null。++ [AllowNull] public string Text { get =&amp;gt; GetValue() ?? &quot;&quot;; set =&amp;gt; SetValue(value ?? &quot;&quot;); }输入：DisallowNull与以上场景相反的一个场景：private string? _text;public string? Text{ get =&amp;gt; _text; set =&amp;gt; _text = value ?? throw new ArgumentNullException(nameof(value), &quot;不允许将这个值设置为 null&quot;);}当你获取这个属性的时候，这个属性可能还没有初始化，于是我们获取到 null。然而我却并不允许你将这个属性赋值为 null，因为这是个不合理的值。于是，请为这个属性加上 DisallowNull。这样，获取此属性的时候会得到可能为 null 的值，而设置的时候却不允许为 null。输出：MaybeNull如果你有尝试过迁移代码到可空类型，基本上一定会遇到泛型方法的迁移问题：public T Find&amp;lt;T&amp;gt;(int index){}比如以上这个方法，找到了就返回找到的值，找不到就返回 T 的默认值。那么问题来了，T 没有指定这是值类型还是引用类型。如果 T 是引用类型，那么默认值 default(T) 就会引入 null。但是泛型 T 并没有写成 T?，因此它是不可为 null 的。然而值类型和引用类型的 T? 代表的是不同的含义。这种矛盾应该怎么办？这个时候，请给返回值标记 MaybeNull：++ [return: MaybeNull] public T Find&amp;lt;T&amp;gt;(int index) { }这表示此方法应该返回一个不可为 null 的类型，但在某些情况下可能会返回 null。实际上这样的写法并没有从本质上解决掉泛型 T 的问题，不过可以用来给旧项目迁移时用来兼容 API 使用。如果你可以不用考虑 API 的兼容性，那么可以使用新的泛型契约 where T : notnull。public T Find&amp;lt;T&amp;gt;(int index) where T : notnull{}输出：NotNull设想你有一个方法，方法参数是可以传入 null 的：public void EnsureInitialized(ref string? text){}然而这个方法的语义是确保此字段初始化。于是可以传入 null 但不会返回 null 的。这个时候请标记 NotNull：-- public void EnsureInitialized(ref string? text)++ public void EnsureInitialized([NotNull] ref string? text) { }NotNullWhen, MaybeNullWhenstring.IsNullOrEmpty 的实现就使用到了 NotNullWhen：bool IsNullOrEmpty([NotNullWhen(false)] string? value);它表示当返回 false 的时候，value 参数是不可为 null 的。这样，你在这个方法返回的 false 判断分支里面，是不需要对变量进行判空的。当然，更典型的还有 TryDo 模式。比如下面是 Version 类的 TryParse：bool TryParse(string? input, [NotNullWhen(true)] out Version? result)当返回 true 的时候，result 一定不为 null。NotNullIfNotNull典型的情况比如指定默认值：[return: NotNullIfNotNull(&quot;defaultValue&quot;)]public string? GetValue(string key, string? defaultValue){}这段代码里面，如果指定的默认值（defaultValue）是 null 那么返回值也就是 null；而如果指定的默认值是非 null，那么返回值也就不可为 null 了。在早期 .NET Framework 或者早期版本的 .NET Core 中使用在本文第一小节里面，我们说 Nullable 是编译到目标程序集中的，所以不需要引用什么特别的程序集就能够使用到可空引用的特性。那么上面这些特性呢？它们并没有编译到目标程序集中怎么办？实际上，你只需要有一个命名空间、名字和实现都相同的类型就够了。你可以写一个放到你自己的程序集中，也可以把这些类型写到一个自己公共的库中，然后引用它。当然，你也可以用我已经写好的 NuGet 包 Walterlv.NullableAttributes。Walterlv.NullableAttributes微软 .NET 官方的可空特性在这里： NullableAttributes.cs我将其注释翻译成中文之后，也写了一份在这里： Walterlv.Packages/CodeAnalysis.cs at master · walterlv/Walterlv.Packages如果你想简单一点，可以直接引用我的 NuGet 包： 作为 dll 引用：NuGet Gallery - Walterlv.NullableAttributes 作为源代码包引用：NuGet Gallery - Walterlv.NullableAttributes.Source源代码包可以在不用引入其他 dll 依赖的情况下完成引用。最终你输出的程序集是不带对此包的依赖的，详见： .NET 将多个程序集合并成单一程序集的 4+3 种方法 - walterlv参考资料 Upgrade APIs for nullable reference types with attributes that define expectations for null values - Microsoft Docs" }, { "title": "一个简单的方法：截取子类名称中不包含基类后缀的部分", "url": "/post/get-derived-type-name-without-base-type-name.html", "categories": "", "tags": "dotnet, csharp", "date": "2019-12-08 15:29:19 +0800", "snippet": "基类是 MenuItem，子类是 WalterlvMenuItem、FooMenuItem。基类是 Configuration，子类是 WalterlvConfiguration、ExtensionConfiguration。在代码中，我们可能会为了能够一眼看清类之间的继承（从属）关系而在子类名称后缀中带上基类的名称。但是由于这种情况下的基类不参与实际的业务，所以对外（文件/网络）的名称通常不需要带上这个后缀。本文提供一个简单的方法，让子类中基类的后缀删掉，只取得前面的那部分。在这段代码中，我们至少需要获得两个传入的参数，一个是基类的名称，一个是子类的名称。但是考虑到让开发者就这样传入两者名称的话会比较容易出问题，因为开发者可能根本就不会按照要求去获取类型的名称。所以我们需要自己通过类型对象来获取名称。另外，我们还需要有一些约束，必须有一个类型是另外一个类型的子类。于是我们可能必须来使用泛型做这样的约束。于是，我们可以写出下面的方法：using System;namespace Walterlv.Utils{ /// &amp;lt;summary&amp;gt; /// 包含类名相关的处理方法。 /// &amp;lt;/summary&amp;gt; internal static class ClassNameUtils { /// &amp;lt;summary&amp;gt; /// 当某个类型的派生类都以基类（&amp;lt;typeparamref name=&quot;T&quot;/&amp;gt;）名称作为后缀时，去掉后缀取派生类名称的前面部分。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&quot;T&quot;&amp;gt;名称统一的基类名称。&amp;lt;/typeparam&amp;gt; /// &amp;lt;param name=&quot;this&quot;&amp;gt;派生类的实例。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;去掉后缀的派生类名称。&amp;lt;/returns&amp;gt; internal static string GetClassNameWithoutSuffix&amp;lt;T&amp;gt;(this T @this) { if (@this is null) { throw new ArgumentNullException(nameof(@this)); } var derivedTypeName = @this.GetType().Name; var baseTypeName = typeof(T).Name; // 截取子类名称中去掉基类后缀的部分。 var name = derivedTypeName.EndsWith(baseTypeName, StringComparison.Ordinal) ? derivedTypeName.Substring(0, derivedTypeName.Length - baseTypeName.Length) : derivedTypeName; // 如果子类名称和基类完全一样，则直接返回子类名称。 return string.IsNullOrWhiteSpace(name) ? derivedTypeName : name; } }}我们通过判断子类是否以基类名称作为后缀来决定是否截取子字符串。在截取完子串之后，我们还需要验证截取的字符串是否已经是空串了，因为父子类的名称可能是完全一样的（虽然这样的做法真的很逗比）。于是使用起来只需要简单调用一下：class Program{ static void Main(string[] args) { var name = ClassNameUtils.GetClassNameWithoutSuffix&amp;lt;Foo&amp;gt;(new XFoo()); }}internal class Foo{}internal class XFoo : Foo{}于是我们可以得到 name 局部变量的值为 X。如果这个时候我们对 XFoo 类型改名，例如改成 XFoo1，那么就不会截取，而是直接得到名称 XFoo1。" }, { "title": "可集成到文件管理器，一句 PowerShell 脚本发布某个版本的所有 NuGet 包", "url": "/post/push-nuget-packages-using-powershell.html", "categories": "", "tags": "powershell, nuget, dotnet", "date": "2019-12-08 15:29:05 +0800", "snippet": "要发布 NuGet 包，只需要执行命令 nuget push xxx.nupkg 即可，或者去 nuget.org 点鼠标上传。不过，如果你有很多的 NuGet 包并且经常需要推送的话，也可以集成到 Directory Opus 或者 Total Commander 中。NuGet 推送命令NuGet 推送命令可直接在微软官方文档中阅读到： NuGet CLI push command - Microsoft Docs在你已经设置了 ApiKey 的情况下：nuget setapikey xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx -source https://api.nuget.org/v3/index.json之后你只需要执行一句命令即可：nuget.exe push Walterlv.Themes.FluentDesign.Source.0.8.0-alpha.nupkg -source https://api.nuget.org/v3/index.json或者推送此文件夹下 0.8.0-alpha 版本的所有 NuGet 包：nuget.exe push *.0.8.0-alpha.nupkg -source https://api.nuget.org/v3/index.json用 PowerShell 包装一下要执行 NuGet 的推送命令，我们需要一个可以执行命令的终端，比如 PowerShell。命令的执行结果我们也可以直接在终端看到。不过，如果命令是集成到其他工具里面，那么就不一定能够看得到命令的执行结果了。这个时候，可以考虑用 PowerShell 间接执行这个命令：# PowerShell 版本powershell -NoExit -c &quot;nuget push *.0.8.0-alpha.nupkg -Source https://api.nuget.org/v3/index.json&quot;# PowerShell Core 版本pwsh -NoExit -c &quot;nuget push *.0.8.0-alpha.nupkg -Source https://api.nuget.org/v3/index.json&quot;关于使用 PowerShell 间接执行命令的更多细节，可以参考我的另一篇博客： PowerShell 的命令行启动参数（可用于执行命令、传参或进行环境配置） - walterlv集成到 Directory Opus我将这个命令集成到了 Directory Opus 中，这样，一次点击或者一个快捷键就能发布某个特定版本的所有的 NuGet 包了。关于使用 Directory Opus 继承工具栏按钮的细节，可以阅读我的另一篇博客： 在 Directory Opus 中添加自定义的工具栏按钮提升效率 - walterlv具体来说，就是安装上文中所述的方法添加一个按钮，在按钮当中需要执行的脚本如下：cd &quot;{sourcepath} &quot;pwsh -NoExit -c &quot;$file=[Regex]::Match(&#39;{file}&#39;, &#39;\\.\\d+\\.\\d+\\.\\d+.+.nupkg&#39;).Value; nuget push *$file -Source https://api.nuget.org/v3/index.json&quot;含义为： 转到 Directory Opus 当前目录 执行一段 PowerShell 脚本，但执行完之后不退出（这样，我可以观察到我实际上推送的是哪一些包，并且可以知道推送是否出现了错误） 要执行的命令为 nuget push *.xxx.nupkg -Source https://api.nuget.org/v3/index.json 其中，中间的 xxx 是使用正则表达式匹配的 {file} 文件名 {file} 是 Directory Opus 当前选中的文件，我用正则表达式匹配出其版本号和后面的 .nupkg 后缀 将正则表达式匹配出来的文本作为 nuget push 的包，最终生成的命令会非常类似于本文一开始提到的命令 nuget push *.0.8.0-alpha.nupkg -Source https://api.nuget.org/v3/index.json 于是，当我选中了一个包，按下这个工具栏按钮之后，就可以推送与这个包相同版本的所有的 NuGet 包了。毕竟我一次编译产生的 NuGet 包太多了，还是需要使用这样的方式来提高一点效率。至于为什么不用持续集成，是因为目前 SourceYard 还不支持在 GitHub 上集成。参考资料 NuGet CLI push command - Microsoft Docs" }, { "title": "配置 legacyUnhandledExceptionPolicy 防止后台线程抛出的异常让程序崩溃退出", "url": "/post/prevent-app-crash-by-background-thread.html", "categories": "", "tags": "dotnet, wpf", "date": "2019-11-28 16:08:14 +0800", "snippet": "如果你的程序抛了异常，你是怎么处理的呢？等待程序崩溃退出？还是进行补救？如果是做 UI 开发，很容易就找到 Dispatcher.UnhandledException 事件，然后在事件中进行补救。如果补救成功，可以设置 e.Handled = true 来阻止异常继续让程序崩溃退出。但是，如果是后台线程抛出了异常呢？并没有 Dispatcher 可以用。所以我们就束手就擒让程序自己退出吗？WPF 和 Windows Forms 都是微软的框架，为了照顾初学者，微软会默认每一个开发者都不会正确地处理异常。于是在异常发生之后，微软 Windows 会假设开发者并不知道如何应对以便让应用程序正常工作，就擅自将应用程序进程结束掉，以便防止应用程序自己内部产生奇怪的状态和错误，避免对系统环境造成不可逆的严重后果。能够写出异常处理代码的开发者，微软会默认他们懂了异常处理。写出了监听 Dispatcher.UnhandledException 事件的开发者，微软会认为他们已经学会了如何在 UI 线程中处理异常。于是允许开发者设置 e.Handled = true 来标记异常已被正确处理，程序可以不用退出了。还有一个事件 AppDomain.CurrentDomain.UnhandledException，然而这个事件却并不允许开发者标记 e.Handled = true。因为微软认为，应用程序域中所有的线程发生异常都会进入这个事件中，大多数开发者都不明白这些线程这些异常是怎么回事，所以不认为这些开发者具备正确处理这些异常的能力。比如 WPF 的触摸模块发生了异常，开发者知道如何恢复吗？并不知道，还不如结束掉程序然后重启呢！在这个事件中，有一个属性 IsTerminating 指示是否应用程序正因为这次异常准备退出，不过开发者并不能拿这个属性做些什么。但还是要照顾更高级的开发者的，于是祭出新的配置——legacyUnhandledExceptionPolicy！在 app.config 文件的 &amp;lt;runtime&amp;gt; 节点中添加如下代码：&amp;lt;legacyUnhandledExceptionPolicy enabled=&quot;1&quot;/&amp;gt; 如果你找不到在 App.config 的哪个地方，我再用一段代码标注一下，大概在这里： &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;startup useLegacyV2RuntimeActivationPolicy=&quot;true&quot;&amp;gt; &amp;lt;supportedRuntime version=&quot;v4.0&quot; sku=&quot;.NETFramework,Version=v4.8&quot; /&amp;gt; &amp;lt;/startup&amp;gt; &amp;lt;runtime&amp;gt;++ &amp;lt;legacyUnhandledExceptionPolicy enabled=&quot;1&quot; /&amp;gt; &amp;lt;/runtime&amp;gt; &amp;lt;/configuration&amp;gt;加上了这个配置之后，AppDomain.CurrentDomain.UnhandledException 事件的 IsTerminating 就变成了 false 啦！也就是说，程序并不会因为这次的异常而崩溃退出。既然你通过这个配置节点于微软达成了契约，你就需要好好地在 AppDomain.CurrentDomain.UnhandledException 事件中写好异常的恢复逻辑。如果不好好恢复，小心有些致命的异常会导致你的程序出现雪崩式的错误，最终 Windows 还是会通过 CorruptedStateException 把你干掉的！参考资料 c# - How to prevent an exception in a background thread from terminating an application? - Stack Overflow Exceptions in Managed Threads - Microsoft Docs" }, { "title": "WPF 程序如何跨窗口/跨进程设置控件焦点", "url": "/post/move-focus-to-win32-window.html", "categories": "", "tags": "windows, wpf, dotnet, csharp", "date": "2019-11-27 08:53:01 +0800", "snippet": "WPF 程序提供了 Focus 方法和 TraversalRequest 来在 WPF 焦点范围内转移焦点。但如果 WPF 窗口中嵌入了其他框架的 UI（比如另一个子窗口），那么就需要使用其他的方法来设置焦点了。一个粗略的设置方法是，使用 Win32 API：SetFocus(hwnd);传入的是要设置焦点的窗口的句柄。参考资料 winapi - Win32: C++: How do I re-focus on Parent Window after clicking in a child window? - Stack Overflow" }, { "title": "PowerShell 的命令行启动参数（可用于执行命令、传参或进行环境配置）", "url": "/post/powershell-startup-arguments.html", "categories": "", "tags": "windows, powershell", "date": "2019-11-20 14:39:56 +0800", "snippet": "有一些程序不支持被直接启动，而要求通过命令行启动。这个时候，你就需要使用 PowerShell 或者 PowerShell Core 来启动这样的程序。我们都知道如何在命令行或各种终端中启动一个程序，但是当你需要自动启动这个程序的时候，你就需要知道如何通过 PowerShell 或其他命令行终端来启动一个程序，而不是手工输入然后回车运行了。本文就介绍 PowerShell 的命令行启动参数。利用这些参数，你可以自动化地通过 PowerShell 程序来完成一些原本需要通过手工执行的操作或者突破一些限制。一些必须通过命令行启动的程序一般来说，编译生成的 exe 程序都可以直接启动，即便是命令行程序也是如此。但是有一些程序就是要做一些限制。比如下面的 FRP 反向代理程序：借助 cmd.exe 来启动的方法可以参见我的另一篇博客： cmd.exe 的命令行启动参数（可用于执行命令、传参或进行环境配置） - 吕毅那么我们如何能够借助于 PowerShell 或者 PowerShell 来启动它呢？PowerShell 的帮助文档先打开一个 PowerShell。对于 Windows 自带的基于 .NET Framework 的 PowerShell，使用 powershell 命令可以直接启动 PowerShell。对于基于 .NET Core 版本的 PowerShell Core，使用 pwsh 命令可以直接启动。关于 .NET Core 版本的 PowerShell Core 可以参见我的另一篇博客： 安装和运行 .NET Core 版本的 PowerShell - 吕毅接下来输入下面三个命令中的任何一个： PowerShell -Help PowerShell -? PowerShell /?或者对于 PowerShell Core 来说，是下面三个命令中的任何一个： pwsh -Help pwsh -? pwsh /?你就可以看到 PowerShell 的使用说明：PowerShell 的启动参数示例使用 PowerShell 间接启动一个程序并传入参数下面的命令，使用 PowerShell 间接启动 frpc.exe 反向代理程序，并给 frpc.exe 程序传入 -c ./frpc.ini 的启动参数：&amp;gt; pwsh -Command &quot;D:\\walterlv\\frpc.exe -c ./frpc.ini&quot;或者简写为：&amp;gt; pwsh -c &quot;D:\\walterlv\\frpc.exe -c ./frpc.ini&quot;实际上使用 PowerShell 来做这些事情简直是用牛刀杀鸡，因为本身 PowerShell 非常强大。我们只是因为一些程序的限制不得不使用这样的方案来启动程序而已。比如其中之一，执行脚本。使用 PowerShell 执行命令/脚本后保留窗口不退出需要加上 -NoExit 参数。&amp;gt; pwsh -NoExit -c &quot;D:\\walterlv\\frpc.exe -c ./frpc.ini&quot;一定要注意，-c 和后面的命令必须放到最末尾，因为 -c 后面的所有字符串都会被解析为需要执行的命令。使用 PowerShell 执行多条命令/脚本多条脚本之间使用 ; 作为分隔：&amp;gt; pwsh -c &quot;D:\\walterlv\\frpc.exe -c ./frpc.ini&quot;; &quot;D:\\walterlv\\frps.exe -c ./frps.ini&quot;如果引号里面还需要写引号，则可以把里面的引号改成单引号 &#39; 或者把外面的引号改为单引号 &#39;。使用 PowerShell 间接执行一个脚本# Execute a PowerShell Command in a sessionPowerShell -Command &quot;Get-EventLog -LogName security&quot;# Run a script block in a sessionPowerShell -Command {Get-EventLog -LogName security}# An alternate way to run a command in a new sessionPowerShell -Command &quot;&amp;amp; {Get-EventLog -LogName security}&quot;附 PowerShell 的全部启动参数说明 PowerShell[.exe] [-PSConsoleFile &amp;lt;文件&amp;gt; | -Version &amp;lt;版本&amp;gt;] [-NoLogo] [-NoExit] [-Sta] [-Mta] [-NoProfile] [-NonInteractive] [-InputFormat {Text | XML}] [-OutputFormat {Text | XML}] [-WindowStyle &amp;lt;样式&amp;gt;] [-EncodedCommand &amp;lt;Base64 编码命令&amp;gt;] [-ConfigurationName &amp;lt;字符串&amp;gt;] [-File &amp;lt;文件路径&amp;gt; &amp;lt;参数&amp;gt;] [-ExecutionPolicy &amp;lt;执行策略&amp;gt;] [-Command { - | &amp;lt;脚本块&amp;gt; [-args &amp;lt;参数数组&amp;gt;] | &amp;lt;字符串&amp;gt; [&amp;lt;命令参数&amp;gt;] } ]PowerShell[.exe] -Help | -? | /?-PSConsoleFile 加载指定的 Windows PowerShell 控制台文件。若要创建控制台 文件，请在 Windows PowerShell 中使用 Export-Console。-Version 启动指定版本的 Windows PowerShell。 使用参数输入版本号，如 &quot;-version 2.0&quot;。-NoLogo 启动时隐藏版权标志。-NoExit 运行启动命令后不退出。-Sta 使用单线程单元启动 shell。 单线程单元(STA)是默认值。-Mta 使用多线程单元启动 shell。-NoProfile 不加载 Windows PowerShell 配置文件。-NonInteractive 不向用户显示交互式提示。-InputFormat 描述发送到 Windows PowerShell 的数据的格式。有效值为 &quot;Text&quot; (文本字符串)或 &quot;XML&quot; (序列化的 CLIXML 格式)。-OutputFormat 确定如何设置 Windows PowerShell 输出内容的格式。有效值 为 &quot;Text&quot; (文本字符串)或 &quot;XML&quot; (序列化的 CLIXML 格式)。-WindowStyle 将窗口样式设置为 Normal、Minimized、Maximized 或 Hidden。-EncodedCommand 接受 base-64 编码字符串版本的命令。使用此参数 向 Windows PowerShell 提交需要复杂引号 或大括号的命令。-ConfigurationName 指定运行 Windows PowerShell 的配置终结点。 该终结点可以是在本地计算机上注册的任何终结点，包括 默认的 Windows PowerShell 远程处理终结点或具有特定用户角色功能 的自定义终结点。-File 在本地作用域(&quot;dot-sourced&quot;)中运行指定的脚本，以便 脚本创建的函数和变量可以在当前 会话中使用。输入脚本文件路径和任何参数。 File 必须是命令中的最后一个参数，因为在 File 参数 名称后面键入的所有字符都将解释 为后跟脚本参数的脚本文件路径。-ExecutionPolicy 设置当前会话的默认执行策略，并将其保存 在 $env:PSExecutionPolicyPreference 环境变量中。 该参数不会更改在注册表中 设置的 Windows PowerShell 执行策略。-Command 执行指定的命令(和任何参数)，就好像它们是 在 Windows PowerShell 命令提示符下键入的一样，然后退出，除非 指定了 NoExit。Command 的值可以为 &quot;-&quot;、字符串或 脚本块。 如果 Command 的值为 &quot;-&quot;，则从标准输入中读取 命令文本。 如果 Command 的值为脚本块，则脚本块必须 用大括号({})括起来。只有在 Windows PowerShell 中运行 PowerShell.exe 时， 才能指定脚本块。脚本块的结果将作为反序列化的 XML 对象 (而非活动对象)返回到父 Shell。 如果 Command 的值为字符串，则 Command 必须是命令中的 最后一个参数，因为在命令后面键入的所有字符 都将解释为命令参数。 若要编写运行 Windows PowerShell 命令的字符串，请使用以下格式: &quot;&amp;amp; {&amp;lt;命令&amp;gt;}&quot; 其中，引号表示一个字符串，调用运算符(&amp;amp;) 导致执行命令。-Help, -?, /? 显示此消息。如果在 Windows PowerShell 中键入 PowerShell.exe 命令，请在命令参数前面添加连字符(-)，而不是添加正 斜杠(/)。你可以在 Cmd.exe 中使用连字符或正斜杠。示例 PowerShell -PSConsoleFile SqlSnapIn.Psc1 PowerShell -version 2.0 -NoLogo -InputFormat text -OutputFormat XML PowerShell -ConfigurationName AdminRoles PowerShell -Command {Get-EventLog -LogName security} PowerShell -Command &quot;&amp;amp; {Get-EventLog -LogName security}&quot; # To use the -EncodedCommand parameter: $command = &#39;dir &quot;c:\\program files&quot; &#39; $bytes = [System.Text.Encoding]::Unicode.GetBytes($command) $encodedCommand = [Convert]::ToBase64String($bytes) powershell.exe -encodedCommand $encodedCommand 参考资料 windows - How do I run multiple commands on one line in PowerShell? - Super User How to split long commands over multiple lines in PowerShell - Stack Overflow Stop Powershell from exiting - Stack Overflow Powershell 任意键退出 – PowerShell 中文博客" }, { "title": "清理 git 仓库太繁琐？试试 bfg！删除敏感信息删除大文件一句命令搞定（比官方文档还详细的使用说明）", "url": "/post/clean-up-git-repo-using-bfg.html", "categories": "", "tags": "git", "date": "2019-11-05 11:22:22 +0800", "snippet": "你可能接触过 git-filter-branch 来清理 git 仓库，不过同时也能体会到这个命令使用的繁琐，以及其超长的执行时间。现在，你可以考虑使用 bfg 来解决问题了！安装 bfg传统方式安装（不推荐） 下载安装 Java 运行时 下载安装 bfg.jar这里并不推荐使用传统方式安装，因为传统方式安装后，bfg 不会成为你计算机的命令。在实际使用工具的时候，你必须为你的每一句命令加上 java -jar bfg.jar 前缀来使用 Java 运行时间接运行。使用包管理器 scoop 安装如果你使用包管理器 scoop，那么安装将会非常简单，只需要以下几个命令。 scoop install bfg scoop bucket add java scoop install java/openjdk安装 bfg：PS C:\\Users\\lvyi&amp;gt; scoop install bfgInstalling &#39;bfg&#39; (1.13.0) [64bit]bfg-1.13.0.jar (12.8 MB) [============================================================================================================================] 100%Checking hash of bfg-1.13.0.jar ... ok.Linking ~\\scoop\\apps\\bfg\\current =&amp;gt; ~\\scoop\\apps\\bfg\\1.13.0Creating shim for &#39;bfg&#39;.&#39;bfg&#39; (1.13.0) was installed successfully!&#39;bfg&#39; suggests installing &#39;java/oraclejdk&#39; or &#39;java/openjdk&#39;.安装 Java 源：PS C:\\Users\\lvyi&amp;gt; scoop bucket add javaChecking repo... okThe java bucket was added successfully.安装 Jdk：PS C:\\Users\\lvyi&amp;gt; scoop install java/openjdkInstalling &#39;openjdk&#39; (13.0.1-9) [64bit]openjdk-13.0.1_windows-x64_bin.zip (186.9 MB) [=======================================================================================================] 100%Checking hash of openjdk-13.0.1_windows-x64_bin.zip ... ok.Extracting openjdk-13.0.1_windows-x64_bin.zip ... done.Linking ~\\scoop\\apps\\openjdk\\current =&amp;gt; ~\\scoop\\apps\\openjdk\\13.0.1-9&#39;openjdk&#39; (13.0.1-9) was installed successfully!准备工作当你准备好清理你的仓库的时候，需要进行一些准备。 克隆一个镜像仓库（git clone 命令加上 --mirror 参数） 这样，当你 git push 的时候，会更新远端仓库的所有引用 cd 到你要清理的仓库路径的根目录 如果你没有前往根目录，那么本文后面的所有命令的最后面你都应该加上路径 可能需要解除保护 如果本文后面的命令你遇到了受保护的提交，那么需要在所有命令的后面加上 --no-blob-protection 参数 常见用法使用 bfg 来清理仓库比 git 原生的 git-filter-branch 快得多。官方说法是，10-720 倍： turning an overnight job into one that takes less than ten minutes.将一整夜的工作缩减到不到十分钟。删除误上传的大文件使用下面的命令，可以将仓库历史中大于 500M 的文件都删除掉。&amp;gt; bfg --strip-blobs-bigger-than 500M删除特定的一个或多个文件删除 walterlv.snk 文件：&amp;gt; bfg --delete-files walterlv.snk删除 walterlv.snk 或 lindexi.snk 文件：&amp;gt; bfg --delete-files {walterlv,lindexi}.snk比如原来仓库结构是这样的：- README.md- Security.md- walterlv.snk+ test - lindexi.snk那么删除完后，根目录的 walterlv.snk 和 test 子目录下的 lindexi.snk 就都删除了。删除文件夹删除名字为 walterlv 的文件夹：&amp;gt; bfg --delete-folders walterlv此命令可以与上面的 --delete-files 放在一起执行：&amp;gt; bfg --delete-folders walterlv --delete-files walterlv.snk删除敏感的密码信息&amp;gt; bfg --replace-text expression-file.txt注意，这里的 expression-file.txt 名称是随便取的，你可以取其他任何名称，只要在命令里输入正确的名称（可能需要包含路径）就行。但是 expression-file.txt 里面的内容却是我们需要关注的重点。此文件中的每一行是一个匹配表达式。默认情况下，每一个表达式被视为一段文本常量，但你可以通过指定 regex: 前缀来说明此表达式是一个正则表达式，或者指定 glob: 前缀。每一个表达式的后面可以加上 ‘==&amp;gt;’ 来指定匹配的文件应该被替换成什么（如果没有指定，就会被替换成默认值 ***REMOVED***。下面这个例子示例将 git 仓库中所有文件中的 密码：123456 字符串替换成 ***REMOVED***：密码：123456更复杂一点的，下面的例子示例将 git 仓库中所有文件中的 密码：123456 字符串替换成 密码：******：密码：123456 ==&amp;gt; 密码：******还可以使用正则表达式：regex:密码：\\d+ ==&amp;gt; 密码：******推回远端仓库当你在本地操作完镜像仓库之后，可以将其推回原来的远端仓库了。&amp;gt; git push最后，有一个不必要的操作。就是回收已经没有引用的旧提交，这可以减小本地仓库的大小：&amp;gt; git reflog expire --expire=now --all &amp;amp;&amp;amp; git gc --prune=now --aggressive附命令行用法输出直接在命令行输入 bfg 可以看 bfg 命令行的用法。我贴在下面可以让还没安装的小伙伴感受一下它的功能：PS C:\\Users\\lvyi\\Desktop\\BfgDemoRepo&amp;gt; bfgbfg 1.13.0Usage: bfg [options] [&amp;lt;repo&amp;gt;] -b, --strip-blobs-bigger-than &amp;lt;size&amp;gt; strip blobs bigger than X (eg &#39;128K&#39;, &#39;1M&#39;, etc) -B, --strip-biggest-blobs NUM strip the top NUM biggest blobs -bi, --strip-blobs-with-ids &amp;lt;blob-ids-file&amp;gt; strip blobs with the specified Git object ids -D, --delete-files &amp;lt;glob&amp;gt; delete files with the specified names (eg &#39;*.class&#39;, &#39;*.{txt,log}&#39; - matches on file name, not path within repo) --delete-folders &amp;lt;glob&amp;gt; delete folders with the specified names (eg &#39;.svn&#39;, &#39;*-tmp&#39; - matches on folder name, not path within repo) --convert-to-git-lfs &amp;lt;value&amp;gt; extract files with the specified names (eg &#39;*.zip&#39; or &#39;*.mp4&#39;) into Git LFS -rt, --replace-text &amp;lt;expressions-file&amp;gt; filter content of files, replacing matched text. Match expressions should be listed in the file, one expression per line - by default, each expression is treated as a literal, but &#39;regex:&#39; &amp;amp; &#39;glob:&#39; prefixes are supported, with &#39;==&amp;gt;&#39; to specify a replacement string other than the default of &#39;***REMOVED***&#39;. -fi, --filter-content-including &amp;lt;glob&amp;gt; do file-content filtering on files that match the specified expression (eg &#39;*.{txt,properties}&#39;) -fe, --filter-content-excluding &amp;lt;glob&amp;gt; don&#39;t do file-content filtering on files that match the specified expression (eg &#39;*.{xml,pdf}&#39;) -fs, --filter-content-size-threshold &amp;lt;size&amp;gt; only do file-content filtering on files smaller than &amp;lt;size&amp;gt; (default is 1048576 bytes) -p, --protect-blobs-from &amp;lt;refs&amp;gt; protect blobs that appear in the most recent versions of the specified refs (default is &#39;HEAD&#39;) --no-blob-protection allow the BFG to modify even your *latest* commit. Not recommended: you should have already ensured your latest commit is clean. --private treat this repo-rewrite as removing private data (for example: omit old commit ids from commit messages) --massive-non-file-objects-sized-up-to &amp;lt;size&amp;gt; increase memory usage to handle over-size Commits, Tags, and Trees that are up to X in size (eg &#39;10M&#39;) &amp;lt;repo&amp;gt; file path for Git repository to clean我觉得你可能需要中文版，于是自己翻译了一下：PS C:\\Users\\lvyi\\Desktop\\BfgDemoRepo&amp;gt; bfgbfg 1.13.0用法: bfg [options] [&amp;lt;repo&amp;gt;] -b, --strip-blobs-bigger-than &amp;lt;size&amp;gt; 移除大于 &amp;lt;size&amp;gt; 大小的文件（&amp;lt;size&amp;gt; 可填写诸如 &#39;128K&#39;、&#39;1M&#39;） -B, --strip-biggest-blobs NUM 从大到小移除 NUM 数量的文件 -bi, --strip-blobs-with-ids &amp;lt;blob-ids-file&amp;gt; 移除具有指定 git 对象 id 的文件 -D, --delete-files &amp;lt;glob&amp;gt; 移除具有指定名称的文件（例如 &#39;*.class&#39;、&#39;*.{txt,log}&#39;，仅匹配文件名而不能匹配路径） --delete-folders &amp;lt;glob&amp;gt; 移除具有指定名称的文件夹（例如 &#39;.svn&#39;、&#39;*-tmp&#39;，仅匹配文件夹名而不能匹配路径） --convert-to-git-lfs &amp;lt;value&amp;gt; 将指定名称的文件（例如 &#39;*.zip&#39; 或 &#39;*.mp4&#39;）解压到 Git LFS -rt, --replace-text &amp;lt;expressions-file&amp;gt; 查找文件内容，并替换其中匹配的文本。&amp;lt;expressions-file&amp;gt; 是一个包含一个或多个匹配表达式的文件，文件中每一行是一个匹配表达式。 默认情况下，每一个表达式被视为一段文本常量，但你可以通过指定 &#39;regex:&#39; 前缀来说明此表达式是一个正则表达式，或者指定 &#39;glob:&#39; 前缀。 每一个表达式的后面可以加上 &#39;==&amp;gt;&#39; 来指定匹配的文件应该被替换成什么（如果没有指定，就会被替换成默认值 &#39;***REMOVED***&#39;。 -fi, --filter-content-including &amp;lt;glob&amp;gt; 指定文件名（例如 &#39;*.{txt,properties}&#39;），在进行内容替换的时候只对这些文件进行处理。 -fe, --filter-content-excluding &amp;lt;glob&amp;gt; 指定文件名（例如 &#39;*.{xml,pdf}&#39;），在进行内容替换的时候不对这些文件进行处理。 -fs, --filter-content-size-threshold &amp;lt;size&amp;gt; 仅对小于 &amp;lt;size&amp;gt; 指定的大小的文件替换内容。（默认值为 1048576 字节） -p, --protect-blobs-from &amp;lt;refs&amp;gt; protect blobs that appear in the most recent versions of the specified refs (default is &#39;HEAD&#39;) --no-blob-protection allow the BFG to modify even your *latest* commit. Not recommended: you should have already ensured your latest commit is clean. --private 仅将本次操作视为个人数据的修改（这样生成的新提交会使用旧提交的 Id，其他人拉取仓库的时候因为这些 Id 已经存在于是不会更新，以至于此更改实际上只影响自己）。 --massive-non-file-objects-sized-up-to &amp;lt;size&amp;gt; increase memory usage to handle over-size Commits, Tags, and Trees that are up to X in size (eg &#39;10M&#39;) &amp;lt;repo&amp;gt; file path for Git repository to clean参考资料 BFG Repo-Cleaner by rtyley" }, { "title": "解决关闭模态窗口后，父窗口居然失去焦点跑到了其他窗口的后面的问题", "url": "/post/fix-owner-window-dropping-down-when-close-a-modal-child-window.html", "categories": "", "tags": "dotnet, csharp, windows", "date": "2019-11-05 09:58:20 +0800", "snippet": "显示一个模态窗口，正常而普遍的操作。然而却一直有一个难缠的 BUG：当关闭模态窗口时，父窗口有时会跑到其他程序窗口的后面！而最近读到了微软工程师写过的话之后，明白了这个 BUG 的产生缘由以及解决方法。这是什么 BUG？ 弹出一个模态窗口，然后将模态窗口的父窗口设置为自身窗口； 切换到其他程序窗口中（比如 Windows 资源管理器窗口）； 切换回此模态窗口，然后关闭这个模态窗口上。你会发现，模态窗口关闭后，父窗口并没有回到当前的顶层显示中。取而代之的，是其他程序的窗口（比如 Windows 资源管理器窗口）。用一张图来描述这个 BUG，将是这样的：有这两个窗口，其中右边那个是我们开发的：我们的窗口在资源管理器上面。然后，我们弹出模态子窗口：现在，我们操作一下资源管理器：然后，回到模态子窗口中，把它关掉：我们期待模态子窗口关掉后，它的父窗口会在顶层继续供我们操作，但实际上，Windows 资源管理器却成为了顶层，我们的程序“掉下去了”：解释和解决方法在《Windows 进化启示录》书中，微软有说到： 当销毁模态对话框时，这个对话框刚好是拥有前台焦点的窗口。现在，窗口管理器需要找到其他的窗口并把前台焦点交给这个窗口。窗口管理器会首先试着把前台焦点交给对话框的所有者窗口，但此时这个窗口却仍然是禁止的，因此窗口管理器将跳过所有者窗口，并继续查找没有被禁止的窗口。这很明显是 Windows 的 BUG，然而让微软感到无奈的是，经常有程序喜欢依赖于微软的 BUG 进行开发，一旦微软修复了 BUG，那些依赖于 BUG 开发的程序将变得不正常！为解决兼容性问题的微软工程师默哀一分钟……我曾经尝试在模态子窗口关闭后激活一下父窗口，但这样会导致窗口的层级闪烁一下（Windows 资源管理器会短暂地显示到我们的窗口之上）。而这本书作者推荐的方法是： 重新激活所有者窗口 销毁模态对话框 于是，我试着监听模态子窗口的 Closing 事件，在其中写下主窗口的激活调用，自此 BUG 才算解决。public ChildModalWindow(){ Closing += (sender, e) =&amp;gt; Owner?.Activate();}将这样的解决办法封装成附加属性给所有的模态子窗口，这样设置附加属性即可解决问题。或者统一模态子窗口的窗口样式，在样式中解决这个 BUG，这样，所有使用了此窗口样式的模态子窗口也将解决问题。参考资料 《伟大的产品：Windows 进化启示录》by 微软软件工程师 Raymond Chen (2016 年 3 月第 1 版，第 112 页)" }, { "title": "C#/.NET 当我们在写事件 += 和 -= 的时候，方法是如何转换成事件处理器的", "url": "/post/method-group-and-event-handler.html", "categories": "", "tags": "dotnet, csharp", "date": "2019-10-29 11:53:34 +0800", "snippet": "当我们在写 += 和 -= 事件的时候，我们会在 += 或 -= 的右边写上事件处理函数。我们可以写很多种不同的事件处理函数的形式，那么这些形式都是一样的吗？如果你不注意，可能出现内存泄漏问题。本文将讲解事件处理函数的不同形式，理解了这些可以避免编写代码的时候出现内存相关的问题。典型的事件处理函数事件处理函数本质上是一个委托，比如 FileSystemWatcher 的 Changed 事件是这样定义的：// 这是简化的代码。public event FileSystemEventHandler Changed;这里的 FileSystemEventHandler 是一个委托类型：public delegate void FileSystemEventHandler(object sender, FileSystemEventArgs e);一个典型的事件的 += 会像下面这样：void Subscribe(FileSystemWatcher watcher){ watcher.Changed += new FileSystemEventHandler(OnChanged);}void OnChanged(object sender, FileSystemEventArgs e){}+= 的右边传入的是一个 new 出来的委托实例。变种事件处理函数除了上面直接创建的目标类型的委托之外，还有其他类型可以放到 += 的右边：// 方法组。watcher.Changed += OnChanged;// Lambda 表达式。watcher.Changed += (sender, e) =&amp;gt; Console.WriteLine(e.ChangeType);// Lambda 表达式。watcher.Changed += (sender, e) =&amp;gt;{ // 事件引发时，代码会在这里执行。};// 匿名方法。watcher.Changed += delegate (object sender, FileSystemEventArgs e){ // 事件引发时，代码会在这里执行。};// 委托类型的局部变量（或者字段）。FileSystemEventHandler onChanged = (sender, e) =&amp;gt; Console.WriteLine(e.ChangeType);watcher.Changed += onChanged;// 局部方法（或者局部静态方法）。watcher.Changed += OnChanged;void OnChanged(object sender, FileSystemEventArgs e){}因为我们可以通过编写事件的 add 和 remove 方法来观察事件 += -= 传入的 value 是什么类型的什么实例，所以可以很容易验证以上每一种实例最终被加入到事件中的真实实例。实际上我们发现，无论哪一个，最终传入的都是 FileSystemEventHandler 类型的实例。然而我们知道，只有直接 new 出来的那个和局部变量那个真正是 FileSystemEventHandler 类型的实例，其他都不是。那么中间发生了什么样的转换使得我们所有种类的写法最终都可以 += 呢？编译器类型转换具有相同签名的不同委托类型，彼此之前并没有继承关系，因此在运行时是不可以进行类型转换的。比如：FileSystemEventHandler onChanged1 = (sender, e) =&amp;gt; Console.WriteLine(e.ChangeType);Action&amp;lt;object, FileSystemEventArgs&amp;gt; onChanged2 = (sender, e) =&amp;gt; Console.WriteLine(e.ChangeType);这里，onChanged1 的实例不可以赋值给 onChanged2，反过来 onChanged2 的实例也不可以赋值给 onChanged1。于是这里只有 onChanged1 才可以作为 Changed 事件 += 的右边，而 onChanged2 放到 += 右边是会出现编译错误的。然而，我们可以放 Lambda 表达式，可以放匿名函数，可以放方法组，也可以放局部函数。因为这些类型可以在编译期间，由编译器帮助进行类型转换。而转换的效果就类似于我们自己编写 new FileSystemEventHandler(xxx) 一样。不是同一个委托实例看下面这一段代码，你认为可以 -= 成功吗？void Subscribe(FileSystemWatcher watcher){ watcher.Changed += new FileSystemEventHandler(OnChanged); watcher.Changed -= new FileSystemEventHandler(OnChanged);}void OnChanged(object sender, FileSystemEventArgs e){}实际上这是可以 -= 成功的。我们平时编写代码的时候，下面的情况可能会多一些，于是自然而然以为 += 和 -= 可以成功，因为他们“看起来”是同一个实例：watcher.Changed += OnChanged;watcher.Changed -= OnChanged;在读完刚刚那一段之后，我们就可以知道，实际上这一段和上面 new 出来委托的写法在运行时是一模一样的。如果你想测试，那么在 += 的时候为对象加上一个 Id，在 -= 的时候你就会发现这是一个新对象（因为没有 Id）。然而，你平时众多的编码经验会告诉你，这里的 -= 是一定可以成功的。也就是说，+= 和 -= 时传入的委托实例即便不是同一个，也是可以成功 += 和 -= 的。+= -= 是怎么做的+= 和 -= 到底是怎么做的，可以在不同实例时也能 += 和 -= 成功呢？+= 和 -= 实际上是调用了 Delegate 的 Combine 和 Remove 方法，并生成一个新的委托实例赋值给 += -= 的左边。public event FileSystemEventHandler Changed{ add { onChangedHandler = (FileSystemEventHandler)Delegate.Combine(onChangedHandler, value); } remove { onChangedHandler = (FileSystemEventHandler)Delegate.Remove(onChangedHandler, value); }}而最终的判断也是通过 Delegate 的 Equals 方法来比较委托的实例是否相等的（== 和 != 也是调用的 Equals）：public override bool Equals(object? obj){ if (obj == null || !InternalEqualTypes(this, obj)) return false; Delegate d = (Delegate)obj; // do an optimistic check first. This is hopefully cheap enough to be worth if (_target == d._target &amp;amp;&amp;amp; _methodPtr == d._methodPtr &amp;amp;&amp;amp; _methodPtrAux == d._methodPtrAux) return true; // even though the fields were not all equals the delegates may still match // When target carries the delegate itself the 2 targets (delegates) may be different instances // but the delegates are logically the same // It may also happen that the method pointer was not jitted when creating one delegate and jitted in the other // if that&#39;s the case the delegates may still be equals but we need to make a more complicated check if (_methodPtrAux == IntPtr.Zero) { if (d._methodPtrAux != IntPtr.Zero) return false; // different delegate kind // they are both closed over the first arg if (_target != d._target) return false; // fall through method handle check } else { if (d._methodPtrAux == IntPtr.Zero) return false; // different delegate kind // Ignore the target as it will be the delegate instance, though it may be a different one /* if (_methodPtr != d._methodPtr) return false; */ if (_methodPtrAux == d._methodPtrAux) return true; // fall through method handle check } // method ptrs don&#39;t match, go down long path // if (_methodBase == null || d._methodBase == null || !(_methodBase is MethodInfo) || !(d._methodBase is MethodInfo)) return Delegate.InternalEqualMethodHandles(this, d); else return _methodBase.Equals(d._methodBase);}于是可以看出来，判断相等就是两个关键对象的判断相等： 方法所在的对象 方法信息（对应到反射里的 MethodInfo)继续回到这段代码：void Subscribe(FileSystemWatcher watcher){ watcher.Changed += new FileSystemEventHandler(OnChanged); watcher.Changed -= new FileSystemEventHandler(OnChanged);}void OnChanged(object sender, FileSystemEventArgs e){}这里的对象就是 this，方法信息就是 OnChanged 的信息，也就是：// this 就是对象，OnChanged 就是方法信息。this.OnChanged-=于是什么样的 -= 才可以把 += 加进去的事件处理函数减掉呢？ 必须是同一个对象的同一个方法所以： 使用方法组、静态局部函数、委托字段的方式创建的委托实例，在 += 和 -= 的时候无视哪个委托实例，都是可以减掉的； 使用局部函数、委托变量，在同一个上下文中，是可以减掉的，如果调用是再次进入此函数，则不能减掉（因为委托方法所在的对象实例不同） 使用 Lambda 表达式、匿名函数是不能减掉的，因为每次编写的 Lambda 表达式和匿名函数都会创建新的包含此对象的实例。" }, { "title": "如何在 .NET 项目中开启不安全代码（以便启用 unsafe fixed 等关键字）", "url": "/post/allow-unsafe-code-in-dotnet-project.html", "categories": "", "tags": "dotnet, csharp", "date": "2019-10-29 11:53:34 +0800", "snippet": "有小伙伴希望在 .NET 代码中使用指针，操作非托管资源，于是可能使用到 unsafe fixed 关键字。但使用此关键字的前提是需要在项目中开启不安全代码。本文介绍如何在项目中开启不安全代码。入门方法第一步：在你需要启用不安全代码的项目上点击右键，然后选择属性：第二步：在“生成”标签下，勾选上“允许不安全代码”：第三步：切换到 Release 配置，再勾上一次“允许不安全代码”（确保 Debug 和 Release 都打开）方法结束。如果你一开始选择了“所有配置”，那么就不需要分别在 Debug 和 Release 下打开了，一次打开即可。高级方法推荐如果你使用 .NET Core / .NET Standard 项目，那么你可以修改项目文件来实现，这样项目文件会更加清真。第一步：在你需要启用不安全代码的项目上点击右键，然后选择编辑项目文件：第二步：在你的项目文件的属性组中添加一行 &amp;lt;AllowUnsafeBlocks&amp;gt;true&amp;lt;/AllowUnsafeBlocks&amp;gt;：我已经把需要新增的行高亮出来了 &amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;OutputType&amp;gt;Exe&amp;lt;/OutputType&amp;gt; &amp;lt;TargetFramework&amp;gt;netcoreapp3.0&amp;lt;/TargetFramework&amp;gt;++ &amp;lt;AllowUnsafeBlocks&amp;gt;true&amp;lt;/AllowUnsafeBlocks&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;/Project&amp;gt;临时方法不推荐如果你只是临时希望加上不安全代码开关，则可以在编译的时候加入 -unsafe 命令行参数：csc -unsafe walterlv.cs注意，不能给 msbuild 或者 dotnet build 加上 -unsafe 参数来编译项目，只能使用 csc 加上 -unsafe 来编译文件。因此使用场景非常受限，不推荐使用。其他说明第一种方法（入门方法）和第二种方法（高级方法）最终的修改是有一些区别的。入门方法会使得项目文件中有针对于 Debug 和 Release 的不同配置，代码会显得冗余；而高级方法中只增加了一行，对任何配置均生效。因此如果可能，尽量使用高级方法呗。 &amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;OutputType&amp;gt;Exe&amp;lt;/OutputType&amp;gt; &amp;lt;TargetFramework&amp;gt;netcoreapp3.0&amp;lt;/TargetFramework&amp;gt;++ &amp;lt;AllowUnsafeBlocks&amp;gt;true&amp;lt;/AllowUnsafeBlocks&amp;gt; &amp;lt;/PropertyGroup&amp;gt;-- &amp;lt;PropertyGroup Condition=&quot;&#39;$(Configuration)|$(Platform)&#39;==&#39;Debug|AnyCPU&#39;&quot;&amp;gt;-- &amp;lt;AllowUnsafeBlocks&amp;gt;true&amp;lt;/AllowUnsafeBlocks&amp;gt;-- &amp;lt;/PropertyGroup&amp;gt;-- &amp;lt;PropertyGroup Condition=&quot;&#39;$(Configuration)|$(Platform)&#39;==&#39;Release|AnyCPU&#39;&quot;&amp;gt;-- &amp;lt;AllowUnsafeBlocks&amp;gt;true&amp;lt;/AllowUnsafeBlocks&amp;gt;-- &amp;lt;/PropertyGroup&amp;gt; &amp;lt;/Project&amp;gt;即使是 .NET Framework 也是可以使用 SDK 风格的项目文件的，详情请阅读： 将 WPF、UWP 以及其他各种类型的旧 csproj 迁移成 Sdk 风格的 csproj - walterlv" }, { "title": "不要在 C# 代码中写部分命名空间（要么不写，要么写全），否则会有源码兼容性问题", "url": "/post/source-code-compatibility-issue-of-adding-apis.html", "categories": "", "tags": "csharp, dotnet, visualstudio", "date": "2019-10-29 08:51:56 +0800", "snippet": "我只是增加库的一个 API，比如增加几个类而已，应该不会造成兼容性问题吧。对于编译好的二进制文件来说，不会造成兼容性问题；但——可能造成源码不兼容。本文介绍可能的源码不兼容问题。This post is written in multiple languages. Please select yours: 中文 English 比如我有一个项目 P 引用 A 和 B 两个库。其中使用到了 A 库中的 Walterlv.A.Diagnostics.Foo 类型。using Walterlv.A;using Walterlv.B;namespace Walterlv.Demo{ class Hello { Run(Diagnostics.Foo foo) { } }}现在，我们在 B 库中新增一个类型 Walterlv.B.Diagnostics.Bar 类型。那么上面的代码将无法完成编译，因为 Diagnosis 命名空间将具有不确定的含义，其中的 Foo 类型也将无法在不确定的命名空间中找到。因此： 强烈建议遵守 使用类型的时候，要么不写命名空间（完全留给 using），要么写全命名空间（从第一段开始写，不要省略任何部分），否则就容易与其他命名空间冲突； 可选遵守 在库中新增 API 的时候，可能需要考虑避免将部分命名空间写成过于通用的名称。是的，即使是单纯的新增 API 也可能会导致使用库的一方在源码级不兼容。当然二进制还是兼容的。另外，OpportunityLiu 提醒，如果命名空间是 Walterlv.B.Walterlv.A.Diagnostics.Bar，一样可以让写全了的命名空间炸掉。呃……还是不要在库里面折腾这样的命名空间好……不然代码当中到处充斥着 global:: 可是非常难受的。" }, { "title": ".NET/C# 在 64 位进程中读取 32 位进程重定向后的注册表", "url": "/post/read-32bit-registry-from-x64-process.html", "categories": "", "tags": "dotnet, windows, csharp", "date": "2019-10-22 16:59:03 +0800", "snippet": "我们知道，32 位程序在读取注册表的时候，会自动将注册表的路径映射到 32 位路径下，即在 Wow6432Node 子节点下。但是 64 位程序不会映射到 32 位路径下。那么 64 位程序如何读取到 32 位程序写入的注册表路径呢？Wow6432Node对于 32 位程序，读取注册表路径的时候，会读到 Wow6432Node 节点下的项：这张图读取的就是前面截图中的节点。那么怎样编译的程序是 32-bit 的程序呢？对于 64 位程序，读取的时候就不会有 Wow6432Node 路径部分。由于我没有在那个路径放注册表项，所以会得到 null。那么怎样编译的程序是 64-bit 的程序呢？如何在 64 位程序中读取 32 位注册表路径前面我们的例子代码是这样的：var value = RegistryHive.LocalMachine.Read(@&quot;SOFTWARE\\Walterlv&quot;);可以看到，相同的代码，在 32 位和 64 位进程下得到的结果是不同的： 32 位进程在 32 位系统上，64 位进程在 64 位系统上，读取的路径会是传入的路径； 32 位进程在 64 位系统上，读取的路径会包含 Wow6432Node。那么如何在 64 位进程中读取 32 位注册表路径呢？方法是在打开注册表项的时候，传入 RegistryView.Registry32。RegistryKey.OpenBaseKey(root, RegistryView.Registry32);Walterlv.Win32可以在我的 GitHub 仓库中查看完整的实现。当然，除了上面那句话，其他都不是关键代码，在哪里都可以找得到的。参考资料 c# - Reading the registry and Wow6432Node key - Stack Overflow" }, { "title": "解决 WPF 嵌套的子窗口在改变窗口大小的时候闪烁的问题", "url": "/post/window-flickers-on-resizing-if-the-window-contains-a-hwndhost-element.html", "categories": "", "tags": "wpf, windows, dotnet, csharp", "date": "2019-10-22 14:14:08 +0800", "snippet": "因为 Win32 的窗口句柄是可以跨进程传递的，所以可以用来实现跨进程 UI。不过，本文不会谈论跨进程 UI 的具体实现，只会提及其实现中的一个重要缓解，使用子窗口的方式。你有可能在使用子窗口之后，发现拖拽改变窗口大小的时候，子窗口中的内容不断闪烁。如果你也遇到了这样的问题，那么正好可以阅读本文来解决。问题你可以看一下下面的这张动图，感受一下窗口的闪烁：实际上在拖动窗口的时候，是一直都在闪的，只是每次闪烁都非常快，截取 gif 的时候截不到。如果你希望实际跑一跑项目看看，可以使用下面的代码： walterlv.demo/Walterlv.Demo.HwndWrapping/Walterlv.Demo.HwndWrapping at a88f81477756af2913349970ba2f0bbab01aaf88 · walterlv/walterlv.demo我特地提取了一个提交下的代码，如果你要尝试，不能使用 master 分支，因为 master 分支修复了闪烁的问题。后来使用 CreateWindowEx 创建了一个纯 Win32 窗口，这种闪烁现象更容易被截图：解决 public class HwndWrapper : HwndHost { protected override HandleRef BuildWindowCore(HandleRef hwndParent) { const int WS_CHILD = 0x40000000;++ const int WS_CLIPCHILDREN = 0x02000000; var owner = ((HwndSource)PresentationSource.FromVisual(this)).Handle; var parameters = new HwndSourceParameters(&quot;demo&quot;) { ParentWindow = owner,-- WindowStyle = (int)(WS_CHILD),++ WindowStyle = (int)(WS_CHILD | WS_CLIPCHILDREN), }; var source = new HwndSource(parameters); source.RootVisual = new ChildPage(); return new HandleRef(this, source.Handle); } protected override void DestroyWindowCore(HandleRef hwnd) { } }原因正在探索……参考资料 wpf - Custom dwm drawn window frame flickers on resizing if the window contains a HwndHost element - Stack Overflow WPF多进程UI探索（Like Chrome） - 简书 关于WS_CLIPCHILDREN和WS_CLIPSIBLINGS的理解（个人认为还是相当全面的） - helloj2ee - 博客园" }, { "title": "System.ComponentModel.Win32Exception (0x80004005): 无效的窗口句柄。", "url": "/post/win32exception.html", "categories": "", "tags": "dotnet, csharp, wpf", "date": "2019-10-22 14:13:45 +0800", "snippet": "在 WPF 获取鼠标当前坐标的时候，可能会得到一个异常：System.ComponentModel.Win32Exception:“无效的窗口句柄。”。本文解释此异常的原因和解决方法。异常获取鼠标当前相对于元素 element 的坐标的代码：var point = Mouse.GetPosition(element);或者，还有其他的代码：var point1 = e.PointFromScreen(new Point());var point2 = e.PointToScreen(new Point());如果在按下窗口关闭按钮的时候调用以上代码，则会引发异常：System.ComponentModel.Win32Exception (0x80004005): 无效的窗口句柄。 at Point MS.Internal.PointUtil.ClientToScreen(Point pointClient, PresentationSource presentationSource) at Point System.Windows.Input.MouseDevice.GetScreenPositionFromSystem()原因将窗口上的点转换到控件上的点的方法是这样的：/// &amp;lt;summary&amp;gt;/// Convert a point from &quot;client&quot; coordinate space of a window into/// the coordinate space of the screen./// &amp;lt;/summary&amp;gt;/// &amp;lt;SecurityNote&amp;gt;/// SecurityCritical: This code causes eleveation to unmanaged code via call to GetWindowLong/// SecurityTreatAsSafe: This data is ok to give out/// validate all code paths that lead to this./// &amp;lt;/SecurityNote&amp;gt;[SecurityCritical, SecurityTreatAsSafe]public static Point ClientToScreen(Point pointClient, PresentationSource presentationSource){ // For now we only know how to use HwndSource. HwndSource inputSource = presentationSource as HwndSource; if(inputSource == null) { return pointClient; } HandleRef handleRef = new HandleRef(inputSource, inputSource.CriticalHandle); NativeMethods.POINT ptClient = FromPoint(pointClient); NativeMethods.POINT ptClientRTLAdjusted = AdjustForRightToLeft(ptClient, handleRef); UnsafeNativeMethods.ClientToScreen(handleRef, ptClientRTLAdjusted); return ToPoint(ptClientRTLAdjusted);}最关键的是 UnsafeNativeMethods.ClientToScreen，此方法要求窗口句柄依然有效，然而此时窗口已经关闭，句柄已经销毁。解决" }, { "title": "使用 Direct3D11 的 OpenSharedResource 方法渲染来自其他进程/设备的共享资源（SharedHandle）", "url": "/post/direct3d11-open-shared-resource.html", "categories": "", "tags": "directx, sharpdx, dotnet", "date": "2019-10-22 14:07:30 +0800", "snippet": "如果你得到了一个来自于其他进程或者其他模块的 Direct3D11 的共享资源，即 SharedHandle 句柄，那么可以使用本文提到的方法将其转换成 Direct3D11 的设备和纹理，这样你可以进行后续的其他处理。SharpDX本文的代码会使用到 SharpDX 库，因此，你需要在你的项目当中安装这些 NuGet 包：&amp;lt;!-- 基础，必装 --&amp;gt;&amp;lt;PackageReference Include=&quot;SharpDX&quot; Version=&quot;4.2.0&quot; /&amp;gt;&amp;lt;PackageReference Include=&quot;SharpDX.D3DCompiler&quot; Version=&quot;4.2.0&quot; /&amp;gt;&amp;lt;PackageReference Include=&quot;SharpDX.DXGI&quot; Version=&quot;4.2.0&quot; /&amp;gt;&amp;lt;PackageReference Include=&quot;SharpDX.Mathematics&quot; Version=&quot;4.2.0&quot; /&amp;gt;&amp;lt;PackageReference Include=&quot;SharpDX.Direct3D11&quot; Version=&quot;4.2.0&quot; /&amp;gt;&amp;lt;!-- 其他，可选 --&amp;gt;&amp;lt;PackageReference Include=&quot;SharpDX.Direct2D1&quot; Version=&quot;4.2.0&quot; /&amp;gt;&amp;lt;PackageReference Include=&quot;SharpDX.Direct3D9&quot; Version=&quot;4.2.0&quot; /&amp;gt;SharedHandleDirect3D 支持在不同的 Direct3D 设备之间共享资源。需要设置 ResourceOptionFlags 为 Shared 的纹理才可以支持共享，当然这不是本文要说的重点。本文要说的是，如果你拿到了一个来自于其他模块的共享资源句柄的时候，你可以如何使用它。你的使用可能类似于这样：public void OnAcceleratedPaint(IntPtr sharedHandle, Int32Rect dirtyRect){ // 通过 sharedHandle 进行后续的处理。}OpenSharedResourceDirectX 中用来表示 Direct3D11 的设备类型是 ID3D11Device，它有一个 OpenSharedResource 方法可以用来打开来自于其他设备的共享资源。对应到 SharpDX 中，用来表示 Direct3D11 的设备的类型是 SharpDX.Direct3D11.Device，其有一个 OpenSharedResource&amp;lt;T&amp;gt; 方法来打开来自于其他设备的共享资源。我们必须要创建一个自己的 Direct3D11 设备，因为设备是不共享的，代码如下：var device = new SharpDX.Direct3D11.Device(DriverType.Hardware, DeviceCreationFlags.BgraSupport);var resource = device.OpenSharedResource&amp;lt;SharpDX.Direct3D11.Resource&amp;gt;(sharedHandle);后续操作在得到此共享资源之后，我们可以获得更多关于此资源的描述，以及有限地使用此资源的方法。获取 Texture2D可以通过 QueryInterface 获取某个资源相关的 COM 对象的引用。我们拿到的共享资源是 2D 纹理的话，我们可以使用 QueryInterface 获取 SharpDX.Direct3D11.Texture2D COM 对象的引用。var texture = resource.QueryInterface&amp;lt;SharpDX.Direct3D11.Texture2D&amp;gt;();获取 Texture2DDescription可以从 Texture2D 的实例中获取到 Texture2DDescription，这是用来描述此 2D 纹理创建时的各种信息。// 在 DirectX 的传统代码中，通常使用 desc 来作为 Texture2DDescription 实例命名的后缀。// 不过 C# 代码通常不这么干，这是 C++ 代码的习惯。在这里这么写是为了在得到 C++ 搜索结果的时候可以与本文所述的 C# 代码对应起来。var desc = texture.Description;获取 Surface或者，我们可以获取到 2D 图面，用于做渲染、绘制等操作。当然，是否能真正进行这些操作取决于 Texture2DDescription 中是否允许相关的操作。var surface = texture2D.QueryInterface&amp;lt;SharpDX.DXGI.Surface&amp;gt;();在获取到 SharpDX.DXGI.Surface 的 COM 组件引用之后，可以在内存中映射位图用于调试，可以参见： 将 Direct3D11 在 GPU 中的纹理（Texture2D）导出到内存或导出成图片文件参考资料 c++ - Direct3D11: Sharing a texture between devices: black texture - Stack Overflow ID3D11Device::OpenSharedResource (d3d11.h) - Microsoft Docs IDXGIResource interface (Windows) IDXGIResource (dxgi.h) - Microsoft Docs IUnknown::QueryInterface(Q,) - Microsoft Docs" }, { "title": "将 Direct3D11 在 GPU 中的纹理（Texture2D）导出到内存（Map）或导出成图片文件", "url": "/post/map-directx-surface-to-bitmap.html", "categories": "", "tags": "directx, sharpdx, dotnet, csharp", "date": "2019-10-22 14:07:29 +0800", "snippet": "Direct3D11 的使用通常不是应用程序唯一的部分，于是使用 Direct3D11 的代码如何与其他模块正确地组合在一起就是一个需要解决的问题。本文介绍将 Direct3D11 在 GPU 中绘制的纹理映射到内存中，这样我们可以直接观察到此纹理是否是正确的，而不用担心是否有其他模块影响了最终的渲染过程。SharpDX本文的代码会使用到 SharpDX 库，因此，你需要在你的项目当中安装这些 NuGet 包：&amp;lt;!-- 基础，必装 --&amp;gt;&amp;lt;PackageReference Include=&quot;SharpDX&quot; Version=&quot;4.2.0&quot; /&amp;gt;&amp;lt;PackageReference Include=&quot;SharpDX.D3DCompiler&quot; Version=&quot;4.2.0&quot; /&amp;gt;&amp;lt;PackageReference Include=&quot;SharpDX.DXGI&quot; Version=&quot;4.2.0&quot; /&amp;gt;&amp;lt;PackageReference Include=&quot;SharpDX.Mathematics&quot; Version=&quot;4.2.0&quot; /&amp;gt;&amp;lt;PackageReference Include=&quot;SharpDX.Direct3D11&quot; Version=&quot;4.2.0&quot; /&amp;gt;&amp;lt;!-- 其他，可选 --&amp;gt;&amp;lt;PackageReference Include=&quot;SharpDX.Direct2D1&quot; Version=&quot;4.2.0&quot; /&amp;gt;&amp;lt;PackageReference Include=&quot;SharpDX.Direct3D9&quot; Version=&quot;4.2.0&quot; /&amp;gt;来自于 Direct3D11 的渲染纹理本文不会说如何创建或者获取来自 Direct3D11 的渲染纹理，不过如果你希望了解，可以： 自己创建：WPF 使用封装的 SharpDx 控件 或者从其他进程/模块获取：使用 Direct3D11 的 OpenSharedResource 方法渲染来自其他进程/设备的共享资源（SharedHandle）本文接下来的内容，是在你已经获得了 SharpDX.Direct3D11.Resource 的引用，或者 SharpDX.Direct3D11.Texture2D 的前提之下。当然，如果你获得了其中任何一个实例，可以通过 COM 组件的 QueryInterface 方法获得其他实例。var texture = resource.QueryInterface&amp;lt;SharpDX.Direct3D11.Texture2D&amp;gt;();var resource = texture.QueryInterface&amp;lt;SharpDX.Direct3D11.Resource&amp;gt;();关键代码（SharpDX.DXGI.Surface.Map）要获得 GPU 中渲染的图片，我们必须要将其映射到内存中才行。而映射到内存中的核心代码是 SharpDX.DXGI.Surface 对象的 Map 方法。using (var surface = texture2D.QueryInterface&amp;lt;SharpDX.DXGI.Surface&amp;gt;()){ var map = surface.Map(SharpDX.DXGI.MapFlags.Read, out DataStream dataStream); for (var y = 0; y &amp;lt; surface.Description.Height; y++) { for (var x = 0; x &amp;lt; surface.Description.Width; x++) { // 在这里使用位图的像素数据，坐标为 (x, y)。 // 得到此坐标下的像素指针： // var ptr = ((byte*)map.DataPointer) + y * map.Pitch; // 得到此像素的颜色值： // var b = *(ptr + 4 * x); // var g = *(ptr + 4 * x + 1); // var r = *(ptr + 4 * x + 2); // var a = *(ptr + 4 * x + 3); } } dataStream.Dispose(); surface.Unmap();}注意以上代码使用了不安全代码（指针），你需要为你的项目开启不安全代码开关，详见： 如何在 .NET 项目中开启不安全代码（以便启用 unsafe fixed 等关键字）你可能需要拷贝资源实际上，在使用上面的代码时，你可能会遇到错误，错误出现在 Map 方法的调用上，描述为“参数错误”。实际上真正检查这里的两个参数时并不能发现究竟是哪个参数出了问题。实际上出问题的参数是 surface 的实例。一段 GPU 中的纹理要能够被映射到内存，必须要具有 CPU 的访问权。而是否具有 CPU 访问权在创建纹理的时候就已经确定下来了。如果前面你得到的纹理是自己创建的，那么恭喜你，你只需要改一下创建纹理的参数就好了。给 Texture2DDescription 的 CpuAccessFlags 属性加上 CpuAccessFlags.Read 标识。desc.CpuAccessFlags = CpuAccessFlags.Read；但是，如果此纹理不是由你自己创建的，那么就需要拷贝一份新的纹理了。当然，拷贝过程发生在 GPU 中，占用的也是 GPU 专用内存（即显存，如果有的话）。拷贝需要做到两点： 创建一个新的 Texture2DDescription（一定要是新的实例，你不能影响原来的实例），然后修改其 CPU 访问权限为 Read； 使用 ImmediateContext 实例的 CopyResource 方法来拷贝资源（此实例可以通过 SharpDX.Direct3D11.Device 来找到）。var originalDesc = originalTexture.Description;var desc = new Texture2DDescription{ CpuAccessFlags = CpuAccessFlags.Read, BindFlags = BindFlags.None, Usage = ResourceUsage.Staging, Width = originalDesc.Width, Height = originalDesc.Height, Format = originalDesc.Format, MipLevels = 1, ArraySize = 1, SampleDescription = { Count = 1, Quality = 0 },};var texture2D = new Texture2D(device, desc);device.ImmediateContext.CopyResource(originalTexture, texture2D);需要注意，拷贝纹理会额外占用显存，一般不建议这么做，除非你真的有需求一定要 CPU 能够访问到这段纹理。导出成图片文件实际上，当你组合起来以上以上方法，你应该能够将纹理导出成图片了。不过，为了理解更方便一些，我还是将导出成图片的全部代码贴出来：public static unsafe void MapTexture2DToFile(SharpDX.Direct3D11.Texture2D texture, string fileName){ // 获取 Texture2D 的相关实例。 var device = texture.Device; var originDesc = texture.Description; // 创建新的 Texture2D 对象。 var desc = new Texture2DDescription { CpuAccessFlags = CpuAccessFlags.Read, BindFlags = BindFlags.None, Usage = ResourceUsage.Staging, Width = originDesc.Width, Height = originDesc.Height, Format = originDesc.Format, MipLevels = 1, ArraySize = 1, SampleDescription = { Count = 1, Quality = 0 }, OptionFlags = ResourceOptionFlags.Shared }; var texture2D = new Texture2D(device, desc); // 拷贝资源。 device.ImmediateContext.CopyResource(texture, texture2D); var bitmap = new System.Drawing.Bitmap(desc.Width, desc.Height); using (var surface = texture2D.QueryInterface&amp;lt;SharpDX.DXGI.Surface&amp;gt;()) { var map = surface.Map(SharpDX.DXGI.MapFlags.Read, out DataStream dataStream); var lines = (int)(dataStream.Length / map.Pitch); var actualWidth = surface.Description.Width * 4; for (var y = 0; y &amp;lt; desc.Height; y++) { var h = desc.Height - y; var ptr = ((byte*)map.DataPointer) + y * map.Pitch; for (var x = 0; x &amp;lt; desc.Width; x++) { var b = *(ptr + 4 * x); var g = *(ptr + 4 * x + 1); var r = *(ptr + 4 * x + 2); var a = *(ptr + 4 * x + 3); bitmap.SetPixel(x, y, System.Drawing.Color.FromArgb(a, r, g, b)); } } dataStream.Dispose(); surface.Unmap(); bitmap.Save(fileName); }}如果你是希望以纯软件的方式渲染到 WPF 中（WriteableBitmap），可以参考： WPF 高性能位图渲染 WriteableBitmap 及其高性能用法示例记得打开不安全代码开关哦！详见： 如何在 .NET 项目中开启不安全代码（以便启用 unsafe fixed 等关键字）参考资料 c++ - How to access pixels data from ID3D11Texture2D? - Stack Overflow SharpDX Directx11 How to add normal mapping ? - Graphics and GPU Programming - GameDev.net directx 11 - How to create bitmap from Surface (SharpDX) - Stack Overflow Desktop Duplication API - Windows applications - Microsoft Docs c# - Reading Datastream sharpDX Error all values are 0 - Stack Overflow SharpDX-Samples/Program.cs at master · sharpdx/SharpDX-Samples" }, { "title": ".NET 实现 NTFS 文件系统的硬链接 mklink /J（Junction）", "url": "/post/mklink-junction-in-dotnet.html", "categories": "", "tags": "dotnet, windows, csharp", "date": "2019-10-22 14:04:24 +0800", "snippet": "我们知道 Windows 系统 NTFS 文件系统提供了硬连接功能，可以通过 mklink 命令开启。如果能够通过代码实现，那么我们能够做更多有趣的事情。本文提供使用 .NET/C# 代码创建 NTFS 文件系统的硬连接功能（目录联接）。目录联接以管理员权限启动 CMD（命令提示符），输入 mklink 命令可以得知 mklink 的用法。C:\\WINDOWS\\system32&amp;gt;mklink创建符号链接。MKLINK [[/D] | [/H] | [/J]] Link Target /D 创建目录符号链接。默认为文件 符号链接。 /H 创建硬链接而非符号链接。 /J 创建目录联接。 Link 指定新的符号链接名称。 Target 指定新链接引用的路径 (相对或绝对)。我们本次要用 .NET/C# 代码实现的是 /J 目录联接。实现的效果像这样：这些文件夹带有一个“快捷方式”的角标，似乎是另一些文件夹的快捷方式一样。但这些与快捷方式的区别在于，应用程序读取路径的时候，目录联接会成为路径的一部分。比如在 D:\\Walterlv\\NuGet\\ 中创建 debug 目录联接，目标设为 D:\\Walterlv\\DemoRepo\\bin\\Debug，那么，你在各种应用程序中使用以下两个路径将被视为同一个： D:\\Walterlv\\NuGet\\debug\\DemoRepo-1.0.0.nupkg D:\\Walterlv\\DemoRepo\\bin\\Debug\\DemoRepo-1.0.0.nupkg或者这种： D:\\Walterlv\\NuGet\\debug\\publish\\ D:\\Walterlv\\DemoRepo\\bin\\Debug\\publish\\使用 .NET/C# 实现本文的代码主要参考自 jeff.brown 在 Manipulating NTFS Junction Points in .NET - CodeProject 一文中所附带的源代码。由于随时可能更新，所以你可以前往 GitHub 仓库打开此代码： walterlv.demo/JunctionPoint.cs at master · walterlv/walterlv.demo使用 JunctionPoint如果希望在代码中创建目录联接，则直接使用：JunctionPoint.Create(&quot;walterlv.demo&quot;, @&quot;D:\\Developments&quot;, true);后面的 true 指定如果目录联接存在，则会覆盖掉原来的目录联接。参考资料 windows - What the C# equivalent of “mklink /J”? - Stack Overflow Manipulating NTFS Junction Points in .NET - CodeProject Reparse Points - Windows applications - Microsoft Docs" }, { "title": "WPF 高性能位图渲染 WriteableBitmap 及其高性能用法示例", "url": "/post/wpf-high-performance-bitmap-rendering.html", "categories": "", "tags": "wpf, dotnet, csharp", "date": "2019-10-22 12:43:29 +0800", "snippet": "WPF 渲染框架并没有对外提供多少可以完全控制渲染的部分，目前可以做的有： D3DImage，用来承载使用 DirectX 各个版本渲染内容的控件 WriteableBitmap，通过一段内存空间来指定如何渲染一个位图的图片 HwndHost，通过承载一个子窗口以便能叠加任何种类渲染的控件本文将解释如何最大程度压榨 WriteableBitmap 在 WPF 下的性能。如何使用 WriteableBitmap创建一个新的 WPF 项目，然后我们在 MainWindow.xaml 中编写一点可以用来显示 WriteableBitmap 的代码：&amp;lt;Window x:Class=&quot;Walterlv.Demo.HighPerformanceBitmap.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:local=&quot;clr-namespace:Walterlv.Demo.HighPerformanceBitmap&quot; Title=&quot;WriteableBitmap - walterlv&quot; SizeToContent=&quot;WidthAndHeight&quot;&amp;gt; &amp;lt;Grid&amp;gt; &amp;lt;Image x:Name=&quot;Image&quot; Width=&quot;1280&quot; Height=&quot;720&quot; /&amp;gt; &amp;lt;/Grid&amp;gt;&amp;lt;/Window&amp;gt;为了评估其性能，我决定绘制和渲染 4K 品质的位图，并通过以下步骤来评估： 使用 CompositionTarget.Rendering 逐帧渲染以评估其渲染帧率 使用 Benchmark 基准测试来测试内部各种不同方法的性能差异于是，在 MainWindow.xaml.cs 中添加一些测试用的修改 WriteableBitmap 的代码：using System;using System.Windows;using System.Windows.Controls;using System.Windows.Input;using System.Windows.Media;using System.Windows.Media.Imaging;namespace Walterlv.Demo.HighPerformanceBitmap{ public partial class MainWindow : Window { private readonly WriteableBitmap _bitmap; public MainWindow() { InitializeComponent(); _bitmap = new WriteableBitmap(3840, 2160, 96.0, 96.0, PixelFormats.Pbgra32, null); Image.Source = _bitmap; CompositionTarget.Rendering += CompositionTarget_Rendering; } private void CompositionTarget_Rendering(object sender, EventArgs e) { var width = _bitmap.PixelWidth; var height = _bitmap.PixelHeight; _bitmap.Lock(); // 在这里添加绘制位图的逻辑。 _bitmap.AddDirtyRect(new Int32Rect(0, 0, width, height)); _bitmap.Unlock(); } }}注意，我留了一行注释说即将添加绘制位图的逻辑，接下来我们的主要内容将从此展开。启用不安全代码为了获取最佳性能，我们需要开启不安全代码。为此，你需要修改一下你的项目属性。你可以阅读我的另一篇博客了解如何启用不安全代码： 如何在 .NET 项目中开启不安全代码（以便启用 unsafe fixed 等关键字） - walterlv简单点说就是在你的项目文件中添加下面这一行： &amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;TargetFramework&amp;gt;netcoreapp3.0&amp;lt;/TargetFramework&amp;gt;++ &amp;lt;AllowUnsafeBlocks&amp;gt;true&amp;lt;/AllowUnsafeBlocks&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;/Project&amp;gt;启用帧率测试接下来，我们需要添加一点点代码来评估 WriteableBitmap 的性能：++ private readonly byte[] _empty4KBitmapArray = new byte[3840 * 2160 * 4];-- private void CompositionTarget_Rendering(object sender, EventArgs e)++ private unsafe void CompositionTarget_Rendering(object sender, EventArgs e) { var width = _bitmap.PixelWidth; var height = _bitmap.PixelHeight; _bitmap.Lock();++ fixed (byte* ptr = _empty4KBitmapArray)++ {++ var p = new IntPtr(ptr);++ Buffer.MemoryCopy(ptr, _bitmap.BackBuffer.ToPointer(), _empty4KBitmapArray.Length, _empty4KBitmapArray.Length);++ } _bitmap.AddDirtyRect(new Int32Rect(0, 0, width, height)); _bitmap.Unlock(); }嗯，就是将一个空的 4K 大小的数组中的内容复制到 WriteableBitmap 的位图缓存中。4K 脏区虽然我们看不到任何可变的修改，不过 WriteableBitmap 可不这么认为。因为我们调用了 AddDirtyRect 将整个位图空间都加入到了脏区中，这样 WPF 会重新渲染整幅位图。Visual Studio 中看到的 CPU 占用率大约维持在 16% 左右（跟具体机器相关）；并且除了一开始启动的时候之外，完全没有 GC（这点很重要），内存稳定在一个值上不再变化。也只有本文一开始提及的三种方法才可能做到渲染任何可能的图形的时候没有 GC查看界面渲染帧率可以发现跑满 60 帧没有什么问题（跟具体机器相关）。小脏区现在，我们把脏区的区域缩小为 100*100，同样看性能数据。-- _bitmap.AddDirtyRect(new Int32Rect(0, 0, width, height));++ _bitmap.AddDirtyRect(new Int32Rect(0, 0, 100, 100));可以发现 CPU 占用降低到一半（确实是大幅降低，但是跟像素数量并不成比例）；内存没有变化（废话，4K 图像是确定的）；帧率没有变化（废话，只要性能够，帧率就是满的）。无脏区现在，我们将脏区清零。-- _bitmap.AddDirtyRect(new Int32Rect(0, 0, width, height));++ _bitmap.AddDirtyRect(new Int32Rect(0, 0, 0, 0));在完全没有脏区的时候，CPU 占用直接降为 0，这个性能提升还是非常恐怖的。不渲染如果我们不把 WriteableBitmap 设置为 Image 的 Source 属性，那么无论脏区多大，CPU 占用都是 0。脏区大小与 CPU 占用率之间的关系从前面的测试中我们可以发现，脏区的大小在 WriteableBitmap 的渲染里占了绝对的耗时。因此，我把脏区大小与 CPU 占用率之间的关系用图表的形式贴出来，这样可以直观地理解其性能差异。需要注意，CPU 占用率与机器性能强相关，因此其绝对占用没有意义，但相对大小则有参考价值。 脏区大小 CPU 占用率 帧率 0*0 0.0% 60 1*1 5.1% 60 16*9 5.7% 60 160*90 6.0% 60 320*180 6.5% 60 640*360 6.9% 60 1280*720 7.5% 60 1920*1080 10.5% 60 2560*1440 12.3% 60 3840*2160 16.1% 60 根据这张表我么可以得出： 脏区渲染是 CPU 占用的最大瓶颈（因为没有脏区仅剩内存拷贝的时候 CPU 占用为 0%）但是有一个需要注意的信息是——虽然 CPU 占用率受脏区影响非常大，但主线程却几乎没有消耗 CPU 占用。此占用基本上全是渲染线程的事。如果我们分析主线程的性能分布，可以发现内存拷贝现在是性能瓶颈：后面我们会提到 WriteableBitmap 的渲染原理，也会说到这一点。启用基准测试（Benchmark）不过，由于内存数据的拷贝和脏区渲染实际上可以分开到两个不同的线程，如果这两者不同步执行（可能执行次数还有差异）的情况下，内存拷贝也可能成为性能瓶颈的一部分。于是我将不同的内存拷贝方法进行一个基准测试，便于大家评估使用哪种方法来为 WriteableBitmap 提供渲染数据。使用 CopyMemory 拷贝内存++ [Benchmark(Description = &quot;CopyMemory&quot;)]++ [Arguments(3840, 2160)]++ [Arguments(100, 100)] public unsafe void CopyMemory(int width, int height) { _bitmap.Lock();++ fixed (byte* ptr = _empty4KBitmapArray)++ {++ var p = new IntPtr(ptr);++ CopyMemory(_bitmap.BackBuffer, new IntPtr(ptr), (uint)_empty4KBitmapArray.Length);++ } _bitmap.AddDirtyRect(new Int32Rect(0, 0, width, height)); _bitmap.Unlock(); }[DllImport(&quot;kernel32.dll&quot;)]private static extern void CopyMemory(IntPtr destination, IntPtr source, uint length);使用 MoveMemory 移动内存++ [Benchmark(Description = &quot;RtlMoveMemory&quot;)]++ [Arguments(3840, 2160)]++ [Arguments(100, 100)] public unsafe void RtlMoveMemory(int width, int height) { _bitmap.Lock();++ fixed (byte* ptr = _empty4KBitmapArray)++ {++ var p = new IntPtr(ptr);++ MoveMemory(_bitmap.BackBuffer, new IntPtr(ptr), (uint)_empty4KBitmapArray.Length);++ } _bitmap.AddDirtyRect(new Int32Rect(0, 0, width, height)); _bitmap.Unlock(); } [DllImport(&quot;kernel32.dll&quot;, EntryPoint = &quot;RtlMoveMemory&quot;)] private static extern void MoveMemory(IntPtr dest, IntPtr src, uint count);使用 Buffer.MemoryCopy 拷贝内存需要注意，Buffer.MemoryCopy 是 .NET Framework 4.6 才引入的 API，在 .NET Framework 后续版本以及 .NET Core 的所有版本才可以使用，更旧版本的 .NET Framework 没有这个 API。++ [Benchmark(Baseline = true, Description = &quot;Buffer.MemoryCopy&quot;)]++ [Arguments(3840, 2160)]++ [Arguments(100, 100)] public unsafe void BufferMemoryCopy(int width, int height) { _bitmap.Lock();++ fixed (byte* ptr = _empty4KBitmapArray)++ {++ var p = new IntPtr(ptr);++ Buffer.MemoryCopy(ptr, _bitmap.BackBuffer.ToPointer(), _empty4KBitmapArray.Length, _empty4KBitmapArray.Length);++ } _bitmap.AddDirtyRect(new Int32Rect(0, 0, width, height)); _bitmap.Unlock(); }自己写 for 循环++ [Benchmark(Description = &quot;for for&quot;)]++ [Arguments(3840, 2160)]++ [Arguments(100, 100)] public unsafe void ForForCopy(int width, int height) { _bitmap.Lock();++ var buffer = (byte*)_bitmap.BackBuffer.ToPointer();++ for (var j = 0; j &amp;lt; height; j++)++ {++ for (var i = 0; i &amp;lt; width; i++)++ {++ var pixel = buffer + j * width * 4 + i * 4;++ *pixel = 0xff;++ *(pixel + 1) = 0x7f;++ *(pixel + 2) = 0x00;++ *(pixel + 3) = 0xff;++ }++ } _bitmap.AddDirtyRect(new Int32Rect(0, 0, width, height)); _bitmap.Unlock(); }基准测试数据我们跑一次基准测试： Method Mean Error StdDev Median Ratio RatioSD CopyMemory 2.723 ms 0.0642 ms 0.1881 ms 2.677 ms 0.84 0.08 RtlMoveMemory 2.659 ms 0.0740 ms 0.2158 ms 2.633 ms 0.82 0.08 Buffer.MemoryCopy 3.246 ms 0.0776 ms 0.2250 ms 3.200 ms 1.00 0.00 ‘for for’ 10.401 ms 0.1979 ms 0.4964 ms 10.396 ms 3.21 0.25 ‘CopyMemory with 100*100 dirty region’ 2.446 ms 0.0757 ms 0.2207 ms 2.368 ms 0.76 0.09 ‘RtlMoveMemory with 100*100 dirty region’ 2.415 ms 0.0733 ms 0.2161 ms 2.369 ms 0.75 0.08 ‘Buffer.MemoryCopy with 100*100 dirty region’ 3.076 ms 0.0612 ms 0.1523 ms 3.072 ms 0.95 0.08 ‘for for with 100*100 dirty region’ 10.014 ms 0.2398 ms 0.6995 ms 9.887 ms 3.10 0.29 可以发现： CopyMemory 和 RtMoveMemory 性能是最好的，其性能差不多； 自己写循环拷贝内存的性能是最差的； 如果 WriteableBitmap 不渲染，那么无论设置多大的脏区都不会对性能有任何影响。结论和使用建议综合前面两者的结论，我们可以发现： WriteableBitmap 的性能瓶颈源于对脏区的重新渲染 脏区为 0 或者不在可视化树渲染，则不消耗性能 只要有脏区，渲染过程就会开始成为性能瓶颈 CPU 占用基础值就很高了 脏区越大，CPU 占用越高，但增幅不大 内存拷贝不是 WriteableBitmap 的性能瓶颈 建议使用 Windows API 或者 .NET API 来拷贝内存（而不是自己写） 另外，如果你有一些特殊的应用场景，可以适当调整下自己写代码的策略： 如果你希望有较大脏区的情况下降低 CPU 占用，可以考虑降低 WriteableBitmap 脏区的刷新率 如果你希望 WriteableBitmap 有较低的渲染延迟，则考虑减小脏区WriteableBitmap 渲染原理在调用 WriteableBitmap 的 AddDirtyRect 方法的时候，实际上是调用 MILSwDoubleBufferedBitmap.AddDirtyRect，这是 WPF 专门为 WriteableBitmap 而提供的非托管代码的双缓冲位图的实现。在 WriteableBitmap 内部数组修改完毕之后，需要调用 Unlock 来解锁内部缓冲区的访问，这时会提交所有的修改。接下来的渲染都交给了 MediaContext，用来完成双缓冲位图的渲染。private void SubscribeToCommittingBatch(){ // Only subscribe the the CommittingBatch event if we are on-channel. if (!_isWaitingForCommit) { MediaContext mediaContext = MediaContext.From(Dispatcher); if (_duceResource.IsOnChannel(mediaContext.Channel)) { mediaContext.CommittingBatch += CommittingBatchHandler; _isWaitingForCommit = true; } }}在上面的 CommittingBatchHandler 中，将渲染指令发送到了渲染线程。channel.SendCommand((byte*)&amp;amp;command, sizeof(DUCE.MILCMD_DOUBLEBUFFEREDBITMAP_COPYFORWARD));前面我们通过脏区大小可以得出内存拷贝不是 CPU 占用率的瓶颈，脏区大小才是，不过是渲染线程在占用这 CPU 而不是主线程。但是内存拷贝却成为了主线程的瓶颈（当然前面我们给出了数据，实际上非常小）。所以如果试图分析这么高 CPU 的占用，会发现并不能从主线程上调查得出符合预期的结论（因为即便你完全干掉了内存拷贝，CPU 占用依然是这么高）。" }, { "title": ".NET Framework 4.x 程序到底运行在哪个 CLR 版本之上", "url": "/dotnet/2017/09/22/dotnet-version.html", "categories": "", "tags": "dotnet", "date": "2019-10-16 09:42:52 +0800", "snippet": "当我们编译程序目标框架选为 .NET Framework 4.5/4.6/4.7/4.8 时，CLR 运行时是如何判断我们究竟应该用哪一个 .NET Framework 呢？.NET Framework 的版本到底由哪些部分组成？我们编译 .NET Framework 时选择的版本决定了什么？让我对这个问题产生兴趣的原因是： 我将程序编译的目标框架选为 .NET Framework 4.8；在一台安装了 .NET Framework 4.6 的电脑上提示缺少 .NET Framework 4.8；删除了随编译一起生成的 app.config 文件后程序能够正常运行。 另一个程序，我明明将程序编译的目标框架选为 .NET Framework 4.5，但在一台没有安装任何额外 .NET Framework 的 Windows 7 的电脑上提示缺少的是 .NET Framework 4.0。这里的疑点在于为什么以上两种看似类似的情况，提示的框架版本却不同。其中的 app.config 文件成为了调查此问题的突破口。配置支持的运行时观察程序附带的 app.config 文件，我们发现支持的运行时版本是 v4.0，sku 版本是 4.8。&amp;lt;configuration&amp;gt; &amp;lt;startup&amp;gt; &amp;lt;supportedRuntime version=&quot;v4.0&quot; sku=&quot;.NETFramework,Version=v4.8&quot; /&amp;gt; &amp;lt;/startup&amp;gt; &amp;lt;/configuration&amp;gt; 疑点： 为什么我们基于 .NET Framework 4.8 开发的程序运行时版本是 4.0？ sku 是什么？微软的官方文档给了我们解答：supportedRuntime Element。 version：用于指定此应用程序支持的公共语言运行时（CLR）的版本。 sku：stock-keeping unit（官方中文为“库存单位”，然而依然不懂这个词的意思），用于指定此应用程序支持的 .NET Framework 发行版本。version 的值可取： .NET Framework 版本 version 值 忽略早期版本 忽略早期版本 2.0 “v2.0.50727” 3.0 “v2.0.50727” 3.5 “v2.0.50727” 3.5 “v2.0.50727” 4.0-4.8 “v4.0” sku 的值可取： .NET Framework version sku 值 4.0 “.NETFramework,Version=v4.0” 忽略中间版本 忽略中间版本 4.5 “.NETFramework,Version=v4.5” 4.5.1 “.NETFramework,Version=v4.5.1” 4.5.2 “.NETFramework,Version=v4.5.2” 4.6 “.NETFramework,Version=v4.6” 4.6.1 “.NETFramework,Version=v4.6.1” 4.6.2 “.NETFramework,Version=v4.6.2” 4.7 “.NETFramework,Version=v4.7” 4.7.1 “.NETFramework,Version=v4.7.1” 4.7.2 “.NETFramework,Version=v4.7.2” 4.8 “.NETFramework,Version=v4.8” 于是我们发现，其实无论我们将程序的目标框架选为 .NET Framework 的哪一个 4.x 版本，CLR 运行时都是用 v4.0 表示的。微软的描述是： 对于支持 .NET Framework 4.0 或更高版本的应用程序，version 属性指示 CLR 版本，这是 .NET Framework 4 及更高版本的通用版本，而 sku 属性指示应用程序所针对的单个 .NET Framework 版本。其实看到这里我们就能有一个看似不错的解释： 无论我们选择的目标框架是 .NET Framework 4.x 的哪一个版本，用于指定 CLR 运行时版本的 version 值都是 v4.0； CLR 运行时会根据配置文件的 sku 值决定应该采用那一组运行库来为程序运行提供支持。.NET Framework 的组成以及各部分的版本我们需要寻找到 .NET Framework 的本质，不然如此错综复杂的版本号系统真把我搞懵了。微软在 .NET Framework Versions and Dependencies 中说到： 每个版本的 .NET Framework 都包含公共语言运行时 (CLR)、基础库和其他托管库。于是我们谈论 .NET Framework 的版本其实应该分三个不同的部分来谈： 每个新版本的 .NET Framework 都会保留早期版本中的功能并会添加新功能。 CLR 有其自己的版本号标识。 虽然 CLR 版本并不总是递增的，但 .NET Framework 版本号在每次发布时都会递增。 例如，.NET Framework 4、4.5 和更高版本包含 CLR 4，而 .NET Framework 2.0、3.0 和 3.5 包含 CLR 2.0。 （没有版本 3 的 CLR。）从官方文档给出的表格当中我们可以确信：.NET Framework 4.0/4.5/4.6/4.7 包含的 CLR 版本都是 4.0。CLR 的更新然而，不相信微软的 CLR 可以完全没有 BUG，既然 CLR 版本都是 4.0，那么微软对 CLR 运行时的更新怎么处理？安装了 .NET Framework 4.5/4.6/4.7 会如何提升 CLR 的稳定性和安全性？在 Targeting and Running .NET Framework apps for version 4.5 and later 中，解释了 CLR 的更新机制——就地更新（in-place update）。这篇文章 .NET 4.5 is an in-place replacement for .NET 4.0 对这种就地更新方式有比官方文档更详细的解释，并且还附带自己的一些试验（含代码）。不过文章是 2012 年写的，部分结论现在看来已经过时（因为在我的 Windows 10 配 .NET Framework 4.7 上结论已经不一样），不过对我理解就地更新本身非常有帮助，也为后续调查提供了更清晰的思路。微软对 .NET Framework 4.x 框架就地更新的说明是： .NET Framework 4.5 是替代计算机上的 .NET Framework 4 的就地更新，同样，.NET Framework 4.5.1 4.5.2、4.6、4.6.1、4.6.2、4.7、4.7.1、4.7.2、4.8 是对 .NET Framework 4.5 的就地更新，这意味着它们将使用相同的运行时版本，但是程序集版本会更新并包括新类型和成员。 在安装其中某个更新后，你的 .NET Framework 4.NET Framework 4.5 或 .NET Framework 4.6 应用应继续运行，而无需重新编译。 但是，反过来则不行。也就是说，无论我们在开发时指定目标框架的版本是 4.x 的哪一个，在运行时，CLR 环境都是 4.0。但是新的 .NET Framework 会带来更新版本的 CLR，这个 CLR 会直接替换掉旧的 CLR。.NET 4.5 is an in-place replacement for .NET 4.0 文章中 .NET Framework 基础库也是就地更新的；但我实际实验的情况是每一个不同的 .NET Framework 基础库有自己单独的文件夹，目前尚不清楚这个改变是从 .NET Framework 的哪一个版本开始的，但一定是 4.5.1、4.5.2、4.6 这三个版本中的一个。解决一开始的疑问于是，本文一开始的疑问就全部明晰了： 不管是 .NET Framework 4.5 的还是 4.8 的那两个程序，都是靠 4.0 版本的公共语言运行时（CLR）运行起来的； 如果没有安装 4.0 版本的 CLR，则会弹出提示需要安装 .NET Framework 4.0 版本才能运行，而不管我们的程序目标框架是 .NET Framework 4.x 的哪一个版本； 虽然说文案说的是 .NET Framework，但其实需要的是 CLR 如果已经安装有 4.0 版本的 CLR（可能随 .NET Framework 4.5/4.6 安装），我们程序的目标框架是 .NET Framework 4.8，但 .NET Framework 基础库并没有安装 4.8 版本，则运行时会提示需要安装 .NET Framework 4.7； 这个提示是 4.0 版的 CLR 弹出的，是根据 supportedRuntime 中指定的 sku 值来决定的 参考资料 supportedRuntime Element - Microsoft Docs .NET Framework Versions and Dependencies - Microsoft Docs .NET 4.5 is an in-place replacement for .NET 4.0 - Rick Strahl’s Web Log app config - What does “SKU” (attribute) mean in C#? - Stack Overflow .net - What happens if I remove the auto added supportedRuntime element? - Stack Overflow" }, { "title": "使用 .editorconfig 配置 .NET/C# 项目的代码分析规则的严重程度", "url": "/post/use-editor-config-file-to-config-diagnostic-severities.html", "categories": "", "tags": "dotnet, csharp", "date": "2019-10-12 11:35:04 +0800", "snippet": "随着 Visual Studio 2019 更新，在 Visual Studio 中编写代码的时候也带来了基于 Roslyn 的代码质量分析。有一些代码分析严重程度可能与团队约定的不一致，这时就需要配置规则的严重程度。另外如果是个人使用插件安装了分析器，也可以配置一些严重程度满足个人的喜好。本文介绍使用 .editorconfig 文件来配置 .NET/C# 项目中，代码分析规则的严重性。可以是全局的，也可以每个项目有自己的配置。生效范围与继承.editorconfig 文件可以在你的项目中的任何地方，甚至是代码仓库之外。是按照文件夹结构来继承生效的。比如我的项目结构是这样：+ Walterlv.Demo + Core - .editorconfig - Foo.cs - .editorconfig - Program.cs那么 Foo.cs 文件的规则严重性将受 Core 文件夹中的 .editorconfig 文件管理，如果有些规则不在此文件夹的 .editorconfig 里面，就会受外层 .editorconfig 管理。另外，你甚至可以在整个代码仓库的外部文件夹放一个 .editorconfig 文件，这样，如果项目中没有对应的规则，那么外面文件夹中的 .editorconfig 规则就会生效，这相当于间接做了一个全局生效的规则集。.editorconfig 中的内容.editorconfig 中的分析器严重性内容就像下面这样：[*.cs]# CC0097: You have missing/unexistent parameters in Xml Docsdotnet_diagnostic.CC0097.severity = error# CA1031: Do not catch general exception typesdotnet_diagnostic.CA1031.severity = suggestion# IDE0051: 删除未使用的私有成员dotnet_diagnostic.IDE0051.severity = none对于 C# 语言的规则，在 [*.cs] 区，每个规则格式是 dotnet_diagnostic.{DiagnosticId}.severity = {Severity}。当然，我们不需要手工书写这个文件，了解它的格式只是为了出问题的时候不至于一脸懵逼。配置严重程度使用 Visual Studio 2019，配置规则严重性非常简单。当然，16.3 以上版本才这么简单，之前的版本步骤多一点。在提示有问题的代码上按下重构快捷键（默认是 Ctrl + .），可以出现重构菜单，其中就有配置规则严重性的选项，直接选择即可自动添加到 .editorconfig 文件中。如果项目中没有 .editorconfig 文件，则会自动在解决方案同目录下创建一个新的。对这部分快捷键不了解的话可以阅读：提高使用 Visual Studio 开发效率的键盘快捷键 - walterlv。" }, { "title": "什么是模态窗口？本文带你了解模态窗口的本质", "url": "/post/what-is-a-modal-dialog.html", "categories": "", "tags": "windows, dotnet, csharp, wpf", "date": "2019-10-10 19:28:26 +0800", "snippet": "做 Windows 桌面应用开发的小伙伴们对“模态窗口”（Modal Dialog）一定不陌生。如果你希望在模态窗口之上做更多的事情，或者自己实现一套模态窗口类似的机制，那么你可能需要了解模态窗口的本质。本文不会太深，只是从模态窗口一词出发，抵达大家都熟知的一些知识为止。开发中的模态窗口在各种系统、语言和框架中，只要有用户可以看见的界面，都存在模态窗口的概念。从交互层面来说，它的形式是在保留主界面作为环境来显示的情况下，打开一个新的界面，用户只能在新的界面上操作，完成或取消后才能返回主界面。从作用上来说，通常是要求用户必须提供某些信息后才能继续操作，或者单纯只是为了广告。模态窗口的三个特点如果你希望自己搞一套模态窗口出来，那么只需要满足这三点即可。你可以随便加戏但那都无关紧要。 保留主界面显示的同时，禁用主界面的用户交互； 显示子界面，主界面在子界面操作完成后返回； 当用户试图跳过子界面的交互的时候进行强提醒。拿 Windows 系统中的模态对话框为例子，大概就像下面这两张图片这样：有一个小的子界面盖住了主界面，要求用户必须进行选择。Windows 系统设置因为让背景变暗了，所以用户肯定会看得到需要进行的交互；而任务管理器没有让主界面变暗，所以用户在操作子界面的时候，模态窗口的边框和标题栏闪烁以提醒用户注意。实现模态窗口对于 Windows 操作系统来说，模态窗口并不是一个单一的概念，你并不能仅通过一个 API 调用就完成显示模态窗口，你需要在不同的时机调用不同的 API 来完成一个模态窗口。如果要完整实现一个自己的模态窗口，则需要编写实现以上三个特点的代码。当然，你可能会发现实际上你显示一个模态窗口仅仅一句话调用就够了，那是因为你所用的应用程序框架帮你完成了模态窗口的一系列机制。关于 WPF 框架是如何实现模态窗口的，可以阅读：直击本质：WPF 框架是如何实现模态窗口的关于如何自己实现一个跨越线程/进程边界的模态窗口，可以阅读：实现 Windows 系统上跨进程/跨线程的模态窗口如果你希望定制以上第三个特点中强提醒的动画效果，可以阅读：WPF window 子窗口反馈效果（抖动/阴影渐变) - 唐宋元明清2188 - 博客园。API 调用为了在 Windows 上实现模态窗口，需要一些 Win32 API 调用（当然，框架够用的话直接用框架就好）。禁用主窗口我们需要使用到 BOOL EnableWindow(HWND hWnd, BOOL bEnable); 来启用与禁用某个窗口。EnableWindow(hWnd, false);try{ // 模态显示一个窗口。}finally{ EnableWindow(hWnd, true);}[DllImport(&quot;user32&quot;)]private static extern bool EnableWindow(IntPtr hwnd, bool bEnable);阻塞代码等待操作完成因为 async/await 的出现，阻塞其实可以使用 await 来实现。虽然这不是真正的阻塞，但可以真实反应出“异步”这个过程，也就是虽然这里在等待，但实际上依然能够继续在同一个线程响应用户的操作。UWP 中的新 API 当然已经都是使用 async/await 来实现模态等待了，不过 WPF/Windows Forms 比较早，只能使用 Dispatcher 线程模型来实现模态等待。于是我们可以考虑直接使用现成的 Dispatcher 线程模型来完成等待，方法是调用下面两个当中的任何一个： Window.ShowDialog 也就是直接使用窗口原生的模态 Dispatcher.PushFrame 新开一个消息循环以阻塞当前代码的同时继续响应 UI 交互上面 Window.ShowDialog 的本质也是在调用 Dispatcher.PushFrame，详见： 直击本质：WPF 框架是如何实现模态窗口的关于 PushFrame 新开消息循环阻塞的原理可以参考： 深入了解 WPF Dispatcher 的工作原理（PushFrame 部分） - walterlv当然，还有其他可以新开消息循环的方法。进行 UI 强提醒由于我们一开始禁用了主窗口，所以如果用户试图操作主窗口是不会有效果的。然而如果用户不知道当前显示了一个模态窗口需要操作，那么给出提醒也是必要的。简单的在 UI 上的提醒是最简单的了，比如： 将主界面变暗（UWP 应用，Web 应用喜欢这么做） 将主界面变模糊（iOS 应用喜欢这么做） 在模态窗口上增加一个很厚重的阴影（Android 应用喜欢这么做）然而 Windows 和 Mac OS 这些古老的系统由于兼容性负担不能随便那么改，于是需要有其他的提醒方式。Windows 采用的方式是让标题栏闪烁，让阴影闪烁。而这些特效的处理，来自于子窗口需要处理一些特定的消息 WM_SETCURSOR。详见：WPF window 子窗口反馈效果（抖动/阴影渐变) - 唐宋元明清2188 - 博客园通常你不需要手工处理这些消息，但是如果你完全定制了窗口样式，则可能需要自行做一个这样的模态窗口提醒效果。" }, { "title": "直击本质：WPF 框架是如何实现模态窗口的", "url": "/post/how-does-wpf-implement-modal-dialog.html", "categories": "", "tags": "wpf, dotnet, csharp, windows", "date": "2019-10-10 18:57:27 +0800", "snippet": "想知道你在 WPF 编写 Window.ShowDialog() 之后，WPF 框架是如何帮你实现模态窗口的吗？本文就带你来了解这一些。Window.ShowDialogWPF 显示模态窗口的方法就是 Window.ShowDialog，因此我们直接进入这个方法查看。由于 .NET Core 版本的 WPF 已经开源，我们会使用 .NET Core 版本的 WPF 源代码。Window.ShowDialog 的源代码可以在这里查看： Window.cs这个方法非常长，所以我只把其中与模态窗口最关键的代码和相关注释留下，其他都删除（这当然是不可编译的）：public Nullable&amp;lt;bool&amp;gt; ShowDialog(){ // NOTE: // _threadWindowHandles is created here. This reference is nulled out in EnableThreadWindows // when it is called with a true parameter. Please do not null it out anywhere else. // EnableThreadWindow(true) is called when dialog is going away. Once dialog is closed and // thread windows have been enabled, then there no need to keep the array list around. // Please see BUG 929740 before making any changes to how _threadWindowHandles works. _threadWindowHandles = new ArrayList(); //Get visible and enabled windows in the thread // If the callback function returns true for all windows in the thread, the return value is true. // If the callback function returns false on any enumerated window, or if there are no windows // found in the thread, the return value is false. // No need for use to actually check the return value. UnsafeNativeMethods.EnumThreadWindows(SafeNativeMethods.GetCurrentThreadId(), new NativeMethods.EnumThreadWindowsCallback(ThreadWindowsCallback), NativeMethods.NullHandleRef); //disable those windows EnableThreadWindows(false); try { _showingAsDialog = true; Show(); } catch { // NOTE: // See BUG 929740. // _threadWindowHandles is created before calling ShowDialog and is deleted in // EnableThreadWindows (when it&#39;s called with true). // // Window dlg = new Window(); // Button b = new button(); // b.OnClick += new ClickHandler(OnClick); // dlg.ShowDialog(); // // // void OnClick(...) // { // dlg.Close(); // throw new Exception(); // } // // // If above code is written, then we get inside this exception handler only after the dialog // is closed. In that case all the windows that we disabled before showing the dialog have already // been enabled and _threadWindowHandles set to null in EnableThreadWindows. Thus, we don&#39;t // need to do it again. // // In any other exception cases, we get in this handler before Dialog is closed and thus we do // need to enable all the disable windows. if (_threadWindowHandles != null) { // Some exception case. Re-enable the windows that were disabled EnableThreadWindows(true); } }}觉得代码还是太长？不要紧，我再简化一下： EnumThreadWindows 获取当前线程的所有窗口 把当前线程中的所有窗口都禁用掉（用的是 Win32 API 的禁用哦，这不会导致窗口内控件的样式变为禁用状态） 将窗口显示出来（如果出现异常，则还原之前禁用的窗口）可以注意到禁用掉的窗口是“当前线程”的哦。ShowHelper接下来的重点方法是 Window.ShowDialog 中的那句 Show()。在 Show() 之前设置了 _showingAsDialog 为 true，于是这里会调用 ShowHelper 方法并传入 true。下面的代码也是精简后的 ShowHelper 方法：private object ShowHelper(object booleanBox){ try { // tell users we&#39;re going modal ComponentDispatcher.PushModal(); _dispatcherFrame = new DispatcherFrame(); Dispatcher.PushFrame(_dispatcherFrame); } finally { // tell users we&#39;re going non-modal ComponentDispatcher.PopModal(); }}可以看到，重点是 PushModal、PopModal 以及 PushFrame。PushFrame 的效果就是让调用 ShowDialog 的代码看起来就像阻塞了一样（实际上就是阻塞了，只不过开了新的消息循环看起来 UI 不卡）。关于 PushFrame 为什么能够“阻塞”你的代码的同时还能继续响应 UI 操作的原理，可以阅读： 深入了解 WPF Dispatcher 的工作原理（PushFrame 部分） - walterlv那么 ComponentDispatcher.PushModal 和 ComponentDispatcher.PopModal 呢？可以在这里（ComponentDispatcherThread.cs）看它的代码，实际上是为了模态计数以及引发事件的，对模态的效果没有本质上的影响。" }, { "title": ".NET/C# 检测电脑上安装的 .NET Framework 的版本", "url": "/post/detect-dotnet-framework-version-of-windows-system.html", "categories": "", "tags": "dotnet, csharp", "date": "2019-10-10 16:51:58 +0800", "snippet": "如果你希望知道某台计算机上安装了哪些版本的 .NET Framework，那么正好本文可以帮助你解决问题。如何找到已安装的 .NET Framework有的电脑的 .NET Framework 是自带的，有的是操作系统自带的。这样，你就不能通过控制面板的“卸载程序”去找到到底安装了哪个版本的 .NET Framework 了。关于各个版本 Windows 10 上自带的 .NET Framework 版本，可以阅读 各个版本 Windows 10 系统中自带的 .NET Framework 版本 - walterlv。而如果通过代码 Environment.Version 来获取 .NET 版本，实际上获取的是 CLR 的版本，详见 使用 PowerShell 获取 CLR 版本号 - walterlv。这些版本号是不同的，详见 .NET Framework 4.x 程序到底运行在哪个 CLR 版本之上 - walterlv。那么如何获取已安装的 .NET Framework 的版本呢？最靠谱的方法竟然是通过读取注册表。注册表位置和含义读取位置在这里：计算机\\HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\NET Framework Setup\\NDP\\v4\\Full\\2052而唯一准确能够判定 .NET Framework 版本的，只有里面的 Release 值。但可惜的是，这个值并不能直接看出来到底是 4.5 还是 4.8。我们需要有一张对应表。我把它整理成了字典和注释，这样会比较容易理解每个编号对应的 .NET Framework 版本代号。/// &amp;lt;summary&amp;gt;/// 获取 .NET Framework 4.5 及以上版本的发行号与版本名称的对应关系。/// 4.5 及以下版本没有这样的对应关系。/// &amp;lt;/summary&amp;gt;private static readonly Dictionary&amp;lt;int, string&amp;gt; ReleaseToNameDictionary = new Dictionary&amp;lt;int, string&amp;gt;{ // .NET Framework 4.5 { 378389, &quot;4.5&quot; }, // .NET Framework 4.5.1（Windows 8.1 或 Windows Server 2012 R2 自带） { 378675, &quot;4.5.1&quot; }, // .NET Framework 4.5.1（其他系统安装） { 378758, &quot;4.5.1&quot; }, // .NET Framework 4.5.2 { 379893, &quot;4.5.2&quot; }, // .NET Framework 4.6（Windows 10 第一个版本 1507 自带） { 393295, &quot;4.6&quot; }, // .NET Framework 4.6（其他系统安装） { 393297, &quot;4.6&quot; }, // .NET Framework 4.6.1（Windows 10 十一月更新 1511 自带） { 394254, &quot;4.6.1&quot; }, // .NET Framework 4.6.1（其他系统安装） { 394271, &quot;4.6.1&quot; }, // .NET Framework 4.6.2（Windows 10 一周年更新 1607 和 Windows Server 2016 自带） { 394802, &quot;4.6.2&quot; }, // .NET Framework 4.6.2（其他系统安装） { 394806, &quot;4.6.2&quot; }, // .NET Framework 4.7（Windows 10 创造者更新 1703 自带） { 460798, &quot;4.7&quot; }, // .NET Framework 4.7（其他系统安装） { 460805, &quot;4.7&quot; }, // .NET Framework 4.7.1（Windows 10 秋季创造者更新 1709 和 Windows Server 1709 自带） { 461308, &quot;4.7.1&quot; }, // .NET Framework 4.7.1（其他系统安装） { 461310, &quot;4.7.1&quot; }, // .NET Framework 4.7.2（Windows 10 2018年四月更新 1803 和 Windows Server 1803 自带） { 461808, &quot;4.7.2&quot; }, // .NET Framework 4.7.2（其他系统安装） { 461814, &quot;4.7.2&quot; }, // .NET Framework 4.8（Windows 10 2019年五月更新 1903 自带） { 528040, &quot;4.8&quot; }, // .NET Framework 4.8（其他系统安装） { 528049, &quot;4.8&quot; },};另外，还有一些值也是有意义的（只是不那么精确）： 主版本 也就是可以共存的版本，比如 v3.5 系列和 v4 系列就是可以共存的，它们分别是就地更新的保持兼容的版本 发行版本名称 完整版 Full 和精简版 Client 版本号 比如 3.5.30729.4926 或者 4.7.02556 服务包版本 古时候的微软喜欢用 SP1 SP2 来命名同一个版本的多次更新，这也就是那个年代的产物 它们分别在注册表的这些位置： 主版本 计算机\\HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\NET Framework Setup\\NDP 里项的名称 发行版本名称 以上项里子项的名称 版本号 以上项里的 Version 值 服务包版本 以上项里的 SP 值 读取注册表在上面已经梳理了读取注册表的位置之后，相信你可以很容易写出读取已安装 .NET Framework 版本的代码出来。我已经将其做成了 NuGet 源代码包（使用 SourceYard 打包），你可以安装 NuGet 包来获得读取已安装 .NET Framework 版本的功能： NuGet Gallery - Walterlv.Environment.Source或者在 GitHub 查看源代码： Walterlv.Packages/NdpInfo.cs at master · walterlv/Walterlv.Packages只有一个类型——NdpInfo。使用方法有两种。第一种，获取当前计算机上所有已经安装的 .NET Framework 版本：var allVersions = await NdpInfo.ReadFromRegistryAsync();执行完成之后看看得到的字典 allVersions 如下：字典里 Key 是不能共存的主版本，Value 是这个主版本里当前已经安装的具体版本信息。如果直接使用 ToString()，是可以生成我们平时经常在各大文档或者社区使用的 .NET Framework 的名称。第二种，获取当前已安装的最新的 .NET Framework 版本名称：var currentVersion = NdpInfo.GetCurrentVersionName();这可以直接获取到一个字符串，比如 .NET Framework 4.8。对于只是简单获取一下已安装名称而不用做更多处理的程序来说会比较方便。" }, { "title": "Windows 系统上用 .NET/C# 查找所有窗口，并获得窗口的标题、位置、尺寸、最小化、可见性等各种状态", "url": "/post/enumerate-all-windows.html", "categories": "", "tags": "windows, dotnet, csharp", "date": "2019-10-10 12:11:37 +0800", "snippet": "在 Windows 应用开发中，如果需要操作其他的窗口，那么可以使用 EnumWindows 这个 API 来枚举这些窗口。你可以使用本文编写的一个类型，查找到所有窗口中你关心的信息。需要使用的 API枚举所有窗口仅需要使用到 EnumWindows，其中需要定义一个委托 WndEnumProc 作为传入参数的类型。剩下的我们需要其他各种方法用于获取窗口的其他属性。 GetParent 获取窗口的父窗口，这可以确认找到的窗口是否是顶层窗口。（关于顶层窗口，可以延伸 使用 SetParent 跨进程设置父子窗口时的一些问题（小心卡死） - walterlv。） IsWindowVisible 判断窗口是否可见 GetWindowText 获取窗口标题 GetClassName 获取窗口类名 GetWindowRect 获取窗口位置和尺寸，为此我们还需要定义一个结构体 LPRECTprivate delegate bool WndEnumProc(IntPtr hWnd, int lParam);[DllImport(&quot;user32&quot;)]private static extern bool EnumWindows(WndEnumProc lpEnumFunc, int lParam);[DllImport(&quot;user32&quot;)]private static extern IntPtr GetParent(IntPtr hWnd);[DllImport(&quot;user32&quot;)]private static extern bool IsWindowVisible(IntPtr hWnd);[DllImport(&quot;user32&quot;)]private static extern int GetWindowText(IntPtr hWnd, StringBuilder lptrString, int nMaxCount);[DllImport(&quot;user32&quot;)]private static extern int GetClassName(IntPtr hWnd, StringBuilder lpString, int nMaxCount);[DllImport(&quot;user32&quot;)]private static extern bool GetWindowRect(IntPtr hWnd, ref LPRECT rect);[StructLayout(LayoutKind.Sequential)]private readonly struct LPRECT{ public readonly int Left; public readonly int Top; public readonly int Right; public readonly int Bottom;}枚举所有窗口我将以上 API 封装成 FindAll 函数，并提供过滤器可以给大家过滤众多的窗口使用。比如，我写了下面一个简单的示例，可以输出当前可见的所有窗口以及其位置和尺寸：using System;namespace Walterlv.WindowDetector{ class Program { static void Main(string[] args) { var windows = WindowEnumerator.FindAll(); for (int i = 0; i &amp;lt; windows.Count; i++) { var window = windows[i]; Console.WriteLine($@&quot;{i.ToString().PadLeft(3, &#39; &#39;)}. {window.Title} {window.Bounds.X}, {window.Bounds.Y}, {window.Bounds.Width}, {window.Bounds.Height}&quot;); } Console.ReadLine(); } }}这里的 FindAll 方法，我提供了一个默认参数，可以指定如何过滤所有枚举到的窗口。如果不指定，则会找可见的，包含标题的，没有最小化的窗口。如果你希望找一些看不见的窗口，可以自己写过滤条件。什么都不要过滤的话，就传入 _ =&amp;gt; true，意味着所有的窗口都会被枚举出来。附源码因为源代码会经常更新，所以建议在这里查看： walterlv.demo/Walterlv.WindowDetector/Walterlv.WindowDetector at master · walterlv/walterlv.demo无法访问的话，可以看下面：using System;using System.Collections.Generic;using System.Drawing;using System.Runtime.InteropServices;using System.Text;namespace Walterlv.WindowDetector{ /// &amp;lt;summary&amp;gt; /// 包含枚举当前用户空间下所有窗口的方法。 /// &amp;lt;/summary&amp;gt; public class WindowEnumerator { /// &amp;lt;summary&amp;gt; /// 查找当前用户空间下所有符合条件的窗口。如果不指定条件，将仅查找可见窗口。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;match&quot;&amp;gt;过滤窗口的条件。如果设置为 null，将仅查找可见窗口。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;找到的所有窗口信息。&amp;lt;/returns&amp;gt; public static IReadOnlyList&amp;lt;WindowInfo&amp;gt; FindAll(Predicate&amp;lt;WindowInfo&amp;gt; match = null) { var windowList = new List&amp;lt;WindowInfo&amp;gt;(); EnumWindows(OnWindowEnum, 0); return windowList.FindAll(match ?? DefaultPredicate); bool OnWindowEnum(IntPtr hWnd, int lparam) { // 仅查找顶层窗口。 if (GetParent(hWnd) == IntPtr.Zero) { // 获取窗口类名。 var lpString = new StringBuilder(512); GetClassName(hWnd, lpString, lpString.Capacity); var className = lpString.ToString(); // 获取窗口标题。 var lptrString = new StringBuilder(512); GetWindowText(hWnd, lptrString, lptrString.Capacity); var title = lptrString.ToString().Trim(); // 获取窗口可见性。 var isVisible = IsWindowVisible(hWnd); // 获取窗口位置和尺寸。 LPRECT rect = default; GetWindowRect(hWnd, ref rect); var bounds = new Rectangle(rect.Left, rect.Top, rect.Right - rect.Left, rect.Bottom - rect.Top); // 添加到已找到的窗口列表。 windowList.Add(new WindowInfo(hWnd, className, title, isVisible, bounds)); } return true; } } /// &amp;lt;summary&amp;gt; /// 默认的查找窗口的过滤条件。可见 + 非最小化 + 包含窗口标题。 /// &amp;lt;/summary&amp;gt; private static readonly Predicate&amp;lt;WindowInfo&amp;gt; DefaultPredicate = x =&amp;gt; x.IsVisible &amp;amp;&amp;amp; !x.IsMinimized &amp;amp;&amp;amp; x.Title.Length &amp;gt; 0; private delegate bool WndEnumProc(IntPtr hWnd, int lParam); [DllImport(&quot;user32&quot;)] private static extern bool EnumWindows(WndEnumProc lpEnumFunc, int lParam); [DllImport(&quot;user32&quot;)] private static extern IntPtr GetParent(IntPtr hWnd); [DllImport(&quot;user32&quot;)] private static extern bool IsWindowVisible(IntPtr hWnd); [DllImport(&quot;user32&quot;)] private static extern int GetWindowText(IntPtr hWnd, StringBuilder lptrString, int nMaxCount); [DllImport(&quot;user32&quot;)] private static extern int GetClassName(IntPtr hWnd, StringBuilder lpString, int nMaxCount); [DllImport(&quot;user32&quot;)] private static extern void SwitchToThisWindow(IntPtr hWnd, bool fAltTab); [DllImport(&quot;user32&quot;)] private static extern bool GetWindowRect(IntPtr hWnd, ref LPRECT rect); [StructLayout(LayoutKind.Sequential)] private readonly struct LPRECT { public readonly int Left; public readonly int Top; public readonly int Right; public readonly int Bottom; } } /// &amp;lt;summary&amp;gt; /// 获取 Win32 窗口的一些基本信息。 /// &amp;lt;/summary&amp;gt; public readonly struct WindowInfo { public WindowInfo(IntPtr hWnd, string className, string title, bool isVisible, Rectangle bounds) : this() { Hwnd = hWnd; ClassName = className; Title = title; IsVisible = isVisible; Bounds = bounds; } /// &amp;lt;summary&amp;gt; /// 获取窗口句柄。 /// &amp;lt;/summary&amp;gt; public IntPtr Hwnd { get; } /// &amp;lt;summary&amp;gt; /// 获取窗口类名。 /// &amp;lt;/summary&amp;gt; public string ClassName { get; } /// &amp;lt;summary&amp;gt; /// 获取窗口标题。 /// &amp;lt;/summary&amp;gt; public string Title { get; } /// &amp;lt;summary&amp;gt; /// 获取当前窗口是否可见。 /// &amp;lt;/summary&amp;gt; public bool IsVisible { get; } /// &amp;lt;summary&amp;gt; /// 获取窗口当前的位置和尺寸。 /// &amp;lt;/summary&amp;gt; public Rectangle Bounds { get; } /// &amp;lt;summary&amp;gt; /// 获取窗口当前是否是最小化的。 /// &amp;lt;/summary&amp;gt; public bool IsMinimized =&amp;gt; Bounds.Left == -32000 &amp;amp;&amp;amp; Bounds.Top == -32000; }}" }, { "title": "在 WPF 程序中应用 Windows 10 真•亚克力效果", "url": "/post/using-acrylic-in-wpf-application.html", "categories": "", "tags": "dotnet", "date": "2019-10-10 10:25:11 +0800", "snippet": "从 Windows 10 (1803) 开始，Win32 应用也可以有 API 来实现原生的亚克力效果了。不过相比于 UWP 来说，可定制性会差很多。本文介绍如何在 WPF 程序中应用 Windows 10 真•亚克力效果。（而不是一些流行的项目里面自己绘制的亚克力效果。）API需要使用的 API 是微软的文档中并未公开的 SetWindowCompositionAttribute。我在另一篇博客中有介绍此 API 各种用法的效果，详见： 使用 SetWindowCompositionAttribute 来控制程序的窗口边框和背景（可以做 Acrylic 亚克力效果、模糊效果、主题色效果等） - walterlv当然，使用此 API 也可以做 Windows 10 早期的模糊效果，比如： 在 Windows 10 上为 WPF 窗口添加模糊特效（就像开始菜单和操作中心那样） - walterlv如何使用为了方便地让你的窗口获得亚克力效果，我做了两层不同的 API： AcrylicBrush 当然，受到 Win32 启用亚克力效果的限制，只能在窗口上设置此属性 WindowAccentCompositor 用于更多地控制窗口与系统的叠加组合效果代码请参见： Walterlv.Packages/WindowAccentCompositor.cs at master · walterlv/Walterlv.Packages注意事项要使得亚克力效果可以生效，需要： 设置一个混合色 GradientColor 混合色不能是全透明（如果全透明，窗口的亚克力部分就全透明穿透了），当然也不能全不透明，这样就看不到亚克力效果了。参考资料 winapi - How do you set the glass blend colour on Windows 10? - Stack Overflow" }, { "title": "使用 SetWindowCompositionAttribute 来控制程序的窗口边框和背景（可以做 Acrylic 亚克力效果、模糊效果、主题色效果等）", "url": "/post/set-window-composition-attribute.html", "categories": "", "tags": "windows, csharp, dotnet, wpf", "date": "2019-10-10 08:09:12 +0800", "snippet": "Windows 系统中有一个没什么文档的 API，SetWindowCompositionAttribute，可以允许应用的开发者将自己窗口中的内容渲染与窗口进行组合。这可以实现很多系统中预设的窗口特效，比如 Windows 7 的毛玻璃特效，Windows 8/10 的前景色特效，Windows 10 的模糊特效，以及 Windows 10 1709 的亚克力（Acrylic）特效。而且这些组合都发生在 dwm 进程中，不会额外占用应用程序的渲染性能。本文介绍 SetWindowCompositionAttribute 可以实现的所有效果。你可以通过阅读本文了解到与系统窗口可以组合渲染到哪些程度。试验用的源代码本文将创建一个简单的 WPF 程序来验证 SetWindowCompositionAttribute 能达到的各种效果。你也可以不使用 WPF，得到类似的效果。简单的项目文件结构是这样的： [项目] Walterlv.WindowComposition App.xaml App.xaml.cs MainWindow.xaml MainWindow.xaml.cs WindowAccentCompositor 其中，App.xaml 和 App.xaml.cs 保持默认生成的不动。为了验证此 API 的效果，我需要将 WPF 主窗口的背景色设置为纯透明或者 null，而设置 ControlTemplate 才能彻彻底底确保所有的样式一定是受我们自己控制的，我们在 ControlTemplate 中没有指定任何可以显示的内容。MainWindow.xaml 的全部代码如下：&amp;lt;Window x:Class=&quot;Walterlv.WindowComposition.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; Title=&quot;欢迎访问吕毅的博客：blog.walterlv.com&quot; Height=&quot;450&quot; Width=&quot;800&quot;&amp;gt; &amp;lt;Window.Template&amp;gt; &amp;lt;ControlTemplate TargetType=&quot;Window&quot;&amp;gt; &amp;lt;AdornerDecorator&amp;gt; &amp;lt;ContentPresenter /&amp;gt; &amp;lt;/AdornerDecorator&amp;gt; &amp;lt;/ControlTemplate&amp;gt; &amp;lt;/Window.Template&amp;gt; &amp;lt;!-- 我们注释掉 WindowChrome，是因为即将验证 WindowChrome 带来的影响。 --&amp;gt; &amp;lt;!--&amp;lt;WindowChrome.WindowChrome&amp;gt; &amp;lt;WindowChrome GlassFrameThickness=&quot;-1&quot; /&amp;gt; &amp;lt;/WindowChrome.WindowChrome&amp;gt;--&amp;gt; &amp;lt;Grid&amp;gt; &amp;lt;/Grid&amp;gt;&amp;lt;/Window&amp;gt;而 MainWindow.xaml.cs 中，我们简单调用一下我们即将写的调用 SetWindowCompositionAttribute 的类型。using System.Windows;using System.Windows.Media;using Walterlv.Windows.Effects;namespace Walterlv.WindowComposition{ public partial class MainWindow : Window { public MainWindow() { InitializeComponent(); var compositor = new WindowAccentCompositor(this); compositor.Composite(Color.FromRgb(0x18, 0xa0, 0x5e)); } }}还剩下一个 WindowAccentCompositor.cs 文件，因为比较长放到博客里影响阅读，所以建议前往这里查看： Walterlv.Packages/WindowAccentCompositor.cs at master · walterlv/Walterlv.Packages而其中对我们最终渲染效果有影响的就是 AccentPolicy 类型的几个属性。其中 AccentState 属性是下面这个枚举，而 GradientColor 将决定窗口渲染时叠加的颜色。private enum AccentState{ ACCENT_DISABLED = 0, ACCENT_ENABLE_GRADIENT = 1, ACCENT_ENABLE_TRANSPARENTGRADIENT = 2, ACCENT_ENABLE_BLURBEHIND = 3, ACCENT_ENABLE_ACRYLICBLURBEHIND = 4, ACCENT_INVALID_STATE = 5,}影响因素经过试验，对最终显示效果有影响的有这些： 选择的 AccentState 枚举值 使用的 GradientColor 叠加色 是否使用 WindowChrome 让客户区覆盖非客户区 目标操作系统（Windows 7/8/8.1/10）使用 WindowChrome，你可以用你自己的 UI 覆盖掉系统的 UI 窗口样式。关于 WindowChrome 让客户区覆盖非客户区的知识，可以阅读： [WPF 自定义控件] Window（窗体）的 UI 元素及行为 - dino.c - 博客园需要注意的是，WindowChrome 的 GlassFrameThickness 属性可以设置窗口边框的粗细，设置为 0 将导致窗口没有阴影，设置为负数将使得整个窗口都是边框。排列组合我们依次来看看效果。AccentState=ACCENT_DISABLED使用 ACCENT_DISABLED 时，GradientColor 叠加色没有任何影响，唯一影响渲染的是 WindowChrome 和操作系统。不使用 WindowChrome，在 Windows 10 上：不使用 WindowChrome 在 Windows 7 上：在 Windows 10 上，使用 WindowChrome：&amp;lt;WindowChrome.WindowChrome&amp;gt; &amp;lt;WindowChrome /&amp;gt;&amp;lt;/WindowChrome.WindowChrome&amp;gt;在 Windows 7 上，使用 WindowChrome：当然，以上边框比较细，跟系统不搭，可以设置成其他值：在 Windows 10 上，使用 WindowChrome 并且 GlassFrameThickness 设置为 -1：&amp;lt;WindowChrome.WindowChrome&amp;gt; &amp;lt;WindowChrome GlassFrameThickness=&quot;-1&quot; /&amp;gt;&amp;lt;/WindowChrome.WindowChrome&amp;gt;而在 Windows 7 上，这就是非常绚丽的全窗口的 Aero 毛玻璃特效：AccentState=ACCENT_ENABLE_GRADIENT使用 ACCENT_DISABLED 时，GradientColor 叠加色会影响到最终的渲染效果。还记得我们前面叠加的颜色是什么吗？接下来别忘了然后把它误以为是我系统的主题色哦！不使用 WindowChrome，在 Windows 10 上：另外，你会注意到左、下、右三个方向上边框会深一些。那是 Windows 10 的窗口阴影效果，因为实际上 Windows 10 叠加的阴影也是窗口区域的一部分，只是一般人看不出来而已。我们叠加了颜色之后，这里就露馅儿了。另外，这个颜色并不是我们自己的进程绘制的哦，是 dwm 绘制的颜色。如果不指定 GradientColor 也就是保持为 0，你将看到上面绿色的部分全是黑色的；嗯，包括阴影的部分……不使用 WindowChrome 在 Windows 7 上：可以看出，在 Windows 7 上，GradientColor 被无视了。而使用 WindowChrome 在 Windows 10 上，则可以得到整个窗口的叠加色：&amp;lt;WindowChrome.WindowChrome&amp;gt; &amp;lt;WindowChrome GlassFrameThickness=&quot;16 48 16 16&quot; /&amp;gt;&amp;lt;/WindowChrome.WindowChrome&amp;gt;可以注意到，窗口获得焦点的时候，整个窗口都是叠加色；而窗口失去焦点的时候，指定了边框的部分颜色会更深（换其他颜色叠加可以看出来是叠加了半透明黑色）。如果你希望失去焦点的时候，边框部分不要变深，请将边框设置为 -1：&amp;lt;WindowChrome.WindowChrome&amp;gt; &amp;lt;WindowChrome GlassFrameThickness=&quot;-1&quot; /&amp;gt;&amp;lt;/WindowChrome.WindowChrome&amp;gt;使用 WindowChrome 在 Windows 7 上，依然没有任何叠加色的效果：AccentState=ACCENT_ENABLE_TRANSPARENTGRADIENT使用 ACCENT_ENABLE_TRANSPARENTGRADIENT 时，GradientColor 叠加色没有任何影响，唯一影响渲染的是 WindowChrome 和操作系统。不使用 WindowChrome，在 Windows 10 上：依然左、下、右三个方向上边框会深一些，那是 Windows 10 的窗口阴影效果。不使用 WindowChrome 在 Windows 7 上：GradientColor 也是被无视的，而且效果跟之前一样。使用 WindowChrome 在 Windows 10 上，在获得焦点的时候整个背景是系统主题色；而失去焦点的时候是灰色，但边框部分是深色。依然可以将边框设置为 -1 使得边框不会变深：使用 WindowChrome 在 Windows 7 上，依然是老样子：AccentState=ACCENT_ENABLE_BLURBEHINDACCENT_ENABLE_BLURBEHIND 可以在 Windows 10 上做出模糊效果，就跟 Windows 10 早期版本的模糊效果是一样的。你可以看我之前的一篇博客，那时亚克力效果还没出来： 在 Windows 10 上为 WPF 窗口添加模糊特效（就像开始菜单和操作中心那样） - walterlv使用 ACCENT_ENABLE_BLURBEHIND 时，GradientColor 叠加色没有任何影响，唯一影响渲染的是 WindowChrome 和操作系统。在 Windows 10 上，没有使用 WindowChrome：你可能需要留意一下那个“诡异”的模糊范围，你会发现窗口的阴影外侧也是有模糊的！！！你能忍吗？肯定不能忍，所以还是乖乖使用 WindowChrome 吧！在 Windows 7 上，没有使用 WindowChrome，效果跟其他值一样，依然没有变化：在 Windows 10 上，使用 WindowChrome：使用 WindowChrome 在 Windows 7 上，依然是老样子：AccentState=ACCENT_ENABLE_ACRYLICBLURBEHIND从 Windows 10 (1803) 开始，Win32 程序也能添加亚克力效果了，因为 SetWindowCompositionAttribute 的参数枚举新增了 ACCENT_ENABLE_ACRYLICBLURBEHIND。亚克力效果相信大家不陌生，那么在 Win32 应用程序里面使用的效果是什么呢？不使用 WindowChrome，在 Windows 10 上：咦！等等！这不是跟之前一样吗？嗯，下面就是不同了，亚克力效果支持与半透明的 GradientColor 叠加，所以我们需要将传入的颜色修改为半透明： var compositor = new WindowAccentCompositor(this);-- compositor.Composite(Color.FromRgb(0x18, 0xa0, 0x5e));++ compositor.Composite(Color.FromArgb(0x3f, 0x18, 0xa0, 0x5e));那么如果改为全透明会怎么样呢？不幸的是，完全没有效果！！！ var compositor = new WindowAccentCompositor(this);-- compositor.Composite(Color.FromRgb(0x18, 0xa0, 0x5e));++ compositor.Composite(Color.FromArgb(0x00, 0x18, 0xa0, 0x5e));接下来是使用 WindowChrome 时：&amp;lt;WindowChrome.WindowChrome&amp;gt; &amp;lt;WindowChrome GlassFrameThickness=&quot;16 48 16 16&quot; /&amp;gt;&amp;lt;/WindowChrome.WindowChrome&amp;gt;然而周围有一圈偏白色的渐变是什么呢？那个其实是 WindowChrome 设置的边框白，被亚克力效果模糊后得到的混合效果。所以，如果要获得全窗口的亚克力效果，请将边框设置成比较小的值：&amp;lt;WindowChrome.WindowChrome&amp;gt; &amp;lt;WindowChrome GlassFrameThickness=&quot;0 1 0 0&quot; /&amp;gt;&amp;lt;/WindowChrome.WindowChrome&amp;gt;记得不要像前面的那些效果一样，如果设置成 -1，你将获得纯白色与设置的 Gradient 叠加色的亚克力特效，是个纯色：你可以将叠加色的透明度设置得小一些，这样可以看出叠加的颜色： var compositor = new WindowAccentCompositor(this);-- compositor.Composite(Color.FromRgb(0x18, 0xa0, 0x5e));++ compositor.Composite(Color.FromArgb(0xa0, 0x18, 0xa0, 0x5e));那么可以设置为全透明吗？ var compositor = new WindowAccentCompositor(this);-- compositor.Composite(Color.FromRgb(0x18, 0xa0, 0x5e));++ compositor.Composite(Color.FromArgb(0x00, 0x18, 0xa0, 0x5e));很不幸，最终你会完全看不到亚克力效果，而变成了毫无特效的透明窗口：最上面那根白线，是我面前面设置边框为 0 1 0 0 导致的。如果在这种情况下，将边框设置为 0 会怎样呢？记得前面我们说过的吗，会导致阴影消失哦！呃……你将看到……这个……什么都没有……是不是找到了一条新的背景透明异形窗口的方法？还是省点心吧，亚克力效果在 Win32 应用上的性能还是比较堪忧的……想要背景透明，请参见： WPF 制作高性能的透明背景异形窗口（使用 WindowChrome 而不要使用 AllowsTransparency=True） - walterlv不用考虑 Windows 7，因为大家都知道不支持。实际效果会跟前面的一模一样。AccentState=ACCENT_INVALID_STATE这个值其实不用说了，因为 AccentState 在不同系统中可用的值不同，为了保证向后兼容性，对于新系统中设置的值，旧系统其实就视之为 ACCENT_INVALID_STATE。那么如果系统认为设置的是 ACCENT_INVALID_STATE 会显示成什么样子呢？答案是，与 ACCENT_DISABLED 完全相同。总结由于 Windows 7 上所有的值都是同样的效果，所以下表仅适用于 Windows 10。   效果 ACCENT_DISABLED 黑色（边框为纯白色） ACCENT_ENABLE_GRADIENT GradientColor 颜色（失焦后边框为深色） ACCENT_ENABLE_TRANSPARENTGRADIENT 主题色（失焦后边框为深色） ACCENT_ENABLE_BLURBEHIND 模糊特效（失焦后边框为灰色） ACCENT_ENABLE_ACRYLICBLURBEHIND 与 GradientColor 叠加颜色的亚克力特效 ACCENT_INVALID_STATE 黑色（边框为纯白色） 在以上的特效之下，WindowChrome 可以让客户区覆盖非客户区，或者让整个窗口都获得特效，而不只是标题栏。附源代码请参见 GitHub 地址以获得最新代码。如果不方便访问，那么就看下面的吧。 Walterlv.Packages/WindowAccentCompositor.cs at master · walterlv/Walterlv.Packagesusing System;using System.Runtime.InteropServices;using System.Windows;using System.Windows.Interop;using System.Windows.Media;namespace Walterlv.Windows.Effects{ /// &amp;lt;summary&amp;gt; /// 为窗口提供模糊特效。 /// &amp;lt;/summary&amp;gt; public class WindowAccentCompositor { private readonly Window _window; /// &amp;lt;summary&amp;gt; /// 创建 &amp;lt;see cref=&quot;WindowAccentCompositor&quot;/&amp;gt; 的一个新实例。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;window&quot;&amp;gt;要创建模糊特效的窗口实例。&amp;lt;/param&amp;gt; public WindowAccentCompositor(Window window) =&amp;gt; _window = window ?? throw new ArgumentNullException(nameof(window)); public void Composite(Color color) { Window window = _window; var handle = new WindowInteropHelper(window).EnsureHandle(); var gradientColor = // 组装红色分量。 color.R &amp;lt;&amp;lt; 0 | // 组装绿色分量。 color.G &amp;lt;&amp;lt; 8 | // 组装蓝色分量。 color.B &amp;lt;&amp;lt; 16 | // 组装透明分量。 color.A &amp;lt;&amp;lt; 24; Composite(handle, gradientColor); } private void Composite(IntPtr handle, int color) { // 创建 AccentPolicy 对象。 var accent = new AccentPolicy { AccentState = AccentState.ACCENT_ENABLE_ACRYLICBLURBEHIND, GradientColor = 0, }; // 将托管结构转换为非托管对象。 var accentPolicySize = Marshal.SizeOf(accent); var accentPtr = Marshal.AllocHGlobal(accentPolicySize); Marshal.StructureToPtr(accent, accentPtr, false); // 设置窗口组合特性。 try { // 设置模糊特效。 var data = new WindowCompositionAttributeData { Attribute = WindowCompositionAttribute.WCA_ACCENT_POLICY, SizeOfData = accentPolicySize, Data = accentPtr, }; SetWindowCompositionAttribute(handle, ref data); } finally { // 释放非托管对象。 Marshal.FreeHGlobal(accentPtr); } } [DllImport(&quot;user32.dll&quot;)] private static extern int SetWindowCompositionAttribute(IntPtr hwnd, ref WindowCompositionAttributeData data); private enum AccentState { ACCENT_DISABLED = 0, ACCENT_ENABLE_GRADIENT = 1, ACCENT_ENABLE_TRANSPARENTGRADIENT = 2, ACCENT_ENABLE_BLURBEHIND = 3, ACCENT_ENABLE_ACRYLICBLURBEHIND = 4, ACCENT_INVALID_STATE = 5, } [StructLayout(LayoutKind.Sequential)] private struct AccentPolicy { public AccentState AccentState; public int AccentFlags; public int GradientColor; public int AnimationId; } [StructLayout(LayoutKind.Sequential)] private struct WindowCompositionAttributeData { public WindowCompositionAttribute Attribute; public IntPtr Data; public int SizeOfData; } private enum WindowCompositionAttribute { // 省略其他未使用的字段 WCA_ACCENT_POLICY = 19, // 省略其他未使用的字段 } }}" }, { "title": "使用傲梅分区助手无损合并分区，无损调整分区大小", "url": "/post/expand-or-merge-partition-using-aomei.html", "categories": "", "tags": "windows", "date": "2019-10-07 20:14:24 +0800", "snippet": "Windows 本身就提供了强大的磁盘和分区管理工具，一个是操作简单的“磁盘管理”，一个是功能强大的命令行版的“diskpart”。不过这两个都有一些限制，一是不能影响到系统文件，二是其修改的分区不能被应用程序占用（diskpart 可在下次重启时做到）。另外，系统为了管理工具操作的效率和正确性，也有一些功能没有开放。DiskGenius 是个强大的工具，不过傲梅也很良心。本文介绍使用傲梅分区助手来管理磁盘。下载傲梅分区助手有绿色版、专业版和 PE 版。一般我们选择绿色版就好，如果你要改到系统分区，就需要使用集成了傲梅分区助手的 PE 系统。 下载傲梅分区助手下面是专业版的截图：下面是 PE 版的截图，也是我实际操作分区时截下来的图：不要吐槽为何我用的是古老的 1709 系统，实际上我的系统盘是下面那个 I 盘。不然为什么我会把系统的版本号放到卷标中呢？调整分区大小在 PE 系统中找到傲梅分区助手，然后启动。在需要调整位置和大小的分区上右键点击选择“调整/移动分区”：然后在弹出的详细设置对话框中调整分区的位置和大小。如果是 SSD，建议点击“高级”然后勾选“允许分区对齐以优化SSD或HDD硬盘”，这可以开启 4K 对齐以大幅优化 SSD 的读写性能。最后点击确定。注意这个时候还没有开始执行真正的操作！合并分区合并分区功能可以将你一个磁盘中的多个分区无损合并成一个。选择好将哪个分区合并到哪一个，这时另一个分区中的所有文件会放到目标分区中的一个文件夹里。合并完之后你自己移动好这些文件即可。因为我的分区在合并过程中的操作没有截图，所以只能看到下面这个提前在磁盘管理中的截图：开始执行真正的操作在你设置好你的所有操作之后，点击左上角的“提交”按钮，这可以开始依次执行之前所有设置的磁盘最终状态。在提交界面，你可以看到即将进行的所有操作的简介，以及预计完成这些操作所花的时间。虽然上图只是示例，但我实际将我在下面这篇博客中删除出来的空余空间全部合并在一起，并且还额外合并了两个都需要保留数据的分区。这个过程傲梅的预计时间是 9小时18分，实际上也刚好在 9 个小时左右！ EFI 分区/恢复分区不可删除？你需要使用命令行了（全命令行操作）所以，如果你打算开始进行大量的磁盘调整、对拷或者其他无损分区操作： 请提前准备好大量你不用电脑的时间。 请提前准备好大量你不用电脑的时间。 请提前准备好大量你不用电脑的时间。这是我实际上在 PE 中操作的截图：" }, { "title": "EFI 分区/恢复分区不可删除？你需要使用命令行了（配合鼠标操作）", "url": "/post/delete-efi-partition-that-cannot-be-deleted-1.html", "categories": "", "tags": "windows", "date": "2019-10-07 11:05:02 +0800", "snippet": "Windows 系统在安装的时候，会自动为我们的磁盘划分一个恢复分区和一个 EFI 分区。如果后面不打算再用这些分区的时候，却发现无法删除。本文将提供解决方法。因为误操作会导致数据丢失，所以我将两种不同的解决方法分开成两篇文章以避免干扰： EFI 分区/恢复分区不可删除？你需要使用命令行了（配合鼠标操作） EFI 分区/恢复分区不可删除？你需要使用命令行了（全命令行操作）无法删除看下图，有两种不同类型的无法删除： 有完整菜单只是删除按钮不可用的 EFI 分区； 仅有一个“帮助”菜单的恢复分区。删除方法会略有不同，我会在合适的地方提示你使用正确的方法的。我的磁盘 2 原本包含两个可见分区，一个是图中黑色色块，原来放的是旧操作系统，一个是图中的 D 盘，放大量文件。因为我新买了一个大容量 SSD 专门用来放操作系统，所以原来操作系统所在的磁盘就可以回收与 D 盘合并。然而悲剧的是，中间隔着一个 820MB 的恢复分区，导致我没有办法为 D 分区扩容。更麻烦的是，在磁盘管理中，这三个我不会再使用的恢复分区都不可删除。PS. 吐槽一下，大版本升级一次 Windows 10 竟然会在后面给我多创建一个恢复分区……解决办法在实操之前，你必须清除地知道你每一步在做什么，否则你需要承担丢失数据的后果： 如果你在网上找到一些操作 disk 的命令，请不要相信——因为此命令清除的是整个磁盘而不只是单个分区第一步：打开命令提示符打开开始菜单，输入 cmd 然后回车确定，我们可以打开命令提示符第二步：打开 diskpart在 cmd 中输入 diskpart 然后回车，你会看到一个 UAC 提示弹窗，点击“是”之后会启动一个新的管理员权限启动的命令提示符，这里运行着 Diskpart 程序。第三步：找到要操作的磁盘输入 list disk 回车，我们可以看到自己计算机中所有已经插入的磁盘。DISKPART&amp;gt; list disk 磁盘 ### 状态 大小 可用 Dyn Gpt -------- ------------- ------- ------- --- --- 磁盘 0 联机 238 GB 0 B 磁盘 1 联机 931 GB 2048 KB 磁盘 2 联机 489 GB 199 GB * 磁盘 3 联机 476 GB 1024 KB *请注意，这里看到的是磁盘，而不是平时在“计算机”中看到的分区——每一个磁盘都可以包含一个到多个分区哦！你有两种方法来确认我们即将操作的是哪个磁盘： 前面我们在磁盘管理中看到的那个界面，也就是本文一开始的那张图，可以直接看出我们要删除的分区在“磁盘 2”上。 根据分区的大小去猜，相信分区少的时候你可以猜对。好的，我们知道要操作的是“磁盘 2”，于是我们输入命令 select disk 2（如果你是其他磁盘请换成自己的数字）：DISKPART&amp;gt; select disk 2磁盘 2 现在是所选磁盘。紧接着，我们输入 list partition 列出此磁盘上的所有分区：DISKPART&amp;gt; list partition 分区 ### 类型 大小 偏移量 ------------- ---------------- ------- ------- 分区 1 恢复 499 MB 1024 KB 分区 2 系统 100 MB 500 MB 分区 3 保留 16 MB 600 MB 分区 5 恢复 820 MB 199 GB 分区 6 主要 288 GB 200 GB通过分区，我们也能再次确认我们找到了正确的要操作的磁盘。截至目前，我们还没有对系统进行任何更改，所以你操作错了也不用担心。但接下来你就需要谨慎一些。第 4.1 步：删除分区（仅适用于 EFI 分区）因为我不再将此磁盘用作系统盘，所以里面除了那个 288GB 的数据部分不能动之外，其他系统生成的部分都是需要删除的，所以接下来我需要对分区 1 2 5 都进行一遍以下操作（你的目的不同可能需要删除的分区也不一样）。先选中要操作的分区：DISKPART&amp;gt; select partition 1分区 1 现在是所选分区。然后更改其 ID：DISKPART&amp;gt; SET ID=ebd0a0a2-b9e5-4433-87c0-68b6b72699c7DiskPart 成功设置了分区 ID。然后操作其他的分区。完整的截图如下：这个时候，回到磁盘管理中，F5 刷新，你可以看到原本不可删除的 EFI 分区，现在可以直接使用鼠标删除了。点击一下“删除卷”即可。第 4.2 步：删除分区（适用于所有类型的分区）恢复分区不能使用上面 4.1 中的方法删除，如果你在 4.1 的操作之后还发现存在不可删除的恢复分区，请尝试使用我的另一篇博客： EFI 分区/恢复分区不可删除？你需要使用命令行了（全命令行操作）参考资料 windows10删除EFI分区(绝对安全) - 修炼之路 - CSDN博客 How to Delete EFI System Partition in Windows 10/8.1/8/7/XP/Vista - EaseUS" }, { "title": "EFI 分区/恢复分区不可删除？你需要使用命令行了（全命令行操作）", "url": "/post/delete-efi-partition-that-cannot-be-deleted-2.html", "categories": "", "tags": "windows", "date": "2019-10-07 11:04:58 +0800", "snippet": "Windows 系统在安装的时候，会自动为我们的磁盘划分一个恢复分区和一个 EFI 分区。如果后面不打算再用这些分区的时候，却发现无法删除。本文将提供解决方法。因为误操作会导致数据丢失，所以我将两种不同的解决方法分开成两篇文章以避免干扰： EFI 分区/恢复分区不可删除？你需要使用命令行了（配合鼠标操作） EFI 分区/恢复分区不可删除？你需要使用命令行了（全命令行操作）无法删除看下图，有两种不同类型的无法删除： 有完整菜单只是删除按钮不可用的 EFI 分区； 仅有一个“帮助”菜单的恢复分区。使用本文提供的方法，你可以删除以上两种不同类型的分区。我的磁盘 2 原本包含两个可见分区，一个是图中黑色色块，原来放的是旧操作系统，一个是图中的 D 盘，放大量文件。因为我新买了一个大容量 SSD 专门用来放操作系统，所以原来操作系统所在的磁盘就可以回收与 D 盘合并。然而悲剧的是，中间隔着一个 820MB 的恢复分区，导致我没有办法为 D 分区扩容。更麻烦的是，在磁盘管理中，这三个我不会再使用的恢复分区都不可删除。PS. 吐槽一下，大版本升级一次 Windows 10 竟然会在后面给我多创建一个恢复分区……解决办法在实操之前，你必须清除地知道你每一步在做什么，否则你需要承担丢失数据的后果： 如果你在网上找到一些操作 disk 的命令，请不要相信——因为此命令清除的是整个磁盘而不只是单个分区第一步：打开命令提示符打开开始菜单，输入 cmd 然后回车确定，我们可以打开命令提示符第二步：打开 diskpart在 cmd 中输入 diskpart 然后回车，你会看到一个 UAC 提示弹窗，点击“是”之后会启动一个新的管理员权限启动的命令提示符，这里运行着 Diskpart 程序。第三步：找到要操作的磁盘输入 list disk 回车，我们可以看到自己计算机中所有已经插入的磁盘。DISKPART&amp;gt; list disk 磁盘 ### 状态 大小 可用 Dyn Gpt -------- ------------- ------- ------- --- --- 磁盘 0 联机 238 GB 0 B 磁盘 1 联机 931 GB 2048 KB 磁盘 2 联机 489 GB 199 GB * 磁盘 3 联机 476 GB 1024 KB *请注意，这里看到的是磁盘，而不是平时在“计算机”中看到的分区——每一个磁盘都可以包含一个到多个分区哦！你有两种方法来确认我们即将操作的是哪个磁盘： 前面我们在磁盘管理中看到的那个界面，也就是本文一开始的那张图，可以直接看出我们要删除的分区在“磁盘 2”上。 根据分区的大小去猜，相信分区少的时候你可以猜对。好的，我们知道要操作的是“磁盘 2”，于是我们输入命令 select disk 2（如果你是其他磁盘请换成自己的数字）：DISKPART&amp;gt; select disk 2磁盘 2 现在是所选磁盘。紧接着，我们输入 list partition 列出此磁盘上的所有分区：DISKPART&amp;gt; list partition 分区 ### 类型 大小 偏移量 ------------- ---------------- ------- ------- 分区 1 恢复 499 MB 1024 KB 分区 2 系统 100 MB 500 MB 分区 3 保留 16 MB 600 MB 分区 5 恢复 820 MB 199 GB 分区 6 主要 288 GB 200 GB通过分区，我们也能再次确认我们找到了正确的要操作的磁盘。截至目前，我们还没有对系统进行任何更改，所以你操作错了也不用担心。但接下来你就需要谨慎一些。第四步：删除分区因为我不再将此磁盘用作系统盘，所以里面除了那个 288GB 的数据部分不能动之外，其他系统生成的部分都是需要删除的，所以接下来我需要对分区 1 2 5 都进行一遍以下操作（你的目的不同可能需要删除的分区也不一样）。先选中要操作的分区：DISKPART&amp;gt; select partition 1分区 1 现在是所选分区。然后输入 delete part override 删除这个分区：DISKPART&amp;gt; delete part overrideDiskPart 成功地删除了所选分区。接着，依次删除其他分区。下面是删除其中前两个分区后的截图：所有分区删除完毕之后，可以看到我的整个磁盘现在只剩下我要留下的重要数据分区了。DISKPART&amp;gt; list partition 分区 ### 类型 大小 偏移量 ------------- ---------------- ------- ------- 分区 6 主要 288 GB 200 GB这时回到磁盘管理中，可以看到大量已被删除的未分配的空间连在了一起。可以将我的 D 盘扩展更多空间啦！参考资料 磁盘中出现多个的恢复分区，能否删除？ - 知乎" }, { "title": "推荐几款连字字体，在代码编辑器中启用连字字体（Visual Studio Code）", "url": "/post/use-font-ligatures-for-coding.html", "categories": "", "tags": "windows, vscode, visualstudio, dotnet", "date": "2019-09-27 10:04:33 +0800", "snippet": "启用转为编程设计的连字字体，可以给你的变成带来不一样的体验。连字字体微软随 Windows Terminal 设计了一款新的字体 Cascadia Code，而这是一款连字字体。 microsoft/cascadia-code: This is a fun, new monospaced font that includes programming ligatures and is designed to enhance the modern look and feel of the Windows Terminal.你可以看到，在 Windows Terminal 的终端中，=&amp;gt; == != 符号显示成了更容易理解的连字符号：在 Cascadia Code 发布之前，Fira Code 是一款特别火的连字字体，下面是 Fira Code 连字字体在 Visual Studio Code 中的显示效果：而显示的，其实是下面这一段代码：x =&amp;gt;{ if (x &amp;gt;= 2 || x == 0) { Console.WriteLine(&quot; &amp;gt;=&amp;gt; 欢迎访问吕毅的博客 ~~&amp;gt; blog.walterlv.com&quot;); }}连字字体推荐作为微软的粉丝，当然首推 Cascadia Code！不过我喜欢比较细的字体风格，目前 Cascadia Code 还没有提供细体，因此我可能还需要等一些时间才正式入坑。在这里可以关注 Cascadia Code 的状态： microsoft/cascadia-code: This is a fun, new monospaced font that includes programming ligatures and is designed to enhance the modern look and feel of the Windows Terminal.灵台，你也可以在这里找到其他一些好看的用于编程的连字字体： 8 Best monospace programming fonts with ligatures as of 2019 - Slant相关的开源项目链接： tonsky/FiraCode: Monospaced font with programming ligatures i-tu/Hasklig: Hasklig - a code font with monospaced ligatures be5invis/Iosevka: Slender typeface for code, from code. Victor Mono以 Fira Code 为例安装的话，去它的 GitHub 的 release 页面： Releases · tonsky/FiraCode下载最新的发布文件 FiraCode_1.207.zip。下载解压后，你会看到五个不同的文件夹，这是四种不同的字体类型： otf (Open Type) ttf (True Type) variable_ttf (Variable True Type) woff (Web Open Font Format) woff2 (Web Open Font Format)对于 Open Type 和 True Type 的选择，一般有对应的 Open Type 类型字体的时候就优先选择 Open Type 类型的，因为 True Type 格式是比较早期的，限制比较多，比如字符的数量受到限制，而 Open Type 是基于 Unicode 字符集来设计的新的跨平台的字体格式。Variable True Type 是可以无极变换的 True Type 字体。而 Web Open Font Format 主要为网络传输优化，其特点是字体均经过压缩，其大小会比较小。我们点击进入 otf 文件夹，然后全选所有的字体文件，右键，安装，等待安装完成即可。在编辑器中启用在 Visual Studio Code 中启用在 Visual Studio Code 中启用连字字体需要用到两个选项：&quot;editor.fontFamily&quot;: &quot;Fira Code Light, Consolas, Microsoft YaHei&quot;,&quot;editor.fontLigatures&quot;: true,然后点击新打开的标签右上角的 {} 图标以打开 json 形式编辑的设置：然后修改把上面两个设置增加或替换进去即可。下面是我的设置的部分截图：在 Visual Studio 或其他 Windows 系统自带软件中启用只需要将字体设置成 Fira Code 即可。参考资料 Type is Beautiful » 参数化设计与字体战争：从 OpenType 1.8 说起" }, { "title": "如何在 Visual Studio 2019 中设置使用 .NET Core SDK 的预览版（全局生效）", "url": "/post/how-to-set-dotnet-core-sdk-preview-in-visual-studio.html", "categories": "", "tags": "msbuild, visualstudio, dotnet", "date": "2019-09-24 08:37:39 +0800", "snippet": ".NET Core 3 相比于 .NET Core 2 是一个大更新。也正因为如此，即便它长时间处于预览版尚未发布的状态，大家也一直在使用。Visual Studio 2019 中提供了使用 .NET Core SDK 预览版的开关。但几个更新的版本其开关的位置不同，本文将介绍在各个版本中的位置，方便你找到然后设置。Visual Studio 2019 (16.3 及以上).NET Core 3.0 已经发布，下载地址： Download .NET (Linux, macOS, and Windows)Visual Studio 16.3 与 .NET Core 3.0 正式版同步发布，因此不再需要 .NET Core 3.0 的预览版设置界面。你只需要安装正式版 .NET Core SDK 即可。Visual Studio 2019 (16.2)从 Visual Studio 2019 的 16.2 版本，.NET Core 预览版的设置项的位置在： 工具 -&amp;gt; 选项 环境 -&amp;gt; 预览功能 -&amp;gt; Use previews of the .NET Core SDK (需要 restart)如果你是英文版的 Visual Studio，也可以参考英文版： Tools -&amp;gt; Options Environment -&amp;gt; Preview Features -&amp;gt; Use previews of the .NET Core SDK (requires restart)Visual Studio 2019 (16.1)从 Visual Studio 2019 的 16.1 版本，.NET Core 预览版的设置项的位置在： 工具 -&amp;gt; 选项 环境 -&amp;gt; 预览功能 -&amp;gt; 使用 .NET Core SDK 的预览如果你是英文版的 Visual Studio，也可以参考英文版： Tools -&amp;gt; Options Environment -&amp;gt; Preview Features -&amp;gt; Use previews of the .NET Core SDKVisual Studio 2019 (16.0 和早期预览版)在 Visual Studio 2019 的早期，.NET Core 在设置中是有一个专用的选项的，在这里： 工具 -&amp;gt; 选项 项目和解决方案 -&amp;gt; .NET Core -&amp;gt; 使用 .NET Core SDK 预览版如果你是英文版的 Visual Studio，也可以参考英文版： Tools -&amp;gt; Options Projects and solutions -&amp;gt; .NET Core -&amp;gt; Use previews of the .NET Core SDK关于全局配置Visual Studio 2019 中此对于 .NET Core SDK 的预览版的设置是全局生效的。也就是说，你在 Visual Studio 2019 中进行了此设置，在命令行中使用 MSBuild 或者 dotnet build 命令进行编译也会使用这样的设置项。那么这个全局的设置项在哪个地方呢？是如何全局生效的呢？可以阅读我的其他博客： Visual Studio 2019 中使用 .NET Core 预览版 SDK 的全局配置文件在哪里？ 找出 .NET Core SDK 是否使用预览版的全局配置文件在那里（探索篇）" }, { "title": "WPF 程序如何移动焦点到其他控件", "url": "/post/wpf-move-focus.html", "categories": "", "tags": "wpf, dotnet, csharp", "date": "2019-09-19 11:41:12 +0800", "snippet": "WPF 中可以使用 UIElement.Focus() 将焦点设置到某个特定的控件，也可以使用 TraversalRequest 仅仅移动焦点。本文介绍如何在 WPF 程序中控制控件的焦点。UIElement.Focus仅仅需要在任何一个控件上调用 Focus() 方法即可将焦点设置到这个控件上。但是需要注意，要使 Focus() 能够工作，这个元素必须满足两个条件： Focusable 设置为 true IsVisible 是 trueTraversalRequest如果你并不是将焦点设置到某个特定的控件，而是希望将焦点转移，可以考虑使用 TraversalRequest 类。比如，以下代码是将焦点转移到下一个控件，也就是按下 Tab 键时焦点会去的控件。var traversalRequest = new TraversalRequest(FocusNavigationDirection.Next);// view 是可视化树中的一个控件。view.MoveFocus(traversalRequest);关于逻辑焦点和键盘焦点键盘焦点就是你实际上按键输入和快捷键会生效的焦点，也就是当前正在工作的控件的焦点。而 WPF 有多个焦点范围（Focus Scope），按下 Tab 键切换焦点的时候只会在当前焦点范围切焦点，不会跨范围。那么一旦跨范围切焦点的时候，焦点会去哪里呢？答案是逻辑焦点。每个焦点范围内都有一个逻辑焦点，记录如果这个焦点范围一旦获得焦点后应该在哪个控件获得键盘焦点。比如默认情况下 WPF 每个 Window 就是一个焦点范围，那么每个 Window 中的当前焦点就是逻辑焦点。而一旦这个 Window 激活，那么这个窗口中的逻辑焦点就会成为键盘焦点，另一个窗口当中的逻辑焦点保留，而键盘焦点则丢失。跨窗口/跨进程切换焦点参见我的另一篇博客： WPF 程序如何跨窗口/跨进程设置控件焦点参考资料 winapi - Win32: C++: How do I re-focus on Parent Window after clicking in a child window? - Stack Overflow" }, { "title": "使用 SetParent 制作父子窗口的时候，如何设置子窗口的窗口样式以避免抢走父窗口的焦点", "url": "/post/win32-child-window-style.html", "categories": "", "tags": "windows, wpf, dotnet, csharp", "date": "2019-09-19 10:24:12 +0800", "snippet": "制作传统 Win32 程序以及 Windows Forms 程序的时候，一个用户看起来独立的窗口本就是通过各种父子窗口嵌套完成的，有大量窗口句柄，窗口之间形成父子关系。不过，对于 WPF 程序来说，一个独立的窗口实际上只有一个窗口句柄，窗口内的所有内容都是 WPF 绘制的。如果你不熟悉 Win32 窗口中的父子窗口关系和窗口样式，那么很有可能遇到父子窗口之间“抢夺焦点”的问题，本文介绍如何解决这样的问题。“抢夺焦点”下图中的上下两个部分是两个不同的窗口，他们之间通过 SetParent 建立了父子关系。注意看下面的窗口标题栏，当我在这些不同区域间点击的时候，窗口标题栏在黑色和灰色之间切换：这说明当子窗口获得焦点的时候，父窗口会失去焦点并显示失去焦点的样式。你可以在这篇博客中找到一个简单的例子：解决办法而原因和解决方法仅有一个，就是子窗口需要有一个子窗口的样式。具体来说，子窗口必须要有 WS_CHILD 样式。你可以看看 Spyxx.exe 抓出来的默认普通窗口和子窗口的样式差别：![默认普通窗口]](/static/posts/2019-09-19-10-21-31.png)▲ 默认普通窗口▲ 子窗口参考资料 关于WS_CLIPCHILDREN和WS_CLIPSIBLINGS的理解（个人认为还是相当全面的） - helloj2ee - 博客园" }, { "title": ".NET/C# 利用 Walterlv.WeakEvents 高性能地定义和使用弱事件", "url": "/post/implement-custom-dotnet-weak-event.html", "categories": "", "tags": "dotnet, csharp", "date": "2019-09-18 22:05:55 +0800", "snippet": "弱引用是 .NET 引入的概念，可以用来协助解决内存泄漏问题。然而事件也可能带来内存泄漏问题，是否有弱事件机制可以使用呢？.NET 没有自带的弱事件机制，但其中的一个子集 WPF 带了。然而我们不是什么项目都能引用 WPF 框架类库的。本文介绍 Walterlv.WeakEvents 库来定义和使用弱事件。系列博客： .NET/C# 利用 Walterlv.WeakEvents 高性能地定义和使用弱事件 .NET/C# 利用 Walterlv.WeakEvents 高性能地中转一个自定义的弱事件（可让任意 CLR 事件成为弱事件） .NET 设计一套高性能的弱事件机制下载安装 Walterlv.WeakEvents在你需要做弱事件的项目中安装 NuGet 包： Walterlv.WeakEvents定义弱事件现在，定义弱事件就不能直接写 event EventHandler Bar 了，要像下面这样写：using System;using Walterlv.WeakEvents;namespace Walterlv.Demo{ public class Foo { private readonly WeakEvent&amp;lt;EventArgs&amp;gt; _bar = new WeakEvent&amp;lt;EventArgs&amp;gt;(); public event EventHandler Bar { add =&amp;gt; _bar.Add(value, value.Invoke); remove =&amp;gt; _bar.Remove(value); } private void OnBar() =&amp;gt; _bar.Invoke(this, EventArgs.Empty); }}使用弱事件对于弱事件的使用，就跟以前任何其他正常事件一样了，直接 += 和 -=。这样，如果我有一个 A 类的实例 a，订阅了以上 Foo 的 Bar 事件，那么当 a 脱离作用范围后，将可以被垃圾回收机制回收。而如果不这么做，Foo 将始终保留对 a 实例的引用，这将阻止垃圾回收。" }, { "title": ".NET 设计一套高性能的弱事件机制", "url": "/post/design-a-dotnet-weak-event-relay.html", "categories": "", "tags": "dotnet, csharp", "date": "2019-09-18 21:59:58 +0800", "snippet": "弱引用是 .NET 引入的概念，可以用来协助解决内存泄漏问题。然而事件也可能带来内存泄漏问题，是否有弱事件机制可以使用呢？.NET 没有自带的弱事件机制，但其中的一个子集 WPF 带了。然而我们不是什么项目都能引用 WPF 框架类库的。网上有很多弱事件的 NuGet 包，不过仅仅支持定义事件的时候写成弱事件而不支持让任意事件变成弱事件，并且存在性能问题。本文将设计一套弱事件机制，不止可以让任意一个 CLR 事件成为弱事件，还具有近乎原生事件的性能。系列博客： .NET/C# 利用 Walterlv.WeakEvents 高性能地定义和使用弱事件 .NET/C# 利用 Walterlv.WeakEvents 高性能地中转一个自定义的弱事件（可让任意 CLR 事件成为弱事件） .NET 设计一套高性能的弱事件机制场景与问题本文主要为了设计一套弱事件机制而编写，因此如果你感兴趣，应该已经理解了我试图做什么事情。当然，如果并不理解，可以阅读这个机制的应用篇，里面有具体的应用场景： .NET/C# 利用 Walterlv.WeakEvents 高性能地中转一个自定义的弱事件（可让任意 CLR 事件成为弱事件）现有设计在我进行此设计之前，已有如下种类的弱事件机制： WPF 框架自带的 WeakEventManager 功能非常有限，自己继承实现一个的难度非常高，但具有很高的性能；WPF 绑定等机制的底层实现用到了这个类型。 WPF 框架自带的泛型类 WeakEventManager&amp;lt;TEventSource, TEventArgs&amp;gt; 可以让你更容易地实现一个自己的弱事件，但是性能非常差 使用网上很多的 NuGet 包 下载量较高的几个 NuGet 包我都有研究过其中的源代码，要么有限制必须是定义事件的时候就必须使用弱事件，要么使用反射或其他动态调用方法性能较差 StackOverflow 上关于 Weak Event 的高赞回答 目前还没有找到可以支持将任意事件添加弱事件支持的回答 由于我希望编写的弱事件机制尽可能减少对非预期框架的依赖，而且具有很高的性能，所以我打算自己实现一套。设计原则 支持为任意类型的事件添加弱事件支持，而不只是自己定义新事件的时候可以使用（对标主流 NuGet 包和 StackOverflow 上的回答） 具有很高的性能（对标主流的 NuGet 包和 WPF 泛型版本的 WeakEventManager） 类的使用者只需要编写极少量的代码就能完成（对标 WPF 非泛型版本的 WeakEventManager）这三个原则，从上到下优先级依次降低。要支持所有类型的 CLR 事件，意味着我的设计中必须要能够直接监听到任意事件，而不能所有代码都从我自己编写的代码开始。要有很高的性能，就意味着我几乎不能使用“反射”，也不能使用委托的 DynamicInvoke 方法，还不能生成 IL 代码（首次生成很慢），也不能使用表达式树（首次编译很慢）。那么可以使用的也就只剩下两个了，一个是纯 C#/.NET 带的编译期就能确定执行的代码，另一个是使用 Roslyn 编译期在编译期间进行特殊处理。类的使用者要编写极少量的代码，意味着能够抽取到框架中的代码就尽量抽取到框架中。取名俗话说，一个好的名字是成功的一半。因为我希望为任意 CLR 事件添加弱事件支持，所以其职责有点像“代理、中间人、中继、中转”，对应英文的 Proxy Agent Relay Transfer。最终我选择名称 Relay（中继），因为好听。API 设计对于 API 的设计，我有一个小原则： 如果技术实现很难，那么 API 迁就技术实现；如果技术实现很容易，那么技术迁就 API我总结了好的 API 设计的一些原则： 好的框架需要好的 API 设计 —— API 设计的六个原则 - walterlv不得不说，此类型设计的技术难度还是挺大的。虽然我们知道有 WeakReference&amp;lt;T&amp;gt; 可用，但依然存在很多的技术难点。于是 API 的设计可能要退而求其次优先满足前两个优先级更高的目标。我们期望 API 足够简单，因此在几个备选方案中选择： WeakEventRelay.Subscribe(&quot;Changed&quot;, OnChanged) 使用字符串来表示事件，肯定会用到反射，不可取 WeakEventRelay.Subscribe(o =&amp;gt; o.Changed, OnChanged) 如果使用 Action 来做，会遇到 o.Changed 必须出现在 += 左边的编译错误 如果使用表达式树，也一样会遇到 o.Changed 必须出现在 += 左边的编译错误，同时还会出现少量性能问题 因此，直接一个方法就能完成事件注册是不可能的了，我们改用其他方法——继承自某个基类：internal sealed class FileSystemWatcherWeakEventRelay : WeakEventRelay&amp;lt;FileSystemWatcher&amp;gt;{ public event FileSystemEventHandler Changed { add =&amp;gt; /*实现弱事件订阅*/; remove =&amp;gt; /*实现弱事件注销*/; }}那么实现的难点就都在 add 和 remove 方法里面了。技术实现我们究竟需要哪些信息才可以完成弱事件机制呢？ 事件源（也就是在使用弱事件机制之前最原始的事件引发者，经常以 object sender 的形式出现在你的代码中） 要订阅的事件（比如 FileSystemWatcher.Changed 事件） 新注册的事件处理函数（也就是 add 和 remove 方法中的 value）然而事情并没有那么简单：一在框架通用代码中，我不可能获取到要订阅的事件。因为事件要求只能出现在 += 的左边，不能以任何其他形式使用（包括但不限于通过参数传递，伪装成 Lambda 表达式，伪装成表达式树）。这意味着 o.Changed += OnChanged 这样的事件订阅完全写不出来通用代码（除非牺牲性能）。那么还能怎么做呢？只能将这段写不出来的代码留给业务编写者来编写了。也就是说，类似于 o.Changed += OnChanged 这样的代码只能交给业务开发者来实现。与此同时也注定了 OnChanged 必须由业务开发者编写（因为无法写出通用的高性能的事件处理函数，并且还能在 += 和 -= 的时候保持同一个实例。二我没有办法通过抽象的办法引发一个事件。具体来说，无法在抽象的通用代码中写出 Changed.Invoke(sender, e) 这样代码。因为委托的基类 Delegate MultiCastDelegate 没有 Invoke 方法可以使用，只有耗性能的 DynamicInvoke 方法。各种不同的委托定义虽然可以有相同的参数和返回值类型，但是却不能相互转换，因此我也不能将传入的委托转换成 Action&amp;lt;TSender, TArgs&amp;gt; 这样的通用委托。庆幸的是，C# 提供了将方法组隐式转换委托的方法，可以让两个参数和返回值类型相同的委托隐式转换。但注意，这是隐式转换，没有运行时代码可以高性能地完成这件事情。在 add 和 remove 方法中，value 参数就是使用方传入的事件处理函数，value.Invoke 就是方法组，可以隐式转换为通用的 Action&amp;lt;TSender, TArgs&amp;gt;。这意味着，我们可以将 value.Invoke 传入来以通用的方式调用事件处理函数。但是请特别注意，这会导致新创建委托实例，导致 -= 的时候实例与 += 的时候不一致，无法注销事件。因此，我们除了传入 value.Invoke 之外，还必须传入 value 本身。API 半残品预览internal sealed class FileSystemWatcherWeakEventRelay : WeakEventRelay&amp;lt;FileSystemWatcher&amp;gt;{ public event FileSystemEventHandler Changed { add =&amp;gt; Subscribe(o =&amp;gt; o.Changed += OnChanged, value, value.Invoke); remove =&amp;gt; Unsubscribe(o =&amp;gt; o.Changed -= OnChanged, value); } private void OnChanged(object sender, FileSystemEventArgs e) =&amp;gt; /* 引发弱事件 */;}这已经开始让业务方的代码变得复杂起来了。方案完善我们还需要能够注册、注销和引发弱事件，而这部分就没那么坑了。因为： 我们已经把最坑的 o.Changed += OnChanged，value，value.Invoke 都传进来了； 在类型中定义一个弱事件，目前网上各种主流弱事件 NuGet 包都有实现。我写了一个 WeakEvent&amp;lt;TSender, TArgs&amp;gt; 泛型类专门用来定义弱事件。不过，这让业务方的代码压力更大了：internal sealed class FileSystemWatcherWeakEventRelay : WeakEventRelay&amp;lt;FileSystemWatcher&amp;gt;{ private readonly WeakEvent&amp;lt;FileSystemEventArgs&amp;gt; _changed = new WeakEvent&amp;lt;FileSystemEventArgs&amp;gt;(); public event FileSystemEventHandler Changed { add =&amp;gt; Subscribe(o =&amp;gt; o.Changed += OnChanged, () =&amp;gt; _changed.Add(value, value.Invoke)); remove =&amp;gt; _changed.Remove(value); } private void OnChanged(object sender, FileSystemEventArgs e) =&amp;gt; TryInvoke(_changed, sender, e);}最后，订阅事件所需的实例，我认为最好不要能够让业务方直接能访问。因为弱事件的实现并不简单（看上面如此复杂的公开 API 就知道了），如果能够直接访问，势必带来更复杂的使用问题。所以我仅在部分方法和 Lambda 表达式参数中开放实例。所以，构造函数需要传入事件源。最后的问题最后还留下了一个问题 订阅者现在确实“弱事件”了，但这个“中继”怎么办？可是被强引用了啊？虽然中继的类实例小得多，但这确实依然也是泄漏，因此需要回收。于是我在任何可能执行代码的时机加上了回收检查：如果发现所有订阅者都已经被回收，那么“中继”也就可以被回收了，将注销所有事件源的订阅。（当然要允许重新开始订阅。）所以最后业务方编写的中继代码又多了一些：using System.IO;using Walterlv.WeakEvents;namespace Walterlv.Demo{ internal sealed class FileSystemWatcherWeakEventRelay : WeakEventRelay&amp;lt;FileSystemWatcher&amp;gt; { public FileSystemWatcherWeakEventRelay(FileSystemWatcher eventSource) : base(eventSource) { } private readonly WeakEvent&amp;lt;FileSystemEventArgs&amp;gt; _changed = new WeakEvent&amp;lt;FileSystemEventArgs&amp;gt;(); public event FileSystemEventHandler Changed { add =&amp;gt; Subscribe(o =&amp;gt; o.Changed += OnChanged, () =&amp;gt; _changed.Add(value, value.Invoke)); remove =&amp;gt; _changed.Remove(value); } private void OnChanged(object sender, FileSystemEventArgs e) =&amp;gt; TryInvoke(_changed, sender, e); protected override void OnReferenceLost(FileSystemWatcher source) { source.Changed -= OnChanged; } }}实际使用虽然弱事件中继的代码复杂了点，但是：1 最终用户的使用可是非常简单的：public class WalterlvDemo{ public WalterlvDemo() { _watcher = new FileSystemWatcher(@&quot;D:\\Desktop\\walterlv.demo.md&quot;) { EnableRaisingEvents = true, }; _watcher.Created += OnCreated; _watcher.Changed += OnChanged; _watcher.Renamed += OnRenamed; _watcher.Deleted += OnDeleted; } private readonly FileSystemWatcher _watcher; private void OnCreated(object sender, FileSystemEventArgs e) { } private void OnChanged(object sender, FileSystemEventArgs e) { } private void OnRenamed(object sender, RenamedEventArgs e) { } private void OnDeleted(object sender, FileSystemEventArgs e) { }}2 是在懒得写，我可以加上 Roslyn 编译器生成中继代码的方式，这个我将在不久的将来加入到 Walterlv.WeakEvents 库中。相关源码更具体的使用场景和示例代码，请阅读： .NET/C# 利用 Walterlv.WeakEvents 高性能地中转一个自定义的弱事件（可让任意 CLR 事件成为弱事件）本文所涉及的全部源代码，已在 GitHub 上开源： Walterlv.Packages/src/Utils/Walterlv.WeakEvents at master · walterlv/Walterlv.Packages注意开源协议：参考资料 Weak Event Patterns - Microsoft Docs" }, { "title": ".NET/C# 利用 Walterlv.WeakEvents 高性能地中转一个自定义的弱事件（可让任意 CLR 事件成为弱事件）", "url": "/post/implement-custom-dotnet-weak-event-relay.html", "categories": "", "tags": "dotnet, csharp", "date": "2019-09-18 21:59:52 +0800", "snippet": "弱引用是 .NET 引入的概念，可以用来协助解决内存泄漏问题。然而事件也可能带来内存泄漏问题，是否有弱事件机制可以使用呢？.NET 没有自带的弱事件机制，但其中的一个子集 WPF 带了。然而我们不是什么项目都能引用 WPF 框架类库的。网上有很多弱事件的 NuGet 包，不过仅仅支持定义事件的时候写成弱事件而不支持让任意事件变成弱事件，并且存在性能问题。本文介绍 Walterlv.WeakEvents 库来做弱事件。你可以借此将任何一个 CLR 事件当作弱事件来使用。系列博客： .NET/C# 利用 Walterlv.WeakEvents 高性能地定义和使用弱事件 .NET/C# 利用 Walterlv.WeakEvents 高性能地中转一个自定义的弱事件（可让任意 CLR 事件成为弱事件） .NET 设计一套高性能的弱事件机制场景与问题了解一下场景，你就能知道这是否是适合你的方案。比如我正在使用 FileSystemWatcher 来监听一个文件的改变，我可能会使用到这些事件： Created 在文件被创建时引发 Changed 在文件内容或属性发生改变时引发 Renamed 在文件被重命名时引发 Deleted 在文件被删除时引发更具体一点的代码是这样的：public class WalterlvDemo{ public WalterlvDemo() { _watcher = new FileSystemWatcher(@&quot;D:\\Desktop\\walterlv.demo.md&quot;) { EnableRaisingEvents = true, }; _watcher.Created += OnCreated; _watcher.Changed += OnChanged; _watcher.Renamed += OnRenamed; _watcher.Deleted += OnDeleted; } private readonly FileSystemWatcher _watcher; private void OnCreated(object sender, FileSystemEventArgs e) { } private void OnChanged(object sender, FileSystemEventArgs e) { } private void OnRenamed(object sender, RenamedEventArgs e) { } private void OnDeleted(object sender, FileSystemEventArgs e) { }}private void Foo(){ var demo = new WalterlvDemo(); // 使用 demo // 此方法结束后，demo 将脱离作用域，本应该可以被回收的。}但是，一旦我们这么写，那么我们这个类型 WalterlvDemo 的实例 demo 将无法被回收，因为 FileSystemWatcher 将始终通过事件引用着这个实例。即使你已经不再引用这个类型的任何一个实例，此实例也会被 _watcher 的事件引用着，而 FileSystemWatcher 的实例也因为 EnableRaisingEvents 而一直存在。一个可行的解决办法是调用 FileSystemWatcher 的 Dispose 方法。不过有些时候很难决定到底在什么时机调用 Dispose 合适。现在，我们希望有一种方法，能够在 WalterlvDemo 的实例失去作用域后被回收，最好 FileSystemWatcher 也能够自动被 Dispose 释放掉。如果你试图解决的是类似这样的问题，那么本文就可以帮到你。总结一下： 用到了一个现有的类型（你无法修改它的源代码，本例中是 FileSystemWatcher）； 你无法决定什么时候释放此类型的实例（本例中是不知道什么时候调用 Dispose）； 一旦你监听此类型的事件，将产生内存泄漏，导致你自己类型的实例无法释放（本例中是 demo 变量脱离作用域。）。目前有 WPF 自带的 WeakEventManager 机制，网上也有很多可用的 NuGet 包，但是都有限制： 只能给自己定义的类型引入弱事件机制，不能给现有类型引入弱事件； 要么用反射，要么用 IL 生成代码，性能都不高。而 Walterlv.WeakEvents 除了解决了给任一类型引入弱事件的问题，还具有非常高的性能，几乎跟定义原生事件无异。下载安装 Walterlv.WeakEvents在你需要做弱事件的项目中安装 NuGet 包： Walterlv.WeakEvents编写自定义的弱事件中继现在，我们需要编写一个自定义的弱事件中继类 FileSystemWatcherWeakEventRelay，即专门为 FileSystemWatcher 做的弱事件中继。下面是一个简单点的例子，为其中的 Changed 事件做了一个中继：using System.IO;using Walterlv.WeakEvents;namespace Walterlv.Demo{ internal sealed class FileSystemWatcherWeakEventRelay : WeakEventRelay&amp;lt;FileSystemWatcher&amp;gt; { public FileSystemWatcherWeakEventRelay(FileSystemWatcher eventSource) : base(eventSource) { } private readonly WeakEvent&amp;lt;FileSystemEventArgs&amp;gt; _changed = new WeakEvent&amp;lt;FileSystemEventArgs&amp;gt;(); public event FileSystemEventHandler Changed { add =&amp;gt; Subscribe(o =&amp;gt; o.Changed += OnChanged, () =&amp;gt; _changed.Add(value, value.Invoke)); remove =&amp;gt; _changed.Remove(value); } private void OnChanged(object sender, FileSystemEventArgs e) =&amp;gt; TryInvoke(_changed, sender, e); protected override void OnReferenceLost(FileSystemWatcher source) { source.Changed -= OnChanged; } }}你可能会看到代码有点儿多，但是我向你保证，这是除了采用 Roslyn 编译器技术以外最高性能的方案了。如果你对弱事件的性能有要求，那么还是接受这些代码会比较好。不要紧张，我来一一解释这些代码。另外，如果你不想懂这些代码，就按照模板一个个敲就好了，都是模板化的代码（特别适合使用 Roslyn 编译器生成，我可能接下来就会做这件事情避免你写出这些代码）。 首先，我们定义了一个自定义的弱事件中继 FileSystemWatcherWeakEventRelay，继承自库 Walterlv.WeakEvents 中的 WeakEventRelay&amp;lt;FileSystemWatcher&amp;gt; 类型。带上的泛型参数表明是针对 FileSystemWatcher 类型做弱事件中继。 一个构造函数，将参数传递给基类：public FileSystemWatcherWeakEventRelay(FileSystemWatcher eventSource) : base(eventSource) { }。这个构造函数是可以用 Visual Studio 生成的，快捷键是 Ctrl + . 或者 Alt + Enter（快捷键功效详见：提高使用 Visual Studio 开发效率的键盘快捷键） 定义了一个私有的 WeakEvent&amp;lt;FileSystemEventArgs&amp;gt;，名为 _changed，这个就是弱事件的核心。泛型参数是事件参数的类型（注意，为了极致的性能，这里的泛型参数是事件参数的名称，而不是大多数弱事件框架中提供的事件处理委托类型）。 定义了一个对外公开的事件 public event FileSystemEventHandler Changed。 add 方法固定调用 Subscribe(o =&amp;gt; o.Changed += OnChanged, () =&amp;gt; _changed.Add(value, value.Invoke));。其中 Changed 是 FileSystemWatcher 中的事件，OnChanged 是我们即将定义的事件处理函数，_changed 是前面定义好的弱事件字段，而后面的 value 和 value.Invoke 是固定写法。 remove 方法固定调用弱事件的 Remove 方法，即 _changed.Remove(value);。 编写针对公开事件的事件处理函数 OnChanged，并在里面固定调用 TryInvoke(_changed, sender, e)。 重写 OnReferenceLost 方法，用于在对象已被回收后反注册 FileSystemWatcher 中的事件。希望看了上面这 6 点之后你还能理解这些代码都是在做啥。如果依然不能理解，可以考虑： 参考下面 FileSystemWatcherWeakEventRelay 的完整代码来理解哪些是可变部分哪些是不可变部分，自己替换就好； 等待 Walterlv.WeakEvents 库的作者更新自动生成这段代码的功能。using System.IO;using Walterlv.WeakEvents;namespace Walterlv.Demo{ internal sealed class FileSystemWatcherWeakEventRelay : WeakEventRelay&amp;lt;FileSystemWatcher&amp;gt; { public FileSystemWatcherWeakEventRelay(FileSystemWatcher eventSource) : base(eventSource) { } private readonly WeakEvent&amp;lt;FileSystemEventArgs&amp;gt; _created = new WeakEvent&amp;lt;FileSystemEventArgs&amp;gt;(); private readonly WeakEvent&amp;lt;FileSystemEventArgs&amp;gt; _changed = new WeakEvent&amp;lt;FileSystemEventArgs&amp;gt;(); private readonly WeakEvent&amp;lt;RenamedEventArgs&amp;gt; _renamed = new WeakEvent&amp;lt;RenamedEventArgs&amp;gt;(); private readonly WeakEvent&amp;lt;FileSystemEventArgs&amp;gt; _deleted = new WeakEvent&amp;lt;FileSystemEventArgs&amp;gt;(); public event FileSystemEventHandler Created { add =&amp;gt; Subscribe(o =&amp;gt; o.Created += OnCreated, () =&amp;gt; _created.Add(value, value.Invoke)); remove =&amp;gt; _created.Remove(value); } public event FileSystemEventHandler Changed { add =&amp;gt; Subscribe(o =&amp;gt; o.Changed += OnChanged, () =&amp;gt; _changed.Add(value, value.Invoke)); remove =&amp;gt; _changed.Remove(value); } public event RenamedEventHandler Renamed { add =&amp;gt; Subscribe(o =&amp;gt; o.Renamed += OnRenamed, () =&amp;gt; _renamed.Add(value, value.Invoke)); remove =&amp;gt; _renamed.Remove(value); } public event FileSystemEventHandler Deleted { add =&amp;gt; Subscribe(o =&amp;gt; o.Deleted += OnDeleted, () =&amp;gt; _deleted.Add(value, value.Invoke)); remove =&amp;gt; _deleted.Remove(value); } private void OnCreated(object sender, FileSystemEventArgs e) =&amp;gt; TryInvoke(_created, sender, e); private void OnChanged(object sender, FileSystemEventArgs e) =&amp;gt; TryInvoke(_changed, sender, e); private void OnRenamed(object sender, RenamedEventArgs e) =&amp;gt; TryInvoke(_renamed, sender, e); private void OnDeleted(object sender, FileSystemEventArgs e) =&amp;gt; TryInvoke(_deleted, sender, e); protected override void OnReferenceLost(FileSystemWatcher source) { source.Created -= OnCreated; source.Changed -= OnChanged; source.Renamed -= OnRenamed; source.Deleted -= OnDeleted; source.Dispose(); } }}使用自定义的弱事件中继当你把上面这个自定义的弱事件中继类型写好了之后，使用它就非常简单了，对我们原有的代码改动非常小。 public class WalterlvDemo { public WalterlvDemo() { _watcher = new FileSystemWatcher(@&quot;D:\\Desktop\\walterlv.demo.md&quot;) { EnableRaisingEvents = true, };++ var weakEvent = new FileSystemWatcherWeakEventRelay(_watcher);-- _watcher.Created += OnCreated;-- _watcher.Changed += OnChanged;-- _watcher.Renamed += OnRenamed;-- _watcher.Deleted += OnDeleted;++ weakEvent.Created += OnCreated;++ weakEvent.Changed += OnChanged;++ weakEvent.Renamed += OnRenamed;++ weakEvent.Deleted += OnDeleted; } private readonly FileSystemWatcher _watcher; private void OnCreated(object sender, FileSystemEventArgs e) { } private void OnChanged(object sender, FileSystemEventArgs e) { } private void OnRenamed(object sender, RenamedEventArgs e) { } private void OnDeleted(object sender, FileSystemEventArgs e) { } }最终效果预览我写了一个程序，每 1 秒修改一次文件；每 5 秒回收一次内存。然后使用 FileSystemWatcher 来监视这个文件的改变。可以看到，在回收内存之后，将不会再监视文件的改变。当然，如果你期望一直可以监视改变，当然也不希望用到本文的弱事件。为什么弱事件中继的 API 如此设计？一句话解答：为了高性能！请参见我的另一篇博客： .NET 设计一套高性能的弱事件机制参考资料 Weak Event Patterns - Microsoft Docs" }, { "title": "C#/.NET 中启动进程时所使用的 UseShellExecute 设置为 true 和 false 分别代表什么意思？", "url": "/post/use-shell-execute-in-process-start-info.html", "categories": "", "tags": "dotnet, csharp", "date": "2019-09-17 12:37:17 +0800", "snippet": "在 .NET 中创建进程时，可以传入 ProcessStartInfo 类的一个新实例。在此类型中，有一个 UseShellExecute 属性。本文介绍 UseShellExecute 属性的作用，设为 true 和 false 时，分别有哪些进程启动行为上的差异。本质差异Process.Start 本质上是启动一个新的子进程，不过这个属性的不同，使得启动进程的时候会调用不同的 Windows 的函数。 UseShellExecute = true 调用的是 ShellExecute UseShellExecute = false 调用的是 CreateProcess 当然，如果你知道这两个函数的区别，那你自然也就了解此属性设置为 true 和 false 的区别了。效果差异ShellExecute 的用途是打开程序或者文件或者其他任何能够打开的东西（如网址）。也就是说，你可以在 Process.Start 的时候传入这些： 一个可执行程序（exe） 一个网址 一个 html / mp4 / jpg / docx / enbx 等各种文件 在 PATH 环境变量中的各种程序不过，此方法有一些值得注意的地方： 不支持重定向输入和输出 最终启动了哪个进程可能是不确定的，你可能需要注意潜在的安全风险而 CreateProcess 则会精确查找路径来执行，不支持各种非可执行程序的打开。但是： 支持重定向输入和输出如何选择UseShellExecute 在 .NET Framework 中的的默认值是 true，在 .NET Core 中的默认值是 false。如果有以下需求，那么建议设置此值为 false： 需要明确执行一个已知的程序 需要重定向输入和输出如果你有以下需求，那么建议设置此值为 true 或者保持默认： 需要打开文档、媒体、网页文件等 需要打开 Url 需要打开脚本执行 需要打开计算机上环境变量中路径中的程序参考资料 c# - When do we need to set UseShellExecute to True? - Stack Overflow" }, { "title": ".NET Framework 的 bug？try-catch-when 中如果 when 语句抛出异常，程序将彻底崩溃", "url": "/post/try-catch-when-causes-app-crash.html", "categories": "", "tags": "dotnet, csharp", "date": "2019-09-12 14:58:50 +0800", "snippet": "在 .NET Framework 4.8 中，try-catch-when 中如果 when 语句抛出异常，程序将彻底崩溃。而 .NET Core 3.0 中不会出现这样的问题。本文涉及的 Bug 已经报告给了微软，并且得到了微软的回复。是 .NET Framework 4.8 为了解决一个安全性问题而强行结束了进程。This post is written in multiple languages. Please select yours: 中文 English 官方文档中 when 的行为你可以前往官方文档： 使用用户筛选的异常处理程序 - Microsoft Docs在其中，你可以找到这样一段话： 用户筛选的子句的表达式不受任何限制。 如果在执行用户筛选的表达式期间发生异常，则将放弃该异常，并视筛选表达式的值为 false。 在这种情况下，公共语言运行时继续搜索当前异常的处理程序。即当 when 块中出现异常时，when 表达式将视为值为 false，并且此异常将被忽略。示例程序鉴于官方文档中的描述，我们可以编写一些示例程序来验证这样的行为。using System;using System.IO;namespace Walterlv.Demo.CatchWhenCrash{ internal class Program { private static void Main(string[] args) { try { try { Console.WriteLine(&quot;Try&quot;); throw new FileNotFoundException(); } catch (FileNotFoundException ex) when (ex.FileName.EndsWith(&quot;.png&quot;)) { Console.WriteLine(&quot;Catch 1&quot;); } catch (FileNotFoundException) { Console.WriteLine(&quot;Catch 2&quot;); } } catch (Exception) { Console.WriteLine(&quot;Catch 3&quot;); } Console.WriteLine(&quot;End&quot;); } }}很显然，我们直接 new 出来的 FileNotFoundException 的 FileName 属性会保持为 null。对其解引用会产生 NullReferenceException。很显然代码不应该这么写，但可以用来验证 catch-when 语句的行为。按照官网描述，输出应该为 Try-Catch 2-End。因为 when 中的异常被忽略，因此不会进入到外层的 catch 块中；因为 when 中出现异常导致表达式值视为 false，因此进入了更合适的异常处理块 Catch 2 中。在 .NET Core 3.0 中的行为和 .NET Framework 4.8 中的行为下面两张图分别是这段代码在 .NET Core 3.0 和 .NET Framework 4.8 中的输出：可以注意到，只有 .NET Core 3.0 中的行为符合官方文档的描述，而 .NET Framework 4.8 中甚至连 End 都没有输出！几乎可以确定，程序在 .NET Framework 4.8 中出现了致命的崩溃！如果我们以 Visual Studio 调试启动此程序，可以看到抛出了 CLR 异常：以下是在 Visual Studio 中单步跟踪的步骤：Issue 和行为由于本人金鱼般的记忆力，我竟然给微软报了三次这个 Bug： 给文档的（2019.09.10）：When use the when keyword in a catch expression the app crashes instead of do what the document says · Issue #14338 · dotnet/docs 给框架和 SDK 的（2019.09.12）： When use the when keyword in a catch expression the app crashes instead of do what the document says · Issue #41047 · dotnet/corefx 给运行时的（2019.07.02）：App will crash when using the when keyword in a catch expression · Issue #25534 · dotnet/coreclr此问题是 .NET Framework 4.8 为了修复一个安全性问题才强行结束了进程： Process corrupting exceptions in exception filter (like access violation) now result in aborting the current process. [110375, clr.dll, Bug, Build:3694]请参见： dotnet/dotnet48-changes.md at master · microsoft/dotnet" }, { "title": "如何在 WPF 中获取所有已经显式赋过值的依赖项属性", "url": "/post/wpf-get-local-value-enumerator.html", "categories": "", "tags": "wpf, dotnet, csharp", "date": "2019-09-12 11:39:49 +0800", "snippet": "获取 WPF 的依赖项属性的值时，会依照优先级去各个级别获取。这样，无论你什么时候去获取依赖项属性，都至少是有一个有效值的。有什么方法可以获取哪些属性被显式赋值过呢？如果是 CLR 属性，我们可以自己写判断条件，然而依赖项属性没有自己写判断条件的地方。本文介绍如何获取以及显式赋值过的依赖项属性。需要用到 DependencyObject.GetLocalValueEnumerator() 方法来获得一个可以遍历所有依赖项属性本地值。public static void DoWhatYouLikeByWalterlv(DependencyObject dependencyObject){ var enumerator = dependencyObject.GetLocalValueEnumerator(); while (enumerator.MoveNext()) { var entry = enumerator.Current; var property = entry.Property; var value = entry.Value; // 在这里使用 property 和 value。 }}这里的 value 可能是 MarkupExtension 可能是 BindingExpression 还可能是其他一些可能延迟计算值的提供者。因此，你不能在这里获取到常规方法获取到的依赖项属性的真实类型的值。但是，此枚举拿到的所有依赖项属性的值都是此依赖对象已经赋值过的依赖项属性的本地值。如果没有赋值过，将不会在这里的遍历中出现。参考资料 Dependency properties overview - Microsoft Docs" }, { "title": "在 WPF 中获取一个依赖对象的所有依赖项属性", "url": "/post/wpf-get-all-dependency-properties.html", "categories": "", "tags": "wpf, dotnet, csharp", "date": "2019-09-12 11:24:33 +0800", "snippet": "本文介绍如何在 WPF 中获取一个依赖对象的所有依赖项属性。通过 WPF 标记获取public static IEnumerable&amp;lt;DependencyProperty&amp;gt; EnumerateDependencyProperties(object element){ if (element is null) { throw new ArgumentNullException(nameof(element)); } MarkupObject markupObject = MarkupWriter.GetMarkupObjectFor(element); if (markupObject != null) { foreach (MarkupProperty mp in markupObject.Properties) { if (mp.DependencyProperty != null) { yield return mp.DependencyProperty; } } }}public static IEnumerable&amp;lt;DependencyProperty&amp;gt; EnumerateAttachedProperties(object element){ if (element is null) { throw new ArgumentNullException(nameof(element)); } MarkupObject markupObject = MarkupWriter.GetMarkupObjectFor(element); if (markupObject != null) { foreach (MarkupProperty mp in markupObject.Properties) { if (mp.IsAttached) { yield return mp.DependencyProperty; } } }}通过设计器专用方法获取本来 .NET 中提供了一些专供设计器使用的类型 TypeDescriptor 可以帮助设计器找到一个类型或者组件的所有可以设置的属性，不过我们也可以通过此方法来获取所有可供使用的属性。下面是带有重载的两个方法，一个传入类型一个传入实例。/// &amp;lt;summary&amp;gt;/// 获取一个对象中所有的依赖项属性。/// &amp;lt;/summary&amp;gt;public static IEnumerable&amp;lt;DependencyProperty&amp;gt; GetDependencyProperties(object instance) =&amp;gt; TypeDescriptor.GetProperties(instance, new Attribute[] { new PropertyFilterAttribute(PropertyFilterOptions.All) }) .OfType&amp;lt;PropertyDescriptor&amp;gt;() .Select(x =&amp;gt; DependencyPropertyDescriptor.FromProperty(x)?.DependencyProperty) .Where(x =&amp;gt; x != null);/// &amp;lt;summary&amp;gt;/// 获取一个类型中所有的依赖项属性。/// &amp;lt;/summary&amp;gt;public static IEnumerable&amp;lt;DependencyProperty&amp;gt; GetDependencyProperties(Type type) =&amp;gt; TypeDescriptor.GetProperties(type, new Attribute[] { new PropertyFilterAttribute(PropertyFilterOptions.All) }) .OfType&amp;lt;PropertyDescriptor&amp;gt;() .Select(x =&amp;gt; DependencyPropertyDescriptor.FromProperty(x)?.DependencyProperty) .Where(x =&amp;gt; x != null);参考资料 wpf - How to enumerate all dependency properties of control? - Stack Overflow Getting list of all dependency/attached properties of an Object" }, { "title": "临时编写和调试 C++ 代码？用 VSCode 就够了！一分钟搭好 C++ 调试环境", "url": "/post/temperarly-debug-cpp-in-vscode.html", "categories": "", "tags": "cpp, vscode", "date": "2019-09-07 10:07:36 +0800", "snippet": "突然间要编写或者调试几个 C++ 的小程序，动用 Visual Studio 创建一个解决方案显得大了些。如果能够利用随时随地就方便打开的 Visual Studio Code 来开发，则清爽很多。本文教你一分钟在 Visual Studio Code 中搭建好 C++ 开发环境。本文大纲本文总共分为三个步骤，每个步骤都非常简单。第一步：安装扩展你需要在 Visual Studio Code 中安装 C/C++ 扩展。第二步：启动 VSCode注意，安装完成后，要通过 Visual Studio 自带的 Developer Command Prompt for VS 2019 来启动 Visual Studio Code。这样才可以获得 Visual Studio 2019 自带的各种编译工具路径的环境变量。Visual Studio Code 就可以无缝使用 Visual Studio 2019 附带的那些工具。然后，在新启动的命令行工具中启动 Visual Studio Code。输入 code 即可启动：&amp;gt; code如果已有线程的路径，可以带上路径的命令行参数：&amp;gt; code C:\\Users\\lvyi\\Desktop\\Walterlv.CppDemo第三步：F5 运行随便在目录中新建一个文件，写上 C++ 代码。比如在 example.cpp 文件中写上如下代码：#include&amp;lt;iostream&amp;gt;using namespace std;int main(){ cout&amp;lt;&amp;lt;&quot;welcome to blog.walterlv.com&quot;; return 0;}按下 F5，选择对应的 C++ 编译平台（我这里选择 C++ (Windows)），然后选择 cl.exe build and debug active file。cl.exe build and debug active file 的目的是调试当前激活的文件，这样的调试方式在 python/java 等语言中大家屡见不鲜，好处是对于小型代码调试起来非常简单直接。接下来 Visual Studio Code 就会生成一些调试所需的配置文件。再次按下 F5，Visual Studio Code 会提示没有编译任务，点击 Configure Task，随后选择 C/C++: cl.exe build active file。接下来 Visual Studio Code 就会生成一些编译所需的配置文件。再次按下 F5 就可以直接编译 example.cpp 文件然后运行调试了。输出在 Debug Console 里面：其他注意事项如果你给 Visual Studio 设置了非默认的终端，那么需要注意： 应该使用 PowerShell 系列的终端（例如 pwsh）不能使用 bash 系列的终端。因为 Windows 下工具使用的路径格式是反斜杠 \\，而 bash 系列终端使用的路径是斜杠 /。如果使用 bash 终端，编译工具会因为路径问题导致编译失败。另外，不要怪我说我是这么编写教程的： 首先，我们已知 1+1=2 于是可以推导出……" }, { "title": "在使用 .NET Remoting 技术开发跨进程通信时可能遇到的各种异常", "url": "/post/dotnet-remoting-exceptions.html", "categories": "", "tags": "dotnet", "date": "2019-09-05 21:26:31 +0800", "snippet": "在使用 .NET Remoting 开发跨进程应用的时候，你可能会遇到一些异常。因为这些异常在后验的时候非常简单但在一开始有各种异常烦扰的时候却并不清晰，所以我将这些异常整理到此文中，方便小伙伴们通过搜索引擎查阅。连接到 IPC 端口失败: 系统找不到指定的文件 System.Runtime.Remoting.RemotingException:“连接到 IPC 端口失败: 系统找不到指定的文件。”或者英文版： System.Runtime.Remoting.RemotingException: Failed to connect to an IPC Port: The system cannot find the file specified.出现此异常时，说明你获取到了一个远端对象，但是在使用此对象的时候，甚至还没有注册 IPC 端口。比如，下面的代码是注册一个 IPC 端口的一种比较粗暴的写法，传入的 portName 是 IPC 的 Uri 路径前缀。例如我可以传入 walterlv，这样一个 IPC 对象的格式大约类似 ipc://walterlv/xxx。private static void RegisterChannel(string portName){ var serverProvider = new BinaryServerFormatterSinkProvider { TypeFilterLevel = TypeFilterLevel.Full, }; var clientProvider = new BinaryClientFormatterSinkProvider(); var properties = new Hashtable { [&quot;portName&quot;] = portName }; var channel = new IpcChannel(properties, clientProvider, serverProvider); ChannelServices.RegisterChannel(channel, false);}当试图访问 ipc://walterlv/foo 对象并调用其中的方法的时候，如果连 walterlv 端口都没有注册，就会出现 连接到 IPC 端口失败: 系统找不到指定的文件。 异常。如果你已经注册了 walterlv 端口，但是没有 foo 对象，则会出现另一个错误 找不到请求的服务，请看下一节。找不到请求的服务 System.Runtime.Remoting.RemotingException:“找不到请求的服务”或者英文版： System.Runtime.Remoting.RemotingException: Requested Service not found当出现此异常时，可能的原因有三个： 要查找的远端对象尚未创建； 要查找的远端对象已被回收； 没有使用匹配的方法创建和访问对象。更具体来说，对于第一种情况，就是当你试图跨进程访问某对象的时候，此对象还没有创建。你需要做的，是控制好对象创建的时机，创建对象的进程需要比访问它的进程更早完成对象的创建和封送。也就是下面的代码需要先调用。RemotingServices.Marshal(@object, typeof(TObject).Name, typeof(TObject));而对于第二种情况，你可能需要手动处理好封送对象的生命周期。重写 InitializeLifetimeService 方法并返回 null 是一个很偷懒却有效的方法。namespace Walterlv.Remoting.Framework{ public abstract class RemoteObject : MarshalByRefObject { public sealed override object InitializeLifetimeService() =&amp;gt; null; }}而对于第三种情况，你需要检查你是如何注册 .NET Remoting 通道的，创建和访问方式必须匹配。信道“ipc”已注册 System.Runtime.Remoting.RemotingException:“信道“ipc”已注册。”在同一个进程中，IpcChannel 类的默认信道名称 IpcChannel.ChannelName 值是字符串 &quot;ipc&quot;。如果你不通过它的参数 properties 来指定 [&quot;name&quot;] = &quot;另一个名称&quot;，那么你就不能重复调用 ChannelServices.RegisterChannel 来调用这个信道。说简单点，就是上面的方法 RegisterChannel 你不能在一个进程中调用两次，即便 &quot;portName&quot; 不同也不行。通常你也不需要去调用两次，如果一定要，请通过 HashTable 修改 name 属性。参考资料 c# - .Net remoting error “Requested Service not found” - Stack Overflow" }, { "title": ".NET/C# 阻止屏幕关闭，阻止系统进入睡眠状态", "url": "/post/set-thread-execution-state.html", "categories": "", "tags": "dotnet, csharp, windows", "date": "2019-09-05 14:49:41 +0800", "snippet": "在 Windows 系统中，一段时间不操作键盘和鼠标，屏幕便会关闭，系统会进入睡眠状态。但有些程序（比如游戏、视频和演示文稿）在运行过程中应该阻止屏幕关闭，否则屏幕总是关闭，会导致体验会非常糟糕。本文介绍如何编写 .NET/C# 代码临时阻止屏幕关闭以及系统进入睡眠状态。Windows API我们需要使用到一个 Windows API：/// &amp;lt;summary&amp;gt;/// Enables an application to inform the system that it is in use, thereby preventing the system from entering sleep or turning off the display while the application is running./// &amp;lt;/summary&amp;gt;[DllImport(&quot;kernel32&quot;)]private static extern ExecutionState SetThreadExecutionState(ExecutionState esFlags);使用到的枚举用 C# 类型定义是：[Flags]private enum ExecutionState : uint{ /// &amp;lt;summary&amp;gt; /// Forces the system to be in the working state by resetting the system idle timer. /// &amp;lt;/summary&amp;gt; SystemRequired = 0x01, /// &amp;lt;summary&amp;gt; /// Forces the display to be on by resetting the display idle timer. /// &amp;lt;/summary&amp;gt; DisplayRequired = 0x02, /// &amp;lt;summary&amp;gt; /// This value is not supported. If &amp;lt;see cref=&quot;UserPresent&quot;/&amp;gt; is combined with other esFlags values, the call will fail and none of the specified states will be set. /// &amp;lt;/summary&amp;gt; [Obsolete(&quot;This value is not supported.&quot;)] UserPresent = 0x04, /// &amp;lt;summary&amp;gt; /// Enables away mode. This value must be specified with &amp;lt;see cref=&quot;Continuous&quot;/&amp;gt;. /// &amp;lt;para /&amp;gt; /// Away mode should be used only by media-recording and media-distribution applications that must perform critical background processing on desktop computers while the computer appears to be sleeping. /// &amp;lt;/summary&amp;gt; AwaymodeRequired = 0x40, /// &amp;lt;summary&amp;gt; /// Informs the system that the state being set should remain in effect until the next call that uses &amp;lt;see cref=&quot;Continuous&quot;/&amp;gt; and one of the other state flags is cleared. /// &amp;lt;/summary&amp;gt; Continuous = 0x80000000,}以上所有的注释均照抄自微软的官方 API 文档： SetThreadExecutionState function (winbase.h) - Microsoft DocsAPI 封装如果你擅长阅读英文，那么以上的 API 函数、枚举和注释足够你完成你的任务了。不过，我这里提供一些封装，以应对一些常用的场景。using System;using System.Runtime.InteropServices;namespace Walterlv.Windows{ /// &amp;lt;summary&amp;gt; /// 包含控制屏幕关闭以及系统休眠相关的方法。 /// &amp;lt;/summary&amp;gt; public static class SystemSleep { /// &amp;lt;summary&amp;gt; /// 设置此线程此时开始一直将处于运行状态，此时计算机不应该进入睡眠状态。 /// 此线程退出后，设置将失效。 /// 如果需要恢复，请调用 &amp;lt;see cref=&quot;RestoreForCurrentThread&quot;/&amp;gt; 方法。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;keepDisplayOn&quot;&amp;gt; /// 表示是否应该同时保持屏幕不关闭。 /// 对于游戏、视频和演示相关的任务需要保持屏幕不关闭；而对于后台服务、下载和监控等任务则不需要。 /// &amp;lt;/param&amp;gt; public static void PreventForCurrentThread(bool keepDisplayOn = true) { SetThreadExecutionState(keepDisplayOn ? ExecutionState.Continuous | ExecutionState.SystemRequired | ExecutionState.DisplayRequired : ExecutionState.Continuous | ExecutionState.SystemRequired); } /// &amp;lt;summary&amp;gt; /// 恢复此线程的运行状态，操作系统现在可以正常进入睡眠状态和关闭屏幕。 /// &amp;lt;/summary&amp;gt; public static void RestoreForCurrentThread() { SetThreadExecutionState(ExecutionState.Continuous); } /// &amp;lt;summary&amp;gt; /// 重置系统睡眠或者关闭屏幕的计时器，这样系统睡眠或者屏幕能够继续持续工作设定的超时时间。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;keepDisplayOn&quot;&amp;gt; /// 表示是否应该同时保持屏幕不关闭。 /// 对于游戏、视频和演示相关的任务需要保持屏幕不关闭；而对于后台服务、下载和监控等任务则不需要。 /// &amp;lt;/param&amp;gt; public static void ResetIdle(bool keepDisplayOn = true) { SetThreadExecutionState(keepDisplayOn ? ExecutionState.SystemRequired | ExecutionState.DisplayRequired : ExecutionState.SystemRequired); } }}如果你对这段封装中的 keepDisplayOn 参数，也就是 ExecutionState.DisplayRequired 枚举不了解，看看下图直接就懂了。一个指的是屏幕关闭，一个指的是系统进入睡眠。此封装后，使用则相当简单：// 阻止系统睡眠，阻止屏幕关闭。SystemSleep.PreventForCurrentThread();// 恢复此线程曾经阻止的系统休眠和屏幕关闭。SystemSleep.RestoreForCurrentThread();或者：// 重置系统计时器，临时性阻止系统睡眠和屏幕关闭。// 此效果类似于手动使用鼠标或键盘控制了一下电脑。SystemSleep.ResetIdle();在使用 PreventForCurrentThread 这个 API 的时候，你需要避免程序对空闲时机的控制不好，导致屏幕始终不关闭。如果你发现无论你设置了多么短的睡眠时间和屏幕关闭时间，屏幕都不会关闭，那就是有某个程序阻止了屏幕关闭，你可以： 查看有哪些程序会一直保持屏幕处于打开状态 找到是谁持续唤醒了计算机屏幕参考资料 SetThreadExecutionState function (winbase.h) - Microsoft Docs" }, { "title": "WPF 不要给 Window 类设置变换矩阵（分析篇）：System.InvalidOperationException: 转换不可逆。", "url": "/post/analyze-matrix-invert-exception-for-wpf-window.html", "categories": "", "tags": "wpf, dotnet, csharp", "date": "2019-09-02 14:13:35 +0800", "snippet": "最近总是收到一个异常 “System.InvalidOperationException: 转换不可逆。”，然而看其堆栈，一点点自己写的代码都没有。到底哪里除了问题呢？虽然异常堆栈信息里面没有自己编写的代码，但是我们还是找到了问题的原因和解决方法。异常堆栈这就是抓到的此问题的异常堆栈：System.InvalidOperationException: 转换不可逆。 在 System.Windows.Media.Matrix.Invert() 在 MS.Internal.PointUtil.TryApplyVisualTransform(Point point, Visual v, Boolean inverse, Boolean throwOnError, Boolean&amp;amp; success) 在 MS.Internal.PointUtil.TryClientToRoot(Point point, PresentationSource presentationSource, Boolean throwOnError, Boolean&amp;amp; success) 在 System.Windows.Input.MouseDevice.LocalHitTest(Boolean clientUnits, Point pt, PresentationSource inputSource, IInputElement&amp;amp; enabledHit, IInputElement&amp;amp; originalHit) 在 System.Windows.Input.MouseDevice.GlobalHitTest(Boolean clientUnits, Point pt, PresentationSource inputSource, IInputElement&amp;amp; enabledHit, IInputElement&amp;amp; originalHit) 在 System.Windows.Input.StylusWisp.WispStylusDevice.FindTarget(PresentationSource inputSource, Point position) 在 System.Windows.Input.StylusWisp.WispLogic.PreNotifyInput(Object sender, NotifyInputEventArgs e) 在 System.Windows.Input.InputManager.ProcessStagingArea() 在 System.Windows.Input.InputManager.ProcessInput(InputEventArgs input) 在 System.Windows.Input.StylusWisp.WispLogic.InputManagerProcessInput(Object oInput) 在 System.Windows.Threading.ExceptionWrapper.InternalRealCall(Delegate callback, Object args, Int32 numArgs) 在 System.Windows.Threading.ExceptionWrapper.TryCatchWhen(Object source, Delegate callback, Object args, Int32 numArgs, Delegate catchHandler)可以看到，我们的堆栈结束点是 ExceptionWrapper.TryCatchWhen 可以得知此异常是通过 Dispatcher.UnhandledException 来捕获的。也就是说，此异常直接通过 Windows 消息被我们间接触发，而不是直接通过我们编写的代码触发。而最顶端是对矩阵求逆，而此异常是试图对一个不可逆的矩阵求逆。分析过程如果你不想看分析过程，可以直接移步至本文的最后一节看原因和解决方案。源代码因为 .NET Framework 版本的 WPF 是开源的，.NET Core 版本的 WPF 目前还处于按揭开源的状态，所以我们看 .NET Framework 版本的代码来分析原因。我按照调用堆栈从顶到底的顺序，将前面三帧的代码贴到下面。PointUtil.TryApplyVisualTransformpublic static Point TryApplyVisualTransform(Point point, Visual v, bool inverse, bool throwOnError, out bool success){ success = true; if(v != null) { Matrix m = GetVisualTransform(v); if (inverse) { if(throwOnError || m.HasInverse) { m.Invert(); } else { success = false; return new Point(0,0); } } point = m.Transform(point); } return point;}PointUtil.TryClientToRoot[SecurityCritical,SecurityTreatAsSafe]public static Point TryClientToRoot(Point point, PresentationSource presentationSource, bool throwOnError, out bool success){ if (throwOnError || (presentationSource != null &amp;amp;&amp;amp; presentationSource.CompositionTarget != null &amp;amp;&amp;amp; !presentationSource.CompositionTarget.IsDisposed)) { point = presentationSource.CompositionTarget.TransformFromDevice.Transform(point); point = TryApplyVisualTransform(point, presentationSource.RootVisual, true, throwOnError, out success); } else { success = false; return new Point(0,0); } return point;}你可能会说，在调用堆栈上面看不到 PointUtil.ClientToRoot 方法。但其实如果我们看一看 MouseDevice.LocalHitTest 的代码，会发现其实调用的是 PointUtil.ClientToRoot 方法。在调用堆栈上面看不到它是因为方法足够简单，被内联了。[SecurityCritical,SecurityTreatAsSafe]public static Point ClientToRoot(Point point, PresentationSource presentationSource){ bool success = true; return TryClientToRoot(point, presentationSource, true, out success);}求逆的矩阵下面我们一步一步分析异常的原因。我们先看看是什么代码在做矩阵求逆。下面截图中的方法是反编译的，就是上面我们在源代码中列出的 TryApplyVisualTransform 方法。先获取了传入 Visual 对象的变换矩阵，然后根据参数 inverse 来对其求逆。如果矩阵可以求逆，即 HasInverse 属性返回 true，那么代码可以继续执行下去而不会出现异常。但如果 HasInverse 返回 false，则根据 throwOnError 来决定是否抛出异常，在需要抛出异常的情况下会真实求逆，也就是上面截图中我们看到的异常发生处的代码。那么接下来我们需要验证三点： 这个 Visual 是哪里来的； 这个 Visual 的变换矩阵什么情况下不可求逆； throwOnError 确定传入的是 true 吗。于是我们继续往上层调用代码中查看。可以很快验证上面需要验证的两个点： throwOnError 传入的是 true； Visual 是 PresentationSource 的 RootVisual。而 PresentationSource 的 RootVisual 是什么呢？PresentationSource 是承载 WPF 可视化树的一个对象，对于窗口 Window，是通过 HwndSource（PresentationSource 的子类）承载的；对于跨线程 WPF UI，可以通过自定义的 PresentationSource 子类来完成。这部分可以参考我之前的一些博客： WPF 同一窗口内的多线程 UI（VisualTarget） WPF 同一窗口内的多线程/多进程 UI（使用 SetParent 嵌入另一个窗口） WPF 多线程 UI：设计一个异步加载 UI 的容器 WPF 获取元素（Visual）相对于屏幕设备的缩放比例，可用于清晰显示图片不管怎么说，这个指的就是 WPF 可视化树的根： 如果你使用 Window 来显示 WPF 窗口，那么根就是 Window 类； 如果你是用 Popup 来承载一个弹出框，那么根就是 PopupRoot 类； 如果你使用了一些跨线程/跨进程 UI 的技术，那么根就是自己写的可视化树根元素。对于绝大多数 WPF 开发者来说，只会碰到前面第一种情况，也就是仅仅有 Window 作为可视化树的根的情况。一般人很难直接给 PopupRoot 设置变换矩阵，一般 WPF 程序的代码也很少做跨线程或跨进程 UI。于是我们几乎可以肯定，是有某处的代码让 Window 的变换矩阵不可逆了。矩阵求逆什么样的矩阵是不可逆的？异常代码发生异常的代码是 WPF 中 Matrix.Invert 方法，其发生异常的代码如下：首先判断矩阵的行列式 Determinant 是否为 0，如果为 0 则抛出矩阵不可逆的异常。行列式WPF 的 2D 变换矩阵 \\(M\\) 是一个 \\(3\\times{3}\\) 的矩阵：\\[\\begin{bmatrix}M11 &amp;amp; M12 &amp;amp; 0 \\\\M21 &amp;amp; M22 &amp;amp; 0 \\\\OffsetX &amp;amp; OffsetY &amp;amp; 1\\end{bmatrix}\\]其行列式 \\(det(M)\\) 是一个标量：\\[\\left | A \\right | =\\begin{vmatrix}M11 &amp;amp; M12 &amp;amp; 0 \\\\M21 &amp;amp; M22 &amp;amp; 0 \\\\OffsetX &amp;amp; OffsetY &amp;amp; 1\\end{vmatrix}= M11 \\times M22 - M12 \\times M21\\]因为矩阵求逆的时候，行列式的值会作为分母，于是会无法计算，所以行列式的值为 0 时，矩阵不可逆。前面我们计算 WPF 的 2D 变换矩阵的行列式的值为 \\(M11 \\times M22 - M12 \\times M21\\)，因此，只要使这个式子的值为 0 即可。那么 WPF 的 2D 变换的时候，如何使此值为 0 呢？ 平移？平移只会修改 \\(OffsetX\\) 和 \\(OffsetY\\)，因此对结果没有影响 缩放？缩放会将原矩阵点乘缩放矩阵 旋转？旋转会将旋转矩阵点乘原矩阵其中，原矩阵在我们的场景下就是恒等的矩阵，即 Matrix.Identity：\\[\\begin{bmatrix}1 &amp;amp; 0 &amp;amp; 0 \\\\0 &amp;amp; 1 &amp;amp; 0 \\\\0 &amp;amp; 0 &amp;amp; 1\\end{bmatrix}\\]接下来缩放和旋转我们都不考虑变换中心的问题，因为变换中心的问题都可以等价为先进行缩放和旋转后，再单纯进行平移。由于平移对行列式的值没有影响，于是我们忽略。缩放矩阵缩放矩阵。如果水平和垂直分量分别缩放 \\(ScaleX\\) 和 \\(ScaleY\\) 倍，则缩放矩阵为：\\[\\begin{bmatrix}ScaleX &amp;amp; 0 &amp;amp; 0 \\\\0 &amp;amp; ScaleY &amp;amp; 0 \\\\0 &amp;amp; 0 &amp;amp; 1\\end{bmatrix}\\]原矩阵点乘缩放矩阵结果为：\\[\\begin{bmatrix}1 &amp;amp; 0 &amp;amp; 0 \\\\0 &amp;amp; 1 &amp;amp; 0 \\\\0 &amp;amp; 0 &amp;amp; 1\\end{bmatrix}\\cdot \\begin{bmatrix}ScaleX &amp;amp; 0 &amp;amp; 0 \\\\0 &amp;amp; ScaleY &amp;amp; 0 \\\\0 &amp;amp; 0 &amp;amp; 1\\end{bmatrix}= \\begin{bmatrix}ScaleX &amp;amp; 0 &amp;amp; 0 \\\\0 &amp;amp; ScaleY &amp;amp; 0 \\\\0 &amp;amp; 0 &amp;amp; 1\\end{bmatrix}\\]于是，只要 \\(ScaleX\\) 和 \\(ScaleY\\) 任何一个为 0 就可以导致新矩阵的行列式必定为 0。旋转矩阵旋转矩阵。假设用户设置的旋转角度为 angle，那么换算成弧度为 angle * (Math.PI/180.0)，我们将弧度记为 \\(\\alpha\\)，那么旋转矩阵为：\\[\\begin{bmatrix}\\cos{\\alpha} &amp;amp; \\sin{\\alpha} &amp;amp; 0 \\\\-\\sin{\\alpha} &amp;amp; \\cos{\\alpha} &amp;amp; 0 \\\\0 &amp;amp; 0 &amp;amp; 1\\end{bmatrix}\\]旋转矩阵点乘原矩阵的结果为：\\[\\begin{bmatrix}\\cos{\\alpha} &amp;amp; \\sin{\\alpha} &amp;amp; 0 \\\\-\\sin{\\alpha} &amp;amp; \\cos{\\alpha} &amp;amp; 0 \\\\0 &amp;amp; 0 &amp;amp; 1\\end{bmatrix}\\cdot \\begin{bmatrix}1 &amp;amp; 0 &amp;amp; 0 \\\\0 &amp;amp; 1 &amp;amp; 0 \\\\0 &amp;amp; 0 &amp;amp; 1\\end{bmatrix}= \\begin{bmatrix}\\cos{\\alpha} &amp;amp; \\sin{\\alpha} &amp;amp; 0 \\\\-\\sin{\\alpha} &amp;amp; \\cos{\\alpha} &amp;amp; 0 \\\\0 &amp;amp; 0 &amp;amp; 1\\end{bmatrix}\\]对此矩阵的行列式求值：\\[\\cos^{2}{\\alpha} + \\sin^{2}{\\alpha} = 1\\]也就是说其行列式的值恒等于 1，因此其矩阵必然可求逆。WPF 2D 变换矩阵求逆小结对于 WPF 的 2D 变换矩阵： 平移和旋转不可能导致矩阵不可逆； 缩放，只要水平和垂直方向的任何一个分量缩放量为 0，矩阵就会不可逆。寻找问题代码现在，我们寻找问题的方向已经非常明确了： 找到设置了 ScaleTransform 的 Window，检查其是否给 ScaleX 或者 ScaleY 属性赋值为了 0。然而，真正写一个 demo 程序来验证这个问题的时候，就发现没有这么简单。因为：我们发现，不止是 ScaleX 和 ScaleY 属性不能设为 0，实际上设成 0.5 或者其他值也是不行的。唯一合理值是 1。那么为什么依然有异常呢？难道是 ScaleTransform 的值一开始正常，然后被修改？编写 demo 验证，果然如此。而只有变换到 0 才会真的引发本文一开始我们提到的异常。一般会开始设为 1 而后设为 0 的代码通常是在做动画。一定是有代码正在为窗口的 ScaleTransform 做动画。结果全代码仓库搜索 ScaleTransform 真的找到了问题代码。&amp;lt;Window x:Name=&quot;WalterlvDoubiWindow&quot; x:Class=&quot;Walterlv.Exceptions.Unknown.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; mc:Ignorable=&quot;d&quot; Title=&quot;MainWindow&quot; Height=&quot;450&quot; Width=&quot;800&quot;&amp;gt; &amp;lt;Window.RenderTransform&amp;gt; &amp;lt;ScaleTransform ScaleX=&quot;1&quot; ScaleY=&quot;1&quot; /&amp;gt; &amp;lt;/Window.RenderTransform&amp;gt; &amp;lt;Window.Resources&amp;gt; &amp;lt;Storyboard x:Key=&quot;Storyboard.Load&quot;&amp;gt; &amp;lt;DoubleAnimation Storyboard.TargetName=&quot;WalterlvDoubiWindow&quot; Storyboard.TargetProperty=&quot;(UIElement.RenderTransform).(ScaleTransform.ScaleX)&quot; From=&quot;0&quot; To=&quot;1&quot; /&amp;gt; &amp;lt;DoubleAnimation Storyboard.TargetName=&quot;WalterlvDoubiWindow&quot; Storyboard.TargetProperty=&quot;(UIElement.RenderTransform).(ScaleTransform.ScaleY)&quot; From=&quot;0&quot; To=&quot;1&quot; /&amp;gt; &amp;lt;/Storyboard&amp;gt; &amp;lt;/Window.Resources&amp;gt; &amp;lt;Grid&amp;gt; &amp;lt;!-- 省略的代码 --&amp;gt; &amp;lt;/Grid&amp;gt;&amp;lt;/Window&amp;gt;不过，这段代码并不会导致每次都出现异常，而是在非常多次尝试中偶尔能出现一次异常。原因和解决方案原因 Window 类是不可以设置 RenderTransform 属性的，但允许设置恒等（Matrix.Identity）的变换； 如果让 Window 类缩放分量设置为 0，就会出现矩阵不可逆异常。解决方案不要给 Window 类设置变换，如果要做，请给 Window 内部的子元素设置。比如上面的例子中，我们给 Grid 设置就没有问题（而且可以做到类似的效果。" }, { "title": "WPF 不要给 Window 类设置变换矩阵（应用篇）", "url": "/post/dont-set-or-animate-scale-transform-for-a-wpf-window.html", "categories": "", "tags": "wpf, dotnet, csharp", "date": "2019-09-02 12:34:25 +0800", "snippet": "WPF 的 Window 类是不允许设置变换矩阵的。不过，总会有小伙伴为了能够设置一下试图绕过一些验证机制。不要试图绕过，因为你会遇到更多问题。试图设置变换矩阵当你试图给 Window 类设置变换矩阵的时候，会出现异常： System.InvalidOperationException:“转换对于 Window 无效。”无论是缩放还是旋转，都一样会出现异常。我们在 WPF 不要给 Window 类设置变换矩阵（分析篇） 一文中已经证明在 WPF 的 2D 变换中，旋转一定不会造成矩阵不可逆，因此此验证是针对此属性的强验证。只有做设置的变换是恒等变换的时候，才可以完成设置。this.RenderTransform = new TranslateTransform(0, 0);this.RenderTransform = new ScaleTransform(1, 1);this.RenderTransform = new RotateTransform(0);this.RenderTransform = new MatrixTransform(Matrix.Identity);绕过验证然而你可以通过先设置变换，再修改变换值的方式绕过验证：var scaleTransform = new ScaleTransform(1, 1);this.RenderTransform = scaleTransform;scaleTransform.ScaleX = 0.5;scaleTransform.ScaleY = 0.5;实际上，你绕过也没有关系，可是这样的设置实际上是没有任何效果的。不过为什么还是会有小伙伴这么设置呢？是因为小伙伴同时还设置了窗口透明 AllowsTransparency=&quot;True&quot;、WindowStyle=&quot;None&quot; 和 Background=&quot;Transparent&quot;，导致看起来好像这个变换生效了一样。小心异常此设置不仅没有效果，还会引发异常，请阅读我的另一篇博客了解： WPF 不要给 Window 类设置变换矩阵（分析篇）：System.InvalidOperationException: 转换不可逆。" }, { "title": "通过设置启用 Visual Studio 默认关闭的大量强大的功能提升开发效率", "url": "/post/let-visual-studio-empower-more-by-change-some-settings.html", "categories": "", "tags": "visualstudio, csharp", "date": "2019-08-29 21:54:47 +0800", "snippet": "使用 Visual Studio 开发 C#/.NET 应用程序，以前有 ReSharper 来不足其各项功能短板，后来不断将 ReSharper 的功能一点点搬过来稍微好了一些。不过直到 Visual Studio 2019，才开始渐渐可以和 ReSharper 拼一下了。如果你使用 Visual Studio 2019，那么像本文这样配置一下，可以大大提升你的开发效率。工具选项打开菜单 “工具” -&amp;gt; “选项”，然后你就打开了 Visual Studio 的选项窗口。接下来本文的所有内容都会在这里进行。文本编辑器在 “文本编辑器” -&amp;gt; “常规” 分类中，我们关心这些设置： 使鼠标单击可执行转到定义 这样按住 Ctrl 键点击标识符的时候可以转到定义（开启此选项之后，后面有其他选项可以转到反编译后的源码）当然也有其他可以打开玩的： 查看空白 专治强迫症，可以把空白字符都显示出来，这样你可以轻易看到对齐问题以及多于的空格了C#在 “文本编辑器” -&amp;gt; “C#” -&amp;gt; “IntelliSense” 分类中，我们关心这些设置： 键入字符后显示完成列表 删除字符后显示完成列表 突出显示完成列表项的匹配部分 显示完成项筛选器 打开这些选项可以让智能感知列表更容易显示出来，而我们也知道智能感知列表的强大 推荐 显示 unimported 命名空间中的项(实验) 这一项默认不会勾选，但强烈建议勾选上；它可以帮助我们直接输入没有 using 的命名空间中的类型，这可以避免记住大量记不住的类名C# 高级在 “文本编辑器” -&amp;gt; “C#” -&amp;gt; “高级” 分类中，我们关心大量设置： 支持导航到反编译源(实验) 前面我们说可以 Ctrl + 鼠标导航到定义，如果打开了这个就可以看反编译后的源码了 启用可为 null 的引用分析 IDE 功能 这个功能可能还没有完成，暂时还是无法开启的当然也有其他可以打开玩的： 启用完成解决方案分析 这是基于 Roslyn 的分析，Visual Studio 的大量重构功能都依赖于它；默认关闭也可以用，只是仅分析当前正在编辑的文件；如果打开则分析整个解决方案，你会在错误列表中看到大量的编译警告代码样式在 “文本编辑器” -&amp;gt; “C#” -&amp;gt; “代码样式” 分类，如果你关心代码的书写风格，那么这个分类底下的每一个子类别都可以考虑一个个检查一下。人工智能 IntelliCodeVisual Studio 2019 默认安装了 IntelliCode 可以充分利用微软使用 GitHub 上开源项目训练出来的模型来帮助编写代码。这些强烈建议开启。 C# 基础模型 微软利用 GitHub 开源项目训练的基础模型 XAML 基础模型 微软利用 GitHub 开源项目训练的基础模型 C# 参数完成 C# 自定义模型 如果针对单个项目训练出来了模型，那么可以使用专门针对此项目训练的模型 EditorConfig 推理 可以根据项目推断生成 EditorConfig 文件 可以参见在 Visual Studio 中使用 EditorConfig 统一代码风格 自定义模型训练提示 如果开启，那么每个项目的规模如果达到一定程度就会提示训练一个自定义模型出来训练模型会上传一部分数据到 IntelliCode 服务器，你可以去 %TEMP%\\Visual Studio IntelliCode 目录来查看到底上传了哪些数据。快捷键当然，设置好快捷键也是高效编码的重要一步，可以参考： 如何快速自定义 Visual Studio 中部分功能的快捷键 提高使用 Visual Studio 开发效率的键盘快捷键自动完成在你点击 “确定” 关闭了以上窗口之后，我们还需要设置一项。确保下图中的这个按钮处于 “非选中” 状态：这样，当出现智能感知列表的时候，我们直接就可以按下回车键输入这个选项了；否则你还需要按上下选中再回车。" }, { "title": "C#/.NET 中 Thread.Sleep(0), Task.Delay(0), Thread.Yield(), Task.Yield() 不同的执行效果和用法建议", "url": "/post/sleep-delay-zero-vs-yield.html", "categories": "", "tags": "dotnet, csharp", "date": "2019-08-29 16:34:41 +0800", "snippet": "在 C#/.NET 中，有 Thread.Sleep(0), Task.Delay(0), Thread.Yield(), Task.Yield() 中，有几种不同的让当前线程释放执行权的方法。他们的作用都是放弃当前线程当前的执行权，让其他线程得以调度。但是他们又不太一样。本文说说他们的原理区别和用法区别。原理区别Thread.Sleep(0)Thread.Sleep(int millisecondsTimeout) 的代码贴在下面，其内部实际上是在调用 SleepInternal，而 SleepInternal 由 CLR 内部实现。其目的是将当前线程挂起一个指定的时间间隔。如果将超时时间设置为 0，即 Thread.Sleep(0)，那么这将强制当前线程放弃剩余的 CPU 时间片。放弃当前线程剩余的 CPU 时间片就意味着其他比此线程优先级高且可以被调度的线程将会在此时被调度。然而此方法只是放弃当前 CPU 执行的时间片，如果当前系统环境下其他可以被调度的其他线程的优先级都比这个线程的优先级低，实际上此线程依然还是会优先执行。如果你的方法不会被其他线程影响，那么不会有执行上的区别，但如果你的方法涉及到多个线程的调用，那么 Thread.Sleep(0) 的调用可能导致其他线程也进入此方法（而不是等此线程的当前时间片执行完后再进入）。当然，CPU 对单个线程的执行时间片是纳秒级别的，所以实际上你因为此方法调用获得的多线程重入效果是“纯属巧合”的。/*=========================================================================** Suspends the current thread for timeout milliseconds. If timeout == 0,** forces the thread to give up the remainer of its timeslice. If timeout** == Timeout.Infinite, no timeout will occur.**** Exceptions: ArgumentException if timeout &amp;lt; 0.** ThreadInterruptedException if the thread is interrupted while sleeping.=========================================================================*/[System.Security.SecurityCritical] // auto-generated[ResourceExposure(ResourceScope.None)][MethodImplAttribute(MethodImplOptions.InternalCall)]private static extern void SleepInternal(int millisecondsTimeout);[System.Security.SecuritySafeCritical] // auto-generatedpublic static void Sleep(int millisecondsTimeout){ SleepInternal(millisecondsTimeout); // Ensure we don&#39;t return to app code when the pause is underway if(AppDomainPauseManager.IsPaused) AppDomainPauseManager.ResumeEvent.WaitOneWithoutFAS();}Thread.Yield()Thread.Yield() 的代码贴在下面，其内部调用 YieldInternal，实际上也是由 CLR 内部实现。此方法也是放弃当前线程的剩余时间片，所以其效果与 Thread.Sleep(0) 是相同的。[System.Security.SecurityCritical] // auto-generated[ResourceExposure(ResourceScope.None)][DllImport(JitHelpers.QCall, CharSet = CharSet.Unicode)][SuppressUnmanagedCodeSecurity][HostProtection(Synchronization = true, ExternalThreading = true), ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]private static extern bool YieldInternal();[System.Security.SecuritySafeCritical] // auto-generated[HostProtection(Synchronization = true, ExternalThreading = true), ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]public static bool Yield(){ return YieldInternal();}Thread.Sleep(1)Thread.Sleep(1) 与 Thread.Sleep(0) 虽然只有参数上的微小差别，但实际上做了不同的事情。Thread.Sleep(1) 会使得当前线程挂起一个指定的超时时间，这里设置为 1ms。于是，在这个等待的超时时间段内，你的当前线程处于不可被调度的状态。那么即便当前剩余的可以被调度的线程其优先级比这个更低，也可以得到调度。下面是针对这三个方法执行时间的一个实验结果：▲ Thread 不同方法的耗时实验结果其中，Nothing 表示没有写任何代码。测量使用的是 Stopwatch，你可以通过阅读 .NET/C# 在代码中测量代码执行耗时的建议（比较系统性能计数器和系统时间） 了解 Stopwatch 测量的原理和精度。var stopwatch = Stopwatch.StartNew();Thread.Sleep(0);var elapsed = stopwatch.Elapsed;Console.WriteLine($&quot;Thread.Sleep(0) : {elapsed}&quot;);Task.Delay(0)Task.Delay 是 Task 系列的线程模型（TAP）中的方法。关于 TAP 可参见 Task-based Asynchronous Pattern (TAP) Microsoft Docs。这是一套基于异步状态机（AsyncStateMachine）实现的线程模型，这也是与 Thread 系列方法最大的不同。当传入参数 0 的时候，会直接返回 Task.CompletedTask。这意味着你在 Task.Delay(0) 后面写的代码会被立刻调用（如果还有剩余 CPU 时间片的话）。/// &amp;lt;summary&amp;gt;/// Creates a Task that will complete after a time delay./// &amp;lt;/summary&amp;gt;/// &amp;lt;param name=&quot;millisecondsDelay&quot;&amp;gt;The number of milliseconds to wait before completing the returned Task&amp;lt;/param&amp;gt;/// &amp;lt;param name=&quot;cancellationToken&quot;&amp;gt;The cancellation token that will be checked prior to completing the returned Task&amp;lt;/param&amp;gt;/// &amp;lt;returns&amp;gt;A Task that represents the time delay&amp;lt;/returns&amp;gt;/// &amp;lt;exception cref=&quot;T:System.ArgumentOutOfRangeException&quot;&amp;gt;/// The &amp;lt;paramref name=&quot;millisecondsDelay&quot;/&amp;gt; is less than -1./// &amp;lt;/exception&amp;gt;/// &amp;lt;exception cref=&quot;T:System.ObjectDisposedException&quot;&amp;gt;/// The provided &amp;lt;paramref name=&quot;cancellationToken&quot;/&amp;gt; has already been disposed./// &amp;lt;/exception&amp;gt; /// &amp;lt;remarks&amp;gt;/// If the cancellation token is signaled before the specified time delay, then the Task is completed in/// Canceled state. Otherwise, the Task is completed in RanToCompletion state once the specified time/// delay has expired./// &amp;lt;/remarks&amp;gt; public static Task Delay(int millisecondsDelay, CancellationToken cancellationToken){ // Throw on non-sensical time if (millisecondsDelay &amp;lt; -1) { throw new ArgumentOutOfRangeException(&quot;millisecondsDelay&quot;, Environment.GetResourceString(&quot;Task_Delay_InvalidMillisecondsDelay&quot;)); } Contract.EndContractBlock(); // some short-cuts in case quick completion is in order if (cancellationToken.IsCancellationRequested) { // return a Task created as already-Canceled return Task.FromCancellation(cancellationToken); } else if (millisecondsDelay == 0) { // return a Task created as already-RanToCompletion return Task.CompletedTask; } // Construct a promise-style Task to encapsulate our return value var promise = new DelayPromise(cancellationToken); // Register our cancellation token, if necessary. if (cancellationToken.CanBeCanceled) { promise.Registration = cancellationToken.InternalRegisterWithoutEC(state =&amp;gt; ((DelayPromise)state).Complete(), promise); } // ... and create our timer and make sure that it stays rooted. if (millisecondsDelay != Timeout.Infinite) // no need to create the timer if it&#39;s an infinite timeout { promise.Timer = new Timer(state =&amp;gt; ((DelayPromise)state).Complete(), promise, millisecondsDelay, Timeout.Infinite); promise.Timer.KeepRootedWhileScheduled(); } // Return the timer proxy task return promise;}Task.Yield()Task.Yield() 的最大作用实际上是让一个异步方法立刻返回，让后面其他代码的调用进入下一个异步上下文。public async Task Foo(){ // 执行某些操作。 await Task.Yield(); // 执行另一些操作。}如果外面的代码使用 await 来等待 Foo，那么 Task.Yield 的作用可能不太明显，但是如果外面并没有 await 或者任何一层更外层的调用没有 await，那么就有区别了。对于没有异步等待的调用，那个方法就会在此 Task.Yield() 这一句执行后返回。而此后的代码将在那些没有异步等待的方法之后执行。Task.Yield() 实际上只是返回一个 YieldAwaitable 的新实例，而 YieldAwaitable.GetAwaiter 方法返回一个 YieldAwaiter 的新实例。也就是说，后续的执行效果完全取决于 YieldAwaiter 是如何实现这个异步过程的（异步状态机会执行这个过程）。我有另一篇博客说明 Awaiter 是如何实现的：如何实现一个可以用 await 异步等待的 Awaiter。YieldAwaiter 靠 QueueContinuation 来决定后续代码的执行时机。此方法的核心代码贴在了下面。有两个分支，如果指定了 SynchronizationContext，那么就会使用 SynchronizationContext 自带的 Post 方法来执行异步任务的下一个步骤。调用 continuation 就是执行异步状态机中的下一个步骤以进入下一个异步状态；不过，为了简化理解，你可以认为这就是调用 await 后面的那段代码。WPF UI 线程的 SynchronizationContext 被设置为了 DispatcherSynchronizationContext，它的 Post 方法本质上是用消息循环来实现的。其他线程如果没有特殊设置，则是 null。这一部分知识可以看参见：出让执行权：Task.Yield, Dispatcher.Yield。如果没有指定 SynchronizationContext 或者当前的 SynchronizationContext 就是 SynchronizationContext 类型基类，那么就会执行后面 else 中的逻辑。主要就是在线程池中寻找一个线程然后执行代码，或者再次启动一个 Task 任务并加入队列；这取决于 TaskScheduler.Current 的设置。// Get the current SynchronizationContext, and if there is one,// post the continuation to it. However, treat the base type// as if there wasn&#39;t a SynchronizationContext, since that&#39;s what it// logically represents.var syncCtx = SynchronizationContext.CurrentNoFlow;if (syncCtx != null &amp;amp;&amp;amp; syncCtx.GetType() != typeof(SynchronizationContext)){ syncCtx.Post(s_sendOrPostCallbackRunAction, continuation);}else{ // If we&#39;re targeting the default scheduler, queue to the thread pool, so that we go into the global // queue. As we&#39;re going into the global queue, we might as well use QUWI, which for the global queue is // just a tad faster than task, due to a smaller object getting allocated and less work on the execution path. TaskScheduler scheduler = TaskScheduler.Current; if (scheduler == TaskScheduler.Default) { if (flowContext) { ThreadPool.QueueUserWorkItem(s_waitCallbackRunAction, continuation); } else { ThreadPool.UnsafeQueueUserWorkItem(s_waitCallbackRunAction, continuation); } } // We&#39;re targeting a custom scheduler, so queue a task. else { Task.Factory.StartNew(continuation, default(CancellationToken), TaskCreationOptions.PreferFairness, scheduler); }}Task.Delay(1)与 Thread 一样，Task.Delay(1) 与 Task.Delay(0) 虽然只有参数上的微小差别，但实际上也做了不同的事情。Task.Delay(1) 实际上是启动了一个 System.Threading.Timer，然后订阅时间抵达之后的回调函数。会从 Timer.TimerSetup 设置，到使用 TimerHolder 并在内部使用 TimerQueueTimer 来设置回调；内部实际使用 TimerQueue.UpdateTimer 来完成时间等待之后的回调通知，最终通过 EnsureAppDomainTimerFiresBy 调用到 ChangeAppDomainTimer 来完成时间抵达之后的回调。而 await 之后的那段代码会被异步状态机封装，传入上面的回调中。[System.Security.SecurityCritical][ResourceExposure(ResourceScope.None)][DllImport(JitHelpers.QCall, CharSet = CharSet.Unicode)][SuppressUnmanagedCodeSecurity]static extern bool ChangeAppDomainTimer(AppDomainTimerSafeHandle handle, uint dueTime);相比于 Thread 相关方法仅涉及到当前线程的调度，Task 相关的方法会涉及到线程池的调度，并且使用 System.Threading.Timer 来进行计时，耗时更加不可控：▲ Task 不同方法的耗时实验结果（三次不同的实验结果）其中，Nothing 表示没有写任何代码。测量使用的是 Stopwatch，你依然可以通过阅读 .NET/C# 在代码中测量代码执行耗时的建议（比较系统性能计数器和系统时间） 了解 Stopwatch 测量的原理和精度。var stopwatch = Stopwatch.StartNew();await Task.Delay(0);var elapsed = stopwatch.Elapsed;Console.WriteLine($&quot;Thread.Sleep(0) : {elapsed}&quot;);在 [c# - Task.Delay().Wait(); sometimes causing a 15ms delay in messaging system - Stack Overflow](https://stackoverflow.com/q/41830216/6233938) 上有个说法，说操作系统的时钟中断有时间间隔，而 Windows 操作系统上这个时间间隔的默认值大约在 15ms，所以实际上你写等待 1ms，实际等待时间也会接近 15ms。 You’re seeing an artifact of the Windows interrupt rate, which is (by default) approx every 15ms. Thus if you ask for 1-15ms, you’ll get an approx 15ms delay. ~16-30 will yield 30ms… so on.用法区别Thread.Sleep(0) 和 Thread.Yield 在线程调度的效果上是相同的，Thread.Sleep(int) 是带有超时的等待，本质上也是线程调度。如果你希望通过放弃当前线程时间片以便给其他线程一些执行实际，那么考虑 Thread.Sleep(0) 或者 Thread.Yield；如果希望进行线程调度级别的等待（效果类似于阻塞线程），那么使用 Thread.Sleep(int)。如果你允许有一个异步上下文，可以使用 async/await，那么可以使用 Task.Delay(0) 或者 Task.Yield()。另外，如果等待时使用 Task.Delay 而不是 Thread.Sleep，那么你可以节省一个线程的资源，尤其是在一个线程池的线程中 Sleep 的话，会使得线程池中更多的线程被进行无意义的占用，对其他任务在线程池中的调度不利。参考资料 Thread.Sleep(0) vs Sleep(1) vs Yeild - stg609 - 博客园 [c# - Task.Delay().Wait(); sometimes causing a 15ms delay in messaging system - Stack Overflow](https://stackoverflow.com/q/41830216/6233938) c# - When to use Task.Delay, when to use Thread.Sleep? - Stack Overflow c# - Should I always use Task.Delay instead of Thread.Sleep? - Stack Overflow What’s the difference between Thread.Sleep(0) and Thread,Yield()?" }, { "title": "WPF 的 Application.Current.Dispatcher 中，为什么 Current 可能为 null", "url": "/post/application-current-may-be-null.html", "categories": "", "tags": "wpf, dotnet, csharp", "date": "2019-08-27 13:05:49 +0800", "snippet": "在 WPF 程序中，可能会存在 Application.Current.Dispatcher.Xxx 这样的代码让一部分逻辑回到主 UI 线程。因为发现在调用这句代码的时候出现了 NullReferenceException，于是就有三位小伙伴告诉我说 Current 和 Dispatcher 属性都可能为 null。然而实际上这里只可能 Current 为 null 而此上下文的 Dispatcher 是绝对不会为 null 的。（当然我们这里讨论的是常规编程手段，如果非常规手段，你甚至可以让实例的 this 为 null 呢……）当你的应用程序退出时，所有 UI 线程的代码都不再会执行，因此这是安全的；但所有非 UI 线程的代码依然在继续执行，此时随时可能遇到 Application.Current 属性为 null。由于本文所述的两个部分都略长，所以拆分成两篇博客，这样更容易理解。 WPF 的 Application.Current.Dispatcher 中，Dispatcher 属性一定不会为 null WPF 的 Application.Current.Dispatcher 中，为什么 Current 可能为 nullApplication.Current 静态属性源代码Application 类型的源代码会非常长，所以这里就不贴了，可以前往这里查看： DispatcherObject.cs其中，Current 返回的是 _appInstance 的静态字段。因此 _appInstance 字段为 null 的时机就是 Application.Current 为 null 的时机。/// &amp;lt;summary&amp;gt;/// The Current property enables the developer to always get to the application in/// AppDomain in which they are running./// &amp;lt;/summary&amp;gt;static public Application Current{ get { // There is no need to take the _globalLock because reading a // reference is an atomic operation. Moreover taking a lock // also causes risk of re-entrancy because it pumps messages. return _appInstance; }}由于 _appInstance 字段是私有字段，所以仅需调查这个类本身即可找到所有的赋值时机。（反射等非常规手段需要排除在外，因为这意味着开发者是逗比——自己闯的祸不能怪 WPF 框架。）赋值时机_appInstance 的赋值时机有两处： Application 的实例构造函数（注意哦，是实例构造函数而不是静态构造函数）； Application.DoShutdown 方法。在 Application 的实例构造函数中： _appInstance 的赋值是线程安全的，这意味着多个 Application 实例的构造不会因为线程安全问题导致 _appInstance 字段的状态不正确。 如果 _appCreatedInThisAppDomain 为 true 那么，将抛出异常，组织此应用程序域中创建第二个 Application 类型的实例。/// &amp;lt;summary&amp;gt;/// Application constructor/// &amp;lt;/summary&amp;gt;/// &amp;lt;SecurityNote&amp;gt;/// Critical: This code posts a work item to start dispatcher if in the browser/// PublicOk: It is ok because the call itself is not exposed and the application object does this internally./// &amp;lt;/SecurityNote&amp;gt;[SecurityCritical]public Application(){ // 省略了一部分代码。 lock(_globalLock) { // set the default statics // DO NOT move this from the begining of this constructor if (_appCreatedInThisAppDomain == false) { Debug.Assert(_appInstance == null, &quot;_appInstance must be null here.&quot;); _appInstance = this; IsShuttingDown = false; _appCreatedInThisAppDomain = true; } else { //lock will be released, so no worries about throwing an exception inside the lock throw new InvalidOperationException(SR.Get(SRID.MultiSingleton)); } } // 省略了一部分代码。}也就是说，此类型实际上是设计为单例的。在第一个实例构造出来之后，单例的实例即可开始使用。后续赋值此单例实例的唯一结束时机就是 Application.DoShutdown 方法。这是唯一将 _appInstance 赋值为 null 的代码。/// &amp;lt;summary&amp;gt;/// DO NOT USE - internal method/// &amp;lt;/summary&amp;gt;///&amp;lt;SecurityNote&amp;gt;/// Critical: Calls critical code: Window.InternalClose/// Critical: Calls critical code: HwndSource.Dispose/// Critical: Calls critical code: PreloadedPackages.Clear()///&amp;lt;/SecurityNote&amp;gt;[SecurityCritical]internal virtual void DoShutdown(){ // 省略了一部分代码。 // Event handler exception continuality: if exception occurs in ShuttingDown event handler, // our cleanup action is to finish Shuttingdown. Since Shuttingdown cannot be cancelled. // We don&#39;t want user to use throw exception and catch it to cancel Shuttingdown. try { // fire Applicaiton Exit event OnExit(e); } finally { SetExitCode(e._exitCode); // By default statics are shared across appdomains, so need to clear lock (_globalLock) { _appInstance = null; } _mainWindow = null; _htProps = null; NonAppWindowsInternal = null; // 省略了一部分代码。 }}可以调用到此代码的公共 API 有： Application.Shutdown 实例方法 导致 Window 关闭的若干方法（InternalDispose） IBrowserHostServices.PostShutdown 接口方法因此，所有直接或间接调用到以上方法的地方都会导致 Application.Current 属性被赋值为 null。对所写代码的影响从以上的分析可以得知，只要你还能在 Application.DoShutdown 执行之后继续执行代码，那么这部分的代码都将面临着 Application.Current 为 null 风险。那么，到底有哪些时机可能遇到 Application.Current 为 null 呢？这部分就与读者项目中所用的业务代码强相关了。但是这部分业务代码会有一些公共特征帮助你判定你是否可能写出遭遇 Application.Current 为 null 的代码。此特征是：此代码与 Application.Current 不在同一线程。与 Application.Current 不在同一线程对于 WPF 程序，你的多数代码可能是由用户交互产生，即便有后续代码的执行，也依然是从 UI 交互产生。这样的代码不会遇到 Application.Current 为 null 的情况。但是，如果你的代码由非 UI 线程触发，例如在 Usb 设备改变、与其他端的通信、某些异步代码的回调等等，这些代码不受 Dispatcher 是否调度影响，几乎一定会执行。因此 Application.Current 就算赋值为 null 了，它们也不知道，依然会继续执行，于是就会遭遇 Application.Current 为 null。这本质上是一个线程安全问题。使用 Invoke/BeginInvoke/InvokeAsync 的代码不会出问题Application.DoShutdown 方法被 ShutdownImpl 包装，且所有调用均从此包装进入，因此，所有可能导致 Application.Current 为 null 的代码，均会调用此方法，也就是说，会调用 Dispatcher.CriticalInvokeShutdown 实例方法。/// &amp;lt;summary&amp;gt;/// This method gets called on dispatch of the Shutdown DispatcherOperationCallback/// &amp;lt;/summary&amp;gt;///&amp;lt;SecurityNote&amp;gt;/// Critical: Calls critical code: DoShutdown, Dispatcher.CritcalInvokeShutdown()///&amp;lt;/SecurityNote&amp;gt;[SecurityCritical]private void ShutdownImpl(){ // Event handler exception continuality: if exception occurs in Exit event handler, // our cleanup action is to finish Shutdown since Exit cannot be cancelled. We don&#39;t // want user to use throw exception and catch it to cancel Shutdown. try { DoShutdown(); } finally { // Quit the dispatcher if we ran our own. if (_ownDispatcherStarted == true) { Dispatcher.CriticalInvokeShutdown(); } ServiceProvider = null; }}所有的关闭 Dispatcher 的调用有两类，Application 关闭时调用的是内部方法 CriticalInvokeShutdown。 立即关闭 CriticalInvokeShutdown，即以 Send 优先级 Invoke 关闭方法，而 Send 优先级调用 Invoke 几乎等同于直接调用（为什么是等同而不是直接调用？因为还需要考虑回到 Dispatcher 初始化时所在的线程）。 开始关闭 BeginInvokeShutdown，即以指定的优先级 InvokeAsync 关闭方法。而关闭 Dispatcher 意味着所有使用 Invoke/BeginInvoke/InvokeAsync 的任务将终止。//&amp;lt;SecurityNote&amp;gt;// Critical - as it accesses security critical data ( window handle)//&amp;lt;/SecurityNote&amp;gt;[SecurityCritical]private void ShutdownImplInSecurityContext(Object state){ // 省略了一部分代码。 // Now that the queue is off-line, abort all pending operations, // including inactive ones. DispatcherOperation operation = null; do { lock(_instanceLock) { if(_queue.MaxPriority != DispatcherPriority.Invalid) { operation = _queue.Peek(); } else { operation = null; } } if(operation != null) { operation.Abort(); } } while(operation != null); // 省略了一部分代码。}由于此终止代码在 Dispatcher 所在的线程执行，而所有 Invoke/BeginInvoke/InvokeAsync 代码也都在此线程执行，因此这些代码均不会并发。已经执行的代码会在此终止代码之前，而在此终止代码之后也不会再执行任何 Invoke/BeginInvoke/InvokeAsync 的任务了。 所有通过 Invoke/BeginInvoke/InvokeAsync 或间接通过此方法（如 WPF 控件相关事件）调用的代码，均不会遭遇 Application.Current 为 null。 所有在 UI 线程使用 async / await 并使用默认上下文执行的代码，均不会遭遇 Application.Current 为 null。（这意味着你没有使用 .ConfigureAwait(false)，详见在编写异步方法时，使用 ConfigureAwait(false) 避免使用者死锁 - walterlv。）最简示例代码using System;using System.Threading;using System.Threading.Tasks;using System.Windows;namespace Walterlv.Demo.ApplicationDispatcher{ class Program { [STAThread] static void Main(string[] args) { var app = new Application(); Task.Delay(1000).ContinueWith(t =&amp;gt; { app.Dispatcher.InvokeAsync(() =&amp;gt; app.Shutdown()); }); Task.Delay(2000).ContinueWith(t =&amp;gt; { Application.Current.Dispatcher.InvokeAsync(() =&amp;gt; { }); }); app.Run(); Thread.Sleep(2000); } }}结论总结以上所有的分析： 任何与 Application 不在同一个线程的代码，都可能遭遇 Application.Current 为 null。 任何与 Application 在同一个线程的代码，都不可能遇到 Application.Current 为 null。这其实是一个线程安全问题。用所有业务开发者都可以理解的说法描述就是：当你的应用程序退出时，所有 UI 线程的代码都不再会执行，因此这是安全的；但所有非 UI 线程的代码依然在继续执行，此时随时可能遇到 Application.Current 属性为 null。因此，记得所有非 UI 线程的代码，如果需要转移到 UI 线程执行，记得判空：private void OnUsbDeviceChanged(object sender, EventArgs e){ // 记得这里需要判空，因为此上下文可能在非 UI 线程。 Application.Current?.InvokeAsync(() =&amp;gt; { });}Application.Dispatcher 实例属性关于 Application.Dispatcher 是否可能为 null 的分析，由于比较长，请参见我的另一篇博客： WPF 的 Application.Current.Dispatcher 中，Dispatcher 属性一定不会为 null - walterlv参考资料 Application.cs" }, { "title": "WPF 的 Application.Current.Dispatcher 中，Dispatcher 属性一定不会为 null", "url": "/post/application-dispatcher-will-never-be-null.html", "categories": "", "tags": "wpf, dotnet, csharp", "date": "2019-08-27 12:51:43 +0800", "snippet": "在 WPF 程序中，可能会存在 Application.Current.Dispatcher.Xxx 这样的代码让一部分逻辑回到主 UI 线程。因为发现在调用这句代码的时候出现了 NullReferenceException，于是就有三位小伙伴告诉我说 Current 和 Dispatcher 属性都可能为 null。然而实际上这里只可能 Current 为 null 而此上下文的 Dispatcher 是绝对不会为 null 的。（当然我们这里讨论的是常规编程手段，如果非常规手段，你甚至可以让实例的 this 为 null 呢……）由于本文所述的两个部分都略长，所以拆分成两篇博客，这样更容易理解。 WPF 的 Application.Current.Dispatcher 中，Dispatcher 属性一定不会为 null WPF 的 Application.Current.Dispatcher 中，为什么 Current 可能为 nullApplication.Dispatcher 实例属性Application.Dispatcher 实例属性来自于 DispatcherObject。源代码为了分析此属性是否可能为 null，我现在将 DispatcherObject 的全部代码贴在下面：using System;using System.Windows;using System.Threading;using MS.Internal.WindowsBase; // FriendAccessAllowed namespace System.Windows.Threading{ /// &amp;lt;summary&amp;gt; /// A DispatcherObject is an object associated with a /// &amp;lt;see cref=&quot;Dispatcher&quot;/&amp;gt;. A DispatcherObject instance should /// only be access by the dispatcher&#39;s thread. /// &amp;lt;/summary&amp;gt; /// &amp;lt;remarks&amp;gt; /// Subclasses of &amp;lt;see cref=&quot;DispatcherObject&quot;/&amp;gt; should enforce thread /// safety by calling &amp;lt;see cref=&quot;VerifyAccess&quot;/&amp;gt; on all their public /// methods to ensure the calling thread is the appropriate thread. /// &amp;lt;para/&amp;gt; /// DispatcherObject cannot be independently instantiated; that is, /// all constructors are protected. /// &amp;lt;/remarks&amp;gt; public abstract class DispatcherObject { /// &amp;lt;summary&amp;gt; /// Returns the &amp;lt;see cref=&quot;Dispatcher&quot;/&amp;gt; that this /// &amp;lt;see cref=&quot;DispatcherObject&quot;/&amp;gt; is associated with. /// &amp;lt;/summary&amp;gt; [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)] public Dispatcher Dispatcher { get { // This property is free-threaded. return _dispatcher; } } // This method allows certain derived classes to break the dispatcher affinity // of our objects. [FriendAccessAllowed] // Built into Base, also used by Framework. internal void DetachFromDispatcher() { _dispatcher = null; } // Make this object a &quot;sentinel&quot; - it can be used in equality tests, but should // not be used in any other way. To enforce this and catch bugs, use a special // sentinel dispatcher, so that calls to CheckAccess and VerifyAccess will // fail; this will catch most accidental uses of the sentinel. [FriendAccessAllowed] // Built into Base, also used by Framework. internal void MakeSentinel() { _dispatcher = EnsureSentinelDispatcher(); } private static Dispatcher EnsureSentinelDispatcher() { if (_sentinelDispatcher == null) { // lazy creation - the first thread reaching here creates the sentinel // dispatcher, all other threads use it. Dispatcher sentinelDispatcher = new Dispatcher(isSentinel:true); Interlocked.CompareExchange&amp;lt;Dispatcher&amp;gt;(ref _sentinelDispatcher, sentinelDispatcher, null); } return _sentinelDispatcher; } /// &amp;lt;summary&amp;gt; /// Checks that the calling thread has access to this object. /// &amp;lt;/summary&amp;gt; /// &amp;lt;remarks&amp;gt; /// Only the dispatcher thread may access DispatcherObjects. /// &amp;lt;p/&amp;gt; /// This method is public so that any thread can probe to /// see if it has access to the DispatcherObject. /// &amp;lt;/remarks&amp;gt; /// &amp;lt;returns&amp;gt; /// True if the calling thread has access to this object. /// &amp;lt;/returns&amp;gt; [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)] public bool CheckAccess() { // This method is free-threaded. bool accessAllowed = true; Dispatcher dispatcher = _dispatcher; // Note: a DispatcherObject that is not associated with a // dispatcher is considered to be free-threaded. if(dispatcher != null) { accessAllowed = dispatcher.CheckAccess(); } return accessAllowed; } /// &amp;lt;summary&amp;gt; /// Verifies that the calling thread has access to this object. /// &amp;lt;/summary&amp;gt; /// &amp;lt;remarks&amp;gt; /// Only the dispatcher thread may access DispatcherObjects. /// &amp;lt;p/&amp;gt; /// This method is public so that derived classes can probe to /// see if the calling thread has access to itself. /// &amp;lt;/remarks&amp;gt; [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)] public void VerifyAccess() { // This method is free-threaded. Dispatcher dispatcher = _dispatcher; // Note: a DispatcherObject that is not associated with a // dispatcher is considered to be free-threaded. if(dispatcher != null) { dispatcher.VerifyAccess(); } } /// &amp;lt;summary&amp;gt; /// Instantiate this object associated with the current Dispatcher. /// &amp;lt;/summary&amp;gt; protected DispatcherObject() { _dispatcher = Dispatcher.CurrentDispatcher; } private Dispatcher _dispatcher; private static Dispatcher _sentinelDispatcher; }}代码来自：DispatcherObject.cs。Dispatcher 属性仅仅是在获取 _dispatcher 字段的值，因此我们只需要看 _dispatcher 字段的赋值时机，以及所有给 _dispatcher 赋值的代码。由于 _dispatcher 字段是私有字段，所以仅需调查这个类本身即可找到所有的赋值时机。（反射等非常规手段需要排除在外，因为这意味着开发者是逗比——自己闯的祸不能怪 WPF 框架。）赋值时机先来看看 dispatcher 字段的赋值时机。DispatcherObject 仅有一个构造函数，而这个构造函数中就已经给 _dispatcher 赋值了，因此其所有的子类的初始化之前，_dispatcher 就会被赋值。protected DispatcherObject(){ _dispatcher = Dispatcher.CurrentDispatcher;}那么所赋的值是否可能为 null 呢，这就要看 Dispatcher.CurrentDispatcher 是否可能返回一个 null 了。以下是 Dispatcher.CurrentDispatcher 的属性获取代码：public static Dispatcher CurrentDispatcher{ get { // Find the dispatcher for this thread. Dispatcher currentDispatcher = FromThread(Thread.CurrentThread);; // Auto-create the dispatcher if there is no dispatcher for // this thread (if we are allowed to). if(currentDispatcher == null) { currentDispatcher = new Dispatcher(); } return currentDispatcher; }}可以看到，无论前面的方法得到的值是否是 null，后面都会再给 currentDispatcher 局部变量赋值一个新创建的实例的。因此，此属性是绝对不会返回 null 的。由此可知，DispatcherObject 自构造起便拥有一个不为 null 的 Dispatcher 属性，其所有子类在初始化之前便会得到不为 null 的 Dispatcher 属性。后续赋值现在我们来看看在初始化完成之后，后面是否有可能将 _dispatcher 赋值为 null。给 _dispatcher 字段的赋值代码仅有两个：// This method allows certain derived classes to break the dispatcher affinity// of our objects.[FriendAccessAllowed] // Built into Base, also used by Framework.internal void DetachFromDispatcher(){ _dispatcher = null;}// Make this object a &quot;sentinel&quot; - it can be used in equality tests, but should// not be used in any other way. To enforce this and catch bugs, use a special// sentinel dispatcher, so that calls to CheckAccess and VerifyAccess will// fail; this will catch most accidental uses of the sentinel.[FriendAccessAllowed] // Built into Base, also used by Framework.internal void MakeSentinel(){ _dispatcher = EnsureSentinelDispatcher();}第一个 DetachFromDispatcher 很好理解，让 DispatcherObject 跟 Dispatcher 无关。在整个 WPF 的代码中，使用此方法的仅有以下 6 处： Freezable.Freeze 实例方法 BeginStoryboard.Seal 实例方法 Style.Seal 实例方法 TriggerBase.Seal 实例方法 StyleHelper 在 SealTemplate 静态方法中对 FrameworkTemplate 类型的实例调用此方法 ResourceDictionary 在构造函数中为 DispatcherObject 类型的 DummyInheritanceContext 属性调用此方法而 Application 类型不是以上任何一个类型的子类（Application 类的直接基类是 DispatcherObject），因此 Application 类中的 Dispatcher 属性不可能因为 DetachFromDispatcher 方法的调用而被赋值为 null。接下来看看 MakeSentinel 方法，此方法的作用不如上面方法那样直观，实际上它的作用仅仅为了验证某个方法调用时所在的线程是否是符合预期的（给 VerifyAccess 和 CheckAccess 使用）。使用此方法的仅有 1 处： ItemsControl 所用的 ItemInfo 类的静态构造函数internal static readonly DependencyObject SentinelContainer = new DependencyObject();internal static readonly DependencyObject UnresolvedContainer = new DependencyObject();internal static readonly DependencyObject KeyContainer = new DependencyObject();internal static readonly DependencyObject RemovedContainer = new DependencyObject();static ItemInfo(){ // mark the special DOs as sentinels. This helps catch bugs involving // using them accidentally for anything besides equality comparison. SentinelContainer.MakeSentinel(); UnresolvedContainer.MakeSentinel(); KeyContainer.MakeSentinel(); RemovedContainer.MakeSentinel();}所有这些使用都与 Application 无关。结论总结以上所有的分析： Application 类型的实例在初始化之前，Dispatcher 属性就已经被赋值且不为 null； 所有可能改变 _dispatcher 属性的常规方法均与 Application 类型无关；因此，所有常规手段均不会让 Application 类的 Dispatcher 属性拿到 null 值。如果你还说拿到了 null，那就检查是否有逗比程序员通过反射或其他手段将 _dispatcher 字段改为了 null 吧……Application.Current 静态属性关于 Application.Current 是否可能为 null 的分析，由于比较长，请参见我的另一篇博客： WPF 的 Application.Current.Dispatcher 中，Current 可能为 null参考资料 DispatcherObject.cs" }, { "title": "使用 SetParent 跨进程设置父子窗口时的一些问题（小心卡死）", "url": "/post/all-processes-freezes-if-their-windows-are-connected-via-setparent.html", "categories": "", "tags": "dotnet, wpf, csharp, windows", "date": "2019-08-27 08:49:06 +0800", "snippet": "在微软的官方文档中，说 SetParent 可以在进程内设置，也可以跨进程设置。当使用跨进程设置窗口的父子关系时，你需要注意本文提到的一些问题，避免踩坑。跨进程设置 SetParent关于 SetParent 函数设置窗口父子关系的文档可以看这个： SetParent function (winuser.h) - Microsoft Docs在这篇文章的 DPI 感知一段中明确写明了在进程内以及跨进程设置父子关系时的一些行为。虽然没有明确说明支持跨进程设置父子窗口，不过这段文字就几乎说明 Windows 系统对于跨进程设置窗口父子关系还是支持的。但 Raymond Chen 在 Is it legal to have a cross-process parent/child or owner/owned window relationship? 一文中有另一段文字： If I remember correctly, the documentation for Set­Parent used to contain a stern warning that it is not supported, but that remark does not appear to be present any more. I have a customer who is reparenting windows between processes, and their application is experiencing intermittent instability.如果我没记错的话，SetParent 的文档曾经包含一个严厉的警告表明它不受支持，但现在这段备注似乎已经不存在了。我就遇到过一个客户跨进程设置窗口之间的父子关系，然后他们的应用程序间歇性不稳定。这里表明了 Raymond Chen 对于跨进程设置父子窗口的一些担忧，但从文档趋势来看，还是支持的。只是这种担忧几乎说明跨进程设置 SetParent 存在一些坑。那么本文就说说跨进程设置父子窗口的一些坑。消息循环强制同步消息循环我们会感觉到 Windows 中某个窗口有响应（比如鼠标点击有反应），是因为这个窗口在处理 Windows 消息。窗口进行消息循环不断地处理消息使得各种各样的用户输入可以被处理，并正确地在界面上显示。一个典型的消息循环大概像这样：while(GetMessage(ref msg, IntPtr.Zero, 0, 0)){ TranslateMessage(ref msg); DispatchMessage(ref msg);}对于显示了窗口的某个线程调用了 GetMessage 获取了消息，Windows 系统就会认为这个线程有响应。相反，如果长时间不调用 GetMessage，Windows 就会认为这个线程无响应。TranslateMessage 则是翻译一些消息（比如从按键消息翻译成字符消息）。真正处理 GetMessage 中的内容则是后面的调度消息 DispatchMessage，是这个函数的调用使得我们 UI 界面上的内容可以有可见的反映。一般来说，每个创建了窗口的线程都有自己独立的消息循环，且不会互相影响。然而一旦这些窗口之间建立了父子关系之后就会变得麻烦起来。强制同步Windows 会让具有父子关系的所有窗口的消息循环强制同步。具体指的是，所有具有父子关系的窗口消息循环，其消息循环会串联成一个队列（这样才可以避免消息循环的并发）。也就是说，如果你有 A、B、C、D 四个窗口，分属不同进程，A 是 B、C、D 窗口的父窗口，那么当 A 在处理消息的时候，B、C、D 的消息循环就会卡在 GetMessage 的调用。同样，无论是 B、C 还是 D 在处理消息的时候，其他窗口也会同样卡在 GetMessage 的调用。这样，所有进程的 UI 线程实际上会互相等待，所有通过消息循环执行的代码都不会同时执行。然而实际上 Windows GUI 应用程序的开发中基本上 UI 代码都是通过消息循环来执行的，所以这几乎等同于所有进程的 UI 线程强制同步成类似一个 UI 线程的效果了。带来的副作用也就相当明显，任何一个进程卡了 UI，其他进程的 UI 将完全无响应。当然，不依赖消息循环的代码不会受此影响，比如 WPF 应用程序的动画和渲染。如何解决对于 SetParent 造成的这些问题，实际上没有官方的解决方案，你需要针对你不同的业务采用不同的解决办法。正如 Raymond Chen 所说： (It’s one of those “if you don’t already know what the consequences are, then you are not smart enough to do it correctly” things. You must first become the master of the rules before you can start breaking them.)正如有些人说的“如果你不知道后果，那么你也不足以正确地完成某件事情”。在开始破坏规则之前，您必须先成为规则的主人。你必须清楚跨进程设置父子窗口带来的各种副作用，然后针对性地给出解决方案： 比如所有窗口会强制串联成一个队列，那么可以考虑将暂时不显示的窗口断开父子关系； 比如设置窗口的位置大小等操作，必须考虑此窗口不是顶层窗口的问题，需要跨越进程到顶层窗口来操作；参考资料 windows - Good or evil - SetParent() win32 API between different processes - Stack Overflow Hosting WPF UI cross-thread and cross-process – Diaries of a Software Plumber [Is it legal to have a cross-process parent/child or owner/owned window relationship? The Old New Thing](https://devblogs.microsoft.com/oldnewthing/?p=4683) winapi - Why are “TranslateMessage” and “DispatchMessage” separate calls? - Stack Overflow" }, { "title": "程序员可能会使用的各种命名规则", "url": "/post/programming-naming-conventions.html", "categories": "", "tags": "miscellaneous", "date": "2019-08-19 08:44:36 +0800", "snippet": "古老的程序员们有时会纠结命名问题，而现在，程序员们的命名已经开创了数个流派。本文整理了程序员们命名会使用到的各种流派，当然一些编程语言会同时使用数个流派。PascalCase有很多个名字，除了 PascalCase 还有 UpperCamelCase, BumpyCase。所有单词直接连接，连接的每个单词的首字母大写。WelcomeToReadWalterlvBlogcamelCase所有单词直接连接，连接的每个单词的首字母大写。walterlvIsADoubisnake_case单词的所有字母小写，单词之间通过下划线 _ 连接起来。welcome_to_read_walterlv_blogkebab-case单词的所有字母小写，单词之间通过连字符（hyphen，-）连接起来。walterlv-is-a-doubi参考资料 Letter case - Wikipedia Naming convention (programming) - Wikipedia" }, { "title": "System.InvalidOperationException:“BuildWindowCore 无法返回寄宿的子窗口句柄。”", "url": "/post/failed-to-return-the-hosted-child-window-handle.html", "categories": "", "tags": "wpf, windows, dotnet, csharp", "date": "2019-08-14 16:32:42 +0800", "snippet": "当试图在 WPF 窗口中嵌套显示 Win32 子窗口的时候，你有可能出现错误：“BuildWindowCore 无法返回寄宿的子窗口句柄。”。这是很典型的 Win32 错误，本文介绍如何修复此错误。我们在 MainWindow 中嵌入一个其他的窗口来承载新的 WPF 控件。一般情况下我们当然不会这么去做，但是如果我们要跨越进程边界来完成 WPF 渲染内容的融合的时候，就需要嵌入一个新的窗口了。WPF 中可以使用 HwndSource 来包装一个 WPF 控件到 Win32 窗口，使用自定义的继承自 HwndHost 的类可以把 Win32 窗口包装成 WPF 控件。由于窗口句柄是可以跨越进程边界传递的，所以这样的方式可以完成跨进程的 WPF 控件显示。问题你有可能在调试嵌入窗口代码的时候遇到错误： System.InvalidOperationException:“BuildWindowCore 无法返回寄宿的子窗口句柄。”英文是： BuildWindowCore failed to return the hosted child window handle.原因和解决办法此异常的原因非常简单，是 HwndSource 的 BuildWindowCore 的返回值有问题。具体来说，就是子窗口的句柄返回了 0。也就是下面这段代码中 return new HandleRef(this, IntPtr.Zero) 这句，第二个参数是 0。protected override HandleRef BuildWindowCore(HandleRef hwndParent){ const int WS_CHILD = 1073741824; const int WS_CLIPCHILDREN = 33554432; var parameters = new HwndSourceParameters(&quot;demo&quot;) { ParentWindow = hwndParent.Handle, WindowStyle = (int)(WS_CHILD | WS_CLIPCHILDREN), TreatAncestorsAsNonClientArea = true, }; var source = new HwndSource(parameters); source.RootVisual = new Button(); return new HandleRef(this, _handle);}要解决，就需要传入正确的句柄值。当然上面的代码为了示例，故意传了一个不知道哪里的 _handle，实际上应该传入 source.Handle 才是正确的。" }, { "title": "System.InvalidOperationException:“寄宿 HWND 必须是子窗口。”", "url": "/post/hosted-hwnd-must-be-a-child-window.html", "categories": "", "tags": "wpf, windows, dotnet, csharp", "date": "2019-08-14 16:32:35 +0800", "snippet": "当试图在 WPF 窗口中嵌套显示 Win32 子窗口的时候，你有可能出现错误：“System.InvalidOperationException:“寄宿 HWND 必须是子窗口。””。这是很典型的 Win32 错误，本文介绍如何修复此错误。一个最简的嵌入其他窗口的例子我们在 MainWindow 中嵌入一个其他的窗口来承载新的 WPF 控件。一般情况下我们当然不会这么去做，但是如果我们要跨越进程边界来完成 WPF 渲染内容的融合的时候，就需要嵌入一个新的窗口了。WPF 中可以使用 HwndSource 来包装一个 WPF 控件到 Win32 窗口，使用自定义的继承自 HwndHost 的类可以把 Win32 窗口包装成 WPF 控件。由于窗口句柄是可以跨越进程边界传递的，所以这样的方式可以完成跨进程的 WPF 控件显示。下面是最简单的一个例子，为了简单，没有跨进程传递 Win32 窗口句柄，而是直接创建出来。using System.Runtime.InteropServices;using System.Windows;using System.Windows.Interop;namespace Walterlv.Demo.HwndWrapping{ public partial class MainWindow : Window { public MainWindow() { InitializeComponent(); Loaded += OnLoaded; } private void OnLoaded(object sender, RoutedEventArgs e) { Content = new HwndWrapper(); } } public class HwndWrapper : HwndHost { private HwndSource _source; protected override HandleRef BuildWindowCore(HandleRef hwndParent) { var parameters = new HwndSourceParameters(&quot;walterlv&quot;); _source = new HwndSource(parameters); // 这里的 ChildPage 是一个继承自 UseControl 的 WPF 控件，你可以自己创建自己的 WPF 控件。 _source.RootVisual = new ChildPage(); return new HandleRef(this, _source.Handle); } protected override void DestroyWindowCore(HandleRef hwnd) { _source?.Dispose(); } }}寄宿 HWND 必须是子窗口当运行此代码的时候，会提示错误： System.InvalidOperationException:“寄宿 HWND 必须是子窗口。”或者英文版： System.InvalidOperationException:”Hosted HWND must be a child window.”这是一个 Win32 错误，因为我们试图将一个普通的窗口嵌入到另一个窗口中，而实际上要完成嵌入需要子窗口才行。那么如何设置一个 Win32 窗口为子窗口呢？使用 SetWindowLong 来设置 Win32 窗口的样式是可以的。不过我们因为使用了 HwndSource，所以可以通过 HwndSourceParameters 来更方便地设置窗口样式。我们需要将 HwndSourceParameters 那一行改成这样：++ const int WS_CHILD = 0x40000000;-- var parameters = new HwndSourceParameters(&quot;walterlv&quot;);++ var parameters = new HwndSourceParameters(&quot;walterlv&quot;)++ {++ ParentWindow = hwndParent.Handle,++ WindowStyle = WS_CHILD,++ };最关键的是两点： 需要设置此窗口为子窗口，也就是设置 WindowStyle 为 WS_CHILD； 需要设置此窗口的父窗口，也就是设置 ParentWindow 为 hwndParent.Handle（我们使用参数中传入的 hwndParent 作为父窗口）。现在再运行，即可正常显示此嵌套窗口：另外，WindowStyle 属性最好加上 WS_CLIPCHILDREN，详情请阅读： 解决 WPF 嵌套的子窗口在改变窗口大小的时候闪烁的问题参考资料 WPF嵌入式调用Win32应用程序的问题—提示异常：寄宿的HWND必须是指定父级的子窗口" }, { "title": "System.InvalidOperationException:“寄宿的 HWND 必须是指定父级的子窗口。”", "url": "/post/hosted-hwnd-must-be-a-child-window-of-the-specified-parent.html", "categories": "", "tags": "wpf, windows, dotnet, csharp", "date": "2019-08-14 16:32:16 +0800", "snippet": "当试图在 WPF 窗口中嵌套显示 Win32 子窗口的时候，你有可能出现错误：“寄宿的 HWND 必须是指定父级的子窗口。”。这是很典型的 Win32 错误，本文介绍如何修复此错误。我们在 MainWindow 中嵌入一个其他的窗口来承载新的 WPF 控件。一般情况下我们当然不会这么去做，但是如果我们要跨越进程边界来完成 WPF 渲染内容的融合的时候，就需要嵌入一个新的窗口了。WPF 中可以使用 HwndSource 来包装一个 WPF 控件到 Win32 窗口，使用自定义的继承自 HwndHost 的类可以把 Win32 窗口包装成 WPF 控件。由于窗口句柄是可以跨越进程边界传递的，所以这样的方式可以完成跨进程的 WPF 控件显示。问题你有可能在调试嵌入窗口代码的时候遇到错误： System.InvalidOperationException:“寄宿的 HWND 必须是指定父级的子窗口。”英文是： Hosted HWND must be a child window of the specified parent.原因和解决办法出现此错误，是因为同一个子窗口被两次设置为同一个窗口的子窗口。具体来说，就是 A 窗口使用 HwndHost 设置成了 B 的子窗口，随后 A 又通过一个新的 HwndHost 设置成了新子窗口。要解决，则必须确保一个窗口只能使用 HwndHost 设置一次子窗口。" }, { "title": "如何创建一个基于 MSBuild Task 的跨平台的 NuGet 工具包", "url": "/post/create-a-cross-platform-msbuild-task-based-nuget-tool.html", "categories": "", "tags": "visualstudio, csharp, dotnet, msbuild", "date": "2019-08-07 14:50:59 +0800", "snippet": "MSBuild 的 Task 为我们扩展项目的编译过程提供了强大的扩展性，它使得我们可以用 C# 语言编写扩展；利用这种扩展性，我们可以为我们的项目定制一部分的编译细节。NuGet 为我们提供了一种自动导入 .props 和 .targets 的方法，同时还是一个 .NET 的包平台；我们可以利用 NuGet 发布我们的工具并自动启用这样的工具。制作这样的一个跨平台 NuGet 工具，我们能够为安装此工具的项目提供自动的但定制化的编译细节——例如自动生成版本号，自动生成某些中间文件等。本文更偏向于入门，只在帮助你一步一步地制作一个最简单的 NuGet 工具包，以体验和学习这个过程。然后我会在另一篇博客中完善其功能，做一个完整可用的 NuGet 工具。关于创建跨平台 NuGet 工具包的博客，我写了两篇。一篇介绍写基于 MSBuild Task 的 dll，一篇介绍写任意的命令行工具，可以是用于 .NET Framework 的 exe，也可以是基于 .NET Core 的 dll，甚至可以是使用本机工具链编译的平台相关的各种格式的命令行工具。内容是相似的但关键的坑不同。我分为两篇可以减少完成单个任务的理解难度： 如何创建一个基于 MSBuild Task 的跨平台的 NuGet 工具包 如何创建一个基于命令行工具的跨平台的 NuGet 工具包第零步：前置条件第一步：创建一个项目，用来写工具的核心逻辑为了方便制作跨平台的 NuGet 工具，新建项目时我们优先选用 .NET Core Library 项目或 .NET Standard Library 项目。紧接着，我们需要打开编辑此项目的 .csproj 文件，将目标框架改成多框架的，并填写必要的信息。&amp;lt;!-- Walterlv.NuGetTool.csproj --&amp;gt;&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;!-- 给一个初始的版本号。 --&amp;gt; &amp;lt;Version&amp;gt;1.0.0-alpha&amp;lt;/Version&amp;gt; &amp;lt;!-- 使用 .NET Framework 4.7 和 .NET Core 2.0。 要点 1： - 加入 net47 的支持是为了能让基于 .NET Framework 的 msbuild 能够使用此工具编译； - 加入 netcoreapp2.0 的支持是为了能让基于 .NET Core 的 dotnet build (Roslyn) 能够使用此工具编译； - 当然 net47 太新了，只适用于 Visual Studio 2017 的较新版本，如果你需要照顾到更多用户，建议使用 net46。 要点 2： 注意，我们使用 NuGet 包来依赖 Task 框架，但此 NuGet 包要求的最低 .NET Framework 版本为 4.6。 如果需要制作 .NET Framework 4.5 及以下版本，就必须改为引用以下程序集： - Microsoft.Build - Microsoft.Build.Framework - Microsoft.Build.Tasks.v4.0 - Microsoft.Build.Utilities.v4.0 --&amp;gt; &amp;lt;TargetFrameworks&amp;gt;net47;netcoreapp2.0&amp;lt;/TargetFrameworks&amp;gt; &amp;lt;!-- 这个就是创建项目时使用的名称。 --&amp;gt; &amp;lt;AssemblyName&amp;gt;Walterlv.NuGetTool&amp;lt;/AssemblyName&amp;gt; &amp;lt;!-- 此值设为 true，才会在编译之后生成 NuGet 包。 --&amp;gt; &amp;lt;GeneratePackageOnBuild&amp;gt;true&amp;lt;/GeneratePackageOnBuild&amp;gt; &amp;lt;!-- 作者的 Id，如果要发布到 nuget.org，那么这里就是 NuGet 用户 Id。 --&amp;gt; &amp;lt;Authors&amp;gt;walterlv&amp;lt;/Authors&amp;gt; &amp;lt;/PropertyGroup&amp;gt;&amp;lt;/Project&amp;gt;然后，安装如下 NuGet 包： Microsoft.Build.Framework: 提供了编写 ITask 的框架，有了这个才能写 ITask Microsoft.Build.Utilities.Core: 提供了 ITask 框架的基本实现，这样才能用更少的代码写完 Task要特别注意：由于我们是一个 NuGet 工具，不需要被其他项目直接依赖，所以此项目的依赖包不应该传递到下一个项目中。所以请将所有的 NuGet 包资产都声明成私有的，方法是在 NuGet 包的引用后面加上 PrivateAssets=&quot;All&quot;。想了解 PrivateAssets 的含义一起相关属性，可以阅读我的另一篇文章项目文件中的已知 NuGet 属性（使用这些属性，创建 NuGet 包就可以不需要 nuspec 文件啦） - 吕毅。&amp;lt;ItemGroup&amp;gt; &amp;lt;PackageReference Include=&quot;Microsoft.Build.Framework&quot; Version=&quot;15.6.85&quot; /&amp;gt; &amp;lt;PackageReference Include=&quot;Microsoft.Build.Utilities.Core&quot; Version=&quot;15.6.85&quot; /&amp;gt; &amp;lt;PackageReference Update=&quot;@(PackageReference)&quot; PrivateAssets=&quot;All&quot; /&amp;gt;&amp;lt;/ItemGroup&amp;gt;接下来就是取名字的时间了！为 Class1 类改一个名字。这个类将成为我们这个 NuGet 工具包的入口类。 比如我们想做一个用 Git 提交信息来生成版本号的类，可以叫做 GitVersion；想做一个生成多语言文件的类，可以叫做 LangGenerator。在这里，为了示范而不是真正的实现功能，我取名为 DemoTool。取好名字之后，让这个类继承自 Microsoft.Build.Utilities.Task：// DemoTool.csusing Microsoft.Build.Utilities;namespace Walterlv.NuGetTool{ public class DemoTool : Task { public override bool Execute() { return true; } }}这时进行编译，我们的 NuGet 包就会出现在项目的输出目录 bin\\Debug 下了。第二步：组织 NuGet 目录刚刚生成的 NuGet 包还不能真正拿来用。事实上你也可以拿去安装，不过最终的效果只是加了一个毫无作用的引用程序集而已（顺便还带来一堆垃圾的间接引用）。所以，我们需要进行“一番配置”，使得这个项目编译成一个NuGet 工具，而不是一个依赖包。现在，介绍一下 NuGet 预设的目录（如果你想看，可以去解压 .nupkg 文件）：// 根目录，用来放 readme.txt 的（已经有人提 issue 要求加入 markdown 支持了）+ /// 用来放引用程序集 .dll，文档注释 .xml 和符号文件 .pdb 的+ lib/// 用来放那些与平台相关的 .dll/.pdb/.pri 的+ runtimes/// 任意种类的文件，在这个文件夹中的文件会在编译时拷贝到输出目录（保持文件夹结构）+ content/// 这里放 .props 和 .targets 文件，会自动被 NuGet 导入，成为项目的一部分（要求文件名与包名相同）+ build/// 这里也是放 .props 和 .targets 文件，会自动被 NuGet 导入，成为项目的一部分（要求文件名与包名相同）+ buildMultiTargeting/// PowerShell 脚本或者程序，在这里的工具可以在“包管理控制台”(Package Manager Console) 中使用+ tools/▲ 以上结构可以去官网翻阅原文 How to create a NuGet package - Microsoft Docs，不过我这里额外写了一个预设目录 buildMultiTargeting，官方文档却没有说。 注意到我们的 csproj 文件中的 &amp;lt;TargetFrameworks&amp;gt; 节点吗？如果指定为单个框架，则自动导入的是 build 目录下的；如果指定为多个框架，则自动导入的是 buildMultiTargeting 目录下的。我们的初衷是做一个 NuGet 工具，所以我们需要选择合适的目录来存放我们的输出文件。我们要放一个 Walterlv.NuGetTool.targets 文件到 build 和 buildMultiTargeting 文件夹中，以便能够让我们定制编译流程。我们要让我们写的 dll（也就是那个 Task）能够工作，但是以上任何预定义的文件夹都不能满足我们的要求，于是我们建一个自定义的文件夹，取名为 tasks，这样 NuGet 便不会对我们的这个 dll 进行特殊处理，而将处理权全部交给我们。于是我们自己的目录结构为：+ build/ - Walterlv.NuGetTool.targets+ buildMultiTargeting/ - Walterlv.NuGetTool.targets+ tasks/ + net47/ - Walterlv.NuGetTool.dll + netcoreapp2.0/ - Walterlv.NuGetTool.dll- readme.txt那么，如何改造我们的项目才能够生成这样的 NuGet 目录结构呢？我们先在 Visual Studio 里建好文件夹：随后去编辑项目的 .csproj 文件，在最后的 &amp;lt;/Project&amp;gt; 前面添加下面这些项：&amp;lt;!-- Walterlv.NuGetTool.csproj --&amp;gt;&amp;lt;ItemGroup&amp;gt; &amp;lt;None Include=&quot;Assets\\build\\**&quot; Pack=&quot;True&quot; PackagePath=&quot;build\\&quot; /&amp;gt; &amp;lt;None Include=&quot;Assets\\buildMultiTargeting\\**&quot; Pack=&quot;True&quot; PackagePath=&quot;buildMultiTargeting\\&quot; /&amp;gt; &amp;lt;None Include=&quot;Assets\\readme.txt&quot; Pack=&quot;True&quot; PackagePath=&quot;&quot; /&amp;gt;&amp;lt;/ItemGroup&amp;gt;None 表示这一项要显示到 Visual Studio 解决方案中（其实对于不认识的文件，None 就是默认值）；Include 表示相对于项目文件的路径（支持通配符）；Pack 表示这一项要打包到 NuGet；PackagePath 表示这一项打包到 NuGet 中的路径。(如果你想了解更多 csproj 中的 NuGet 属性，可以阅读我的另一篇文章：项目文件中的已知 NuGet 属性（使用这些属性，创建 NuGet 包就可以不需要 nuspec 文件啦） - 吕毅)这样的一番设置，我们的 build、buildMultiTargeting 和 readme.txt 准备好了，但是 tasks 文件夹还没有。由于我们是把我们生成的 dll 放到 tasks 里面，第一个想到的当然是修改输出路径——然而这是不靠谱的，因为 NuGet 并不识别输出路径。事实上，我们还可以设置一个属性 &amp;lt;BuildOutputTargetFolder&amp;gt;，将值指定为 tasks，那么我们就能够将我们的输出文件打包到 NuGet 对应的 tasks 文件夹下了。至此，我们的 .csproj 文件看起来像如下这样（为了减少行数，我已经去掉了注释）：&amp;lt;!-- Walterlv.NuGetTool.csproj --&amp;gt;&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;Version&amp;gt;1.0.0-alpha&amp;lt;/Version&amp;gt; &amp;lt;AssemblyName&amp;gt;Walterlv.NuGetTool&amp;lt;/AssemblyName&amp;gt; &amp;lt;GeneratePackageOnBuild&amp;gt;true&amp;lt;/GeneratePackageOnBuild&amp;gt; &amp;lt;!-- ↓ 新增的属性 --&amp;gt; &amp;lt;BuildOutputTargetFolder&amp;gt;tasks&amp;lt;/BuildOutputTargetFolder&amp;gt; &amp;lt;!-- ↓ 新增的属性 --&amp;gt; &amp;lt;NoPackageAnalysis&amp;gt;true&amp;lt;/NoPackageAnalysis&amp;gt; &amp;lt;!-- ↓ 新增的属性 --&amp;gt; &amp;lt;DevelopmentDependency&amp;gt;true&amp;lt;/DevelopmentDependency&amp;gt; &amp;lt;Authors&amp;gt;walterlv&amp;lt;/Authors&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;PackageReference Include=&quot;Microsoft.Build.Framework&quot; Version=&quot;15.6.85&quot; /&amp;gt; &amp;lt;PackageReference Include=&quot;Microsoft.Build.Utilities.Core&quot; Version=&quot;15.6.85&quot; /&amp;gt; &amp;lt;!-- ↓ 在第一步中不要忘了这一行 --&amp;gt; &amp;lt;PackageReference Update=&quot;@(PackageReference)&quot; PrivateAssets=&quot;All&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;Folder Include=&quot;Assets\\tasks\\&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;!-- ↓ 新增的三项 --&amp;gt; &amp;lt;None Include=&quot;Assets\\build\\**&quot; Pack=&quot;True&quot; PackagePath=&quot;build\\&quot; /&amp;gt; &amp;lt;None Include=&quot;Assets\\buildMultiTargeting\\**&quot; Pack=&quot;True&quot; PackagePath=&quot;buildMultiTargeting\\&quot; /&amp;gt; &amp;lt;None Include=&quot;Assets\\readme.txt&quot; Pack=&quot;True&quot; PackagePath=&quot;&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt;&amp;lt;/Project&amp;gt;注意到我同时还在文件中新增了另外两个属性配置 NoPackageAnalysis 和 DevelopmentDependency。由于我们没有 lib 文件夹，所以 NuGet 会给出警告，NoPackageAnalysis 将阻止这个警告。DevelopmentDependency 是为了说明这是一个开发依赖，设置为 true 将阻止包作为依赖传递给下一个项目。（事实上这又是官方的一个骗局！因为新版本的 NuGet 竟然去掉了这个功能！，已经被吐槽了，详见：PackageReference should support DevelopmentDependency metadata · Issue #4125 · NuGet/Home）。关于这些属性更详细的解释，依然可以参见：项目文件中的已知 NuGet 属性（使用这些属性，创建 NuGet 包就可以不需要 nuspec 文件啦） - 吕毅。现在再尝试编译一下我们的项目，去输出目录下解压查看 nupkg 文件，你就能看到期望的 NuGet 文件夹结构了；建议一个个点进去看，你可以看到我们准备好的空的 Walterlv.NuGetTool.targets 文件，也能看到我们生成的 Walterlv.NuGetTool.dll。第三步：编写 Target.targets 文件是对项目功能进行扩展的关键文件，由于安装 NuGet 包会自动导入包中的此文件，所以它几乎相当于我们功能的入口。现在，我们需要徒手编写这个文件了。&amp;lt;!-- Assets\\build\\Walterlv.NuGetTool.targets --&amp;gt;&amp;lt;Project&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;!-- 我们使用 $(MSBuildRuntimeType) 来判断编译器是 .NET Core 的还是 .NET Framework 的。 然后选用对应的文件夹。--&amp;gt; &amp;lt;NuGetWalterlvTaskFolder Condition=&quot; &#39;$(MSBuildRuntimeType)&#39; == &#39;Core&#39;&quot;&amp;gt;$(MSBuildThisFileDirectory)..\\tasks\\netcoreapp2.0\\&amp;lt;/NuGetWalterlvTaskFolder&amp;gt; &amp;lt;NuGetWalterlvTaskFolder Condition=&quot; &#39;$(MSBuildRuntimeType)&#39; != &#39;Core&#39;&quot;&amp;gt;$(MSBuildThisFileDirectory)..\\tasks\\net47\\&amp;lt;/NuGetWalterlvTaskFolder&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;UsingTask TaskName=&quot;Walterlv.NuGetTool.DemoTool&quot; AssemblyFile=&quot;$(NuGetWalterlvTaskFolder)\\Walterlv.NuGetTool.dll&quot; /&amp;gt; &amp;lt;Target Name=&quot;WalterlvDemo&quot; BeforeTargets=&quot;CoreCompile&quot;&amp;gt; &amp;lt;DemoTool /&amp;gt; &amp;lt;/Target&amp;gt;&amp;lt;/Project&amp;gt;targets 的文件结构与 csproj 是一样的，你可以阅读我的另一篇文章 理解 C# 项目 csproj 文件格式的本质和编译流程 - 吕毅 了解其结构。上面的文件中，我们指定 Target 的执行时机为 CoreCompile 之前，也就是编译那些 .cs 文件之前。在这个时机，我们可以修改要编译的 .cs 文件。如果想了解更多关于 Target 执行时机或顺序相关的资料，可以阅读：Target Build Order。别忘了我们还有一个 buildMultiTargeting 文件夹，也要放一个几乎一样功能的 targets 文件；不过我们肯定不会傻到复制一个一样的。我们在 buildMultiTargeting 文件夹里的 targets 文件中写以下内容，这样我们的注意力便可以集中在前面的 targets 文件中了。&amp;lt;!-- Assets\\buildMultiTargeting\\Walterlv.NuGetTool.targets --&amp;gt;&amp;lt;Project&amp;gt; &amp;lt;!-- 直接 Import 我们在 build 中写的那个 targets 文件。 NuGet 留下了为多框架项目提供特殊扩展的方案，其实有时候也是很有用的。--&amp;gt; &amp;lt;Import Project=&quot;..\\build\\Walterlv.NuGetTool.targets&quot; /&amp;gt;&amp;lt;/Project&amp;gt;第四部：调试严格来说，写到这里，我们的跨平台 NuGet 工具已经写完了。在以上状态下，你只需要编译一下，就可以获得一个跨平台的基于 MSBuild Task 的 NuGet 工具。只是——你肯定会非常郁闷——心里非常没谱，这工具到底有没有工作起来！有没有按照我预期的进行工作！如果遇到了 Bug 怎么办！于是现在我们来掌握一些调试技巧，这样才方便我们一步步完善我们的功能嘛！额外插一句：以上第一到第三步几乎都是结构化的步骤，其实非常适合用工具来自动化完成的。让我们的 Target 能够正确找到我们新生成的 dll你应该注意到，我们的 targets 文件在 Assets\\build 目录下，而我们的 Assets 文件夹下并没有真实的 tasks 文件夹（里面是空的）。于是我们希望在调试状态下，dll 能够指向输出目录下。于是我们修改 targets 文件添加配置：&amp;lt;!-- Assets\\build\\Walterlv.NuGetTool.targets --&amp;gt;&amp;lt;Project&amp;gt; &amp;lt;PropertyGroup Condition=&quot; $(IsInDemoToolDebugMode) == &#39;True&#39; &quot;&amp;gt; &amp;lt;NuGetWalterlvTaskFolder Condition=&quot; &#39;$(MSBuildRuntimeType)&#39; == &#39;Core&#39;&quot;&amp;gt;$(MSBuildThisFileDirectory)..\\..\\bin\\$(Configuration)\\netcoreapp2.0\\&amp;lt;/NuGetWalterlvTaskFolder&amp;gt; &amp;lt;NuGetWalterlvTaskFolder Condition=&quot; &#39;$(MSBuildRuntimeType)&#39; != &#39;Core&#39;&quot;&amp;gt;$(MSBuildThisFileDirectory)..\\..\\bin\\$(Configuration)\\net47\\&amp;lt;/NuGetWalterlvTaskFolder&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;PropertyGroup Condition=&quot; $(IsInDemoToolDebugMode) != &#39;True&#39; &quot;&amp;gt; &amp;lt;NuGetWalterlvTaskFolder Condition=&quot; &#39;$(MSBuildRuntimeType)&#39; == &#39;Core&#39;&quot;&amp;gt;$(MSBuildThisFileDirectory)..\\tasks\\netcoreapp2.0\\&amp;lt;/NuGetWalterlvTaskFolder&amp;gt; &amp;lt;NuGetWalterlvTaskFolder Condition=&quot; &#39;$(MSBuildRuntimeType)&#39; != &#39;Core&#39;&quot;&amp;gt;$(MSBuildThisFileDirectory)..\\tasks\\net47\\&amp;lt;/NuGetWalterlvTaskFolder&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;UsingTask TaskName=&quot;Walterlv.NuGetTool.DemoTool&quot; AssemblyFile=&quot;$(NuGetWalterlvTaskFolder)\\Walterlv.NuGetTool.dll&quot; /&amp;gt; &amp;lt;Target Name=&quot;WalterlvDemo&quot; BeforeTargets=&quot;CoreCompile&quot;&amp;gt; &amp;lt;DemoTool /&amp;gt; &amp;lt;/Target&amp;gt;&amp;lt;/Project&amp;gt;这样，我们就拥有了一个可以供用户设置的属性 &amp;lt;IsInDemoToolDebugMode&amp;gt; 了。准备一个用于测试 Task 的测试项目接着，我们在解决方案中新建一个调试项目 Walterlv.Debug（我选用了 .NET Standard 2.0 框架）。然后在它的 csproj 中 &amp;lt;Import&amp;gt; 我们刚刚的 .targets 文件，并设置 &amp;lt;IsInDemoToolDebugMode&amp;gt; 属性为 True：&amp;lt;!-- Walterlv.Debug.csproj --&amp;gt;&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;TargetFramework&amp;gt;netstandard2.0&amp;lt;/TargetFramework&amp;gt; &amp;lt;IsInDemoToolDebugMode&amp;gt;True&amp;lt;/IsInDemoToolDebugMode&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;Import Project=&quot;..\\Walterlv.NuGetTool\\Assets\\build\\Walterlv.NuGetTool.targets&quot; /&amp;gt; &amp;lt;/Project&amp;gt;当准备好基本的调试环境之后，我们的解决方案看起来是下面这样的样子：让我们自定义的 Task 开始工作，并能够进入断点最简单能够让 DemoTool 这个自定义的 Task 进入断点的方式当然是加上 Debugger.Launch(); 了，就像这样：// DemoTool.csusing System.Diagnostics;using Microsoft.Build.Utilities;namespace Walterlv.NuGetTool{ public class DemoTool : Task { public override bool Execute() { // 新增了启动调试器的代码。 Debugger.Launch(); return true; } }}这样，一旦此函数开始执行，Windows 将显示一个选择调试器的窗口，我们选择当前打开的 Visual Studio 即可。当然，也有一些比较正统的方法，为了使这篇文章尽可能简单，我只附一张图，如果有需要，可以自己去尝试：现在，我们去 Walterlv.Debug 目录下输入 msbuild 命令，在输出到如下部分的时候，就会进入我们的断点了：这下，我们的调试环境就全部搭建好了，你可以发挥你的想象力在 Task 里面随意挥洒你的代码！当然，只要你记得去掉 Debugger.Launch();，或者加上 #if DEBUG 这样的条件编译，那么随时打包就是一个可以发布的跨平台 NuGet 工具包了。提示：一旦调试环境搭建好，你可能会遇到编译 Walterlv.NuGetTool 项目时，发现 dll 被占用的情况，这时，打开任务管理器结束掉 msbuild.exe 进行即可。第五步：发挥你的想象力想象力是没有限制的，不过如果不知道 Task 能够为我们提供到底什么样的功能，也是无从下手的。这一节我会说一些 Task 在 C# 代码和 .targets 文件中的互相操作。.targets 向 Task 传参数.targets 向 Task 传参数只需要写一个属性赋值的句子就可以了：&amp;lt;!-- Assets\\build\\Walterlv.NuGetTool.targets --&amp;gt;&amp;lt;Target Name=&quot;WalterlvDemo&quot; BeforeTargets=&quot;CoreCompile&quot;&amp;gt; &amp;lt;DemoTool IntermediateOutputPath=&quot;$(IntermediateOutputPath)&quot; /&amp;gt;&amp;lt;/Target&amp;gt;这里，$(IntermediateOutputPath) 是 msbuild 编译期间会自动设置的全局属性，代表此项目编译过程中临时文件的存放路径（也就是我们常见的 obj 文件夹）。当然，使用 dotnet build 或者 dotnet msbuild 也是有这样的全局属性的。我们为 &amp;lt;DemoTool&amp;gt; 节点也加了一个属性，名为 IntermediateOutputPath。在 DemoTool 的 C# 代码中，只需要写一个字符串属性即可接收这样的传参。// DemoTool.cspublic class DemoTool : Task{ public string IntermediateOutputPath { get; set; } public override bool Execute() { Debugger.Launch(); var intermediateOutputPath = IntermediateOutputPath; return true; }}▲ 在断点中我们能够看到传进来的参数的值你可以尽情发挥你的想象力，传入更多让人意想不到的参数，实现不可思议的功能。更多 MSBuild 全局参数，可以参考我的另一篇文章项目文件中的已知属性（知道了这些，就不会随便在 csproj 中写死常量啦） - 吕毅。Task 向 .targets 返回参数如果只是传入参数，那么我们顶多只能干一些不痛不痒的事情，或者就是两者互相约定了一些常量。什么？你说直接去改源代码？那万一你的代码不幸崩溃了，项目岂不被你破坏了！（当然，你去改了源码，还会破坏 MSBuild 的差量编译。）我们新定义一个属性，但在属性上面标记 [Output] 特性。这样，这个属性就会作为输出参数传到 .targets 里了。// DemoTool.csusing System.Diagnostics;using System.IO;using Microsoft.Build.Framework;using Microsoft.Build.Utilities;namespace Walterlv.NuGetTool{ public class DemoTool : Task { public string IntermediateOutputPath { get; set; } [Output] public string AdditionalCompileFile { get; set; } public override bool Execute() { Debugger.Launch(); var intermediateOutputPath = IntermediateOutputPath; var additional = Path.Combine(intermediateOutputPath, &quot;DoubiClass.cs&quot;); AdditionalCompileFile = Path.GetFullPath(additional); File.WriteAllText(AdditionalCompileFile, @&quot;using System;namespace Walterlv.Debug{ public class Doubi { public string Name { get; } private Doubi(string name) =&amp;gt; Name = name; public static Doubi Get() =&amp;gt; new Doubi(&quot;&quot;吕毅&quot;&quot;); }}&quot;); return true; } }}然后，我们在 .targets 里接收这个输出参数，生成一个属性：&amp;lt;!-- Assets\\build\\Walterlv.NuGetTool.targets --&amp;gt;&amp;lt;Target Name=&quot;WalterlvDemo&quot; BeforeTargets=&quot;CoreCompile&quot;&amp;gt; &amp;lt;DemoTool IntermediateOutputPath=&quot;$(IntermediateOutputPath)&quot;&amp;gt; &amp;lt;Output TaskParameter=&quot;AdditionalCompileFile&quot; PropertyName=&quot;WalterlvDemo_AdditionalCompileFile&quot; /&amp;gt; &amp;lt;/DemoTool&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;Compile Include=&quot;$(WalterlvDemo_AdditionalCompileFile)&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt;&amp;lt;/Target&amp;gt;这样，我们生成的 Walterlv.Debug 调试项目在编译完成之后，还会额外多出一个“逗比”类。而且——我们甚至能够直接在 Walterlv.Debug 项目的中使用这个编译中生成的新类。使用编译生成的新类既不会报错，也不会产生警告下划线，就像原生写的类一样。如果你要在编译期间替换一个类而不是新增一个类，例如将 Class1.cs 更换成新类，那么需要将其从编译列表中移除：&amp;lt;!-- Assets\\build\\Walterlv.NuGetTool.targets --&amp;gt;&amp;lt;ItemGroup&amp;gt; &amp;lt;Compile Remove=&quot;Class1.cs&quot; /&amp;gt; &amp;lt;Compile Include=&quot;$(WalterlvDemo_AdditionalCompileFile)&quot; /&amp;gt;&amp;lt;/ItemGroup&amp;gt;需要注意：编译期间才生成的项（&amp;lt;ItemGroup&amp;gt;）或者属性（&amp;lt;PropertyGroup&amp;gt;），需要写在 &amp;lt;Target&amp;gt; 节点的里面。如果写在外面，则不是编译期间生效的，而是始终生效的。当写在外面时，要特别留意可能某些属性没有初始化完全，你应该只使用那些肯定能确认存在的属性或文件。在 Target 里编写调试代码虽然说以上的每一个步骤我都是一边实操一边写的，但即便如此，本文都写了 500 多行了，如果你依然能够不出错地完成以上每一步，那也是万幸了！Task 里我能还能用断点调试，那么 Target 里面怎么办呢？我们可以用 &amp;lt;Message&amp;gt; 节点来输出一些信息：&amp;lt;!-- Assets\\build\\Walterlv.NuGetTool.targets --&amp;gt;&amp;lt;Target Name=&quot;WalterlvDemo&quot; BeforeTargets=&quot;CoreCompile&quot;&amp;gt; &amp;lt;DemoTool IntermediateOutputPath=&quot;$(IntermediateOutputPath)&quot;&amp;gt; &amp;lt;Output TaskParameter=&quot;AdditionalCompileFile&quot; PropertyName=&quot;WalterlvDemo_AdditionalCompileFile&quot; /&amp;gt; &amp;lt;/DemoTool&amp;gt; &amp;lt;Message Text=&quot;临时文件的路径为：$(WalterlvDemo_AdditionalCompileFile)&quot; /&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;Compile Include=&quot;$(WalterlvDemo_AdditionalCompileFile)&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt;&amp;lt;/Target&amp;gt;在 Task 输出错误或警告我们继承了 Microsoft.Build.Utilities.Task，此类有一个 Log 属性，可以用来输出信息。使用 LogWarning 方法可以输出警告，使用 LogError 可以输出错误。如果输出了错误，那么就会导致编译不通过。加入差量编译支持如果你觉得你自己写的 Task 执行非常耗时，那么建议加入差量编译的支持。关于加入差量编译，可以参考我的另一篇文章每次都要重新编译？太慢！让跨平台的 MSBuild/dotnet build 的 Target 支持差量编译。本地测试 NuGet 包在发布 NuGet 包之前，我们可以先在本地安装测试。由于我们在 C:\\Users\\lvyi\\Desktop\\Walterlv.NuGetTool\\Walterlv.NuGetTool\\bin\\Debug 输出路径下已经有了打包好的 nupkg 文件，所以可以加一个本地 NuGet 源。我们找一个其他的项目，然后在 Visual Studio 中设置 NuGet 源为我们那个 NuGet 工具项目的输出路径。这时安装，编译完之后，我们就会发现我们的项目生成的 dll 中多出了一个“逗比(Doubi)”类，并且可以在那个项目中编写使用 Doubi 的代码了。总结不得不说，制作一个跨平台的基于 MSBuild Task 的 NuGet 工具包还是比较麻烦的，我们总结一下： 准备项目的基本配置（设置各种必要的项目属性，安装必要的 NuGet 依赖） 建立好 NuGet 的文件夹结构 编写 Task 和 Target 新增功能、调试和测试如果你在实践的过程中遇到了各种问题，欢迎在下面留言，一般我会在一天之内给予回复。如果在阅读这篇文章时存在一些概念理解上的问题，或者不知道如何扩展本文的功能，可能需要阅读下我的另一些文章： 理解 C# 项目 csproj 文件格式的本质和编译流程 - 吕毅 项目文件中的已知属性（知道了这些，就不会随便在 csproj 中写死常量啦） - 吕毅 项目文件中的已知 NuGet 属性（使用这些属性，创建 NuGet 包就可以不需要 nuspec 文件啦） - 吕毅当然，还有一些正在编写，过一段时间可以阅读到。参考资料 docs.microsoft.com-nuget/Creating-a-Package.md at master · NuGet/docs.microsoft.com-nuget NuGet pack and restore as MSBuild targets - Microsoft Docs Bundling .NET build tools in NuGet Shipping a cross-platform MSBuild task in a NuGet package MSBuild Reserved and Well-Known Properties build process - How does MSBuild check whether a target is up to date or not? - Stack Overflow How to: Build Incrementally How To: Implementing Custom Tasks – Part I – MSBuild Team Blog Overwrite properties with MSBuild - Stack Overflow How to Access MSBuild properties inside custom task visual studio - How to get property value of a project file using msbuild - Stack Overflow davidfowl/NuGetPowerTools: A bunch of powershell modules that make it even easier to work with nuget MSBuild and Skipping target &quot;&amp;lt;TargetName&amp;gt;&quot; because it has no outputs - Stack Overflow WriteCodeFragment Task Don’t include dependencies from packages.config file when creating NuGet package - Stack Overflow NuGet 2.7 Release Notes - Microsoft Docs PackageReference should support DevelopmentDependency metadata · Issue #4125 · NuGet/Home debugging - How to debug MSBuild Customtask - Stack Overflow" }, { "title": "如何创建一个基于命令行工具的跨平台的 NuGet 工具包", "url": "/post/create-a-cross-platform-command-based-nuget-tool.html", "categories": "", "tags": "visualstudio, csharp, dotnet, msbuild", "date": "2019-08-07 14:50:52 +0800", "snippet": "命令行可是跨进程通信的一种非常方便的手段呢，只需启动一个进程传入一些参数即可完成一些很复杂的任务。NuGet 为我们提供了一种自动导入 .props 和 .targets 的方法，同时还是一个 .NET 的包平台；我们可以利用 NuGet 发布我们的工具并自动启用这样的工具。制作这样的一个跨平台 NuGet 工具，我们能够为安装此工具的项目提供自动的但定制化的编译细节——例如自动生成版本号，自动生成某些中间文件等。本文更偏向于入门，只在帮助你一步一步地制作一个最简单的 NuGet 工具包，以体验和学习这个过程。然后我会在另一篇博客中完善其功能，做一个完整可用的 NuGet 工具。关于创建跨平台 NuGet 工具包的博客，我写了两篇。一篇介绍写基于 MSBuild Task 的 dll，一篇介绍写任意的命令行工具，可以是用于 .NET Framework 的 exe，也可以是基于 .NET Core 的 dll，甚至可以是使用本机工具链编译的平台相关的各种格式的命令行工具。内容是相似的但关键的坑不同。我分为两篇可以减少完成单个任务的理解难度： 如何创建一个基于 MSBuild Task 的跨平台的 NuGet 工具包 如何创建一个基于命令行工具的跨平台的 NuGet 工具包第零步：前置条件第一步：创建一个项目，用来写工具的核心逻辑为了方便制作跨平台的 NuGet 工具，新建项目时我们优先选用 .NET Core 控制台项目。紧接着，我们需要打开编辑此项目的 .csproj 文件，填写必要的信息（尤其是 &amp;lt;GeneratePackageOnBuild&amp;gt;，确保编译时会生成 NuGet 包）。&amp;lt;!-- Walterlv.NuGetTool.csproj --&amp;gt;&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;!-- 输出为 exe（其实对于 .NET Core 依然是 dll，除非进行发布）。 --&amp;gt; &amp;lt;OutputType&amp;gt;Exe&amp;lt;/OutputType&amp;gt; &amp;lt;!-- 给一个初始的版本号。 --&amp;gt; &amp;lt;Version&amp;gt;1.0.0-alpha&amp;lt;/Version&amp;gt; &amp;lt;!-- 由于 .NET Core 本身即具备跨平台的特性，所以我们直接基于 .NET Core 开发 --&amp;gt; &amp;lt;TargetFramework&amp;gt;netcoreapp2.0&amp;lt;/TargetFramework&amp;gt; &amp;lt;!-- 这个就是创建项目时使用的名称。 --&amp;gt; &amp;lt;AssemblyName&amp;gt;Walterlv.NuGetTool&amp;lt;/AssemblyName&amp;gt; &amp;lt;!-- 此值设为 true，才会在编译之后生成 NuGet 包。 --&amp;gt; &amp;lt;GeneratePackageOnBuild&amp;gt;true&amp;lt;/GeneratePackageOnBuild&amp;gt; &amp;lt;!-- 作者的 Id，如果要发布到 nuget.org，那么这里就是 NuGet 用户 Id。 --&amp;gt; &amp;lt;Authors&amp;gt;walterlv&amp;lt;/Authors&amp;gt; &amp;lt;/PropertyGroup&amp;gt;&amp;lt;/Project&amp;gt;接下来随便在 Program.cs 里写什么代码，这取决于你希望这个 NuGet 工具做什么。using System;namespace Walterlv.NuGetTool{ class Program { static void Main(string[] args) { Console.WriteLine(&quot;Hello World!&quot;); } }}这时进行编译，我们的 NuGet 包就会出现在项目的输出目录 bin\\Debug 下了。第二步：组织 NuGet 目录刚刚生成的 NuGet 包还不能真正拿来用。事实上你也可以拿去安装，不过最终的效果只是加了一个毫无作用的引用程序集而已（事实上就是把你写的程序作为普通 dll 引用了）。所以，我们需要进行“一番配置”，使得这个项目编译成一个NuGet 工具，而不是一个依赖包。现在，介绍一下 NuGet 预设的目录（如果你想看，可以去解压 .nupkg 文件）：// 根目录，用来放 readme.txt 的（已经有人提 issue 要求加入 markdown 支持了）+ /// 用来放引用程序集 .dll，文档注释 .xml 和符号文件 .pdb 的+ lib/// 用来放那些与平台相关的 .dll/.pdb/.pri 的+ runtimes/// 任意种类的文件，在这个文件夹中的文件会在编译时拷贝到输出目录（保持文件夹结构）+ content/// 这里放 .props 和 .targets 文件，会自动被 NuGet 导入，成为项目的一部分（要求文件名与包名相同）+ build/// 这里也是放 .props 和 .targets 文件，会自动被 NuGet 导入，成为项目的一部分（要求文件名与包名相同）+ buildMultiTargeting/// PowerShell 脚本或者程序，在这里的工具可以在“包管理控制台”(Package Manager Console) 中使用+ tools/▲ 以上结构可以去官网翻阅原文 How to create a NuGet package - Microsoft Docs，不过我这里额外写了一个预设目录 buildMultiTargeting，官方文档却没有说。 注意到我们的 csproj 文件中的 &amp;lt;TargetFrameworks&amp;gt; 节点吗？如果指定为单个框架，则自动导入的是 build 目录下的；如果指定为多个框架，则自动导入的是 buildMultiTargeting 目录下的。我们的初衷是做一个 NuGet 工具，所以我们需要选择合适的目录来存放我们的输出文件。我们要放一个 Walterlv.NuGetTool.targets 文件到 build 和 buildMultiTargeting 文件夹中，以便能够让我们定制编译流程。我们要让我们写的 .NET Core 工具程序能够工作，所以我们将生成的输出程序放到 tools 目录下。于是我们自己的目录结构为：+ build/ - Walterlv.NuGetTool.targets+ buildMultiTargeting/ - Walterlv.NuGetTool.targets+ tools/ + netcoreapp2.0/ - Walterlv.NuGetTool.dll- readme.txt提醒一下，.NET Core 生成的程序，如果没有针对特定平台发布，输出的是 dll。那么，如何改造我们的项目才能够生成这样的 NuGet 目录结构呢？我们先在 Visual Studio 里建好文件夹：随后去编辑项目的 .csproj 文件，在最后的 &amp;lt;/Project&amp;gt; 前面添加下面这些项：&amp;lt;!-- Walterlv.NuGetTool.csproj --&amp;gt;&amp;lt;ItemGroup&amp;gt; &amp;lt;None Include=&quot;Assets\\build\\**&quot; Pack=&quot;True&quot; PackagePath=&quot;build\\&quot; /&amp;gt; &amp;lt;None Include=&quot;Assets\\buildMultiTargeting\\**&quot; Pack=&quot;True&quot; PackagePath=&quot;buildMultiTargeting\\&quot; /&amp;gt; &amp;lt;None Include=&quot;Assets\\readme.txt&quot; Pack=&quot;True&quot; PackagePath=&quot;&quot; /&amp;gt;&amp;lt;/ItemGroup&amp;gt;None 表示这一项要显示到 Visual Studio 解决方案中（其实对于不认识的文件，None 就是默认值）；Include 表示相对于项目文件的路径（支持通配符）；Pack 表示这一项要打包到 NuGet；PackagePath 表示这一项打包到 NuGet 中的路径。(如果你想了解更多 csproj 中的 NuGet 属性，可以阅读我的另一篇文章：项目文件中的已知 NuGet 属性（使用这些属性，创建 NuGet 包就可以不需要 nuspec 文件啦） - 吕毅)这样的一番设置，我们的 build、buildMultiTargeting 和 readme.txt 准备好了，但是 tools 文件夹还没有。由于我们是把我们生成的命令行工具放到 tools 里面，第一个想到的当然是修改输出路径——然而这是不靠谱的，因为 NuGet 并不识别输出路径。事实上，我们还可以设置一个属性 &amp;lt;BuildOutputTargetFolder&amp;gt;，将值指定为 tools，那么我们就能够将我们的输出文件打包到 NuGet 对应的 tools 文件夹下了。至此，我们的 .csproj 文件看起来像如下这样（为了减少行数，我已经去掉了注释）：&amp;lt;!-- Walterlv.NuGetTool.csproj --&amp;gt;&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;Version&amp;gt;1.0.0-alpha&amp;lt;/Version&amp;gt; &amp;lt;AssemblyName&amp;gt;Walterlv.NuGetTool&amp;lt;/AssemblyName&amp;gt; &amp;lt;GeneratePackageOnBuild&amp;gt;true&amp;lt;/GeneratePackageOnBuild&amp;gt; &amp;lt;!-- ↓ 新增的属性 --&amp;gt; &amp;lt;BuildOutputTargetFolder&amp;gt;tools&amp;lt;/BuildOutputTargetFolder&amp;gt; &amp;lt;!-- ↓ 新增的属性 --&amp;gt; &amp;lt;NoPackageAnalysis&amp;gt;true&amp;lt;/NoPackageAnalysis&amp;gt; &amp;lt;!-- ↓ 新增的属性 --&amp;gt; &amp;lt;DevelopmentDependency&amp;gt;true&amp;lt;/DevelopmentDependency&amp;gt; &amp;lt;Authors&amp;gt;walterlv&amp;lt;/Authors&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;Folder Include=&quot;Assets\\tools\\&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;!-- ↓ 新增的三项 --&amp;gt; &amp;lt;None Include=&quot;Assets\\build\\**&quot; Pack=&quot;True&quot; PackagePath=&quot;build\\&quot; /&amp;gt; &amp;lt;None Include=&quot;Assets\\buildMultiTargeting\\**&quot; Pack=&quot;True&quot; PackagePath=&quot;buildMultiTargeting\\&quot; /&amp;gt; &amp;lt;None Include=&quot;Assets\\readme.txt&quot; Pack=&quot;True&quot; PackagePath=&quot;&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt;&amp;lt;/Project&amp;gt;注意到我同时还在文件中新增了另外两个属性配置 NoPackageAnalysis 和 DevelopmentDependency。由于我们没有 lib 文件夹，所以 NuGet 会给出警告，NoPackageAnalysis 将阻止这个警告。DevelopmentDependency 是为了说明这是一个开发依赖，设置为 true 将阻止包作为依赖传递给下一个项目。（事实上这又是官方的一个骗局！因为新版本的 NuGet 竟然去掉了这个功能！，已经被吐槽了，详见：PackageReference should support DevelopmentDependency metadata · Issue #4125 · NuGet/Home）。关于这些属性更详细的解释，依然可以参见：项目文件中的已知 NuGet 属性（使用这些属性，创建 NuGet 包就可以不需要 nuspec 文件啦） - 吕毅。现在再尝试编译一下我们的项目，去输出目录下解压查看 nupkg 文件，你就能看到期望的 NuGet 文件夹结构了；建议一个个点进去看，你可以看到我们准备好的空的 Walterlv.NuGetTool.targets 文件，也能看到我们生成的 Walterlv.NuGetTool.dll。第三步：编写 Target.targets 文件是对项目功能进行扩展的关键文件，由于安装 NuGet 包会自动导入包中的此文件，所以它几乎相当于我们功能的入口。现在，我们需要徒手编写这个文件了。&amp;lt;!-- Assets\\build\\Walterlv.NuGetTool.targets --&amp;gt;&amp;lt;Project&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;NuGetWalterlvToolPath&amp;gt;$(MSBuildThisFileDirectory)..\\tools\\netcoreapp2.0\\Walterlv.NuGetTool.dll&amp;lt;/NuGetWalterlvToolPath&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;Target Name=&quot;WalterlvDemo&quot; BeforeTargets=&quot;CoreCompile&quot;&amp;gt; &amp;lt;Exec Command=&quot;dotnet $(NuGetWalterlvToolPath)&quot; /&amp;gt; &amp;lt;/Target&amp;gt;&amp;lt;/Project&amp;gt;targets 的文件结构与 csproj 是一样的，你可以阅读我的另一篇文章 理解 C# 项目 csproj 文件格式的本质和编译流程 - 吕毅 了解其结构。上面的文件中，我们指定 Target 的执行时机为 CoreCompile 之前，也就是编译那些 .cs 文件之前。在这个时机，我们可以修改要编译的 .cs 文件。如果想了解更多关于 Target 执行时机或顺序相关的资料，可以阅读：Target Build Order。别忘了我们还有一个 buildMultiTargeting 文件夹，也要放一个几乎一样功能的 targets 文件；不过我们肯定不会傻到复制一个一样的。我们在 buildMultiTargeting 文件夹里的 targets 文件中写以下内容，这样我们的注意力便可以集中在前面的 targets 文件中了。&amp;lt;!-- Assets\\buildMultiTargeting\\Walterlv.NuGetTool.targets --&amp;gt;&amp;lt;Project&amp;gt; &amp;lt;!-- 直接 Import 我们在 build 中写的那个 targets 文件。 NuGet 留下了为多框架项目提供特殊扩展的方案，其实有时候也是很有用的。--&amp;gt; &amp;lt;Import Project=&quot;..\\build\\Walterlv.NuGetTool.targets&quot; /&amp;gt;&amp;lt;/Project&amp;gt;第四部：调试严格来说，写到这里，我们的跨平台 NuGet 工具已经写完了。在以上状态下，你只需要编译一下，就可以获得一个跨平台的基于 MSBuild Task 的 NuGet 工具。只是——你肯定会非常郁闷——心里非常没谱，这工具到底有没有工作起来！有没有按照我预期的进行工作！如果遇到了 Bug 怎么办！于是现在我们来掌握一些调试技巧，这样才方便我们一步步完善我们的功能嘛！额外插一句：以上第一到第三步几乎都是结构化的步骤，其实非常适合用工具来自动化完成的。让我们的 Target 能够正确找到我们新生成的 dll你应该注意到，我们的 targets 文件在 Assets\\build 目录下，而我们的 Assets 文件夹下并没有真实的 tools 文件夹（里面是空的）。于是我们希望在调试状态下，dll 能够指向输出目录下。于是我们修改 targets 文件添加配置：&amp;lt;!-- Assets\\build\\Walterlv.NuGetTool.targets --&amp;gt;&amp;lt;Project&amp;gt; &amp;lt;PropertyGroup Condition=&quot; $(IsInDemoToolDebugMode) == &#39;True&#39; &quot;&amp;gt; &amp;lt;NuGetWalterlvToolPath&amp;gt;$(MSBuildThisFileDirectory)..\\..\\bin\\$(Configuration)\\netcoreapp2.0\\Walterlv.NuGetTool.dll&amp;lt;/NuGetWalterlvToolPath&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;PropertyGroup Condition=&quot; $(IsInDemoToolDebugMode) != &#39;True&#39; &quot;&amp;gt; &amp;lt;NuGetWalterlvToolPath&amp;gt;$(MSBuildThisFileDirectory)..\\tools\\netcoreapp2.0\\Walterlv.NuGetTool.dll&amp;lt;/NuGetWalterlvToolPath&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;Target Name=&quot;WalterlvDemo&quot; BeforeTargets=&quot;CoreCompile&quot;&amp;gt; &amp;lt;Exec Command=&quot;dotnet $(NuGetWalterlvToolPath)&quot; /&amp;gt; &amp;lt;/Target&amp;gt;&amp;lt;/Project&amp;gt;这样，我们就拥有了一个可以供用户设置的属性 &amp;lt;IsInDemoToolDebugMode&amp;gt; 了。准备一个用于测试此命令行工具的测试项目接着，我们在解决方案中新建一个调试项目 Walterlv.Debug（我选用了 .NET Standard 2.0 框架）。然后在它的 csproj 中 &amp;lt;Import&amp;gt; 我们刚刚的 .targets 文件，并设置 &amp;lt;IsInDemoToolDebugMode&amp;gt; 属性为 True：&amp;lt;!-- Walterlv.Debug.csproj --&amp;gt;&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;TargetFramework&amp;gt;netstandard2.0&amp;lt;/TargetFramework&amp;gt; &amp;lt;IsInDemoToolDebugMode&amp;gt;True&amp;lt;/IsInDemoToolDebugMode&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;Import Project=&quot;..\\Walterlv.NuGetTool\\Assets\\build\\Walterlv.NuGetTool.targets&quot; /&amp;gt; &amp;lt;/Project&amp;gt;当准备好基本的调试环境之后，我们的解决方案看起来是下面这样的样子：调试命令行项目为了保持根兄弟文章的结构一致，我依然保留了“调试项目”这一部分内容，但其实大家都懂，不是吗？—— 一个控制台程序，谁不会调试啊！！！但是——如果你希望能够在 MSBuild 或者 dotnet build 的环境下调试，就会发现，普通的调试方法并不能得到这样的环境——例如项目特定的参数。加一句 Debugger.Launch(); 是最简单的方法了。// Program.csusing System;using System.Diagnostics;namespace Walterlv.NuGetTool{ class Program { static void Main(string[] args) { // 新增了启动调试器的代码。 Debugger.Launch(); Console.WriteLine(&quot;Hello World!&quot;); } }}这样，在使用 msbuild 或者 dotnet build 时，就会弹出一个调试器选择界面。当然，也有一些比较正统的方法，为了使这篇文章尽可能简单，我只附一张图，如果有需要，可以自己去尝试：现在，即使我们去 Walterlv.Debug 目录下输入 msbuild 命令或 dotnet build 命令，也能进入我们的断点了：第五步：发挥你的想象力想象力是没有限制的，我们只需要在 .targets 文件里面向我们的控制台程序传入合适的参数，即可完成非常多的功能。.targets 向控制台程序传参数.targets 向控制台程序传参数只需要按照普通控制台程序传参的方式就可以了：&amp;lt;!-- Assets\\build\\Walterlv.NuGetTool.targets --&amp;gt;&amp;lt;Target Name=&quot;WalterlvDemo&quot; BeforeTargets=&quot;CoreCompile&quot;&amp;gt; &amp;lt;Exec Command=&quot;dotnet $(NuGetWalterlvToolPath) -i $(IntermediateOutputPath)&quot; /&amp;gt;&amp;lt;/Target&amp;gt;这里，$(IntermediateOutputPath) 是 msbuild 编译期间会自动设置的全局属性，代表此项目编译过程中临时文件的存放路径（也就是我们常见的 obj 文件夹）。当然，使用 dotnet build 或者 dotnet msbuild 也是有这样的全局属性的。在 Program.cs 中，只需要解析命令行参数即可接收这样的传参。// Program.csusing System;using System.Diagnostics;namespace Walterlv.NuGetTool{ class Program { static void Main(string[] args) { Debugger.Launch(); var intermediateOutputPath = args[1]; Console.WriteLine(&quot;Hello World!&quot;); } }}你可以尽情发挥你的想象力，传入更多让人意想不到的参数，实现不可思议的功能。更多 MSBuild 全局参数，可以参考我的另一篇文章项目文件中的已知属性（知道了这些，就不会随便在 csproj 中写死常量啦） - 吕毅。需要注意，控制台传参数是有字符数量限制的，要解决传参字符数量限制问题，可以参考 Roslyn 使用 WriteLinesToFile 解决参数过长无法传入。控制台程序向 .targets 返回数据控制台程序的输出（也就是 Console.WriteLine() 那个）是能够直接和 MSBuild 的 Target 进行数据交换的。有两种不同的方式： 直接传数据，这些数据可以被捕获成属性或者项，具体可以阅读我的另一篇博客： 如何使用 MSBuild Target（Exec）中的控制台输出 报告编译警告和编译错误，具体可以阅读我的另一篇博客： 如何在 MSBuild Target（Exec）中报告编译错误和编译警告 使用命令执行完之后的结果如果只是传入参数，那么我们顶多只能干一些不痛不痒的事情，我们应该使用我们的控制台程序做一些什么。什么？你说直接去改源代码？那万一你的代码不幸崩溃了，项目岂不被你破坏了！（当然，你去改了源码，还会破坏 MSBuild 的差量编译。）所以，我们应该建立一种约定，要求控制台程序生成一些什么，然后在 .targets 里面取出使用。// Program.csusing System;using System.Diagnostics;using System.IO;namespace Walterlv.NuGetTool{ class Program { static void Main(string[] args) { Debugger.Launch(); var additionalCompileFile = args[1]; File.WriteAllText(additionalCompileFile, @&quot;using System;namespace Walterlv.Debug{ public class Doubi { public string Name { get; } private Doubi(string name) =&amp;gt; Name = name; public static Doubi Get() =&amp;gt; new Doubi(&quot;&quot;吕毅&quot;&quot;); }}&quot;); Console.WriteLine(&quot;Hello World!&quot;); } }}然后，我们需要在 .targets 文件里接收这个输出参数。然而命令行调用与 如何创建一个基于 MSBuild Task 的跨平台的 NuGet 工具包 - 吕毅 中所写的 Task 不同，命令行调用的后面是不能够立刻应用命令行调用的结果的，因为此时命令还没有结束。所以我们需要写一个新的 Target，来使用命令行程序执行后的结果。&amp;lt;!-- Assets\\build\\Walterlv.NuGetTool.targets --&amp;gt;&amp;lt;Target Name=&quot;WalterlvDemo&quot; BeforeTargets=&quot;CoreCompile&quot;&amp;gt; &amp;lt;Exec Command=&quot;dotnet $(NuGetWalterlvToolPath) -i $(IntermediateOutputPath)Doubi.cs&quot; /&amp;gt;&amp;lt;/Target&amp;gt;&amp;lt;Target Name=&quot;WalterlvDemoUseResult&quot; AfterTargets=&quot;WalterlvDemo&quot; BeforeTargets=&quot;CoreCompile&quot;&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;Compile Include=&quot;$(IntermediateOutputPath)Doubi.cs&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt;&amp;lt;/Target&amp;gt;这样，我们生成的 Walterlv.Debug 调试项目在编译完成之后，还会额外多出一个“逗比”类。而且——我们甚至能够直接在 Walterlv.Debug 项目的中使用这个编译中生成的新类。使用编译生成的新类既不会报错，也不会产生警告下划线，就像原生写的类一样。如果你要在编译期间替换一个类而不是新增一个类，例如将 Class1.cs 更换成新类，那么需要将其从编译列表中移除：&amp;lt;!-- Assets\\build\\Walterlv.NuGetTool.targets --&amp;gt;&amp;lt;ItemGroup&amp;gt; &amp;lt;Compile Remove=&quot;Class1.cs&quot; /&amp;gt; &amp;lt;Compile Include=&quot;$(IntermediateOutputPath)Doubi.cs&quot; /&amp;gt;&amp;lt;/ItemGroup&amp;gt;需要注意：编译期间才生成的项（&amp;lt;ItemGroup&amp;gt;）或者属性（&amp;lt;PropertyGroup&amp;gt;），需要写在 &amp;lt;Target&amp;gt; 节点的里面。如果写在外面，则不是编译期间生效的，而是始终生效的。当写在外面时，要特别留意可能某些属性没有初始化完全，你应该只使用那些肯定能确认存在的属性或文件。加入差量编译支持在本文的例子中，当你每次编译时，虽然核心的编译流程不怎么耗时，不过那个命令却是每次都执行。如果你觉得此命令的执行非常耗时，那么建议加入差量编译的支持。关于加入差量编译，可以参考我的另一篇文章每次都要重新编译？太慢！让跨平台的 MSBuild/dotnet build 的 Target 支持差量编译。本地测试 NuGet 包在发布 NuGet 包之前，我们可以先在本地安装测试。由于我们在 C:\\Users\\lvyi\\Desktop\\Walterlv.NuGetTool\\Walterlv.NuGetTool\\bin\\Debug 输出路径下已经有了打包好的 nupkg 文件，所以可以加一个本地 NuGet 源。我们找一个其他的项目，然后在 Visual Studio 中设置 NuGet 源为我们那个 NuGet 工具项目的输出路径。这时安装，编译完之后，我们就会发现我们的项目生成的 dll 中多出了一个“逗比(Doubi)”类，并且可以在那个项目中编写使用 Doubi 的代码了。总结制作一个跨平台的基于控制台的 NuGet 工具包虽然无关步骤比较多，但总体还算不太难，我们总结一下： 准备项目的基本配置（设置各种必要的项目属性） 建立好 NuGet 的文件夹结构 编写 Target 新增功能、调试和测试如果你在实践的过程中遇到了各种问题，欢迎在下面留言，一般我会在一天之内给予回复。如果在阅读这篇文章时存在一些概念理解上的问题，或者不知道如何扩展本文的功能，可能需要阅读下我的另一些文章： 理解 C# 项目 csproj 文件格式的本质和编译流程 - 吕毅 项目文件中的已知属性（知道了这些，就不会随便在 csproj 中写死常量啦） - 吕毅 项目文件中的已知 NuGet 属性（使用这些属性，创建 NuGet 包就可以不需要 nuspec 文件啦） - 吕毅当然，还有一些正在编写，过一段时间可以阅读到。参考资料 docs.microsoft.com-nuget/Creating-a-Package.md at master · NuGet/docs.microsoft.com-nuget NuGet pack and restore as MSBuild targets - Microsoft Docs Bundling .NET build tools in NuGet MSBuild Reserved and Well-Known Properties build process - How does MSBuild check whether a target is up to date or not? - Stack Overflow How to: Build Incrementally Exec Task Overwrite properties with MSBuild - Stack Overflow visual studio - How to get property value of a project file using msbuild - Stack Overflow davidfowl/NuGetPowerTools: A bunch of powershell modules that make it even easier to work with nuget [MSBuild and Skipping target “&quot; because it has no outputs - Stack Overflow](https://stackoverflow.com/q/27377095/6233938) Don’t include dependencies from packages.config file when creating NuGet package - Stack Overflow NuGet 2.7 Release Notes - Microsoft Docs PackageReference should support DevelopmentDependency metadata · Issue #4125 · NuGet/Home" }, { "title": "好的框架需要好的 API 设计 —— API 设计的六个原则", "url": "/post/framework-api-design.html", "categories": "", "tags": "dotnet, framework", "date": "2019-08-05 12:20:04 +0800", "snippet": "说到框架设计，打心底都会觉得很大很宽泛，而 API 设计是框架设计中的重要组成部分。相比于有很多大佬都认可的面向对象的六大原则、23 种常见的设计模式来说，API 设计确实缺少行业公认的原则或者说设计范式。不过，没有公认不代表没有。无论是对外提供类库还是提供 url 形式的 API，为了使用者良好的使用体验，依然也是有可以借鉴和参考的经验的。This post is written in multiple languages. Please select yours: 中文 English 本文中的 API 设计原则在主要思想上出自 NetBeans 创始人 Jaroslav Tulach 所著的 Practical API Design 一书；但原书讲述的所有内容很零散，缺乏系统性。所以我们结合了一些开源项目的 API 升级方式对内容进行了整理，形成六个原则。API 是什么？如果要解释 API 这个英文缩写，那一定要说出它的英文原文来：Application Programming Interface，即应用编程接口。虽然维基百科上有它的定义，不过还是太复杂了。在 .NET 中，我们认为 API 包括了所有公开的类、接口、属性、字段、方法，以及类库提供的配置文件（包括格式）、协议等。API 设计原则即便没有学习过任何 API 设计，也没有阅读过设计或重构相关的书籍，只要你有一些编程经验，应该都能够或多或少地评估一组 API 设计得是好是坏。因为——我们都是 API 的使用者，用的 API 多了，也便能体会到各种不同 API 带给我们的不同体验。我们团队的几个小伙伴开撕之后，写出了以下文辞： 我（吕毅）说：在 API 设计原则里面，无法写出错误代码是为上策，写错了会出现异常次之，仅靠文档约束为下策，连约束都没有只剩坑的需祭天。 头像大人云：故上码伐编译，其次伐异常，其次伐文档，其下祭天。祭天之法，为不得已。所以，在下面总结的 API 设计原则中，前面四个都是站在使用者的角度来考虑的。可理解性通常使用者希望使用到某个 API 的时候，为了正确使用这个 API，需要学习一些与这个 API 相关的新知识。而需要新学习的知识越多，我们认为“可理解性”就越低。为了提升 API 的可理解性，我们在设计 API 的时候建议考虑这些因素： 如果没有必要，不要引入新的概念 防止误用 最好能够避免使用者写出错误的代码（即让错误的代码编译不通过） 如果上面那一条有些难度，则建议在运行时抛出异常（使用者便能够明白为什么自己写错了，改怎么更正） 另外，最好让错误使用的代码变丑（例如非常冗长难以理解，例如 IDE 会显示下划线警告） 不要试图在文档中警告使用者用错了，因为典型的程序员是不看文档的 关于防止误用的一个优秀案例，要属单元测试模拟 Moq 了；可以参考 Moq 基础系列教程 并上手编写，体验它对防止误用上做出的努力。可见性我们大多数人的开发工具是功能齐全，傻瓜也能使用的 IDE（集成开发环境），这其实是 IDE 可理解性较好的一个体现。不过这里要说的是 IDE 的智能感知提示功能；就算没有 IDE，一些常见的代码编辑工具（Visual Studio Code、Sublime、Atom、Notepad++、Vim）也都带有只能感知提示功能。在智能感知提示的帮助下，我们能够在不查阅文档的情况之下了解到当前上下文相关的 API 说明及其简易的使用提示。如果我们只通过智能感知提示便能够发现一个新 API 并正确使用它，便可以说这个 API 的可见性是好的。典型的例子是实现或者调用某个函数过程： 实现某个函数的时候，函数的参数类型本来并没有见过，但通过智能感知提示我们能够了解到这个新 API 并正确取到参数中我们期望得到的信息。 调用某个函数的时候，我们需要传入本来并没有见过的参数类型，通过智能感知提示，我们能够知道如何构造或获取这些类型然后正确传进去。 调用完某个函数后我们得到了返回值，我们本来并没有见过这个类型，但通过智能感知提示，我们能够学习到这个新的类型，并知道如何正确使用这个返回值。如果画一个图来表示较高的可见性和较低的可见性，我想可以画成这样：▲ 连接线表示可以通过函数的参数、返回值等得知的新 API左侧的 API 没有什么规律，知道什么或者不知道什么全凭经验而定。右侧的 API 从入门 API 开始，可以发现可见性较高的其他相关 API；当更深入地使用后，可能可以发现更高级别（通常也更难正确使用）的 API。当然，并不是说可见性越高越好，如果某些 API 是用来完成某些高级功能，或者这个 API 存在较大的性能开销等，为了避免初学者混淆或者误用，应该适当降低其可见性。为了更好的可见性，简易在 API 设计的时候： 对于多数常用功能，尽量少提供独立的类； 对于高级功能，尽量与简单功能隔离。一致性当多个相似功能的 API 之间有相似的使用方法时，使用者只需要很少的迁移成本便可以轻松学会新 API 的正确用法。比如 LINQ 带来了集合的便捷操作，其中的 Select 方法用于查找和转换集合每一项的信息。而 LINQ to XML 虽然不是在操作集合而是在操作 XML，但其也有 Select 等方法完成节点的查找和选择。于是，使用者可以通过智能感知提示大致了解到 Select/SelectSingleNode 的基本正确用法。这便是良好的一致性带来的快速入门体验。简单性可能有些 API 在经过修改满足了以上可理解性、可见性、一致性之后，极有可能导致一个类或者一组相关类包含了太多方法可用。于是，简单而正确的使用可能就隐藏在众多的 API 中。当然，从面向对象的原则中我们可以说这通常违反了“单一职责原则”。简单的任务应该有简单的实现，这是 API 设计中简单性应该做到的。这意味着 API 在提供了灵活的功能之后，建议为常用的任务提供更简单的调用方式。例如，InkCanvas 只需要添加下面这样的 XAML 便可完成书写功能：&amp;lt;InkCanvas x:Name=&quot;inkCanvas&quot; /&amp;gt;虽然可以进行更多的定制，但是这不是必须的，更多的定制是属于更高级的功能需求的： // 以下源码来自 https://docs.microsoft.com/en-us/windows/uwp/design/input/pen-and-stylus-interactions // Set supported inking device types.inkCanvas.InkPresenter.InputDeviceTypes = Windows.UI.Core.CoreInputDeviceTypes.Mouse | Windows.UI.Core.CoreInputDeviceTypes.Pen;// Set initial ink stroke attributes.InkDrawingAttributes drawingAttributes = new InkDrawingAttributes();drawingAttributes.Color = Windows.UI.Colors.Black;drawingAttributes.IgnorePressure = false;drawingAttributes.FitToCurve = true;inkCanvas.InkPresenter.UpdateDefaultDrawingAttributes(drawingAttributes); 可测性API 内部本身需要被测试（单元测试、基准测试等）；然而，API 的使用者也应该具备可测性。典型的反例，比如获取某个配置文件的配置信息的方法是静态方法 Config.Get(&quot;SomeKey&quot;)。那么使用这个 API 的开发者就很难写出能够被单元测试的方法，因为找不到有效的方案来模拟这样的静态方法。兼容性良好的 API 设计利于未来的版本升级——升级带来的用户兼容性成本较低，或者框架开发者的兼容性包袱较轻。兼容性有三类： 二进制兼容：更新库后，无需重新编译项目，能够直接运行而不会崩溃。 源码兼容：更新库后，可以不用修改项目的源代码可编译通过。 功能兼容：更新库后，功能表现依旧和更新之前一样。为了将来的兼容性考虑，设计 API 时建议考虑这些因素： 不要提前公开 API 如果你的某个 API 是为将来预留的，那么不要开放，因为你不清楚未来的设计需求是怎样的，提前公开的 API 在将来改变的可能性非常高） 预留足够的扩展点 没有良好扩展性的 API 通常会因为频繁的需求变更而导致 API 间接变化，这都是兼容性成本。如果在良好的设计下预留了足够的扩展点，那么这样的 API 能够应对未来一段时间内未知的需求变化，使得 API 变化在可控范围内。 要预留扩展点就意味着通常应该使用接口或者抽象的概念来描述 API，建议用清晰定位的接口替代具体的类型。 应该有明确的 API 迁移说明 如果某个 API 过时了，也不建议删除它；应该标记为过时，并告诉使用者新的 API 是什么。当然如果这个 API 会导致出现不可接受的问题，也可以标记它无法通过编译。 框架设计Practical API Design 一书认为框架和 API 是等同的。不过从实际行业上的描述来看，框架是更大层面的 API，可以理解为用于完整解决某类问题而开发的一整套 API。框架的概念可以很大，也可以很小。Avalonia 可以称为一个跨平台的 UI 框架，这是很大的框架；其中的 ReactiveUI 是一个 UI 响应框架（包含 MVVM）。更小的可以有一套多语言框架、一套依赖注入框架等。实践以上总结的六个原则，我们也许能设计出更多优秀的框架。参考资料 Practical API Design, NetBeans 创始人 Jaroslav Tulach 著" }, { "title": "通过 mklink 收集本地文件系统的所有 NuGet 包输出目录来快速调试公共组件代码", "url": "/post/collect-nuget-output-folder-for-fast-package-debugging.html", "categories": "", "tags": "dotnet, csharp, msbuild, visualstudio, nuget", "date": "2019-08-04 21:17:27 +0800", "snippet": "我们做的公共库可能通过 nuget.org 发布，也可能是自己搭建 NuGet 服务器。但是，如果某个包正在开发中，需要快速验证其是否解决掉一些诡异的 bug 的话，除了单元测试这种间接的测试方法，还可以在本地安装未发布的 NuGet 包的方法来快速调试。本文介绍如何本地打包发布 NuGet 包，然后通过 mklink 收集所有的本地包达到快速调试的目的。将本地文件夹作为 NuGet 源我有另一篇博客介绍如何将本地文件夹设置称为 NuGet 包源： 全局或为单独的项目添加自定义的 NuGet 源 - walterlv在 Visual Studio 中打开 工具 -&amp;gt; 选项 -&amp;gt; NuGet 包管理器 -&amp;gt; 包源 可以直接将一个本地文件夹设置称为 NuGet 包源。其他设置方法可以去那篇博客当中阅读。通过 mklink 收集散落在各处的本地文件夹 NuGet 源如下图，是我通过 mklink 将散落在各处的 NuGet 包的调试输出目录收集了起来：比如，点开其中的 Walterlv.Packages 可以看到 Walterlv.Packages 仓库中输出的 NuGet 包：由于我的每一个文件夹都是指向的 Visual Studio 编译后的输出目录，所以，只需要使用 Visual Studio 重新编译一下项目，文件夹中的 NuGet 包即会更新。于是，这相当于我在一个文件夹中，包含了我整个计算机上所有库项目的 NuGet 包，只需要将这个文件夹设置称为 NuGet 包源，即可直接调试本地任何一个公共组件库打出来的 NuGet 包。设置源并体验快速调试如下图，是我将那个收集所有 NuGet 文件夹的目录设置成为了 NuGet 源：于是，我可以在 Visual Studio 的包管理器中看到所有还没有发布的，依然处于调试状态的各种库：基于此，我们可以在包还没有编写完的时候调试，验证速度非常快。" }, { "title": "使用 C# 中的 dynamic 关键字调用类型方法时可能遇到的各种问题", "url": "/post/problems-when-using-csharp-dymanic-binding.html", "categories": "", "tags": "csharp, dotnet", "date": "2019-08-04 14:58:15 +0800", "snippet": "你可以使用 dynamic 来定义一个变量或者字段，随后你可以像弱类型语言一样调用这个实例的各种方法，就像你一开始就知道这个类型的所有属性和方法一样。但是，使用不当又会遇到各种问题，本文收集使用过程中可能会遇到的各种问题，帮助你解决掉它们。快速入门dynamic 可以这么用：dynamic foo = GetSomeInstance();foo.Run(&quot;欢迎访问吕毅（lvyi）的博客：blog.walterlv.com&quot;);object GetSomeInstance(){ return 诡异的东西;}我们的 GetSomeInstance 明明返回的是 object，我们却可以调用真实类中的方法。接下来讲述使用 dynamic 过程中可能会遇到的问题和解决方法。编译错误：缺少编译器要求的成员你初次在你的项目中引入 dynamic 关键字后，会出现编译错误，提示 “缺少编译器要求的成员”。 error CS0656: 缺少编译器要求的成员“Microsoft.CSharp.RuntimeBinder.CSharpArgumentInfo.Create”对于 .NET Core 或者 .NET Standard 项目需要为你的项目安装以下两个 NuGet 包： Microsoft.CSharp System.Dynamic.Runtime于是你的项目里面会多出两个引用： &amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;TargetFrameworks&amp;gt;netstandard2.0;net48&amp;lt;/TargetFrameworks&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;ItemGroup&amp;gt;++ &amp;lt;PackageReference Include=&quot;Microsoft.CSharp&quot; Version=&quot;4.5.0&quot; /&amp;gt;++ &amp;lt;PackageReference Include=&quot;System.Dynamic.Runtime&quot; Version=&quot;4.3.0&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;/Project&amp;gt;对于 .NET Framework 项目你需要引用 Microsoft.CSharp：于是你的项目里面会多出一项引用： &amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk.WindowsDesktop&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;TargetFramework&amp;gt;net48&amp;lt;/TargetFramework&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;ItemGroup&amp;gt;++ &amp;lt;Reference Include=&quot;Microsoft.CSharp&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;/Project&amp;gt;异常：“{0}”未包含“{1}”的定义{0} 是类型名称，而 {1} 是使用 dynamic 访问的属性或者方法的名称。比如，我试图从某个 Attribute 中访问到 Key 属性的时候会抛出以下异常： Microsoft.CSharp.RuntimeBinder.RuntimeBinderException:““System.Attribute”未包含“Key”的定义”出现此异常的原因是： dynamic 所引用的对象里面，没有签名相同的 public 的属性或者方法于是，如果你确认你的类型里面是有这个属性或者方法的话，那么就需要注意需要将此成员改成 public 才可以访问。参考资料 c# - Why a Microsoft.CSharp.RuntimeBinder.RuntimeBinderException if the invoked method is there? - Stack Overflow" }, { "title": "设计一个 .NET 可用的弱引用集合（可用来做缓存池使用）", "url": "/post/dotnet-weak-collection.html", "categories": "", "tags": "dotnet, csharp", "date": "2019-08-04 14:49:21 +0800", "snippet": "我们有弱引用 WeakReference&amp;lt;T&amp;gt; 可以用来保存可被垃圾回收的对象，也有可以保存键值对的 ConditionalWeakTable。我们经常会考虑制作缓存池。虽然一般不推荐这么设计，但是你可以使用本文所述的方法和代码作为按垃圾回收缓存的缓存池的设计。设计思路既然现有 WeakReference&amp;lt;T&amp;gt; 和 ConditionalWeakTable 可以帮助我们实现弱引用，那么我们可以考虑封装这两个类中的任何一个或者两个来帮助我们完成弱引用集合。ConditionalWeakTable 类型仅仅在 internal 级别可以访问到集合中的所有的元素，对外开放的接口当中是无法拿到集合中的所有元素的，仅仅能根据 Key 来找到 Value 而已。所以如果要根据 ConditionalWeakTable 来实现弱引用集合那么需要自己记录集合中的所有的 Key，而这样的话我们依然需要自己实现一个用来记录所有 Key 的弱引用集合，相当于鸡生蛋蛋生鸡的问题。所以我们考虑直接使用 WeakReference&amp;lt;T&amp;gt; 来实现弱引用集合。自己维护一个列表 List&amp;lt;WeakReference&amp;lt;T&amp;gt;&amp;gt;，对外开放的 API 只能访问到其中未被垃圾回收到的对象。设计原则在设计此类型的时候，有一个非常大的需要考虑的因素，就是此类型中的元素个数是不确定的，如果设计不当，那么此类型的使用者可能写出的每一行代码都是 Bug。你可以参考我的另一篇博客了解设计这种不确定类型的 API 的时候的一些指导： 如何为非常不确定的行为（如并发）设计安全的 API，使用这些 API 时如何确保安全总结起来就是： 必须提供一个单一的方法，能够完成一些典型场景下某一时刻确定性状态的获取 绝不能提供一些可能多次调用获取状态的方法那么这个原则怎么体现在此弱引用集合的类型设计上呢？设计实践分析踩坑IList&amp;lt;T&amp;gt;我们来看看 IList&amp;lt;T&amp;gt; 接口是否可行：public class WeakCollection&amp;lt;T&amp;gt; : IList&amp;lt;T&amp;gt; where T : class{ public T this[int index] { get =&amp;gt; throw new NotImplementedException(); set =&amp;gt; throw new NotImplementedException(); } public int Count =&amp;gt; throw new NotImplementedException(); public bool IsReadOnly =&amp;gt; throw new NotImplementedException(); public void Add(T item) =&amp;gt; throw new NotImplementedException(); public void Clear() =&amp;gt; throw new NotImplementedException(); public bool Contains(T item) =&amp;gt; throw new NotImplementedException(); public void CopyTo(T[] array, int arrayIndex) =&amp;gt; throw new NotImplementedException(); public IEnumerator&amp;lt;T&amp;gt; GetEnumerator() =&amp;gt; throw new NotImplementedException(); public int IndexOf(T item) =&amp;gt; throw new NotImplementedException(); public void Insert(int index, T item) =&amp;gt; throw new NotImplementedException(); public bool Remove(T item) =&amp;gt; throw new NotImplementedException(); public void RemoveAt(int index) =&amp;gt; throw new NotImplementedException(); IEnumerator IEnumerable.GetEnumerator() =&amp;gt; throw new NotImplementedException();}this[]、Count、IsReadOnly、Contains、CopyTo、IndexOf、GetEnumerator 这些都是在获取状态，Add、Clear、Remove 是在修改状态，而 Insert、RemoveAt 会在修改状态的同时读取状态。这么多的获取和修改状态的方法，如果提供出去，还指望使用者能够正常使用，简直是做梦！违背以上两个原则。ICollection&amp;lt;T&amp;gt;那我们看看 IList&amp;lt;T&amp;gt; 的底层集合 ICollection&amp;lt;T&amp;gt;，实际上并没有解决问题，所以依然排除不能用！ public class WeakCollection&amp;lt;T&amp;gt; : ICollection&amp;lt;T&amp;gt; where T : class {-- public T this[int index] { get =&amp;gt; throw new NotImplementedException(); set =&amp;gt; throw new NotImplementedException(); } public int Count =&amp;gt; throw new NotImplementedException(); public bool IsReadOnly =&amp;gt; throw new NotImplementedException(); public void Add(T item) =&amp;gt; throw new NotImplementedException(); public void Clear() =&amp;gt; throw new NotImplementedException(); public bool Contains(T item) =&amp;gt; throw new NotImplementedException(); public void CopyTo(T[] array, int arrayIndex) =&amp;gt; throw new NotImplementedException(); public IEnumerator&amp;lt;T&amp;gt; GetEnumerator() =&amp;gt; throw new NotImplementedException();-- public int IndexOf(T item) =&amp;gt; throw new NotImplementedException();-- public void Insert(int index, T item) =&amp;gt; throw new NotImplementedException(); public bool Remove(T item) =&amp;gt; throw new NotImplementedException();-- public void RemoveAt(int index) =&amp;gt; throw new NotImplementedException(); IEnumerator IEnumerable.GetEnumerator() =&amp;gt; throw new NotImplementedException(); }不过，Add 和 Remove 方法可能我们会考虑留下来，但这就不能是继承自 ICollection&amp;lt;T&amp;gt; 了。IEnumerable&amp;lt;T&amp;gt;IEnumerable&amp;lt;T&amp;gt; 里面只有两个方法，看起来少多了，那么我们能用吗？public IEnumerator&amp;lt;T&amp;gt; GetEnumerator() =&amp;gt; throw new NotImplementedException();IEnumerator IEnumerable.GetEnumerator() =&amp;gt; throw new NotImplementedException();这个方法仅供 foreach 使用，本来如果只是如此的话，问题还不是很大，但针对 IEnumerator&amp;lt;T&amp;gt; 有一大堆的 Linq 扩展方法，于是这相当于给此弱引用集合提供了大量可以用来读取状态的方法。这依然非常危险！使用者随时可能使用其中一个扩展方法得到了其中一个状态，随后使用另一个扩展方法得知其第二个状态，例如：// 判断集合中是否存在 IFoo 类型以及是否存在 IBar 类型。var hasFoo = weakList.OfType&amp;lt;IFoo&amp;gt;().Any();var hasBar = weakList.OfType&amp;lt;IBar&amp;gt;().Any();对具有并发开发经验的你来说，以上方法第一眼就能识别出这是不正确的写法。然而类型既然已经开放出去给大家使用了，那么这就非常危险。关键是这不是一个并发场景，于是开发者可能更难感受到在同一个上下文中调用两个方法将得到不确定的结果。对于并发可以使用锁，但对于弱引用，没有可以使用的相关方法来快速解决问题。因此，IEnumerable&amp;lt;T&amp;gt; 也是不能继承的。object看来，我们只能继承自单纯的 object 基类了。此类型没有对托管来说可见的状态，于是谁也不会多次读取状态造成状态不确定了。因此，我们需要自行实现所有场景下的 API。动手弱引用集合我们需要这些使用场景： 向弱引用集合中添加一个元素 此场景下仅仅修改集合而不需要读取任何状态。 向弱引用集合中移除一个元素 既然可以在参数中传入元素，说明此元素一定没有会垃圾回收；因此只要集合中还存在此元素，一定可以确定地移除，不会出现不确定的状态。 在弱引用集合中找到符合要求的一个或多个元素 一旦满足要求，必须得到完全确定的结果，且在此结果保存的过程中一直生效。可选考虑下面这些场景： 清除所有元素 通常是为了复用某个缓存池的实例。一定不能实现下面这些方法： 判断是否存在某个元素 因为判断是否存在通常不是单独的操作，通常会使用此集合继续下一个操作，因此一定不能直接提供。 其他在本文前面已经喷过不能添加进来的方法于是，我们的 API 设计将是这样的：public class WeakCollection&amp;lt;T&amp;gt; where T : class{ public void Add(T item) =&amp;gt; throw new NotImplementedException(); public bool Remove(T item) =&amp;gt; throw new NotImplementedException(); public void Clear() =&amp;gt; throw new NotImplementedException(); public T[] TryGetItems(Func&amp;lt;T, bool&amp;gt; filter) =&amp;gt; throw new NotImplementedException();}完整代码此类型已经以源代码包的形式发布到了 NuGet 上，你可以安装以下 NuGet 包阅读和使用其源代码： Walterlv.Collections.Source安装后，你可以在你的项目中使用其源代码，并且可以直接使用 Ctrl + 鼠标点击的方式打开类型的源代码，而不需要进行反编译。" }, { "title": "如何为非常不确定的行为（如并发）设计安全的 API，使用这些 API 时如何确保安全", "url": "/post/design-principles-of-uncertain-behavior.html", "categories": "", "tags": "dotnet, csharp", "date": "2019-08-03 13:56:32 +0800", "snippet": ".NET 中提供了一些线程安全的类型，如 ConcurrentDictionary&amp;lt;TKey, TValue&amp;gt;，它们的 API 设计与常规设计差异很大。如果你对此觉得奇怪，那么正好阅读本文。本文介绍为这些非常不确定的行为设计 API 时应该考虑的原则，了解这些原则之后你会体会到为什么会有这些 API 设计上的差异，然后指导你设计新的类型。不确定性像并发集合一样，如 ConcurrentDictionary&amp;lt;TKey, TValue&amp;gt;、ConcurrentQueue&amp;lt;T&amp;gt;，其设计为线程安全，于是它的每一个对外公开的方法调用都不会导致其内部状态错误。但是，你在调用其任何一个方法的时候，虽然调用的方法本身能够保证其线程安全，能够保证此方法涉及到的状态是确定的，但是一旦完成此方法的调用，其状态都将再次不确定。你只能依靠其方法的返回值来使用刚刚调用那一刻确定的状态。我们来看几段代码：var isRunning = Interlocked.CompareExchange(ref _isRunning, 1, 0);if (isRunning is 1){ // 当前已经在执行队列，因此无需继续执行。}private ConcurrentDictionary&amp;lt;string, object&amp;gt; KeyValues { get; } = new ConcurrentDictionary&amp;lt;string, object&amp;gt;();object Get(string key){ var value = KeyValues.TryGetValue(key, out var v) ? v : null; return value;}这两段代码都使用到了可能涉及线程安全的一些代码。前者使用 Interlocked 做原则操作，而后者使用并发字典。无论写上面哪一段代码，都面临着问题： 此刻调用的那一句话得到的任何结果都仅仅只表示这一刻，而不代表其他任何代码时的结果。比如前者的 Interlocked.CompareExchange(ref _isRunning, 1, 0) 我们得到一个返回值 isRunning，然后判断这个返回值。但是我们绝对不能够判断 _isRunning 这个字段，因为这个字段非常易变，在你的任何一个代码上下文中都可能变成你不希望看到的值。Interlocked 是原子操作，所以才确保安全。而后者，此时访问得到的字典数据，和下一时刻访问得到的字典数据将可能完全不匹配，两次的数据不能通用。API 用法指导如果你正在为一个易变的状态设计 API，或者说你需要编写的类型带有很强的不确定性（类型状态的变化可能发生在任何一行代码上），那么你需要遵循一些设计原则才能确保安全。同一个上下文仅能查看或修改一次状态比如要为缓存设计一个获取可用实例的方法，可以使用：private ConcurrentDictionary&amp;lt;string, object&amp;gt; KeyValues { get; } = new ConcurrentDictionary&amp;lt;string, object&amp;gt;();void Get(string key){ // CreateCachedInstance 是一个工厂方法，所有 GetOrAdd 的地方都是用此工厂方法创建。 var value = KeyValues.GetOrAdd(key, CreateCachedInstance); return value;}但是绝对不能使用：if(!KeyValues.TryGetValue(key, out var v)){ KeyValues.TryAdd(key, CreateCachedInstance(key));}这一段代码就是对并发的状态 KeyValues 做了两次访问。ConcurrentDictionary 也正是考虑到了这种设计场景，于是才提供了 API GetOrAdd 方法。让你在获取对象实例的时候可以通过工厂方法去创建实例。如果你需要设计这种状态极易变的 API，那么需要针对一些典型的设计场景提供一次调用就能获取此时此刻所有状态的方法。就像上文的 GetOrAdd 一样。另一个例子，WeakReference&amp;lt;T&amp;gt; 弱引用对象的管理也是在一个方法里面可以获取到一个绝对确定的状态，而避免使用方进行两次判断：if (weak.TryGetTarget(out var value)){ // 一旦这里拿到了对象，这个对象一定会存在且可用。}一定不能提供两个方法调用来完成这样的事情（比如先判断是否存在再获取对象的实例，就像 .NET Framework 4.0 和早期版本弱引用的 API 设计一样）。对于并发，如果有多次查看或者修改状态，必须加锁比如以下方法，是试图一个接一个地依次执行 _queue 中的所有任务。虽然我们使用 Interlocked.CompareExchange 原子操作，但因为后面依然涉及到了多次状态的获取，导致不得不加锁才能确保安全。我们依然使用原则操作是为了避免单纯 lock 带来的性能损耗。private volatile int _isRunning;private readonly object _locker = new object();private readonly ConcurrentQueue&amp;lt;TaskWrapper&amp;gt; _queue = new ConcurrentQueue&amp;lt;TaskWrapper&amp;gt;();private async void Run(){ var isRunning = Interlocked.CompareExchange(ref _isRunning, 1, 0); if (isRunning is 1) { lock (_locker) { if (_isRunning is 1) { // 当前已经在执行队列，因此无需继续执行。 return; } } } var hasTask = true; while (hasTask) { // 当前还没有任何队列开始执行，因此需要开始执行队列。 while (_queue.TryDequeue(out var wrapper)) { // 内部已包含异常处理，因此外面可以无需捕获或者清理。 await wrapper.RunAsync().ConfigureAwait(false); } lock (_locker) { hasTask = _queue.TryPeek(out _); if (!hasTask) { _isRunning = 0; } } }}这段代码的完全解读： 当执行 Run 方法的时候，先判断当前是否已经在跑其他的任务： isRunning 为 0 表示当前一定没有在跑其他任务，我们使用原则操作立刻将其修改为 1； isRunning 为 1 表示当前不确定是否在跑其他任务； 既然 isRunning 为 1 的时候状态不确定，于是我们加锁来判断其是否真的有任务在跑： 在 lock 环境中确认 _isRunning 字段而非变量为 1 则说明真的有任务在跑，此时等待任务完成即可，这里就可以退出了； 在 lock 环境中发现 _isRunning 字段而非变量为 0 则说明实际上是没有任务在跑的（刚刚判断为 1 只是因为这两次判断之间，并发的任务刚刚在结束的过程中），于是需要跟一开始判断为 0 一样，进入到后面的循环中； 外层的 while 循环第一次是一定能进去的，于是我们暂且不谈； 在 while 内循环中，我们依次检查并发队列 _queue 中是否还有任务要执行，如果有要执行的，就执行： 这个过程我们完全没有做加锁，因为这可能是非常耗时的任务，如果我们加锁，将导致其他线程出现非常严重的资源浪费； 如果 queue 中的所有任务执行完毕，我们将进入一个 lock 区间： 在这个 lock 区间里面我们再次确认任务是否已经完成，如果没有完成，我们靠最外层的 while 循环重新回到内层 while 循环中继续任务； 如果在这个 lock 区间里面我们发现任务已经完成了，就设置 _isRunning 为 0，表示任务真的已经完成，随后退出 while 循环； 你可以注意到我们的 lock 是用来确认一开始 isRunning 为 1 时的那个不确定的状态的。因为我们需要多次访问这个状态，所以必须加锁来确认状态是同步的。API 设计指导在了解了上面的用法指导后，API 设计指导也呼之欲出了： 针对典型的应用场景，必须设计一个专门的方法，一次调用即可完全获取当时需要的状态，或者一次调用即可完全修改需要修改的状态； 不要提供大于 1 个方法组合在一起才能使用的 API，这会让调用方获取不一致的状态。对于多线程并发导致的不确定性，使用方虽然可以通过 lock 来规避以上第二条问题，但设计方最好在设计之初就避免问题，以便让 API 更好使用。关于通用 API 设计指导，你可以阅读我的另一篇双语博客： 好的框架需要好的 API 设计 —— API 设计的六个原则 - walterlv" }, { "title": "通过 AppSwitch 禁用 WPF 内置的触摸让 WPF 程序可以处理 Windows 触摸消息", "url": "/post/wpf-disable-stylus-and-touch-support.html", "categories": "", "tags": "wpf, windows, dotnet, csharp", "date": "2019-08-01 20:56:16 +0800", "snippet": "WPF 框架自己实现了一套触摸机制，但同一窗口只能支持一套触摸机制，于是这会禁用系统的触摸消息（WM_TOUCH）。这能够很大程度提升 WPF 程序的触摸响应速度，但是很多时候又会产生一些 Bug。如果你有需要，可以考虑禁用 WPF 的内置的实时触摸（RealTimeStylus）。本文介绍禁用方法，使用 AppSwitch，而不是网上广为流传的反射方法。如何设置 AppSwitch在你的应用程序的 app.config 文件中加入 Switch.System.Windows.Input.Stylus.DisableStylusAndTouchSupport=true 开关，即可关闭 WPF 内置的实时触摸，而改用 Windows 触摸消息（WM_TOUCH）。&amp;lt;configuration&amp;gt; &amp;lt;runtime&amp;gt; &amp;lt;AppContextSwitchOverrides value=&quot;Switch.System.Windows.Input.Stylus.DisableStylusAndTouchSupport=true&quot; /&amp;gt; &amp;lt;/runtime&amp;gt;&amp;lt;/configuration&amp;gt;如果你的解决方案中没有找到 app.config 文件，可以创建一个：然后，把上面的代码拷贝进去即可。反射禁用的方法微软的官方文档也有提到使用放射禁用的方法，但一般不推荐这种调用内部 API 的方式，比较容易在 .NET 的版本更新中出现问题： Disable the RealTimeStylus for WPF Applications - Microsoft Docs WPF 禁用实时触摸 - 林德熙此方法可以解决的问题一览拖拽窗口或者调整窗口大小时不能实时跟随的问题 Why all my WPF applications fail to drag outside of their windows since Windows 10 (1809/1903) such as resizing the window or do drag drop? - Stack Overflow All WPF applications fail to drag outside of their windows since Windows 10 (1809/1903) such as resizing the window or do drag drop · Issue #1323 · dotnet/wpf在部分设备上启动即崩溃 .NET 4.7 - WPF - Touch Enabled Devices Crash Applications · Issue #480 · microsoft/dotnet Visual Studio may freeze or crash when running on a pen-enabled machine - Developer Community在透明窗口上触摸会挡住 UWP 程序 c# - On Windows 10 (1803), all applications lost touch or stylus if a WPF transparent window covers on them - Stack Overflow参考资料 Disable the RealTimeStylus for WPF Applications - Microsoft Docs WPF-Samples/runtimeconfig.template.json at master · microsoft/WPF-Samples All WPF applications fail to drag outside of their windows since Windows 10 (1809/1903) such as resizing the window or do drag drop · Issue #1323 · dotnet/wpf" }, { "title": "Visual Studio 2019 中使用 .NET Core 预览版 SDK 的全局配置文件在哪里？", "url": "/post/where-is-the-dotnet-sdk-preview-config-file.html", "categories": "", "tags": "msbuild, visualstudio, dotnet", "date": "2019-07-29 17:47:40 +0800", "snippet": "本文介绍在使用 Visual Studio 2019 或者命令行执行 MSBuild dotnet build 命令时，决定是否使用 .NET Core SDK 预览版的全局配置文件。指定是否使用 .NET Core 预览版 SDK 的全局配置文件在： %LocalAppData%\\Microsoft\\VisualStudio\\16.0_xxxxxxxx\\sdk.txt其中 %LocalAppData% 是 Windows 系统中自带的环境变量，16.0_xxxxxxxx 在不同的 Visual Studio 版本下不同。比如，我的路径就是 C:\\Users\\lvyi\\AppData\\Local\\Microsoft\\VisualStudio\\16.0_0b1a4ea6\\sdk.txt。这个文件的内容非常简单，只有一行：UsePreviews=True你一定觉得奇怪，我们在 Visual Studio 2019 中设置了使用 .NET Core SDK 预览版之后，这个配置是全局生效的，即便在命令行中运行 MSBuild 或者 dotnet build 也是会因此而使用预览版或者正式版的。但是这个路径明显看起来是 Visual Studio 的私有路径。虽然这很诡异，但确实如此，不信，可以看我是如何确认这个文件就是 .NET Core SDK 预览版的全局配置的： 找出 .NET Core SDK 是否使用预览版的全局配置文件在那里（探索篇）另外，如果你想知道如何在 Visual Studio 2019 中指定使用 .NET Core SDK 的预览版，可以参考我的另外一篇博客： 如何在 Visual Studio 2019 中设置使用 .NET Core SDK 的预览版（全局生效）" }, { "title": "The partial same C# namespace may cause source code compatibility issue", "url": "/post/source-code-compatibility-issue-of-adding-apis-en.html", "categories": "", "tags": "csharp, dotnet, visualstudio", "date": "2019-07-27 20:48:49 +0800", "snippet": "You might just add some simple APIs in your library and you’ll not think that will break down your compatibility. But actually, it might, that is – the source-code compatibility.This post is written in multiple languages. Please select yours: 中文 English Assume that we’ve written a project P which references another two libraries A and B. And we have a Walterlv.A.Diagnostics.Foo class in library A.using Walterlv.A;using Walterlv.B;namespace Walterlv.Demo{ class Hello { Run(Diagnostics.Foo foo) { } }}And now we add a new class Walterlv.B.Diagnostics.Bar class into the B library. That is adding a new API only.Unfortunately, the code above would fail to compile because of the ambiguity of Diagnostics namespace. The Foo class cannot be found in an ambiguity namespace.I write this post down to tell you that there may be source-code compatibility issue even if you only upgrade your library by simply adding APIs." }, { "title": "使用基于 Roslyn 的 Microsoft.CodeAnalysis.PublicApiAnalyzers 来追踪项目的 API 改动，帮助保持库的 API 兼容性", "url": "/post/track-api-changes-using-roslyn-public-api-analyzers.html", "categories": "", "tags": "dotnet, csharp, visualstudio, nuget, roslyn", "date": "2019-07-27 16:54:26 +0800", "snippet": "做库的时候，需要一定程度上保持 API 的兼容性第一步：安装 NuGet 包首先打开你的库项目，或者如果你希望从零开始也可以直接新建一个项目。这里为了博客阅读的简单，我创建一个全新的项目来演示。然后，为主要的库项目安装 NuGet 包： NuGet Gallery - Microsoft.CodeAnalysis.PublicApiAnalyzers安装完成之后，你的项目文件（.csproj）可能类似于下面这样：&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;TargetFramework&amp;gt;netstandard2.0&amp;lt;/TargetFramework&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;PackageReference Include=&quot;Microsoft.CodeAnalysis.PublicApiAnalyzers&quot; Version=&quot;2.9.3&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt;&amp;lt;/Project&amp;gt;第二步：创建 API 记录文件在你的项目内创建两个文件： PublicAPI.Shipped.txt PublicAPI.Unshipped.txt这就是两个普通的文本文件。创建纯文本文件的方法是在项目上右键 -&amp;gt; 添加 -&amp;gt; 新建项...，然后在打开的模板中选择 文本文件，使用上面指定的名称即可（要创建两个）。然后，编辑项目文件，我们需要将这两个文件加入到项目中来。如果你看不到上图中的“编辑项目文件”选项，则需要升级项目文件到 SDK 风格，详见： 将 WPF、UWP 以及其他各种类型的旧 csproj 迁移成 Sdk 风格的 csproj - walterlv然后，将这两个文件添加为 AdditionalFiles： &amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;TargetFramework&amp;gt;netstandard2.0&amp;lt;/TargetFramework&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;PackageReference Include=&quot;Microsoft.CodeAnalysis.PublicApiAnalyzers&quot; Version=&quot;2.9.3&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt;+ &amp;lt;ItemGroup&amp;gt;+ &amp;lt;AdditionalFiles Include=&quot;PublicAPI.Shipped.txt&quot; /&amp;gt;+ &amp;lt;AdditionalFiles Include=&quot;PublicAPI.Unshipped.txt&quot; /&amp;gt;+ &amp;lt;/ItemGroup&amp;gt; &amp;lt;/Project&amp;gt;如果你把这两个文件放到了其他的路径，那么上面也需要改成对应的路径。这时，这两个文件内容还是空的。第三步：添加 API 记录这个时候，你会看到库中的 public 类、方法、属性等都会发出修改建议，说此符号并不是已声明 API 的一部分。点击小灯泡，即可将点击所在的 API 加入到 PublicAPI.Unshipped.txt 中。我将两个 API 都添加之后，PublicAPI.Unshipped.txt 文件中现在是这样的（注意有一个隐式构造函数哦）：Walterlv.PackageDemo.ApiTracking.Class1Walterlv.PackageDemo.ApiTracking.Class1.Class1() -&amp;gt; voidWalterlv.PackageDemo.ApiTracking.Class1.Foo.get -&amp;gt; string体验 API 的追踪现在，我们将 Foo 属性改名成 Foo2 属性，于是就会出现编译警告： RS0016 Symbol ‘Foo2.get’ is not part of the declared API.RS0017 Symbol ‘Walterlv.PackageDemo.ApiTracking.Class1.Foo.get -&amp;gt; string’ is part of the declared API, but is either not public or could not be found提示 Foo2 属性不是已声明 API 的一部分，而 Foo 属性虽然是已声明 API 的一部分，但已经找不到了。这种提示对于保持库的兼容性是非常有帮助的。将警告变成错误在分析器的规则上面右键，可以为某项规则设置严重性。这时，再编译即会报告编译错误。项目中也会多一个规则集文件： &amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;TargetFramework&amp;gt;netstandard2.0&amp;lt;/TargetFramework&amp;gt;+ &amp;lt;CodeAnalysisRuleSet&amp;gt;Walterlv.PackageDemo.ApiTracking.ruleset&amp;lt;/CodeAnalysisRuleSet&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;PackageReference Include=&quot;Microsoft.CodeAnalysis.PublicApiAnalyzers&quot; Version=&quot;2.9.3&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;AdditionalFiles Include=&quot;PublicAPI.Shipped.txt&quot; /&amp;gt; &amp;lt;AdditionalFiles Include=&quot;PublicAPI.Unshipped.txt&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;/Project&amp;gt;第四步：将 API 打包前面我们都是在 PublicAPI.Unshipped.txt 文件中追踪 API。但是如果我们的库需要发布一个版本的时候，我们就需要跟上一个版本比较 API 的差异。上一个发布版本的 API 就记录在 PublicAPI.Shipped.txt 文件中，这两个文件的差异即是这两个版本的 API 差异。在一个新的版本发布后，就需要将 API 归档到 PublicAPI.Shipped.txt 文件中。参考资料 roslyn-analyzers/Microsoft.CodeAnalysis.PublicApiAnalyzers.md at master · dotnet/roslyn-analyzers" }, { "title": "找出 .NET Core SDK 是否使用预览版的全局配置文件在哪里（探索篇）", "url": "/post/find-out-the-dotnet-sdk-preview-config-file.html", "categories": "", "tags": "msbuild, visualstudio, dotnet", "date": "2019-07-27 14:57:42 +0800", "snippet": "你是否好奇 Visual Studio 2019 中的 .NET Core SDK 预览版开关是全局生效的，那个全局的配置在哪里呢？本文将和你一起探索找到这个全局的配置文件。使用 Process Monitor 探索下载 Process MonitorProcess Monitor 是微软极品工具箱的一部分，你可以在此页面下载： Process Monitor - Windows Sysinternals - Microsoft Docs打开 Process Monitor当你一开始打开 Process Monitor 的时候，列表中会立刻刷出大量的进程的操作记录。这么多的记录会让我们找到目标进程操作的文件有些吃力，于是我们需要设置规则。Process Monitor 的工具栏按钮并不多，而且我们这一次的目标只会用到其中的两个： 清除列表（将已经记录的所有数据清空，便于聚焦到我们最关心的数据中） 设置过滤器（防止大量无关的进程操作进入列表中干扰我们的查找）设置过滤规则在工具栏上点击“设置过滤器”，然后，添加我们感兴趣的两个进程名称： devenv.exe MSBuild.exe前者是 Visual Studio 的进程名，后者是 MSBuild.exe 的进程名。我们使用这两个进程名称分别找到 Visual Studio 2019 是如何设置全局 .NET Core 预览配置的，并且在命令行中运行 MSBuild.exe 来验证确实是这个全局配置。然后排除除了文件意外的所有事件类型，最终是如下过滤器：捕获 devenv.exe现在，我们打开 Visual Studio 2019，然后停留到下面这个界面中。改变一下 .NET Core SDK 预览版选项的勾选状态。现在，我们点击一下“确定”，将立即可以在 Process Monitor 中看到一些文件的修改：上面是在点击“确定”按钮一瞬间 Visual Studio 2019 的所有文件操作。你可以注意到左侧的时间，我的截图中从 45 秒到 48 秒是可能有效的文件读写，再后面已经延迟了 10 秒了，多半是其他的操作。在这些文件中，可以很明显看到文件分为三类： sdk.txt 一个不知名的文件，但似乎跟我们的 .NET Core SDK 相关 SettingsLogs 一看就是给设置功能用的日志 VSApplicationInsights 一看就是数据收集相关通过排除法，我们能得知最关键的文件就是那个 sdk.txt。去看一看那个文件的内容，发现只有一行：UsePreviews=True这基本上可以确认 Visual Studio 2019 设置是否使用 .NET Core SDK 预览版就是在这个文件中。不过，这带来一个疑惑，就是这个路径特别不像是 .NET Core SDK 的配置路径，倒像是 Visual Studio 自己的设置配置。于是必须通过其他途径来确认这是否就是真实的全局配置。捕获 MSBuild.exe现在，我们清除一下 Process Monitor 中的已经记录的数据，然后，我们在命令行中对一个项目敲下 msbuild 命令。&amp;gt; msbuild然后在 Process Monitor 里面观察事件。这次发现事件相当多，于是换个方式。因为我们主要是验证 sdk.txt 文件，但同时希望看看是否还有其他文件。于是我们将 sdk.txt 文件相关的事件高亮。点击 Filter -&amp;gt; Highlight...，然后选择 Path contains sdk.txt 时则 Include。这时，再看捕获到的事件，可以发现编译期间确实读取了这个文件。此举虽不能成为此文件是全局配置的铁证，但至少说明这个文件与全局配置非常相关。另外，继续在记录中翻找，还可以发现与此配置可能相关的两个 dll： Microsoft.Build.NuGetSdkResolver.dll Microsoft.DotNet.MSBuildSdkResolver.dll验证结论要验证此文件确实是全局配置其实也很简单，自行改一改配置，然后使用 MSBuild.exe 编译试试即可。现在，将 sdk.txt 文件内容改为：UsePreviews=False编译一下使用了 .NET Core 3.0 新特性的项目（我使用了 Microsoft.NET.Sdk.WindowsDesktop，这是 3.0 才有的 SDK）。编译错误，提示 Microsoft.NET.Sdk.WindowsDesktop 这个 SDK 没有找到。现在，将 sdk.txt 文件内容改为：UsePreviews=True编译相同的项目，发现可以正常编译通过了。这可以证明，此文件正是决定是否使用预览版的决定性证据。其他但值得注意的是，打开 Visual Studio 2019 后，发现其设置界面并没有应用此文件最新的修改，这可以说 Visual Studio 2019 的配置是不止这一处。反编译探索通过反编译探索的方式感谢小伙伴 KodamaSakuno (神樹桜乃) 彻夜寻找。相关的代码在 cli/VSSettings.cs at master · dotnet/cli 中，你可以前往查看。在 VSSettings 的构造函数中，为字段 _settingsFilePath 赋值，拼接了 sdk.txt 文件的路径。_settingsFilePath = Path.Combine( Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData), &quot;Microsoft&quot;, &quot;VisualStudio&quot;, version.Major + &quot;.0_&quot; + instanceId, &quot;sdk.txt&quot;);读取时，使用此路径下的 sdk.txt 文件读取了 UsePreviews 变量的值。private void ReadFromDisk(){ using (var reader = new StreamReader(_settingsFilePath)) { string line; while ((line = reader.ReadLine()) != null) { int indexOfEquals = line.IndexOf(&#39;=&#39;); if (indexOfEquals &amp;lt; 0 || indexOfEquals == (line.Length - 1)) { continue; } string key = line.Substring(0, indexOfEquals).Trim(); string value = line.Substring(indexOfEquals + 1).Trim(); if (key.Equals(&quot;UsePreviews&quot;, StringComparison.OrdinalIgnoreCase) &amp;amp;&amp;amp; bool.TryParse(value, out bool usePreviews)) { _disallowPrerelease = !usePreviews; return; } } } // File does not have UsePreviews entry -&amp;gt; use default _disallowPrerelease = _disallowPrereleaseByDefault;}" }, { "title": "nuget.exe 还原解决方案 NuGet 包的时候出现错误：调用的目标发生了异常。Error parsing the nested project section in solution file.", "url": "/post/error-parsing-the-nested-project-section-in-solution-file.html", "categories": "", "tags": "msbuild, visualstudio, dotnet", "date": "2019-07-25 19:35:37 +0800", "snippet": "我这里使用 Visual Studio 2019 能好好编译的一个项目，发现在另一个小伙伴那里却编译不通过，是在 NuGet 还原那里报告了错误： 调用的目标发生了异常。Error parsing the nested project section in solution file.本文介绍如何解决这样的问题。原因此问题的原因可能有多种： 解决方案里面 Project 和 EndProject 不成对，导致某个项目没有被识别出来 解决方案中 Global 部分的项目 Id 没有在 Project 部分发现对应的项目 解决方案里面出现了当前 MSBuild 版本不认识的项目类型解决方法Project 和 EndProject 不成对Project 和 EndProject 不成对通常是合并分支时，自动解冲突解错了导致的，例如像下面这样：Project(&quot;{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}&quot;) = &quot;Walterlv.Demo&quot;, &quot;Walterlv.Demo\\Walterlv.Demo.csproj&quot;, &quot;{DC0B1D44-5DF4-4590-BBFE-072183677A78}&quot;Project(&quot;{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}&quot;) = &quot;Walterlv.Demo2&quot;, &quot;Walterlv.Demo2\\Walterlv.Demo2.csproj&quot;, &quot;{98FF9756-B95A-4FDB-9858-5106F486FBF3}&quot;EndProject而解决方法，就是补全缺失的 EndProject 行： Project(&quot;{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}&quot;) = &quot;Walterlv.Demo&quot;, &quot;Walterlv.Demo\\Walterlv.Demo.csproj&quot;, &quot;{DC0B1D44-5DF4-4590-BBFE-072183677A78}&quot;++ EndProject Project(&quot;{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}&quot;) = &quot;Walterlv.Demo2&quot;, &quot;Walterlv.Demo2\\Walterlv.Demo2.csproj&quot;, &quot;{98FF9756-B95A-4FDB-9858-5106F486FBF3}&quot; EndProjectGlobal 部分的项目 Id 没有在 Project 部分发现对应的项目这是说，如果在 Global 部分通过项目 Id 引用了一些项目，但是这些项目没有在前面 Project 部分定义。例如下面的 sln 片段： Project(&quot;{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}&quot;) = &quot;Walterlv.Demo2&quot;, &quot;Walterlv.Demo2\\Walterlv.Demo2.csproj&quot;, &quot;{98FF9756-B95A-4FDB-9858-5106F486FBF3}&quot; EndProject Global GlobalSection(SolutionConfigurationPlatforms) = preSolution Debug|Any CPU = Debug|Any CPU Release|Any CPU = Release|Any CPU EndGlobalSection GlobalSection(ProjectConfigurationPlatforms) = postSolution {98FF9756-B95A-4FDB-9858-5106F486FBF3}.Debug|Any CPU.ActiveCfg = Debug|Any CPU {98FF9756-B95A-4FDB-9858-5106F486FBF3}.Debug|Any CPU.Build.0 = Debug|Any CPU {98FF9756-B95A-4FDB-9858-5106F486FBF3}.Release|Any CPU.ActiveCfg = Release|Any CPU {98FF9756-B95A-4FDB-9858-5106F486FBF3}.Release|Any CPU.Build.0 = Release|Any CPU EndGlobalSection GlobalSection(SolutionProperties) = preSolution HideSolutionNode = FALSE EndGlobalSection GlobalSection(NestedProjects) = preSolution-- {DC0B1D44-5DF4-4590-BBFE-072183677A78} = {20B61509-640C-492B-8B33-FB472CCF1391} {98FF9756-B95A-4FDB-9858-5106F486FBF3} = {20B61509-640C-492B-8B33-FB472CCF1391} EndGlobalSection GlobalSection(ExtensibilityGlobals) = postSolution SolutionGuid = {F2F1AD1B-207B-4731-ABEB-92882F89B155} EndGlobalSection EndGlobal上面红框标注的项目 Id {DC0B1D44-5DF4-4590-BBFE-072183677A78} 在前面的 Project 部分是没有定义的，于是出现问题。这通常也是合并冲突所致。解决方法是删掉这个多于的配置，或者在前面加回误删的 Project 节点，如：Project(&quot;{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}&quot;) = &quot;Walterlv.Demo&quot;, &quot;Walterlv.Demo\\Walterlv.Demo.csproj&quot;, &quot;{DC0B1D44-5DF4-4590-BBFE-072183677A78}&quot;EndProject出现了当前 MSBuild 版本不认识的项目类型可能是 nuget 识别出来的 MSBuild 版本过旧，也可能是没有安装对应的工作负载。检查你的项目是否安装了需要的工作负载，比如做 Visual Studio 插件开发需要插件工作负载。可以阅读： 如何安装和准备 Visual Studio 扩展/插件开发环境 - walterlv我在另外的博客中写了解决方案中项目类型的内容： 理解 Visual Studio 解决方案文件格式（.sln） - walterlv 解决方案文件 sln 中的项目类型 GUID - walterlv而如果是 nuget 自动识别出来的 MSBuild 版本过旧，则你会同时看到下面的这段提示： NuGet Version: 5.1.0.6013 MSBuild auto-detection: using msbuild version ‘15.9.21.664’ from ‘C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Enterprise\\MSBuild\\15.0\\Bin’. Use option -MSBuildVersion to force nuget to use a specific version of MSBuild. Error parsing solution file at C:\\walterlv\\Walterlv.Demo\\Walterlv.Demo.sln: 调用的目标发生了异常。 Error parsing the nested project section in solution file.于是解决方法是使 NuGet 能够找到正确的 MSBuild.exe 的版本。我在另一篇博客中有写一些决定 MSBuild.exe 版本的方法： 为 NuGet 指定检测的 MSBuild 路径或版本，解决 MSBuild auto-detection: using msbuild version 自动查找路径不合适的问题 - walterlv可以通过设置环境变量的方式来解决自动查找版本错误的问题。你可以看到本文后面附带了很多的参考资料，但实际上这里的所有资料都没有帮助我解决掉任何问题。这个问题的本质是 nuget 识别到了旧版本的 MSBuild.exe。参考资料 Nested project issues · Issue #7040 · dotnet/corefx Fixed nested project issues in msbuild by svick · Pull Request #7041 · dotnet/corefx MSBuild: Command Line Build error: Solution file error MSB5023: Error parsing the nested project section - Stack Overflow MSBuild detecting wrong version of Visual Studio VS2017 MSBuild autodetection takes MSBuild/v14 instead of v15 for WPF project - Stack Overflow How Can I Tell NuGet What MSBuild Executable to Use? - Stack Overflow NuGet CLI restore command - Microsoft Docs" }, { "title": "为 NuGet 指定检测的 MSBuild 路径或版本，解决 MSBuild auto-detection: using msbuild version 自动查找路径不合适的问题", "url": "/post/specify-msbuild-version-for-nuget-command-line.html", "categories": "", "tags": "nuget, msbuild, visualstudio, dotnet", "date": "2019-07-25 18:11:47 +0800", "snippet": "使用 nuget restore 命令还原项目的 NuGet 包的时候，NuGet 会尝试自动检测计算机上已经安装的 MSBuild。不过，如果你同时安装了 Visual Studio 2017 和 Visual Studio 2019，那么 NuGet 有可能找到错误版本的 MSBuild。本文介绍如何解决自动查找版本错误的问题。问题当我们敲下 nuget restore 命令的时候，命令行的第 2 行会输出自动检测到的 MSBuild 版本号，就像下面的输出一样： NuGet Version: 5.0.2.5988MSBuild auto-detection: using msbuild version ‘15.9.21.664’ from ‘C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\MSBuild\\15.0\\Bin’. Use option -MSBuildVersion to force nuget to use a specific version of MSBuild.实际上我计算机上同时安装了 Visual Studio 2017 和 Visual Studio 2019，我有两个不同版本的 MSBuild： 15.9.21.664 在 C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\MSBuild\\15.0\\Bin 16.1.76.45076 在 C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\MSBuild\\Current\\Bin 要让 NuGet 找到正确版本的 MSBuild.exe，我们有三种方法。使用命令行参数解决实际上前面 nuget restore 命令的输出中就已经可以看出来其中一个解决方法了，即使用 -MSBuildVersion 来指定 MSBuild 的版本号。虽然命令行输出中推荐使用了 -MSBuildVersion 选项来指定 MSBuild 的版本，但是实际上实现同样功能的有两个不同的选项： -MSBuildPath 自 NuGet 4.0 开始新增的选项，指定 MSBuild 程序的路径。 -MSBuildVersion当同时指定上面两个选项时，-MSBuildPath 选项优先级高于 -MSBuildVersion 选项。于是我们的 nuget restore 命令改成这样写：&amp;gt; nuget restore -MSBuildPath &quot;C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\MSBuild\\Current\\Bin&quot;输出现在会使用期望的 MSBuild 了：Using Msbuild from &#39;C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\MSBuild\\Current\\Bin&#39;.修改环境变量解决NuGet 的命令行自动查找 MSBuild.exe 时，是通过环境变量中的 PATH 变量来找的。会找到 PATH 中第一个包含 msbuild.exe 文件的路径，将其作为自动查找到的 MSBuild 的路径。所以，我们的解决方法是，如果找错了，我们就把期望正确的 MSBuild 所在的路径设置到不期望的 MSBuild 路径的前面。就像下图这样，我们把 2019 版本的 MSBuild 设置到了 2017 版本的前面。以下是 NuGet 项目中自动查找 MSBuild.exe 文件的方法，源代码来自 https://github.com/NuGet/NuGet.Client/blob/2b45154b8568d6cbf1469f414938f0e3e88e3704/src/NuGet.Clients/NuGet.CommandLine/MsBuildUtility.cs#L986。private static string GetMSBuild(){ var exeNames = new [] { &quot;msbuild.exe&quot; }; if (RuntimeEnvironmentHelper.IsMono) { exeNames = new[] { &quot;msbuild&quot;, &quot;xbuild&quot; }; } // Try to find msbuild or xbuild in $Path. var pathDirs = Environment.GetEnvironmentVariable(&quot;PATH&quot;)?.Split(new[] { Path.PathSeparator }, StringSplitOptions.RemoveEmptyEntries); if (pathDirs?.Length &amp;gt; 0) { foreach (var exeName in exeNames) { var exePath = pathDirs.Select(dir =&amp;gt; Path.Combine(dir, exeName)).FirstOrDefault(File.Exists); if (exePath != null) { return exePath; } } } return null;}我故意在桌面上放了一个老旧的 MSBuild.exe，然后将此路径设置到环境变量 PATH 的前面，出现了编译错误。参考资料 NuGet CLI restore command - Microsoft Docs How Can I Tell NuGet What MSBuild Executable to Use? - Stack Overflow VS2017 MSBuild autodetection takes MSBuild/v14 instead of v15 for WPF project - Stack Overflow" }, { "title": "解决方案文件 sln 中的项目类型 GUID", "url": "/post/a-list-of-project-type-guids.html", "categories": "", "tags": "visualstudio", "date": "2019-07-24 11:06:12 +0800", "snippet": "Visual Studio 可以通过得知项目类型快速地为项目显示相应的图标、对应的功能等等。本文整理已收集到的一些项目的 GUID，如果你把你的解决方案文件（sln）改坏了，那么可以修复一下。 8BB2217D-0F2D-49D1-97BC-3654ED321F3B ASP.NET 5 603C0E0B-DB56-11DC-BE95-000D561079B0 ASP.NET MVC 1 F85E285D-A4E0-4152-9332-AB1D724D3325 ASP.NET MVC 2 E53F8FEA-EAE0-44A6-8774-FFD645390401 ASP.NET MVC 3 E3E379DF-F4C6-4180-9B81-6769533ABE47 ASP.NET MVC 4 349C5851-65DF-11DA-9384-00065B846F21 ASP.NET MVC 5 / Web Application FAE04EC0-301F-11D3-BF4B-00C04F79EFBC C# 9A19103F-16F7-4668-BE54-9A1E7A4F7556 C# (SDK 风格的项目) 8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942 C++ A9ACE9BB-CECE-4E62-9AA4-C7E7C5BD2124 Database 4F174C21-8C12-11D0-8340-0000F80270F8 Database (other project types) 3EA9E505-35AC-4774-B492-AD1749C4943A Deployment Cab 06A35CCD-C46D-44D5-987B-CF40FF872267 Deployment Merge Module 978C614F-708E-4E1A-B201-565925725DBA Deployment Setup AB322303-2255-48EF-A496-5904EB18DA55 Deployment Smart Device Cab F135691A-BF7E-435D-8960-F99683D2D49C Distributed System BF6F8E12-879D-49E7-ADF0-5503146B24B8 Dynamics 2012 AX C# in AOT 82B43B9B-A64C-4715-B499-D71E9CA2BD60 Extensibility F2A71F9B-5D33-465A-A702-920D77279786 F# 6EC3EE1D-3C4E-46DD-8F32-0CC8E7565705 F# (SDK 风格的项目) 95DFC527-4DC1-495E-97D7-E94EE1F7140D IL project E6FDF86B-F3D1-11D4-8576-0002A516ECE8 J# 262852C6-CD72-467D-83FE-5EEB1973A190 JScript 20D4826A-C6FA-45DB-90F4-C717570B9F32 Legacy (2003) Smart Device (C#) CB4CE8C6-1BDB-4DC7-A4D3-65A1999772F8 Legacy (2003) Smart Device (VB.NET) 581633EB-B896-402F-8E60-36F3DA191C85 LightSwitch Project 8BB0C5E8-0616-4F60-8E55-A43933E57E9C LightSwitch b69e3092-b931-443c-abe7-7e7b65f2a37f Micro Framework C1CDDADD-2546-481F-9697-4EA41081F2FC Office/SharePoint App 786C830F-07A1-408B-BD7F-6EE04809D6DB Portable Class Library 66A26720-8FB5-11D2-AA7E-00C04F688DDE Project Folders D954291E-2A0B-460D-934E-DC6B0785DB48 Shared Project 593B0543-81F6-4436-BA1E-4747859CAAE2 SharePoint (C#) EC05E597-79D4-47f3-ADA0-324C4F7C7484 SharePoint (VB.NET) F8810EC1-6754-47FC-A15F-DFABD2E3FA90 SharePoint Workflow A1591282-1198-4647-A2B1-27E5FF5F6F3B Silverlight 4D628B5B-2FBC-4AA6-8C16-197242AEB884 Smart Device (C#) 68B1623D-7FB9-47D8-8664-7ECEA3297D4F Smart Device (VB.NET) 2150E333-8FDC-42A3-9474-1A3956D46DE8 解决方案文件夹 3AC096D0-A1C2-E12C-1390-A8335801FDAB Test A5A43C5B-DE2A-4C0C-9213-0A381AF9435A Universal Windows Class Library F184B08F-C81C-45F6-A57F-5ABD9991F28F VB.NET 778DAE3C-4631-46EA-AA77-85C1314464D9 VB.NET (forces use of SDK project system) C252FEB5-A946-4202-B1D4-9916A0590387 Visual Database Tools 54435603-DBB4-11D2-8724-00A0C9A8B90C Visual Studio 2015 Installer Project Extension A860303F-1F3F-4691-B57E-529FC101A107 Visual Studio Tools for Applications (VSTA) BAA0C2D2-18E2-41B9-852F-F413020CAA33 Visual Studio Tools for Office (VSTO) E24C65DC-7377-472B-9ABA-BC803B73C61A Web Site 3D9AD99F-2412-4246-B90B-4EAA41C64699 Windows Communication Foundation (WCF) 76F1466A-8B6D-4E39-A767-685A06062A39 Windows Phone 8/8.1 Blank/Hub/Webview App C089C8C0-30E0-4E22-80C0-CE093F111A43 Windows Phone 8/8.1 App (C#) DB03555F-0C8B-43BE-9FF9-57896B3C5E56 Windows Phone 8/8.1 App (VB.NET) 60DC8134-EBA5-43B8-BCC9-BB4BC16C2548 Windows Presentation Foundation (WPF) BC8A1FFA-BEE3-4634-8014-F334798102B3 Windows Store (Metro) Apps &amp;amp; Components D954291E-2A0B-460D-934E-DC6B0785DB48 Windows Store App Universal 14822709-B5A1-4724-98CA-57A101D1B079 Workflow (C#) D59BE175-2ED0-4C54-BE3D-CDAA9F3214C8 Workflow (VB.NET) 32F31D43-81CC-4C15-9DE6-3FC5453562B6 Workflow Foundation EFBA0AD7-5A72-4C68-AF49-83D382785DCF Xamarin.Android / Mono for Android 6BC8ED88-2882-458C-8E55-DFD12B67127B Xamarin.iOS / MonoTouch F5B4F3BC-B597-4E2B-B552-EF5D8A32436F MonoTouch Binding 6D335F3A-9D43-41b4-9D22-F6F17C4BE596 XNA (Windows) 2DF5C3F4-5A5F-47a9-8E94-23B4456F55E2 XNA (XBox) D399B71A-8929-442a-A9AC-8BEC78BB2433 XNA (Zune)参考资料 csproj - Visual Studio project type guids - Stack Overflow INFO: List of known project type Guids List of Visual Studio Project Type GUIDs - CodeProject" }, { "title": ".NET/C# 使用 #if 和 Conditional 特性来按条件编译代码的不同原理和适用场景", "url": "/post/preprocessor-symbols-if-vs-conditional.html", "categories": "", "tags": "dotnet, csharp", "date": "2019-07-20 15:41:17 +0800", "snippet": "有小伙伴看到我有时写了 #if 有时写了 [Conditional] 问我两个不是一样的吗，何必多此一举。然而实际上两者的编译处理是不同的，因此也有不同的应用场景。于是我写到这篇文章当中。条件编译符号和预处理符号我们有时会使用 #if DEBUG 或者 [Conditional(&quot;DEBUG&quot;)] 来让我们的代码仅在特定的条件下编译。而这里的 DEBUG 是什么呢？ 在我们编写的 C# 代码中，这个叫做 “条件编译符号”（Conditional compilation symbols） 在项目的构建过程中，这个叫做 “定义常量”（Define constants） 而在将 C# 代码编译到 dll 的编译环节，这个叫做 “预处理符号”（Preprocessor symbols）本文要讨论的是 #if 和 Conditional 的使用，这是在 C# 代码中的使用场景，因此，本文后面都将其称之为 “条件编译符号”。区别#if#if DEBUGConsole.WriteLine(&quot;欢迎来 blog.walterlv.com 来做客呀！&quot;);#endif在这段代码中，#if DEBUG 和 #endif 之间的代码仅在 DEBUG 下会编译，在其他配置下是不会编译的。Conditional[Conditional(&quot;DEBUG&quot;)]public void Foo(){ Console.WriteLine(&quot;欢迎来 blog.walterlv.com 来做客呀！&quot;);}而这段代码，是会被编译到目标程序集中的。它影响的，是调用这个方法的代码。调用这个方法的代码，仅在 DEBUG 下会编译，在其他配置下是不会编译的。场景因为 #if DEBUG 和 #endif 仅仅影响包含在其内的代码块，因此其仅仅影响写的这点代码所在的项目（或者说程序集）。于是使用 #if 只会影响实现代码。而 [Conditional(&quot;DEBUG&quot;)] 影响的是调用它的代码，因此可以设计作为 API 使用——让目标项目（或者程序集）仅在目标项目特定的配置下才会编译。" }, { "title": "如何为你的 Windows 应用程序关联 URL 协议，以便在浏览器中也能打开你的应用", "url": "/post/windows-uri-scheme-association.html", "categories": "", "tags": "windows", "date": "2019-07-20 09:15:12 +0800", "snippet": "移动程序关联 URL 是常态，桌面应用程序其实也早就支持关联 URL 以便在浏览器中打开。当我们的程序关联了一个 URL 协议之后，开发的网站上就可以通过这个 URL 与程序进行互操作，这很互联网。对于 Windows 桌面应用来说，关联一个 URL 协议是通过修改注册表来实现的。本文介绍如何为你的应用关联一个 URL 协议。URL 协议一个常用的 URL 协议是这样子的：https://walterlv.com。前面的 https 就是协议名称，而 https:// 放在一起就是在使用 https 协议。本文我们将定义一个 walterlv 协议，然后关联到我们本地安装的一个桌面应用程序上，然后使用 walterlv://open?id=1 来打开一个 id 为 1 的逗比。注册一个 URL 协议要在 Windows 系统上注册一个 URL 协议，你只需要两个步骤： 好好想一个协议名称 在注册表中添加协议关联好好想一个协议名称就知道你想不出来名字，于是可以使用命名生成工具：Whitman，其原理可阅读 冷算法：自动生成代码标识符（类名、方法名、变量名） - 吕毅。然后本文使用协议名称 walterlv。在注册表中添加协议关联你需要在注册表的 HKEY_LOCAL_MACHINE\\Software\\Classes 或者 HKEY_CURRENT_USER\\Software\\Classes 添加一些子键：HKEY_CURRENT_USER\\Software\\Classes walterlv (Default) = 吕毅的特殊链接 URL Protocol = WalterlvProtocol Shell Open Command (Default) = &quot;C:\\Users\\lvyi\\AppData\\Local\\Walterlv.Foo\\Walterlv.Windows.Association.exe&quot; &quot;%1&quot;在 Classes 中的那个根键 walterlv 就是我们的协议名称，也就是 walterlv:// 的那个前缀。walterlv 根键 中的 (Default) 属性给出的是链接的名称；如果后面没有设置打开方式（也就是那个 Shell\\Open\\Command）的话，那么在 Chrome 里打开就会显示为那个名称（如下图）。URL Protocol 这个注册表项是必须存在的，但里面的值是什么其实无所谓。这只是表示 walterlv 是一个协议。接下来 Shell\\Open\\Command 中的 (Default) 值设置为一个打开此协议用的命令行。其中路径后面的 &quot;%1&quot; 是文件资源管理器传入的参数，其实就是文件的完整路径。我们加上了引号是避免解析命令行的时候把包含空格的路径拆成了多个参数。在正确填写了注册表的以上内容之后，在 Chrome 里打开此链接将看到以下 URL 打开提示：关于注册表路径的说明：HKEY_LOCAL_MACHINE 主键是此计算机上的所有用户共享的注册表键值，而 HKEY_CURRENT_USER 是当前用户使用的注册表键值。而我们在注册表的 HKEY_CLASSES_ROOT 中也可以看到跟 HKEY_LOCAL_MACHINE\\Software\\Classes 和 HKEY_CURRENT_USER\\Software\\Classes 中一样的文件关联项，是因为 HKEY_CLASSES_ROOT 是 HKEY_LOCAL_MACHINE\\Software\\Classes 和 HKEY_CURRENT_USER\\Software\\Classes 合并之后的一个视图，其中用户键值会覆盖此计算机上的相同键值。也就是说，如果你试图修改文件关联，那么需要去 HKEY_LOCAL_MACHINE\\Software\\Classes 和 HKEY_CURRENT_USER\\Software\\Classes 中，但如果只是去查看文件关联的情况，则只需要去 HKEY_CLASSES_ROOT 中。写入计算机范围内的注册表项需要管理员权限，而写入用户范围内的注册表项不需要管理员权限；你可以酌情选用。额外说明感谢 人猿 提供的补充信息： 假如初次点击不打开，并且勾选了始终，那么以后这个弹框就没有了，而程序也不会打开，需要做下配置的修改 谷歌浏览器：C:\\Users(你的用户名)\\AppData\\Local\\Google\\Chrome\\User Data\\Default\\Preferences 火狐浏览器：先关闭浏览器C:\\Users(你的用户名)\\AppData\\Roaming\\Mozilla\\Firefox\\Profiles\\4uasyvvi.default 找到handlers.json" }, { "title": "软件界面中一些易混淆/易用错的界面文案，以及一些约定俗成的文案约定", "url": "/post/some-confusing-ui-text.html", "categories": "", "tags": "windows, ui, ux", "date": "2019-07-13 09:49:39 +0800", "snippet": "经常有小伙伴跟我撕到底一些常用同音的词语应该使用哪个的问题。于是我将一些常用的软件界面中用错的文案整理出来，为自己和其他开发者提供我 已经整理的结论 和 可以溯源的资料。词语下面列举出来的一些词语，有的我写的是 “推荐”，指两者都是正确的，但更应该使用 “推荐” 中的词语；而有的我写的是 “正确”，指只有这一个才是正确的，而其他写法是错误的。无论哪一种，都说明了理由和可溯源的资料。撤销 / 撤消 推荐：在软件界面中推荐使用 “撤销”。应该逐渐淘汰“撤消”的使用。 实际：国产软件主要使用“撤销”，而国外软件的中文版本两者都有使用。看《现代汉语词典》：第五、六、七版： 【撤销】chèxiāo [动] 取消：～处分｜～职务。也作撤消。【撤消】chèxiāo 同“撤销”。第三版： 【撤销】chèxiāo [动] 撤除；取消 |&amp;gt; ～原判决 | ～多余的机构。☞ 不宜写作“撤消”。【撤消】chèxiāo 现在一般写作“撤销”。可见，“撤消”已经被淘汰，现全部应该使用“撤销”。那么实际中大家是如何使用的呢？Windows 系统和 Office 套件使用的是“撤消”：撤销恢复 / 撤销重做，撤消恢复 / 撤消重做 正确：恢复。撤销：Undo。恢复：Redo。重做：Repeat。有些软件会出现此错误，估计跟 Office 的使用有关。在正常情况下，Office 的左上角有一对按钮：“撤消” 和 “重做”。但是，“重做” 的意思真的是 “重复上一步操作”。当你点了 “撤消” 之后，这个 “重做” 按钮会消失，变成 “恢复” 按钮，意思是将刚刚 “撤消” 的操作 “恢复” 回来。因此，如果只是在 Office 软件里看了一眼就把文案抄过来了，那就会出现 “撤消重做” 这样的误用；实际上应该是 “撤销恢复”。 Added zh-CN translation by lindexi · Pull Request #32 · JasonStein/Notepads账号 / 帐号，账户 / 帐户 推荐：在软件 zhànghào / zhànghù 界面中推荐使用 “账号” 和 “账户”。 实际：各大软件平分秋色，都有使用。在 第一批异形词整理表 中对于 “账” 和 “帐” 的用法有一项相关的说明，明确 “账本”（zhàngběn）一词是普通话书面语中推荐的使用词形，而 “帐本” 是 “账本” 异形词。其对于 “账” 和 “帐” 的解释如下： “账”是“帐”的分化字。古人常把账目记于布帛上悬挂起来以利保存，故称日用的账目为“帐”。后来为了与帷帐分开，另造形声字“账”，表示与钱财有关。“账”“帐”并存并用后，形成了几十组异形词。《简化字总表》、《现代汉语通用字表》中“账”“帐”均收，可见主张分化。二字分工如下：“账”用于货币和货物出入的记载、债务等，如“账本、报账、借账、还账”等；“帐”专表用布、纱、绸子等制成的遮蔽物，如“蚊帐、帐篷、青纱帐（比喻用法）”等。从主张分化的目的来看，其更推荐在表示“货币和货物出入的记载、债务”时使用“账”，而在表示“布、纱、绸子等制成的遮蔽物”时使用“帐”。那么软件界面中应该使用哪一个呢？对于“支付宝”/“京东”/“淘宝”/“微信钱包”/各类银行这些一看就跟钱相关的应用里面，很明显推荐使用“账户”。另外一些如论坛 zhànghào，QQ zhànghào 等没有明前与钱相关的应用，其通常也包含一些虚拟的服务行为记录、以及与其他用户相关的虚拟交易方式（例如论坛币、Q 币），因此也推荐使用“账户”。然而还有一些与这些虚拟交易也没有关系的，非营利组织的或者完全个人的 zhànghào，应该使用什么呢？这些 zhànghù 通常只做一些密码记录、行为记录、用户个人设置个人偏好存储等。从含义上讲，这些信息与“账”描述中的“货物出入的记载”这一句是相关的，而与“帐”中的“布、纱、绸子等制成的遮蔽物”不相关。因此，即便是这些与钱不直接相关的用户 zhànghù 或者 zhànghào 也更加推荐使用 “账号” 和 “账户”。那么实际中大家是如何使用的呢？在我们刚刚参考的维基文库中，其使用的就是 “账号”：京东/1号店/支付宝的登录页面使用了 “账号”（淘宝使用了“会员名”来规避了这种争议词的使用）：淘宝使用了“会员名”来规避了这种争议词的使用。QQ/微信/网易中使用的是 “帐号”：Windows 系统采用了 “帐户” 一词。不过其中文版对此异形词做了很友好的适配，无论你输入哪一个词，最终都可以搜到你想要的 zhànghù：你以为微软统一使用 “帐户” 吗？实际上可以看看下面这个页面，两个词都有使用。微软一定很纠结。 怎么注册Microsoft账户 - 常见问题 - 微软官方商城登录 / 登陆 正确：“登录” 才是正确用法。“登陆”根本就不是计算机术语。 实际：主流软、大公司基本都正确使用了 “登录”，但其他网站就不好说了各种乱用。标点符号句号 推荐：句子的结尾必须有句号或者可以承担句号职责的标点；而短语后面则不应该加句号或同类标点。 实际：很多不成熟的软件会在句子结尾不带任何句号或同类标点。为什么连句号也要拿出来说呢？省略号从早期的界面设计中一直延续下来一个约定： 如果某个按钮有后续操作，那么这个按钮的名称后面需要带上省略号 “…”。注意，这是半个省略号 “…”，而不是三个点 “…”。无论中文还是英文都如此。 正在搜寻资料确认到底是什么。后续操作指的是“需要提供额外的信息”。例如“保存”直接存成文件，而“另存为”需要提供一个新的文件名。因此“保存”没有省略号而“另存为”则有省略号。这个约定在微软的 Windows 系统中和苹果的 macOS 系统中原本一直都有执行下去，就像下面这样：直到后来发现，如果继续执行这项约定，那么整个界面中将充斥着省略号，非常影响美观。于是后来就只在菜单中保留这项约定，其他常显界面中就去掉了省略号：额外说明可能需要解释一下异形词，来自维基文库： 异形词（variant forms of the same word） 普通话书面语中并存并用的同音（本规范中指声、韵、调完全相同）、同义（本规范中指理性意义、色彩意义和语法意义完全相同）而书写形式不同的词语。而异体字： 异体字（variant forms of a Chinese character） 与规定的正体字同音、同义而写法不同的字。本规范中专指被《第一批异体字整理表》淘汰的异体字。对于异形词，其不同的写法需要用在不同的场景中；对于异体字，则需要逐渐淘汰使用。参考资料 第一批异形词整理表 - 维基文库，自由的图书馆 第一批异体字整理表 - 维基文库，自由的图书馆 [【撤销】【撤消】 × 【C】√ - 校对标准：寻找权威依据 - Powered by phpwind](http://www.jiaodui.com/bbs/read.php?tid=9865) " }, { "title": "The VisualBrush of WPF only refresh the visual but not the layout", "url": "/post/visual-brush-refresh-views-only-but-not-layout-en.html", "categories": "", "tags": "wpf, dotnet, csharp", "date": "2019-07-12 20:53:11 +0800", "snippet": "Now we’ll talk about a behavior of WPF VisualBrush. Maybe it is a bug, but let’s view some details and determine whether it is or not.The reproduction codeLet’s make a XAML layout to reproduce such an issue.We have a large Grid which contains an inner Grid and an inner Border. The Grid contains a Rectangle which is as large as the Grid itself and a TextBlock which presents some contents. The Border only shows its background which a VisualBrush of the Grid.This is the whole XAML file:&amp;lt;Window x:Class=&quot;Walterlv.Demo.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; Title=&quot;Walterlv 的 WindowChrome 示例窗口&quot; Height=&quot;450&quot; Width=&quot;800&quot; WindowStartupLocation=&quot;CenterScreen&quot;&amp;gt; &amp;lt;Grid&amp;gt; &amp;lt;Grid x:Name=&quot;VisualSource&quot;&amp;gt; &amp;lt;Rectangle x:Name=&quot;VisibleOr&quot; Fill=&quot;LightCoral&quot; Visibility=&quot;Visible&quot; /&amp;gt; &amp;lt;TextBlock FontSize=&quot;24&quot; TextAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;&amp;gt; &amp;lt;Run Text=&quot;I&#39;m walterlv, &quot; /&amp;gt; &amp;lt;LineBreak /&amp;gt; &amp;lt;Run Text=&quot;I&#39;m reproducing this Visual bug.&quot; /&amp;gt; &amp;lt;/TextBlock&amp;gt; &amp;lt;/Grid&amp;gt; &amp;lt;Border&amp;gt; &amp;lt;Border.Background&amp;gt; &amp;lt;VisualBrush Visual=&quot;{Binding Source={x:Reference VisualSource}}&quot; /&amp;gt; &amp;lt;/Border.Background&amp;gt; &amp;lt;/Border&amp;gt; &amp;lt;/Grid&amp;gt;&amp;lt;/Window&amp;gt;This is the code-behind. Notice that it changes the visibility of the Rectangle every 1 second.using System.Threading.Tasks;using System.Windows;namespace Walterlv.Demo{ public partial class MainWindow : Window { public MainWindow() { InitializeComponent(); Loaded += OnLoaded; } private async void OnLoaded(object sender, RoutedEventArgs e) { while (true) { await Task.Delay(1000); VisibleOr.Visibility = Visibility.Collapsed; await Task.Delay(1000); VisibleOr.Visibility = Visibility.Visible; } } }}To verify the issueWe know that the VisualBrush shows and stretch the whole Visual so we can predicate only two results: If the Rectangle is visible with Visibility property Visible, the Border background which contains the VisualBrush will be exactly the same with the Grid. If the Rectangle is invisible with Visibility property Collapsed, the Border background which contains the VisualBrush will stretch the whole content to the Border without any area of the Rectangle.But it is the real result?The animation picture below shows the result when the Rectangle is visible as the startup:The animation picture below shows the result when the Rectangle is invisible as the startup:Did you notice that?Only at the very beginning when the program runs it behaves the same as we predicted. But when we change the visibility of the Rectangle the layout never changes.The issue?I’ve fired this issue into GitHub and this is the link: The VisualBrush only refresh the visual but not the layout when the Visual visibility changes · Issue #1241 · dotnet/wpf" }, { "title": "WPF 的 VisualBrush 只刷新显示的视觉效果，不刷新布局范围", "url": "/post/visual-brush-refresh-views-only-but-not-layout.html", "categories": "", "tags": "wpf, dotnet, csharp", "date": "2019-07-12 20:31:34 +0800", "snippet": "WPF 的 VisualBrush 可以帮助我们在一个控件中显示另一个控件的外观。这是非常妙的功能。但是本文需要说其中的一个 Bug —— 如果使用 VisualBrush 显示另一个控件的外观，那么只会在其显示效果有改变的时候刷新，而不会在目标布局改变的时候刷新布局。用于复现问题的代码我们现在做一个可以用于验证此问题的布局。在一个大的 Grid 容器中有一个 Grid 和一个 Border，这个 Grid 将放一个大面积的 Rectangle 和一个表示内容的 TextBlock；而那个 Border 将完全以 VisualBrush 的形式呈现，呈现的内容是此 Grid 中的全部内容。它的完整 XAML 代码如下：&amp;lt;Window x:Class=&quot;Walterlv.Demo.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; Title=&quot;Walterlv 的 WindowChrome 示例窗口&quot; Height=&quot;450&quot; Width=&quot;800&quot; WindowStartupLocation=&quot;CenterScreen&quot;&amp;gt; &amp;lt;Grid&amp;gt; &amp;lt;Grid x:Name=&quot;VisualSource&quot;&amp;gt; &amp;lt;Rectangle x:Name=&quot;VisibleOr&quot; Fill=&quot;LightCoral&quot; Visibility=&quot;Visible&quot; /&amp;gt; &amp;lt;TextBlock FontSize=&quot;24&quot; TextAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;&amp;gt; &amp;lt;Run Text=&quot;I&#39;m walterlv, &quot; /&amp;gt; &amp;lt;LineBreak /&amp;gt; &amp;lt;Run Text=&quot;I&#39;m reproducing this Visual bug.&quot; /&amp;gt; &amp;lt;/TextBlock&amp;gt; &amp;lt;/Grid&amp;gt; &amp;lt;Border&amp;gt; &amp;lt;Border.Background&amp;gt; &amp;lt;VisualBrush Visual=&quot;{Binding Source={x:Reference VisualSource}}&quot; /&amp;gt; &amp;lt;/Border.Background&amp;gt; &amp;lt;/Border&amp;gt; &amp;lt;/Grid&amp;gt;&amp;lt;/Window&amp;gt;其后台 C# 代码如下，包含每隔 1 秒钟切换 Rectangle 可见性的代码。using System.Threading.Tasks;using System.Windows;namespace Walterlv.Demo{ public partial class MainWindow : Window { public MainWindow() { InitializeComponent(); Loaded += OnLoaded; } private async void OnLoaded(object sender, RoutedEventArgs e) { while (true) { await Task.Delay(1000); VisibleOr.Visibility = Visibility.Collapsed; await Task.Delay(1000); VisibleOr.Visibility = Visibility.Visible; } } }}验证问题我们知道，VisualBrush 在默认情况下会将 Visual 中的全部内容拉伸到控件中显示，于是可以预估出两个可能的结果： 如果 Rectangle 可见（Visibility 为 Visible），那么 Border 中以 VisualBrush 显示的内容将完全和下面重叠（因为大小相同，拉伸后正好重叠）。 如果 Rectangle 不可见（Visibility 为 Collapsed），那么 Border 中以 VisualBrush 显示的内容将仅有文字且拉伸到整个 Border 范围。然而实际运行真的是这样子吗？下面的动图是 Rectangle 初始状态可见时，窗口运行后的结果：下面的动图是 Rectangle 初始状态不可见时，窗口运行后的结果：注意到了吗？只有初始状态才能正确反应我们之前预估出的结果，而无论后面怎么再改变可见性，布局都不会再刷新了。只是——后面 VisualBrush 的内容始终重叠。这意味着 VisualBrush 中目标 Visual 的范围增大之后不会再缩小了。问题？这是问题吗？于是在以下 issue 中跟进此问题： VisualBrush 的其他 Bug参见： wpf VisualBrush 已知问题 - 林德熙" }, { "title": "WPF 很少人知道的科技", "url": "/post/those-people-dont-know-about-wpf.html", "categories": "", "tags": "wpf, dotnet, csharp", "date": "2019-07-11 14:16:23 +0800", "snippet": "本文介绍不那么常见的 WPF 相关的知识。在 C# 代码中创建 DataTemplate大多数时候我们只需要在 XAML 中就可以实现我们想要的各种界面效果。这使得你可能已经不知道如何在 C# 代码中创建同样的内容。比如在代码中创建 DataTemplate，主要会使用到 FrameworkElementFactory 类型。可以参考： WPF 后台创建 DateTemplate - Iron 的博客 - CSDN博客多个数据源合并为一个列表显示WPF 提供 CompositionCollection 用于将多个列表合并为一个，以便在 WPF 界面的同一个列表中显示多个数据源的数据。&amp;lt;ListBox Name=&quot;WalterlvDemoListBox&quot;&amp;gt; &amp;lt;ListBox.Resources&amp;gt; &amp;lt;CollectionViewSource x:Key=&quot;Items1Source&quot; Source=&quot;{Binding Items1}&quot;/&amp;gt; &amp;lt;CollectionViewSource x:Key=&quot;Items2Source&quot; Source=&quot;{Binding Items2}&quot;/&amp;gt; &amp;lt;/ListBox.Resources&amp;gt; &amp;lt;ListBox.ItemsSource&amp;gt; &amp;lt;CompositeCollection&amp;gt; &amp;lt;CollectionContainer Collection=&quot;{Binding Source={StaticResource Items1Source}}&quot; /&amp;gt; &amp;lt;CollectionContainer Collection=&quot;{Binding Source={StaticResource Items2Source}}&quot; /&amp;gt; &amp;lt;ListBoxItem&amp;gt;Walterlv End Item 1&amp;lt;/ListBoxItem&amp;gt; &amp;lt;ListBoxItem&amp;gt;Walterlv End Item 2&amp;lt;/ListBoxItem&amp;gt; &amp;lt;/CompositeCollection&amp;gt; &amp;lt;/ListBox.ItemsSource&amp;gt;&amp;lt;/ListBox&amp;gt;关于 CompositeCollection 的使用示例可以参考： How to: Implement a CompositeCollection - Microsoft Docs神樹桜乃写了一份非 WPF 框架的版本，如果希望在非 WPF 程序中使用，可以参考： Sakuno.Base/ConcatenatedCollectionView`T.cs at master · KodamaSakuno/Sakuno.Base使用附加属性做缓存，避免内存泄漏在没有使用 WPF 的时候，如果我们要为一个对象添加属性或者行为，我们可能会使用字典来实现。但字典带来了内存泄漏的问题，要自己处理内存泄漏问题可能会写比较复杂的代码。然而，WPF 的附加属性可以非常容易地为对象添加属性或者行为，而且也不用担心内存泄漏问题。例如，我曾经用 WPF 来模拟 UWP 流畅设计（Fluent Design）中的光照效果，使用附加属性来管理此行为则完全不用担心内存泄漏问题： 流畅设计 Fluent Design System 中的光照效果 RevealBrush，WPF 也能模拟实现啦！使用 ConditionalWeakTable 做非 WPF 版本的缓存如果你有一些非 WPF 的对象需要做类似 WPF 那种附加属性，那么可以考虑使用 ConditionalWeakTable 来实现，Key 是那个对象，而 Value 是你需要附加的属性或者行为。这里的引用关系是 Key 引用着 Value，如果 Key 被回收，那么 Value 也可以被回收。 .NET/C# 使用 ConditionalWeakTable 附加字段（CLR 版本的附加属性，也可用用来当作弱引用字典 WeakDictionary）使用代码模拟触摸WPF 默认情况下的触摸是通过 COM 组件 PimcManager 获取到的，在禁用实时触摸后会启用系统的 TOUCH 消息获取到，如果开启了 Pointer 消息那么会使用 POINTER 消息。我们可以继承自 TouchDevice 来模拟触摸，详见： WPF 模拟触摸设备模拟 UWP 界面在现有的 Windowing API 下，系统中看起来非常接近系统级的窗口样式可能都是用不同技术模拟实现的，只是模拟得很像而已。如果要将 WPF 模拟得很像 UWP，可以参考我的这两篇博客： WPF 使用 WindowChrome，在自定义窗口标题栏的同时最大程度保留原生窗口样式（类似 UWP/Chrome） WPF 应用完全模拟 UWP 的标题栏按钮模拟 Fluent Design 特效目前 WPF 还不能直接使用 Windows 10 Fluent Design 特效。当然如果你的程序非常小，那么模拟一下也不会伤害太多性能： 流畅设计 Fluent Design System 中的光照效果 RevealBrush，WPF 也能模拟实现啦！ 在 Windows 10 上为 WPF 窗口添加模糊特效然而充分利用 Fluent Design 的高性能，需要上 XAML Islands，详见： [Using the UWP XAML hosting API in a desktop application - Windows apps Microsoft Docs](https://docs.microsoft.com/en-us/windows/apps/desktop/modernize/using-the-xaml-hosting-api) " }, { "title": "如果不用 ReSharper，那么 Visual Studio 2019 能还原 ReSharper 多少功能呢？", "url": "/post/visual-studio-vs-resharper.html", "categories": "", "tags": "visualstudio, dotnet, csharp", "date": "2019-07-10 22:03:12 +0800", "snippet": "本文只谈论 ReSharper 的那些常用功能中，Visual Studio 2019 能还原多少，主要提供给那些正在考虑不使用 ReSharper 插件的 Visual Studio 用户作为参考。毕竟 ReSharper 如此强大的功能是建立在每年缴纳不少的费用以及噩梦般占用 Visual Studio 性能的基础之上的。然而使用 Visual Studio 2019 社区版不搭配 ReSharper 则可以免费为开源社区做贡献。本文的内容分为三个部分： Visual Studio 能完全还原的 ReSharper 的功能 可能 Visual Studio 在此功能上已经追赶上了 ReSharper 可能 Visual Studio 在此功能上虽然依然不如 ReSharper 完善，但缺少的部分几乎不影响体验 可能 Visual Studio 此功能比 ReSharper 更胜一筹 Visual Studio 能部分还原 ReSharper 的功能 可能在多数场景中 Visual Studio 能获得 ReSharper 的此功能效果，在少数场景下不如 ReSharper 可能对多数人来说 Visual Studio 能获得 ReSharper 的此功能效果，对另一部分人来说无法替代 ReSharper 有可能 Visual Studio 在此功能上另辟蹊径比 ReSharper 更厉害，但综合效果不如 ReSharper Visual Studio 此功能依然很弱，但可以通过安装免费的插件的方式补足 Visual Studio 此功能依然比不上 ReSharper 可能是 Visual Studio 没有此功能 可能是 Visual Studio 此功能的实现方式上不如 ReSharper 快速、高效、简单 完美还原无处不在的智能感知提示默认情况下，Visual Studio 只在你刚开始打字或者输入 . 和 ( 的时候才出现智能感知提示，但是如果你使用 ReSharper 开发，你会发现智能感知提示无处不在（所以那么卡？）。实际上你也可以配置 Visual Studio 的智能感知在更多的情况下出现，请打开下面“工具”-&amp;gt;“选项”-&amp;gt;“文本编辑器”-&amp;gt;“C#”-&amp;gt;“IntelliSense”：打开“键入字符后显示完成列表”和“删除字符后显示完成列表”。这样，你只要正在编辑，都会显示智能感知提示。另外，如果你当前需要打开智能感知提示，默认情况下使用 Ctrl + 空格键 可以打开。当然你也可以将其修改为 ReSharper 中常见的快捷键 Alt + 右箭头。方法是修改键盘快捷键中的 “” 项。修改快捷键方法详见： 如何快速自定义 Visual Studio 中部分功能的快捷键另外，在 IntelliCode 部分，可以选择打开更多的 IntelliSense 完成项：在输入时即自动导入需要的命名空间ReSharper 的智能感知提示包含所依赖的各种程序集中的类型，然而 Visual Studio 的智能感知则没有包含那些，只有顶部写了 using 的几个命名空间中的类型。Visual Studio 2019 中可以设置智能感知提示中“显示未导入命名空间中的项”。默认是没有开启的，当开启后，你将直接能在智能感知提示中看到原本 ReSharper 中才能有的编写任何类型的体验。默认情况下输入未知类型时只能完整输入类名然后使用重构快捷键将命名空间导入：但开启了此选项后，只需要输入类名的一部分，哪怕此类型还没有写 using 将其导入，也能在智能感知提示中看到并且完成输入。提取局部变量在 ReSharper 中，选中一段代码，如果这段代码可以返回一个值，那么可以使用重构快捷键（默认 Alt+Enter）生成一个局部变量。如果同样带代码块在此方法体中有多处，那么可以同时将多处代码一并提取出来成为一个布局变量。在 Visual Studio 中，也可以选中一段代码将其提取称一个局部变量：重命名标识符（类名/方法名/属性名/变量名等）ReSharper 可以使用 Ctrl + R, R 快捷键重命名一个标识符。Visual Studio 中也是默认使用 F2 或者与 ReSharper 相同的 Ctrl + R, R 快捷键来重命名一个标识符。可以还原正在填坑……依然不足大量的代码片段ReSharper 中自带了大量方便的代码片段，而且其代码片段的可定制性非常强，有很多可以只能完成的宏；而且还有后置式代码片段。然而 Visual Studio 自带的代码片段就弱很多，只能支持最基本的宏。不过可以通过下面一些插件通过数量来补足功能上的一些短板： Snippetica for C# - Visual Studio Marketplace C# Methods Code Snippets - Visual Studio Marketplace" }, { "title": "Roslyn 入门：使用 Visual Studio 的语法可视化（Syntax Visualizer）窗格查看和了解代码的语法树", "url": "/post/roslyn-syntax-visualizer.html", "categories": "", "tags": "visualstudio, dotnet, csharp, roslyn", "date": "2019-07-07 10:00:43 +0800", "snippet": "使用 Visual Studio 提供的 Syntax Visualizer，我们可以实时看到一个代码文件中的语法树。这对我们基于 Roslyn 编写静态分析和修改工具非常有帮助。本文将介绍如何安装它和使用它。本文是 Roslyn 入门系列之一： Roslyn 入门：使用 Visual Studio 的语法可视化（Syntax Visualizer）窗格查看和了解代码的语法树（本文） Roslyn 入门：使用 .NET Core 版本的 Roslyn 编译并执行跨平台的静态的源码 Roslyn 入门：使用 Roslyn 静态分析现有项目中的代码这里是 Visual Studio 的语法可视化（Syntax Visualizer）：正在分析的代码文件是 MSTestEnhancer 中的 ContractTestContext.cs；也就是我的另一篇文章 Roslyn 入门：使用 Roslyn 静态分析现有项目中的代码 中所采用的例子。语法可视化树中有三种不同颜色的节点： 蓝色：SyntaxNode，表示声明、语句、子句和表达式等语法构造。 绿色：SyntaxToken，表示关键字、标识符、运算符等标点。 红色：SyntaxTrivia，代表语法上不重要的信息，例如标记、预处理指令和注释之间的空格。如果你是 Visual Studio 2017 / 2019，并且在安装 Visual Studio 时选择了 Visual Studio 扩展开发的工作负载，并且已经勾选了 .NET Compiler Platform SDK，那么你就已经安装好了。如果没有找到，请前往 如何安装和准备 Visual Studio 扩展/插件开发环境 - walterlv 再安装。如果你的 Visual Studio 版本比较旧，则需要去 .NET Compiler Platform SDK - Visual Studio Marketplace 下载安装。安装完之后，去“视图-&amp;gt;其它窗口”中就可以找到“Syntax Visualizer”。现在，我们在代码文件中任意地移动光标、选择代码块，都可以在 Syntax Visualizer 中看到对应的语法节点。这对我们基于 Roslyn 编写静态分析和修改工具非常有帮助。参考资料 Get started with syntax analysis (Roslyn APIs) - Microsoft Docs" }, { "title": "如何安装和准备 Visual Studio 扩展/插件开发环境", "url": "/post/how-to-prepare-visual-studio-extension-development-environment.html", "categories": "", "tags": "visualstudio, dotnet", "date": "2019-07-07 09:58:32 +0800", "snippet": "因为很多涉及到 Visual Studio 插件开发相关的文章/博客需要以安装 Visual Studio 插件开发环境为基础，所以本文介绍如何安装 Visual Studio 插件开发环境，以简化那些博客中的内容。启动 Visual Studio 安装程序请在开始菜单中找到或者搜索 Visual Studio Installer，然后启动它：安装 Visual Studio 插件开发工作负载在 Visual Studio 的安装界面中选择“修改”：在工作负载中找到并勾选 Visual Studio 扩展开发（英文版是 Visual Studio extension development），然后按下右下角的“修改”：等待 Visual Studio 安装完 Visual Studio 扩展开发。如果提示重启计算机，那么就重启一下。如果你想开发基于 Roslyn 的语法/语义分析插件如果你想开发基于 Roslyn 的语法/语义分析插件，那么需要在选择了 Visual Studio 扩展开发工作负载之后，在右侧将可选的 .NET Compiler Platform SDK 也打上勾。体验 Visual Studio 插件模板如果你成功安装了 Visual Studio 扩展开发的工作负载，那么你在新建项目的时候就可以看到 Visual Studio 扩展开发相关的项目模板。" }, { "title": "如何快速创建 Visual Studio 代码片段？", "url": "/post/create-code-snippet-for-visual-studio.html", "categories": "", "tags": "visualstudio, dotnet, csharp", "date": "2019-07-05 13:32:21 +0800", "snippet": "使用 Visual Studio 的代码片段功能，我们可以快速根据已有模板创建出大量常用的代码出来。ReSharper 已经自带了一份非常好用的代码片段工具，不过使用 ReSharper 创建出来的代码片段只能用在 ReSharper 插件中。如果团队当中有一些小伙伴没有 ReSharper（毕竟很贵），那么也可以使用到 Visual Studio 原生的代码片段。Visual Studio 的官方文档有演示如何创建 Visual Studio 的代码片段，不过上手成本真的很高。本文介绍如何快速创建 Visual Studio 代码片段，并不需要那么麻烦。Visual Studio 的代码片段管理器Visual Studio 中代码片段管理器的入口在“工具”中。你可以参照下图找到代码片段管理器的入口。在打开代码片段管理器之后，你可以选择自己熟悉的语言。里面会列出当前语言中可以插入的各种代码片段的源。不过，Visual Studio 并没有提供创建代码片段的方法。在这个管理器里面，你只能导入已经存在的代码片段，并不能直接进行编辑。官方文档提供了创建代码片段的方法，就在这里： Code snippets - Visual Studio - Microsoft Docs你只需要看一看就知道这其实是非常繁琐的创建方式，你几乎在手工编写本来是给机器阅读的代码。我们创建代码片段其实只是关注代码片段本身，那么有什么更快速的方法呢？方法是安装插件。Snippet Designer 插件请去 Visual Studio 的扩展管理器中安装插件，或者去 Visual Studio 的插件市场中下载安装插件： Snippet Designer - Visual Studio Marketplace在安装完插件之后（需要重新启动 Visual Studio 以完成安装），你就可以直接在 Visual Studio 中创建和编辑代码片段了。创建代码片段你需要去 Visual Studio 的“文件”-&amp;gt;“新建”-&amp;gt;“新建文件”中打开的模板选择列表中选择“Code Snippet”。下面，我演示创建一个 Debug.WriteLine 代码片段的创建方法。编写一段代码我将一段最简单的代码编写到了代码编辑窗格中：Debug.WriteLine(&quot;[section] text&quot;);插入占位符实际上，这段代码中的 section 和 text 应该是占位符。那么如何插入占位符呢？选中需要成为占位符的文本，在这里是 section ，然后鼠标右键，选择“Make Replacement”。这样，在下方的列表中就会出现一个新的占位符。设置文本占位符现在我们设置这个占位符的更多细节。比如在下图中，我设置了工具提示（即我们使用此代码片段的时候 Visual Studio 如何提示我们编写这个代码片段），设置了默认值（即没有写时应该是什么值）。设置了这只是一个文本文字，没有其他特别含义。设置这是可以编辑的。用通常的方法，设置 text 也是一个占位符。设置类型占位符如果我们只是这样创建一个代码片段，而目标代码可能没有引用 System.Diagnostics 命名空间，那么插入完之后手动引用这个命名空间体验可不好。那么如何让 Debug 类可以带命名空间地插入呢？我们需要将 Debug 也设置成占位符。但是这是可以自动生成的占位符，不需要用户输入，于是我们将其设置为不可编辑。同时，在“Function”一栏填写这是一个类型名称：SimpleTypeName(global::System.Diagnostics.Debug)转义 $ 符号实际上用于调试的话，代码越简单功能越全越好。于是我希望 Debug.WriteLine 上能够有一个字符串内插符号 $。那么问题来了，$ 符号是表示代码片段中占位符的符号，那么如何输入呢？方法是——写两遍 $。于是我们的代码片段现在是这样的：Debug.WriteLine($$&quot;[$section$] $text$&quot;);保存代码片段你可以随时按下 Ctrl+S 保存这个新建的代码片段。插件一个很棒的设计是，默认所在的文件夹就是 Visual Studio 中用来存放代码片段的文件夹。于是，你刚刚保存完就可以立刻在 Visual Studio 中看到效果了。导入代码片段如果你将代码片段保存在插件给你的默认的位置，那么你根本不需要导入任何代码片段。但如果你曾经导出过代码片段或者保存在了其他的地方，那么就需要在代码片段管理器中导入这些代码片段文件了。使用代码片段如果你前面使用了默认的保存路径，那么现在直接就可以开始使用了。使用我们在 Shortcut 中设置的字母组合可以插入代码片段：在插入完成之后，我们注意到此类型可以使用导入的命名空间前缀 System.Diagnostics。如果没有导入此命名空间前缀，代码片段会自动加入。按下 Tab 键可以在多个占位符之间跳转，而使用回车键可以确认这个代码片段。管理代码片段在 Visual Studio 视图菜单的其他窗口中，可以找到“Snippet Explorer”，打开它可以管理已有的代码片段，包括 Visual Studio 中内置的那些片段。推荐 C# 代码片段推荐另一款插件 Snippetica： Snippetica - Visual Studio Marketplace Snippetica for C# - Visual Studio Marketplace前者适用于 Visual Studio，后者适用于 Visual Studio Code。它自带了很多的 C# 代码片段，可以很大程度补充 Visual Studio 原生代码片段存在感低的问题。参考资料 Code snippets - Visual Studio - Microsoft Docs [Walkthrough: Create a code snippet - Visual Studio Microsoft Docs](https://docs.microsoft.com/en-us/visualstudio/ide/walkthrough-creating-a-code-snippet) Snippet Designer - Visual Studio Marketplace mmanela/SnippetDesigner: The Snippet Designer is a plugin which enhances the Visual Studio IDE to allow a richer and more productive code snippet experience." }, { "title": ".NET/C# 中设置当发生某个特定异常时进入断点（不借助 Visual Studio 的纯代码实现）", "url": "/post/set-a-breakpoint-when-exception-occurred.html", "categories": "", "tags": "dotnet, csharp", "date": "2019-07-04 13:26:55 +0800", "snippet": "使用 Visual Studio 可以帮助我们在发生异常的时候中断，便于我们调试程序出现异常那一时刻的状态。如果没有 Visual Studio 的帮助（例如运行已发布的程序），当出现某个或某些特定异常的时候如何能够迅速进入中断的环境来调试呢？本文介绍如何实现在发生特定异常时中断，以便调查此时程序的状态的纯代码实现。第一次机会异常.NET 程序代码中的任何一段代码，在刚刚抛出异常，还没有被任何处理的那一时刻，AppDomain 的实例会引发一个 FirstChanceException 事件，用于通知此时刚刚开始发生了一个异常。于是我们可以通过监听第一次机会异常来获取到异常刚刚发生那一刻而还没有被 catch 的状态：using System;using System.IO;using System.Runtime.ExceptionServices;namespace Walterlv.Demo.DoubiBlogs{ internal class Program { private static void Main(string[] args) { AppDomain.CurrentDomain.FirstChanceException += OnFirstChanceException; // 这里是程序的其他代码。 } private static void OnFirstChanceException(object sender, FirstChanceExceptionEventArgs e) { // 在这里，可以通过 e.Exception 来获取到这个异常。 } }}在第一次机会异常处中断我在这篇博客中举了一个例子来说明如何在发生异常的时候中断，不过是使用 Visual Studio： 在 Visual Studio 中设置当发生某个特定异常或所有异常时中断那么现在我们使用第一次机会异常来完善一下其中的代码：using System;using System.IO;using System.Runtime.ExceptionServices;namespace Walterlv.Demo.DoubiBlogs{ internal class Program { private static void Main(string[] args) { AppDomain.CurrentDomain.FirstChanceException += OnFirstChanceException; try { File.ReadAllText(@&quot;C:\\walterlv\\逗比博客\\不存在的文件.txt&quot;); } catch (IOException) { Console.WriteLine(&quot;出现了异常&quot;); } } private static void OnFirstChanceException(object sender, FirstChanceExceptionEventArgs e) { // 现在，我们使用 Debugger.Break() 来中断程序。 Debugger.Break(); } }}保持 Visual Studio 异常设置窗格中的异常设置处于默认状态（意味着被 catch 的异常不会在 Visual Studio 中中断）。现在运行这个程序，你会发现程序发生了中断，在我们写下了 Debugger.Break() 的那段代码上。而在这个时候查看 Visual Studio 中程序的堆栈，可以发现其实调用堆栈是接在一开始发生异常的那一个方法的后面的，而且是除了非托管代码之外帧都是相邻的。双击 Visual Studio 堆栈中亮色的帧，即可定位到我们自己写的代码。因此，双击第一个亮色的帧可以转到我们自己写的代码中第一个引发异常的代码块。这个时候可以查看应用程序中各处的状态，这正好是发生此熠时的状态（而不是 catch 之后的状态）。优化代码和提示为了让这段代码包装得更加“魔性”，我们可以对第一次机会异常的事件加以处理。现在，我们这么写：[DebuggerStepThrough, DebuggerNonUserCode]private static void OnFirstChanceException(object sender, FirstChanceExceptionEventArgs e) =&amp;gt; ExceptionDebugger.Break();用到的 ExceptionDebugger 类型如下：using System.Diagnostics;namespace Walterlv.Demo.DoubiBlogs{ internal class ExceptionDebugger { // 现在请查看 Visual Studio 中的堆栈以迅速定位刚刚发生异常时的程序状态。 // 如果你按下 F10，可以立刻但不跳转到你第一个出现异常的代码块中。 private static void BreakCore() =&amp;gt; Debugger.Break(); // 现在请查看 Visual Studio 中的堆栈以迅速定位刚刚发生异常时的程序状态。 // 如果你按下 F10，可以立刻但不跳转到你第一个出现异常的代码块中。 private static void LaunchCore() =&amp;gt; Debugger.Launch(); [DebuggerStepThrough, DebuggerNonUserCode] internal static void Break() { if (Debugger.IsAttached) { BreakCore(); } else { LaunchCore(); } } }}现在，发生了第一次机会异常的时候，会断点在我们写的 BreakCore 方法上。这里的代码很少，因此开发者看到这里的时候可以很容易地注意到上面的注释以了解到如何操作。现在再看堆栈，依然像前面一样，找到第一个亮色的帧可以找到第一个抛出异常的我们的代码。注意，我们在从第一次机会异常到后面中断的代码中，都设置了这两个特性： DebuggerStepThrough 设置此属性可以让断点不会出现在写的这几个方法中 于是，当你按下 F10 的时候，会跳过所有标记了此特性的方法，这可以直接跳转到最终发生异常的那段代码中去。 DebuggerNonUserCode 设置此代码非用户编写的代码 于是，在 Visual Studio 的堆栈中，我们会发现这几个方法会变成暗色的，Visual Studio 不会优先显式这部分的源代码，这可以让错误在最关键的代码中显示而不会被我们刚刚写的这些代码中污染。 附加调试器前面的代码中，我们做了一个判断 Debugger.IsAttached。这是在判断，如果当前没有附加调试器，那么就附加一个。于是这段代码可以运行在非 Visual Studio 的环境中，当出现了异常的时候，还可以补救选择一个调试器。当然，实际上附加到 Visual Studio 进行调试也是最佳的方法。只不过，我们不需要一定通过 Visual Studio，我们可以在一般测试代码的时候也能获得出现特定异常时立刻开始断点调查异常的特性。" }, { "title": "在 Visual Studio 中设置当发生某个特定异常或所有异常时中断", "url": "/post/break-when-a-specific-exception-throw-in-visual-studio.html", "categories": "", "tags": "dotnet, csharp, visualstudio", "date": "2019-07-04 13:07:52 +0800", "snippet": "当使用 Visual Studio 调试的时候，如果我们的代码中出现了异常，那么 Visual Studio 会让我们的程序中断，然后我们就能知道程序中出现了异常。但是，如果这个异常已经被 catch 了，那么默认情况下 Visual Studio 是不会帮我们中断的。能否在这个异常发生的第一时间让 Visual Studio 中断程序以便于我们调试呢？本文将介绍方法。会中断的异常看下面这一段代码，读取一个根本不存在的文件。我们都知道这会抛出 FileNotFoundException，随后 Visual Studio 会中断，然后告诉我们这句话发生了异常。using System;using System.IO;namespace Walterlv.Demo.DoubiBlogs{ internal class Program { private static void Main(string[] args) { File.ReadAllText(@&quot;C:\\walterlv\\逗比博客\\不存在的文件.txt&quot;); } }}不会中断的异常现在，我们为这段会出异常的代码加上 try-catch：using System;using System.IO;namespace Walterlv.Demo.DoubiBlogs{ internal class Program { private static void Main(string[] args) { try { File.ReadAllText(@&quot;C:\\walterlv\\逗比博客\\不存在的文件.txt&quot;); } catch (IOException) { Console.WriteLine(&quot;出现了异常&quot;); } } }}现在再运行，会发现 Visual Studio 并没有在出现此异常的时候中断，而是完成了程序最终的输出，随后结束程序。设置发生所有异常时中断有时我们会发现已经 catch 过的代码在后来也可能被证明有问题，于是希望即便被 catch 也要发生中断，以便在异常发生的第一时刻定位问题。Visual Studio 提供了一个异常窗格，可以用来设置在发生哪些异常的时候一定会中断并及时给出提示。异常窗格可以在“调试”-&amp;gt;“窗口”-&amp;gt;“异常设置”中打开：在异常设置窗格中，我们可以将 Common Language Runtime Exceptions 选项打勾，这样任何 CLR 异常引发的时候 Visual Studio 都会中断而无论是否有 catch 块处理掉了此异常。如果需要恢复设置，点击上面的恢复成默认的按钮即可。设置发生特定异常时中断或不中断当然，你也可以不需要全部打勾，而是只勾选你期望诊断问题的那几个异常。你可以试试，这其实是一个非常繁琐的工作，你会在大量的异常名称中失去眼神而再也无法直视任何异常了。所以更推荐的做法不是仅设置特定异常时中断，而是反过来设置——设置发生所有异常时中断，除了特定的一些异常之外。方法是： 将整个 Common Language Runtime Exceptions 打勾 在实际运行程序之后，如果发生了一些不感兴趣的异常，那么就在下面的框中将此异常取消勾选即可脱离 Visual Studio 设置如果程序并不是在 Visual Studio 中运行，那么有没有方法进行中断呢？一个做法是调用 Debugger.Launch()，但这样的话中断的地方就是在 Debugger.Launch() 所在的代码处，可能异常还没发生或者已经发生过了。有没有方法可以在异常发生的那一刻中断呢？请阅读我的另一篇博客： .NET/C# 中设置当发生某个特定异常时进入断点（不借助 Visual Studio 的纯代码实现）" }, { "title": ".NET/MSBuild 中的发布路径在哪里呢？如何在扩展编译的时候修改发布路径中的文件呢？", "url": "/post/where-is-msbuild-publish-folder.html", "categories": "", "tags": "dotnet, csharp, msbuild, visualstudio", "date": "2019-07-04 09:47:21 +0800", "snippet": "在扩展 MSBuild 编译的时候，我们一般的处理的路径都是临时路径或者输出路径，那么发布路径在哪里呢？我曾经在下面这一篇博客中说到可以通过阅读 Microsoft.NET.Sdk 的源码来探索我们想得知的扩展编译的答案： 解读 Microsoft.NET.Sdk 的源码，你能定制各种奇怪而富有创意的编译过程 - walterlv于是，我们可以搜索 &quot;Publish&quot; 这样的关键字找到我们希望找到的编译目标，于是找到在 Microsoft.NET.Sdk.Publish.targets 文件中，有很多的 PublishDir 属性存在，这可以很大概率猜测这个就是发布路径。不过我只能在这个文件中找到这个路径的再次赋值，找不到初值。如果全 Sdk 查找，可以找到更多赋初值和使用它复制和生成文件的地方。于是可以确认，这个就是最终的发布路径，只不过不同类型的项目，其发布路径都是不同的。比如默认是：&amp;lt;PublishDir Condition=&quot;&#39;$(PublishDir)&#39;==&#39;&#39;&quot;&amp;gt;$(OutputPath)app.publish\\&amp;lt;/PublishDir&amp;gt;还有：&amp;lt;_DeploymentApplicationDir&amp;gt;$(PublishDir)$(_DeploymentApplicationFolderName)\\&amp;lt;/_DeploymentApplicationDir&amp;gt;和其他。" }, { "title": "如何给 Windows Terminal 增加一个新的终端（以 Bash 为例）", "url": "/post/add-a-new-profile-for-windows-terminal.html", "categories": "", "tags": "windows", "date": "2019-07-03 16:51:53 +0800", "snippet": "Windows Terminal 的预览版本可以在微软应用商店下载，下载完后它原生就可以打开三个不同的终端 PowerShell Core、CMD 和 PowerShell。然而我的计算机上还安装了一个 Bash 可以如何添加到 Windows Terminal 里呢？本文将介绍添加一个新终端应该如何修改配置。下载安装 Windows TerminalWindows Terminal 预览版已上架微软应用商店，你可以前往下载： https://www.microsoft.com/store/productId/9N0DX20HK701随后，在开始菜单中启动 Windows Terminal。打开配置文件在界面的右上角点按下拉按钮，点击“Settings”可以打开配置文件。这个配置文件虽然看起来有 300+ 行，但实际上结构非常简单。我把它折叠起来加上一点点注释你应该很容易看出其配置文件的结构。新增一个 profile我们把原来的一个 profile 复制一份出来，这样我们就能够写一份自己的终端配置了。下面是我添加的 Bash 的配置。如果你是通过安装 Git for Windows 而安装的 Git Bash，那么默认路径就是 C:\\Program Files\\Git\\bin\\bash.exe。{ &quot;acrylicOpacity&quot; : 0.5, &quot;closeOnExit&quot; : true, &quot;colorScheme&quot; : &quot;Campbell&quot;, &quot;commandline&quot; : &quot;C:\\\\Program Files\\\\Git\\\\bin\\\\bash.exe&quot;, &quot;cursorColor&quot; : &quot;#FFFFFF&quot;, &quot;cursorShape&quot; : &quot;bar&quot;, &quot;fontFace&quot; : &quot;Monaco&quot;, &quot;fontSize&quot; : 12, &quot;guid&quot; : &quot;{1d4e097e-fe87-4164-97d7-3ca794c316fd}&quot;, &quot;historySize&quot; : 9001, &quot;icon&quot; : &quot;C:\\\\Users\\\\walterlv\\\\Resources\\\\Icons\\\\git-bash.png&quot;, &quot;name&quot; : &quot;Bash&quot;, &quot;padding&quot; : &quot;0, 0, 0, 0&quot;, &quot;snapOnInput&quot; : true, &quot;startingDirectory&quot; : &quot;%USERPROFILE%&quot;, &quot;useAcrylic&quot; : true},注意，必须要改的有这些项： commandline 你需要改成你的新的终端的路径； guid 必须使用新的跟其他终端不重复的 guid； name 改为终端的名称（本例中是 Bash，虽然不是必须，但强烈建议修改）Visual Studio 自带了一个 guid 生成工具，你可以在菜单的工具中找到：你也可以在网上搜索 GUID 生成器得到很多在线的 GUID 生成工具。另外，还有一些可选的参数： useAcrylic 使用亚克力效果 acrylicOpacity 亚克力效果透明度 colorScheme 配色方案（配置文件后面自带了五种配色方案，你也可以额外再添加新的配色方案） fontFace 字体名称 fontSize 字号大小 icon 图标 startingDirectory 初始路径其中，你可能需要一个 icon 文件，下面有一个 Git Bash 的图标，有需要自取：最终效果在你按下 Ctrl+S 保存这个配置文件之后，配置将会立刻生效。你可以在你的 Windows Terminal 中看到你新增的 Bash 终端了。" }, { "title": "Reading the Source Code of Microsoft.NET.Sdk, Writing the Creative Extension of Compiling", "url": "/post/read-microsoft-net-sdk-en.html", "categories": "", "tags": "dotnet, visualstudio, nuget, msbuild", "date": "2019-07-02 19:43:29 +0800", "snippet": "Project node starts to support the Sdk attribute since MSBuild release the 15.0 version which is embedded in Visual Studio 2017. For the Sdk attribute, the C# project file whose file extension is csproj becomes much more powerful and extensible.We’ll try to read the source code of Microsoft.NET.Sdk which is the default Sdk value of C#.NET project and try to write some creative extension of compiling.This post is written in multiple languages. Please select yours: 中文 English Where to find the source code of Microsoft.NET.SdkSearch Microsoft.NET.Sdk using Everything or Wox, I find that multiple versions are installed in my computer. As I’ve installed the .NET Core 2.1, the location of my latest version is C:\\Program Files\\dotnet\\sdk\\3.0.100-preview6-012264. The official document How to: Reference an MSBuild Project SDK says that if you implement your own Sdk, you can also push it to .▲ Search Microsoft.NET.Sdk▲ The Sdk folder on my computerThe NuGet part of Microsoft.NET.Sdk is on GitHub: NuGet.Client/src/NuGet.Core at dev · NuGet/NuGet.ClientThe folder structure of Microsoft.NET.SdkWhen clicking into the Microsoft.NET.Sdk folder, we can find that the folder structure is very similar to the NuGet folder structure.I’ve written some posts talking about the NuGet folder structure but unfortunately they are all not in English: How to Write a Cross-Platform NuGet Tool Package Base on MSBuild Task How to Write a Cross-Platform NuGet Tool Package Base on Command Line ApplicationMicrosoft have some official document talking about the NuGet folder structure How to create a NuGet package from a convention-based working directory.But there exists an extra Sdk folder for the Sdk kind of NuGet package.The Sdk.props file and the Sdj.targets file will be imported by default and Microsoft’s official document also mentions it here: How to: Reference an MSBuild Project SDK - Visual Studio. It says that the two code blocks are actually the same: &amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;TargetFramework&amp;gt;net46&amp;lt;/TargetFramework&amp;gt; &amp;lt;/PropertyGroup&amp;gt;&amp;lt;/Project&amp;gt; &amp;lt;Project&amp;gt; &amp;lt;!-- Implicit top import --&amp;gt; &amp;lt;Import Project=&quot;Sdk.props&quot; Sdk=&quot;Microsoft.NET.Sdk&quot; /&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;TargetFramework&amp;gt;net46&amp;lt;/TargetFramework&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;!-- Implicit bottom import --&amp;gt; &amp;lt;Import Project=&quot;Sdk.targets&quot; Sdk=&quot;Microsoft.NET.Sdk&quot; /&amp;gt;&amp;lt;/Project&amp;gt; Because of the default importation behavior, Sdk can do variaty of tasks when MSBuild or Roslyn build the .NET projects. The default Sdk Microsoft.NET.Sdk is very extensible so that we can easily use it to customize out compiling behavior and I’ve mentioned these in the two non-English posts above.The major targets of Microsoft.NET.SdkI try to search Target node in the whole Sdk folder and find out 174 Targets. Don’t worry about the huge Target amount because most of them are private by indicating the name with a _ prefix and some of them have the same name to override and wait to be overridden.So the core compiling Target is not so many and I pick up some core Target here: CollectPackageReferences: Collect the PackageReference items to resolve the package dependencies of the project. CoreCompile The core compiling Target. GenerateAssemblyInfo: Generate the AssemblyInfo.cs file which is usually written by developers manually before .NET Core published. Pack: Pack current project into a NuGet package file whose extension is nupkg. GenerateNuspec: Generate the nuspec file which is the meta info of the NuGet package.Write creative extensions of compilingI also find some creative Target that inspires me:&amp;lt;Target Name=&quot;DontRestore&quot; BeforeTargets=&quot;Restore&quot;&amp;gt; &amp;lt;Error Text=&quot;This project should not be restored&quot; /&amp;gt; &amp;lt;/Target&amp;gt;▲ If a Restore target exists, then report a compiling error.&amp;lt;Target Name=&quot;ReferenceStaticLegacyPackage&quot; BeforeTargets=&quot;CollectPackageReferences&quot;&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;PackageReference Remove=&quot;LiteDB&quot; /&amp;gt; &amp;lt;PackageReference Include=&quot;LiteDB&quot; Version=&quot;2.0.2&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt;&amp;lt;/Target&amp;gt;▲ This is written by me to prevent a specific package named LiteDB to be upgrade. I post this method in my another non-English post.References How to: Reference an MSBuild Project SDK - Visual Studio - Microsoft Docs" }, { "title": "解读 Microsoft.NET.Sdk 的源码，你能定制各种奇怪而富有创意的编译过程", "url": "/post/read-microsoft-net-sdk.html", "categories": "", "tags": "dotnet, visualstudio, nuget, msbuild", "date": "2019-07-02 19:42:50 +0800", "snippet": "在 csproj 中，Project 中的 Sdk 属性是 MSBuild 15.0 开始支持的，也就是 Visual Studio 2017 开始支持。有了 Sdk 属性的存在，MSBuild 编译过程能够扩展得非常强大，而不止是过去 Import 的一个 props 和 targets 文件。本文将介绍 Microsoft.NET.Sdk 的源码，以及利用源码中的一些线索来完成官方文档中没有提及的功能扩展。This post is written in multiple languages. Please select yours: 中文 English Microsoft.NET.Sdk 源码的位置在计算机上全局搜索 Microsoft.NET.Sdk 可以找到不同版本的多个 Sdk 目录，由于我安装了 .NET Core 3.0，所以找到的目录是：C:\\Program Files\\dotnet\\sdk\\3.0.100-preview6-012264。当然，按照官网 How to: Reference an MSBuild Project SDK 的描述，如果自己实现了一套 Sdk，也可以以 NuGet 包的形式发布。▲ 搜索 Microsoft.NET.Sdk▲ 我计算机上的 Sdk 文件夹Sdk 中的 NuGet 部分在 GitHub 上的仓库地址： NuGet.Client/src/NuGet.Core at dev · NuGet/NuGet.ClientMicrosoft.NET.Sdk 的目录结构在打开看 Microsoft.NET.Sdk 的目录结构后，我们可以发现这几乎就是 NuGet 包要求的目录结构。关于 NuGet 包的目录结构，我在下面两篇文章中都有提到过： 如何创建一个基于 MSBuild Task 的跨平台的 NuGet 工具包 如何创建一个基于命令行工具的跨平台的 NuGet 工具包官方对 NuGet 的目录结构也有介绍：How to create a NuGet package from a convention-based working directory。不过，Sdk 类型的 NuGet 包会多一个 Sdk 文件夹。Sdk 文件夹中的 Sdk.props 和 Sdk.targets 是会被默认 Import 的，这一点在官方文档 How to: Reference an MSBuild Project SDK - Visual Studio 中是有说明的，以下两段代码的含义相同： &amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;TargetFramework&amp;gt;net48&amp;lt;/TargetFramework&amp;gt; &amp;lt;/PropertyGroup&amp;gt;&amp;lt;/Project&amp;gt; &amp;lt;Project&amp;gt; &amp;lt;!-- Implicit top import --&amp;gt; &amp;lt;Import Project=&quot;Sdk.props&quot; Sdk=&quot;Microsoft.NET.Sdk&quot; /&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;TargetFramework&amp;gt;net48&amp;lt;/TargetFramework&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;!-- Implicit bottom import --&amp;gt; &amp;lt;Import Project=&quot;Sdk.targets&quot; Sdk=&quot;Microsoft.NET.Sdk&quot; /&amp;gt;&amp;lt;/Project&amp;gt; 由于这两个文件的默认引入，Sdk 可以完成非常多的编译任务。而且通常 Sdk 带有扩展性，使得我们可以很方便地对项目的编译过程进行扩展，这一点在我前面提到了两篇制作 NuGet 工具包的文章中都有说明。Microsoft.NET.Sdk 的主要任务在 Sdk 文件夹中搜索 Target 节点的个数，我得到了 174 个（随 .NET Core 2.1 发布）；不过有一些是同名的，会被重写（类似于 C#/.NET 中的继承和重写）；核心的并没有那么多。 CollectPackageReferences 用于收集 PackageReference 收集到的所有依赖（也就是 NuGet 包依赖） CoreCompile 核心的编译过程 GenerateAssemblyInfo 用于生成 AssemblyInfo.cs 文件（以前可是手工写的呢） Pack 用于将当前程序集打包成一个 NuGet 包 GenerateNuspec 在打包之前生成 nuspec 文件定制富有创意的编译过程下面是 Microsoft.NET.Sdk 中发现的一些富有创意的编译过程：&amp;lt;Target Name=&quot;DontRestore&quot; BeforeTargets=&quot;Restore&quot;&amp;gt; &amp;lt;Error Text=&quot;This project should not be restored&quot; /&amp;gt; &amp;lt;/Target&amp;gt;▲ 如果有 Restore，那么让你编译不通过&amp;lt;Target Name=&quot;ReferenceStaticLegacyPackage&quot; BeforeTargets=&quot;CollectPackageReferences&quot;&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;PackageReference Remove=&quot;LiteDB&quot; /&amp;gt; &amp;lt;PackageReference Include=&quot;LiteDB&quot; Version=&quot;2.0.2&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt;&amp;lt;/Target&amp;gt;▲ 这是我另外写的一篇文章：阻止某个 NuGet 包意外升级参考资料 How to: Reference an MSBuild Project SDK - Visual Studio - Microsoft Docs" }, { "title": "App will crash when using the when keyword in a catch expression", "url": "/post/try-catch-when-causes-app-crash-en.html", "categories": "", "tags": "dotnet, csharp", "date": "2019-07-02 19:32:59 +0800", "snippet": "We know that we can add a when keyword after a catch filter. But if there is another exception happened in the when expression, the app will totally crash.This happens in .NET Framework 4.8 but in .NET Core 3.0, it works correctly as the document says.Maybe this is a bug in the .NET Framework 4.8 CLR.本文使用 多种语言 编写，请选择你想阅读的语言： 中文 English The when in the official documentYou can view the official document here: Using User-Filtered Exception Handlers - Microsoft DocsThere is such a sentence here: The expression of the user-filtered clause is not restricted in any way. If an exception occurs during execution of the user-filtered expression, that exception is discarded and the filter expression is considered to have evaluated to false. In this case, the common language runtime continues the search for a handler for the current exception.When there is an exception occurred in the when expression the exception will be ignored and the expression will return false.A demoWe can write a demo to verify this behavior of the official document.using System;using System.IO;namespace Walterlv.Demo.CatchWhenCrash{ internal class Program { private static void Main(string[] args) { try { try { Console.WriteLine(&quot;Try&quot;); throw new FileNotFoundException(); } catch (FileNotFoundException ex) when (ex.FileName.EndsWith(&quot;.png&quot;)) { Console.WriteLine(&quot;Catch 1&quot;); } catch (FileNotFoundException) { Console.WriteLine(&quot;Catch 2&quot;); } } catch (Exception) { Console.WriteLine(&quot;Catch 3&quot;); } Console.WriteLine(&quot;End&quot;); } }}Obviously, the FileName property will keep null in the first when expression and will cause a NullReferenceException. It is not recommended to write such the code but it can help us verify the behavior of the catch-when blocks.If the official document is correct then we can get the output as Try-Catch 2-End because the exception in the when will be ignored and the outer catch will not catch it and then the when expression returns false so that the exception handling goes into the second one.In .NET Core 3.0 and in .NET Framework 4.8The pictures below show the actual output of the demo code above in .NET Core 3.0 and in .NET Framework 4.8.Only in the .NET Core 3.0, the output behaves the same as the official document says. But in .NET Framework 4.8, the End even not appear in the output. We can definitely sure that the app crashes in .NET Framework 4.8.If we run the app step by step in Visual Studio, we can see that a CLR exception happens.This animated picture below shows how the code goes step by step." }, { "title": ".NET / MSBuild 扩展编译时什么时候用 BeforeTargets / AfterTargets 什么时候用 DependsOnTargets？", "url": "/post/msbuild-before-after-targets-vs-depends-on-targets.html", "categories": "", "tags": "visualstudio, msbuild, nuget, dotnet", "date": "2019-07-01 16:43:43 +0800", "snippet": "在为 .NET 项目扩展 MSBuild 编译而编写编译目标（Target）时，我们会遇到用于扩展编译目标用的属性 BeforeTargets AfterTargets 和 DependsOnTargets。这三个应该分别在什么情况下用呢？本文将介绍其用法。BeforeTargets / AfterTargetsBeforeTargets 和 AfterTargets 是用来扩展编译用的。如果你希望在某个编译任务开始执行一定要执行你的编译目标，那么请使用 BeforeTargets。例如我想多添加一个文件加入编译，那么写：&amp;lt;Target Name=&quot;_WalterlvIncludeSourceFiles&quot; BeforeTargets=&quot;CoreCompile&quot;&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;Compile Include=&quot;$(MSBuildThisFileFullPath)..\\src\\Foo.cs&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt;&amp;lt;/Target&amp;gt;这样，一个 Foo.cs 就会在编译时加入到被编译的文件列表中，里面的 Foo 类就可以被使用了。这也是 NuGet 源代码包的核心原理部分。关于 NuGet 源代码包的制作方法，可以扩展阅读： 将 .NET Core 项目打一个最简单的 NuGet 源码包，安装此包就像直接把源码放进项目一样 从零开始制作 NuGet 源代码包（全面支持 .NET Core / .NET Framework / WPF 项目）如果你希望一旦执行完某个编译任务之后执行某个操作，那么请使用 AfterTargets。例如我想在编译完成生成了输出文件之后，将这些输出文件拷贝到另一个调试目录，那么写：&amp;lt;Target Name=&quot;CopyOutputLibToFastDebug&quot; AfterTargets=&quot;AfterBuild&quot;&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;OutputFileToCopy Include=&quot;$(OutputPath)$(AssemblyName).dll&quot;&amp;gt;&amp;lt;/OutputFileToCopy&amp;gt; &amp;lt;OutputFileToCopy Include=&quot;$(OutputPath)$(AssemblyName).pdb&quot;&amp;gt;&amp;lt;/OutputFileToCopy&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;Copy SourceFiles=&quot;@(OutputFileToCopy)&quot; DestinationFolder=&quot;$(MainProjectPath)&quot;&amp;gt;&amp;lt;/Copy&amp;gt;&amp;lt;/Target&amp;gt;这种写法可以进行快速的组件调试。下面这篇博客就是用到了 AfterTargets 带来的此机制来实现的： Roslyn 让 VisualStudio 急速调试底层库方法如果 BeforeTargets 和 AfterTargets 中写了多个 Target 的名称（用分号分隔），那么只要任何一个准备执行或者执行完毕，就会触发此 Target 的执行。DependsOnTargets而 DependsOnTargets 是用来指定依赖的。DependsOnTargets 并不会直接帮助你扩展一个编译目标，也就是说如果你只为你的 Target 写了一个名字，然后添加了 DependsOnTargets 属性，那么你的 Target 在编译期间根本都不会执行。但是，使用 DependsOnTargets，你可以更好地控制执行流程和其依赖关系。例如上面的 CopyOutputLibToFastDebug 这个将输出文件复制到另一个目录的编译目标（Target），依赖于一个 MainProjectPath 属性，因此计算这个属性值的编译目标（Target）应该设成此 Target 的依赖。当 A 的 DependsOnTargets 设置为 B;C;D 时，那么一旦准备执行 A 时将会发生： 如果 B C D 中任何一个曾经已经执行过，那么就忽略（因为已经执行过了） 如果 B C D 中还有没有执行的，就立刻执行实践当我们实际上在扩展编译的时候，我们会用到不止一个编译目标，因此这几个属性都是混合使用的。但是，你应该在合适的地方编写合适的属性设置。例如我们做一个 NuGet 包，这个 NuGet 包的 .targets 文件中写了下面几个 Target： _WalterlvEvaluateProperties 用于初始化一些属性和参数，其他所有的 Target 都依赖于这些参数 _WalterlvGenerateStartupObject 生成一个类，包含 Main 入口点函数，然后将入口点设置成这个类 _WalterlvIncludeSourceFiles 为目标项目添加一些源代码，这就包含刚刚新生成的入口点类 _WalterlvPackOutput 将目标项目中生成的文件进行自定义打包 那么我们改如何为每一个 Target 设置正确的属性呢？第一步：找出哪些编译目标是真正完成编译任务的，这些编译目标需要通过 BeforeTargets 和 AfterTarget 设置扩展编译。于是我们可以找到 _WalterlvIncludeSourceFiles、_WalterlvPackOutput。 _WalterlvIncludeSourceFiles 需要添加参与编译的源代码文件，因此我们需要将 BeforeTargets 设置为 CoreCompile。 _WalterlvPackOutput 需要在编译完成后进行自定义打包，因此我们将 AfterTargets 设置为 AfterBuild。这个时候可以确保文件已经生成完毕可以使用了。第二步：找到依赖关系，这些依赖关系需要通过 DependsOnTargets 来执行。于是我们可以找到 _WalterlvEvaluateProperties、_WalterlvGenerateStartupObject。 _WalterlvEvaluateProperties 被其他所有的编译目标使用了，因此，我们需要将后面所有的 DependsOnTargets 属性设置为 _WalterlvEvaluateProperties。 _WalterlvGenerateStartupObject 生成的入口点函数被 _WalterlvIncludeSourceFiles 加入到编译中，因此 _WalterlvIncludeSourceFiles 的 DependsOnTargets 属性需要添加 _WalterlvGenerateStartupObject（添加方法是使用分号“;”分隔）。将所有的这些编译任务合在一起写，将是下面这样：&amp;lt;Target Name=&quot;_WalterlvEvaluateProperties&quot;&amp;gt;&amp;lt;/Target&amp;gt;&amp;lt;Target Name=&quot;_WalterlvGenerateStartupObject&quot; DependsOnTargets=&quot;_WalterlvEvaluateProperties&quot;&amp;gt;&amp;lt;/Target&amp;gt;&amp;lt;Target Name=&quot;_WalterlvIncludeSourceFiles&quot; BeforeTargets=&quot;CoreCompile&quot; DependsOnTargets=&quot;_WalterlvEvaluateProperties;_WalterlvGenerateStartupObject&quot;&amp;gt;&amp;lt;/Target&amp;gt;&amp;lt;Target Name=&quot;_WalterlvPackOutput&quot; AfterTargets=&quot;AfterBuild&quot; DependsOnTargets=&quot;_WalterlvEvaluateProperties&quot;&amp;gt;&amp;lt;/Target&amp;gt;具体依赖于抽象我们平时在编写代码时会考虑面向对象的六个原则，其中有一个是依赖倒置原则，即具体依赖于抽象。你不这么写代码当然不会带来错误，但会带来维护性困难。在编写扩展编译目标的时候，这一条同样适用。假如我们要写的编译目标不止上面这些，还有更多： _WalterlvConvertTemplateCompileToRealCompile 包里有一些模板代码，会在编译期间转换为真实代码并加入编译 _WalterlvConditionalImportedSourceCode 会根据 NuGet 包用户的设置有条件地引入一些额外的源代码 那么这个时候我们前面写的用于引入源代码的 _WalterlvIncludeSourceFiles 编译目标其依赖的 Target 会更多。似乎看起来应该这么写了：&amp;lt;Target Name=&quot;_WalterlvIncludeSourceFiles&quot; BeforeTargets=&quot;CoreCompile&quot; DependsOnTargets=&quot;_WalterlvEvaluateProperties;_WalterlvGenerateStartupObject;_WalterlvConvertTemplateCompileToRealCompile;_WalterlvConditionalImportedSourceCode&quot;&amp;gt;&amp;lt;/Target&amp;gt;但你小心： 这个列表会越来越长，而且指不定还会增加一些边边角角的引入的新的源代码呢 _WalterlvConditionalImportedSourceCode 是有条件的，而我们 DependsOnTargets 这样的写法会导致这个 Target 的条件失效这里更抽象的编译目标是 _WalterlvIncludeSourceFiles，我们的依赖关系倒置了！为了解决这样的问题，我们引入一个新的属性 _WalterlvIncludeSourceFilesDependsOn，如果有编译目标在编译过程中生成了新的源代码，那么就需要将自己加入到此属性中。现在的源代码看起来是这样的：&amp;lt;!-- 这里是一个文件 --&amp;gt;&amp;lt;PropertyGroup&amp;gt; &amp;lt;_WalterlvIncludeSourceFilesDependsOn&amp;gt; $(_WalterlvIncludeSourceFilesDependsOn); _WalterlvGenerateStartupObject &amp;lt;/_WalterlvIncludeSourceFilesDependsOn&amp;gt;&amp;lt;/PropertyGroup&amp;gt;&amp;lt;Target Name=&quot;_WalterlvEvaluateProperties&quot;&amp;gt;&amp;lt;/Target&amp;gt;&amp;lt;Target Name=&quot;_WalterlvGenerateStartupObject&quot; DependsOnTargets=&quot;_WalterlvEvaluateProperties&quot;&amp;gt;&amp;lt;/Target&amp;gt;&amp;lt;Target Name=&quot;_WalterlvIncludeSourceFiles&quot; BeforeTargets=&quot;CoreCompile&quot; DependsOnTargets=&quot;$(_WalterlvIncludeSourceFilesDependsOn)&quot;&amp;gt;&amp;lt;/Target&amp;gt;&amp;lt;Target Name=&quot;_WalterlvPackOutput&quot; AfterTargets=&quot;AfterBuild&quot; DependsOnTargets=&quot;_WalterlvEvaluateProperties&quot;&amp;gt;&amp;lt;/Target&amp;gt;&amp;lt;!-- 这里是另一个文件 --&amp;gt;&amp;lt;PropertyGroup&amp;gt; &amp;lt;_WalterlvIncludeSourceFilesDependsOn&amp;gt; $(_WalterlvIncludeSourceFilesDependsOn); _WalterlvConvertTemplateCompileToRealCompile; _WalterlvConditionalImportedSourceCode &amp;lt;/_WalterlvIncludeSourceFilesDependsOn&amp;gt;&amp;lt;/PropertyGroup&amp;gt;&amp;lt;PropertyGroup Condition=&quot; &#39;$(UseWalterlvDemoCode)&#39; == &#39;True&#39; &quot;&amp;gt; &amp;lt;_WalterlvIncludeSourceFilesDependsOn&amp;gt; $(_WalterlvIncludeSourceFilesDependsOn); _WalterlvConditionalImportedSourceCode &amp;lt;/_WalterlvIncludeSourceFilesDependsOn&amp;gt;&amp;lt;/PropertyGroup&amp;gt;&amp;lt;Target Name=&quot;_WalterlvConvertTemplateCompileToRealCompile&quot; DependsOnTargets=&quot;_WalterlvEvaluateProperties&quot;&amp;gt;&amp;lt;/Target&amp;gt;&amp;lt;Target Name=&quot;_WalterlvConditionalImportedSourceCode&quot; Condition=&quot; &#39;$(UseWalterlvDemoCode)&#39; == &#39;True&#39; &quot; DependsOnTargets=&quot;_WalterlvEvaluateProperties&quot;&amp;gt;&amp;lt;/Target&amp;gt;实际上，Microsoft.NET.Sdk 内部有很多的编译任务是通过这种方式提供的扩展，例如： BuildDependsOn CleanDependsOn CompileDependsOn你可以阅读我的另一篇博客了解更多： 通过重写预定义的 Target 来扩展 MSBuild / Visual Studio 的编译过程" }, { "title": "使用 Visual Studio 编译时，让错误一开始发生时就停止编译（以便及早排查编译错误节省时间）", "url": "/post/cancel-building-if-error-occurred-in-visual-studio.html", "categories": "", "tags": "visualstudio, dotnet, csharp", "date": "2019-06-30 13:36:09 +0800", "snippet": "对于稍微大一点的 .NET 解决方案来说，编译时间通常都会长一些。如果项目结构和差量编译优化的好，可能编译完也就 5~30 秒，但如果没有优化好，那么出现 1~3 分钟都是可能的。如果能够在编译出错的第一时间停止编译，那么我们能够更快地去找编译错误的原因，也能从更少的编译错误列表中找到出错的关键原因。如果你只是觉得你的项目或解决方案编译很慢而不知道原因，我推荐你安装 Parallel Builds Monitor 插件来调查一下。你可以阅读我的一篇博客来了解它： Visual Studio 使用 Parallel Builds Monitor 插件迅速找出编译速度慢的瓶颈，优化编译速度 - walterlv一个优化比较差的解决方案可能是下面这个样子的：明明没有多少个项目，但是项目之间的依赖几乎是一条直线，于是不可能开启项目的并行编译。图中这个项目的编译时长有 1 分 30 秒。可想而知，如果你的改动导致非常靠前的项目编译错误，而默认情况下编译的时候会继续尝试编译下去，于是你需要花非常长的时间才能等待编译完毕，然后从一大堆项目中出现的编译错误中找到最开始出现错误的那个（通常也是编译失败的本质原因）。现在，推荐使用插件 VSColorOutput。它的主要功能是给你的输出窗格加上颜色，可以让你更快速地区分调试信息、输出、警告和错误。不过，也正是因为它是通过匹配输出来上色的，于是它可以得知你的项目出现了编译错误，可以采取措施。在你安装了这款插件之后，你可以在 Visual Studio 的“工具”-&amp;gt;“设置”中找到 VSColorOutput 的设置。其中有一项是“Stop Build on First Error”，打开之后，再出现了错误的话，将第一时间会停止。你也可以发现你的 Visual Studio 错误列表中的错误数量非常少了，这些错误都是导致编译失败的最早出现的错误，利于你定位问题。" }, { "title": "C#/.NET 移动或重命名一个文件夹（如果存在，则合并而不是出现异常报错）", "url": "/post/move-files-from-a-directory-to-another.html", "categories": "", "tags": "dotnet, csharp", "date": "2019-06-29 12:57:15 +0800", "snippet": ".NET 提供了一个简单的 API 来移动一个文件夹 Directory.Move(string sourceDirName, string destDirName)。不过如果你稍微尝试一下这个 API 就会发现其实相当不实用。在使用 Directory.Move(string sourceDirName, string destDirName) 这个 API 来移动文件夹的时候，比如我们需要将 A 文件夹移动成 B 文件夹（也可以理解成重命名成 B）。一旦 B 文件夹是存在的，那么这个时候会抛出异常。然而实际上我们可能希望这两个文件夹能够合并。.NET 的 API 没有原生提供合并两个文件夹的方法，所以我们需要自己实现。方法是递归遍历里面的所有文件，然后将源文件夹中的文件依次移动到目标文件夹中。为了应对复杂的文件夹层次结构，我写的方法中也包含了递归。private static void MoveDirectory(string sourceDirectory, string targetDirectory){ MoveDirectory(sourceDirectory, targetDirectory, 0); void MoveDirectory(string source, string target, int depth) { if (!Directory.Exists(source)) { return; } if (!Directory.Exists(target)) { Directory.CreateDirectory(target); } var sourceFolder = new DirectoryInfo(source); foreach (var fileInfo in sourceFolder.EnumerateFiles(&quot;*&quot;, SearchOption.TopDirectoryOnly)) { var targetFile = Path.Combine(target, fileInfo.Name); if (File.Exists(targetFile)) { File.Delete(targetFile); } File.Move(fileInfo.FullName, targetFile); } foreach (var directoryInfo in sourceFolder.EnumerateDirectories(&quot;*&quot;, SearchOption.TopDirectoryOnly)) { var back = string.Join(&quot;\\\\&quot;, Enumerable.Repeat(&quot;..&quot;, depth)); MoveDirectory(directoryInfo.FullName, Path.GetFullPath(Path.Combine(target, back, directoryInfo.Name)), depth + 1); } Directory.Delete(source); }}depth 是一个整型，表示递归深度。我在计算文件需要移动到的新文件夹的路径的时候，需要使用到这个递归深度，以便回溯到最开始需要移动的那个文件夹上。" }, { "title": "如何追踪 WPF 程序中当前获得键盘焦点的元素并显示出来", "url": "/post/how-to-track-wpf-focused-element.html", "categories": "", "tags": "wpf, dotnet, csharp", "date": "2019-06-29 09:07:54 +0800", "snippet": "我们有很多的调试工具可以帮助我们查看 WPF 窗口中当前获得键盘焦点的元素。本文介绍监控当前键盘焦点元素的方法，并且提供一个不需要任何调试工具的自己绘制键盘焦点元素的方法。使用调试工具查看当前获得键盘焦点的元素Visual Studio 带有实时可视化树的功能，使用此功能调试 WPF 程序的 UI 非常方便。在打开实时可视化树后，我们可以略微认识一下这里的几个常用按钮：这里，我们需要打开两个按钮： 为当前选中的元素显示外框 追踪具有焦点的元素这样，只要你的应用程序当前获得焦点的元素发生了变化，就会有一个表示这个元素所在位置和边距的叠加层显示在窗口之上。你可能已经注意到了，Visual Studio 附带的这一叠加层会导致鼠标无法穿透操作真正具有焦点的元素。这显然不能让这一功能一直打开使用，这是非常不方便的。使用代码查看当前获得键盘焦点的元素我们打算在代码中编写追踪焦点的逻辑。这可以规避 Visual Studio 中叠加层中的一些问题，同时还可以在任何环境下使用，而不用担心有没有装 Visual Studio。获取当前获得键盘焦点的元素：var focusedElement = Keyboard.FocusedElement;不过只是拿到这个值并没有多少意义，我们需要： 能够实时刷新这个值； 能够将这个控件在界面上显示出来。实时刷新Keyboard 有路由事件可以监听，得知元素已获得键盘焦点。Keyboard.AddGotKeyboardFocusHandler(xxx, OnGotFocus);这里的 xxx 需要替换成监听键盘焦点的根元素。实际上，对于窗口来说，这个根元素可以唯一确定，就是窗口的根元素。于是我可以写一个辅助方法，用于找到这个窗口的根元素：// 用于存储当前已经获取过的窗口根元素。private FrameworkElement _root;// 获取当前窗口的根元素。private FrameworkElement Root =&amp;gt; _root ?? (_root = FindRootVisual(this));// 一个辅助方法，用于根据某个元素为起点查找当前窗口的根元素。private static FrameworkElement FindRootVisual(FrameworkElement source) =&amp;gt; (FrameworkElement)((HwndSource)PresentationSource.FromVisual(source)).RootVisual;于是，监听键盘焦点的代码就可以变成：Keyboard.AddGotKeyboardFocusHandler(Root, OnGotFocus);void OnGotFocus(object sender, KeyboardFocusChangedEventArgs e){ if (e.NewFocus is FrameworkElement fe) { // 在这里可以输出或者显示这个获得了键盘焦点的元素。 }}显示为了显示一个跟踪焦点的控件，我写了一个 UserControl，里面的主要代码是：&amp;lt;Canvas IsHitTestVisible=&quot;False&quot;&amp;gt; &amp;lt;Border x:Name=&quot;FocusBorder&quot; BorderBrush=&quot;#80159f5c&quot; BorderThickness=&quot;4&quot; HorizontalAlignment=&quot;Left&quot; VerticalAlignment=&quot;Top&quot; IsHitTestVisible=&quot;False&quot; SnapsToDevicePixels=&quot;True&quot;&amp;gt; &amp;lt;Border x:Name=&quot;OffsetBorder&quot; Background=&quot;#80159f5c&quot; Margin=&quot;-200 -4 -200 -4&quot; Padding=&quot;12 0&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Bottom&quot; SnapsToDevicePixels=&quot;True&quot;&amp;gt; &amp;lt;Border.RenderTransform&amp;gt; &amp;lt;TranslateTransform x:Name=&quot;OffsetTransform&quot; Y=&quot;16&quot; /&amp;gt; &amp;lt;/Border.RenderTransform&amp;gt; &amp;lt;TextBlock x:Name=&quot;FocusDescriptionTextBlock&quot; Foreground=&quot;White&quot; HorizontalAlignment=&quot;Center&quot; /&amp;gt; &amp;lt;/Border&amp;gt; &amp;lt;/Border&amp;gt;&amp;lt;/Canvas&amp;gt;using System;using System.Runtime.InteropServices;using System.Text;using System.Windows;using System.Windows.Controls;using System.Windows.Input;using System.Windows.Interop;using System.Windows.Threading;namespace Walterlv.Windows{ public partial class KeyboardFocusView : UserControl { public KeyboardFocusView() { InitializeComponent(); Loaded += OnLoaded; Unloaded += OnUnloaded; } private void OnLoaded(object sender, RoutedEventArgs e) { if (Keyboard.FocusedElement is FrameworkElement fe) { SetFocusVisual(fe); } Keyboard.AddGotKeyboardFocusHandler(Root, OnGotFocus); } private void OnUnloaded(object sender, RoutedEventArgs e) { Keyboard.RemoveGotKeyboardFocusHandler(Root, OnGotFocus); _root = null; } private void OnGotFocus(object sender, KeyboardFocusChangedEventArgs e) { if (e.NewFocus is FrameworkElement fe) { SetFocusVisual(fe); } } private void SetFocusVisual(FrameworkElement fe) { var topLeft = fe.TranslatePoint(new Point(), Root); var bottomRight = fe.TranslatePoint(new Point(fe.ActualWidth, fe.ActualHeight), Root); var isOnTop = topLeft.Y &amp;lt; 16; var isOnBottom = bottomRight.Y &amp;gt; Root.ActualHeight - 16; var bounds = new Rect(topLeft, bottomRight); Canvas.SetLeft(FocusBorder, bounds.X); Canvas.SetTop(FocusBorder, bounds.Y); FocusBorder.Width = bounds.Width; FocusBorder.Height = bounds.Height; FocusDescriptionTextBlock.Text = string.IsNullOrWhiteSpace(fe.Name) ? $&quot;{fe.GetType().Name}&quot; : $&quot;{fe.Name}({fe.GetType().Name})&quot;; } private FrameworkElement _root; private FrameworkElement Root =&amp;gt; _root ?? (_root = FindRootVisual(this)); private static FrameworkElement FindRootVisual(FrameworkElement source) =&amp;gt; (FrameworkElement)((HwndSource)PresentationSource.FromVisual(source)).RootVisual; }}这样，只要将这个控件放到窗口中，这个控件就会一直跟踪窗口中的当前获得了键盘焦点的元素。当然，为了最好的显示效果，你需要将这个控件放到最顶层。绘制并实时显示 WPF 程序中当前键盘焦点的元素如果我们需要监听应用程序中所有窗口中的当前获得键盘焦点的元素怎么办呢？我们需要给所有当前激活的窗口监听 GotKeyboardFocus 事件。于是，你需要我在另一篇博客中写的方法来监视整个 WPF 应用程序中的所有窗口： 如何监视 WPF 中的所有窗口，在所有窗口中订阅事件或者附加 UI里面有一段对 ApplicationWindowMonitor 类的使用：var app = Application.Current;var monitor = new ApplicationWindowMonitor(app);monitor.ActiveWindowChanged += OnActiveWindowChanged;void OnActiveWindowChanged(object sender, ActiveWindowEventArgs e){ var newWindow = e.NewWindow; // 一旦有一个新的获得焦点的窗口出现，就可以在这里执行一些代码。}于是，我们只需要在 OnActiveWindowChanged 事件中，将我面前面写的控件 KeyboardFocusView 从原来的窗口中移除，然后放到新的窗口中即可监视新的窗口中的键盘焦点。由于每一次的窗口激活状态的切换都会更新当前激活的窗口，所以，我们可以监听整个 WPF 应用程序中所有窗口中的键盘焦点。" }, { "title": "如何监视 WPF 中的所有窗口，在所有窗口中订阅事件或者附加 UI", "url": "/post/how-to-monitor-all-windows-of-wpf-application.html", "categories": "", "tags": "wpf, dotnet, csharp", "date": "2019-06-28 08:38:21 +0800", "snippet": "由于 WPF 路由事件（主要是隧道和冒泡）的存在，我们很容易能够通过只监听窗口中的某些事件使得整个窗口中所有控件发生的事件都被监听到。然而，如果我们希望监听的是整个应用程序中所有的事件呢？路由事件的路由可并不会跨越窗口边界呀？本文将介绍我编写的应用程序窗口监视器，来监听整个应用程序中所有窗口中的路由事件。这样的方法可以用来无时无刻监视 WPF 程序的各种状态。其实问题依旧摆在那里，因为我们依然无法让路由事件跨越窗口边界。更麻烦的是，我们甚至不知道应用程序有哪些窗口，这些窗口都是什么时机显示出来的。Application 类中有一个属性 Windows，这是一个 WindowCollection 类型的属性，可以用来获取当前已经被 Application 类管理的所有的窗口的集合。当然 Application 类内部还有一个属性 NonAppWindowsInternal 用来管理与此 Application 没有逻辑关系的窗口集合。于是，我们只需要遍历 Windows 集合便可以获得应用程序中的所有窗口，然后对每一个窗口监听需要的路由事件。var app = Application.Current;foreach (Window window in app.Windows){ // 在这里监听窗口中的事件。}等等！这种操作意味着将来新打开的窗口是不会被监听到事件的。我们有没有方法拿到新窗口的显示事件呢？遗憾的是——并不行。但是，我们有一些变相的处理思路。比如，由于 Windows 系统的特性，整个用户空间内，统一时刻只能有一个窗口能处于激活状态。我们可以利用当前窗口的激活与非激活的切换时机再去寻找新的窗口。于是，一开始的时候，我们可以监听一些窗口的激活事件。如果执行这段初始化代码的时候没有任何窗口是激活的状态，那么就监听所有窗口的激活事件；如果有一个窗口是激活的，那么就监听这个窗口的取消激活事件。private void InitializeActivation(){ var app = Application.Current; var availableWindows = app.Windows.ToList(); var activeWindow = availableWindows.FirstOrDefault(x =&amp;gt; x.IsActive); if (activeWindow == null) { foreach (var window in availableWindows) { window.Activated -= Window_Activated; window.Activated += Window_Activated; } } else { activeWindow.Deactivated -= Window_Deactivated; activeWindow.Deactivated += Window_Deactivated; UpdateActiveWindow(activeWindow); }}private void UpdateActiveWindow(Window window){ // 当前激活的窗口已经发生了改变，可以在这里为新的窗口做一些事情了。}在 Window_Activated 和 Window_Deactivated 事件中，我们主要也是在做初始化。现在思路基本上全部清晰了，于是我将我写的 ApplicationWindowMonitor 类的全部源码贴出来。using System;using System.Linq;using System.Windows;using System.Windows.Threading;namespace Walterlv.Windows{ public sealed class ApplicationWindowMonitor { private readonly Application _app; private readonly Predicate&amp;lt;Window&amp;gt; _windowFilter; private Window _lastActiveWindow; public ApplicationWindowMonitor(Application app, Predicate&amp;lt;Window&amp;gt; windowFilter = null) { _app = app ?? throw new ArgumentNullException(nameof(app)); _windowFilter = windowFilter; _app.Dispatcher.InvokeAsync(InitializeActivation, DispatcherPriority.Send); } private void InitializeActivation() { var availableWindows = _app.Windows.OfType&amp;lt;Window&amp;gt;().Where(FilterWindow).ToList(); var activeWindow = availableWindows.FirstOrDefault(x =&amp;gt; x.IsActive); if (activeWindow == null) { foreach (var window in availableWindows) { window.Activated -= Window_Activated; window.Activated += Window_Activated; } } else { activeWindow.Deactivated -= Window_Deactivated; activeWindow.Deactivated += Window_Deactivated; UpdateActiveWindow(activeWindow); } } private void Window_Activated(object sender, EventArgs e) { var window = (Window) sender; window.Activated -= Window_Activated; window.Deactivated -= Window_Deactivated; window.Deactivated += Window_Deactivated; UpdateActiveWindow(window); } private void Window_Deactivated(object sender, EventArgs e) { var availableWindows = _app.Windows.OfType&amp;lt;Window&amp;gt;().Where(FilterWindow).ToList(); foreach (var window in availableWindows) { window.Deactivated -= Window_Deactivated; window.Activated -= Window_Activated; window.Activated += Window_Activated; } } private void UpdateActiveWindow(Window window) { if (!Equals(window, _lastActiveWindow)) { try { OnActiveWindowChanged(_lastActiveWindow, window); } finally { _lastActiveWindow = window; } } } private bool FilterWindow(Window window) =&amp;gt; _windowFilter == null || _windowFilter(window); public event EventHandler&amp;lt;ActiveWindowEventArgs&amp;gt; ActiveWindowChanged; private void OnActiveWindowChanged(Window oldWindow, Window newWindow) { ActiveWindowChanged?.Invoke(this, new ActiveWindowEventArgs(oldWindow, newWindow)); } }}使用方法是：var app = Application.Current;var monitor = new ApplicationWindowMonitor(app);monitor.ActiveWindowChanged += OnActiveWindowChanged;void OnActiveWindowChanged(object sender, ActiveWindowEventArgs e){ var newWindow = e.NewWindow; // 一旦有一个新的获得焦点的窗口出现，就可以在这里执行一些代码。}另外，我在 ApplicationWindowMonitor 的构造函数中加入了一个过滤窗口的委托。比如你可以让窗口的监听只对主要的几个窗口生效，而对一些信息提示窗口忽略等等。" }, { "title": ".NET/C# 如何获取当前进程的 CPU 和内存占用？如何获取全局 CPU 和内存占用？", "url": "/post/how-to-get-process-cpu-memory-usage.html", "categories": "", "tags": "dotnet", "date": "2019-06-28 07:48:08 +0800", "snippet": "都知道可以在任务管理器中查看进程的 CPU 和内存占用，那么如何通过 .NET 编写代码的方式来获取到 CPU 和内存占用呢？.NET 中提供了 PerformanceCounter 类型，可以用来监视系统中大量的性能问题。获取全局 CPU 和内存占用要获取到全系统中的 CPU 占用率，获取全系统中内存占用，需要首先分别创建这两者的性能计数器：// 创建对 CPU 占用百分比的性能计数器。var cpuCounter = new PerformanceCounter(&quot;Processor&quot;, &quot;% Processor Time&quot;, &quot;_Total&quot;);// 创建内存占用字节数的性能计数器var ramCounter = new PerformanceCounter(&quot;Memory&quot;, &quot;Available MBytes&quot;);接下来，使用 NextValue() 可分别获取到两者的值：float cpu = CpuCounter.NextValue();float ram = RamCounter.NextValue();你需要注意的是，我们在创建 PerformanceCounter 时，构造函数中传入的参数是固定的，或者说必须跟当前系统中安装的计数器的计数器类别的名称（categoryName，第一个参数）和计数器的名称（counterName，第二个参数）对应。另外，如果某个类别包含单个实例，那么需要传入实例名称（instanceName，第三个参数）。获取当前进程的 CPU 和内存占用在了解的 PerformanceCounter 各个参数代表的含义之后，我们还可以获取到单个进程的性能计数。var name = Process.GetCurrentProcess().ProcessName;var cpuCounter = new PerformanceCounter(&quot;Process&quot;, &quot;% Processor Time&quot;, name);var ramCounter = new PerformanceCounter(&quot;Process&quot;, &quot;Working Set&quot;, name);也是使用 NextValue() 来获取到此性能计数器实例的值。这里，我们在计算单个进程的内存占用时，使用的是工作集大小，这个值会比较接近我们平时使用任务管理器看到的物理内存占用的大小，但是我们还有其他可以查询的类别： Private Bytes 包含进程向系统中申请的私有内存大小，不包含跨进程中共享的部分内存。 Working Set 进程占用的物理内存的大小。由于包含共享内存部分和其他资源，所以其实并不准；但这个值就是在任务管理器中看到的值。 Virtual Bytes 进程在地址空间中已经使用到的所有的地址空间总大小。参考资料 PerformanceCounter Class (System.Diagnostics) - Microsoft Docs How to get the CPU Usage in C#? - Stack Overflow .net - Get CPU Usage for Process by Process ID - Stack Overflow c# - What is the correct Performance Counter to get CPU and Memory Usage of a Process? - Stack Overflow debugging - What is private bytes, virtual bytes, working set? - Stack Overflow" }, { "title": "从 git 的历史记录中彻底删除文件或文件夹", "url": "/post/remove-files-or-folders-from-git-history.html", "categories": "", "tags": "git", "date": "2019-06-23 16:43:41 +0800", "snippet": "如果你对外开源的代码中出现了敏感信息（例如你将私钥上传到了仓库中），你可能需要考虑将这个文件从 git 的历史记录中完全删除掉。本文介绍如何从 git 的历史记录中彻底删除文件或文件夹。第一步：修改本地历史记录彻底删除文件：git filter-branch --force --index-filter &#39;git rm --cached --ignore-unmatch walterlv.xml&#39; --prune-empty --tag-name-filter cat -- --all其中 walterlv.xml 是本来不应该上传的私钥文件，于是使用此命令彻底删除。后面的命令 --tag-name-filter 指所有相关的标签都需要更新。彻底删除文件夹：git filter-branch --force --index-filter &#39;git rm --cached -r --ignore-unmatch WalterlvDemoFolder&#39; --prune-empty --tag-name-filter cat -- --all删除文件夹时需要额外带一个 -r 选项，并指定文件夹名称，这里的例子是 WalterlvDemoFolder。第二步：强制推送到远端仓库刚刚我们的操作仅仅发生在本地仓库，敏感信息需要删除的仓库通常都在远端，于是我们一定要将修改推送到远端仓库。需要推送的目标分支包括我们所有长期维护的分支，这通常就包括了 master 分支和所有的标签。于是使用推送命令：git.exe push origin master:master --tags --force" }, { "title": ".NET 中让 Task 支持带超时的异步等待", "url": "/post/task-wait-async-with-timeout.html", "categories": "", "tags": "dotnet, csharp", "date": "2019-06-21 09:17:55 +0800", "snippet": "Task 自带有很多等待任务完成的方法，有的是实例方法，有的是静态方法。有的阻塞，有的不阻塞。不过带超时的方法只有一个，但它是阻塞的。本文将介绍一个非阻塞的带超时的等待方法。Task 已有的等待方法Task 实例已经有的等待方法有这些：▲ Task 实例的等待方法一个支持取消，一个支持超时，再剩下的就是这两个的排列组合了。但是 Task 实例的等待方法都有一个弊端，就是 阻塞。如果你真的试图去等待这个 Task，势必会占用一个宝贵的线程资源。所以通常不建议这么做。另外，Task 还提供了静态的等待方法：▲ Task 静态的等待方法Task.Wait 提供的功能几乎与 Task 实例的 Wait 方法是一样的，只是可以等待多个 Task 的实例。而 Task.When 则是真正的异步等待，不阻塞线程的，可以节省一个线程资源。可是，依然只有 Task.Wait 这种阻塞的方法才有超时，Task.When 系列是没有的。我们补充一个带超时的异步等待方法Task 有一个 Delay 静态方法，我们是否可以利用这个方法来间接实现异步非阻塞的等待呢？答案是可以的，我们有 Task.WhenAny 可以在多个任务的任何一个完成时结束。我们的思路是要么任务先完成，要么超时先完成。于是我们可以先建一个新的 Task，即 Task.Delay(timeout)，再比较这两个 Task 的执行先后：public static async Task&amp;lt;TResult&amp;gt; WaitAsync&amp;lt;TResult&amp;gt;(Task&amp;lt;TResult&amp;gt; task, TimeSpan timeout){ if (await Task.WhenAny(task, Task.Delay(timeout)) == task) { return await task; } throw new TimeoutException(&quot;The operation has timed out.&quot;);}考虑延时任务可以取消，于是我们可以使用 CancellationTokenSource。将这个方法封装成 Task 的扩展方法：namespace Walterlv{ public static class TaskWaitingExtensions { public static async Task&amp;lt;TResult&amp;gt; WaitAsync&amp;lt;TResult&amp;gt;(this Task&amp;lt;TResult&amp;gt; task, TimeSpan timeout) { using (var timeoutCancellationTokenSource = new CancellationTokenSource()) { var delayTask = Task.Delay(timeout, timeoutCancellationTokenSource.Token); if (await Task.WhenAny(task, delayTask) == task) { timeoutCancellationTokenSource.Cancel(); return await task; } throw new TimeoutException(&quot;The operation has timed out.&quot;); } } }}于是我们就可以在任意的 Task 实例上调用 Task.WaitAsync 来获取带超时的等待了。参考资料 [c# - Asynchronously wait for Task to complete with timeout - Stack Overflow](https://stackoverflow.com/q/4238345/6233938)" }, { "title": ".NET 使用 ILMerge 合并多个程序集，避免引入额外的依赖", "url": "/post/merge-assemblies-using-ilmerge.html", "categories": "", "tags": "dotnet, csharp", "date": "2019-06-17 21:34:41 +0800", "snippet": "我们有多种工具可以将程序集合并成为一个。打包成一个程序集可以避免分发程序的时候带上一堆依赖而出问题。ILMerge 可以用来将多个程序集合并成一个程序集。本文介绍使用 ILMerge 工具和其 NuGet 工具包来合并程序集和其依赖。以 NuGet 包的形式使用 ILMergeILMerge 提供了可供你项目使用的 NuGet 包。如果你在团队项目当中安装了 ILMerge 的 NuGet 包，那么无论团队其他人是否安装了 ILMerge 的工具，都可以使用 ILMerge 工具。这可以避免要求团队所有成员安装工具或者将工具内置到项目的源代码管理中。要以 NuGet 包的形式来使用 ILMerge，需要首先安装 ILMerge 的 NuGet 包： [NuGet Gallery ilmerge](https://www.nuget.org/packages/ilmerge) 或者直接在你的项目的 csproj 文件中添加 PackageReference：&amp;lt;ItemGroup&amp;gt; &amp;lt;PackageReference Include=&quot;ILMerge&quot; Version=&quot;3.0.29&quot; /&amp;gt;&amp;lt;/ItemGroup&amp;gt;我现在有一个项目 Walterlv.Demo.AssemblyLoading，这是一个控制台程序。这个程序引用了一个 NuGet 包 Ben.Demystifier。为此带来了三个额外的依赖。- Walterlv.Demo.AssemblyLoading.exe- Ben.Demystifier.dll- System.Collections.Immutable.dll- System.Reflection.Metadata.dll而我们可以使用 ILMerge 将这些依赖和我们生成的主程序合并成一个程序集，这样分发程序的时候只需要一个程序集即可。那么，我们现在需要编辑我们的项目文件： &amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;OutputType&amp;gt;Exe&amp;lt;/OutputType&amp;gt; &amp;lt;TargetFramework&amp;gt;net48&amp;lt;/TargetFramework&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;PackageReference Include=&quot;Ben.Demystifier&quot; Version=&quot;0.1.4&quot; /&amp;gt; &amp;lt;PackageReference Include=&quot;ILMerge&quot; Version=&quot;3.0.29&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt;++ &amp;lt;Target Name=&quot;ILMerge&quot;&amp;gt;++ &amp;lt;Exec Command=&quot;&amp;amp;quot;$(ILMergeConsolePath)&amp;amp;quot; /ndebug /target:exe /out:$(OutputPath)$(AssemblyName).exe /log $(OutputPath)$(AssemblyName).exe /log $(OutputPath)Ben.Demystifier.dll /log $(OutputPath)System.Collections.Immutable.dll /log $(OutputPath)System.Reflection.Metadata.dll /targetplatform:v4&quot; /&amp;gt;++ &amp;lt;/Target&amp;gt; &amp;lt;/Project&amp;gt;我们只增加了三行，添加了一个名称为 ILMerge 的 Target。（注意到项目文件中我有额外引用一个其他的 NuGet 包 Ben.Demystifier，这是为了演示将依赖进行合并而添加的 NuGet 包，具体是什么都没有关系，我们只是在演示依赖的合并。）在这个 Target 里面，我们使用 Exec 的 Task 来执行 ILMerge 命令。具体这个命令代表的含义我们在下一节介绍 ILMerge 工具的时候会详细介绍。如果你希望在你的项目当中进行尝试，可以把所有 /log 参数之后的那些程序集名称改为你自己的名称。那么在编译的时候使用命令 msbuild /t:ILMerge 就可以完成程序集的合并了。注意，你普通编译的话是不会进行 IL 合并的。如果你希望常规编译也可以进行 IL 合并，或者说希望在 Visual Studio 里面点击生成按钮的时候也能完成 IL 合并的话，那么你还需要增加一个跳板的编译目标 Target。我将这个名为 _ProjectRemoveDependencyFiles 的 Target 增加到了下面。它的目的是在 AfterBuild 这个编译目标完成之后（AfterTargets）执行，然后执行前需要先执行（DependsOnTargets）ILMerge 这个 Target。在这个编译目标执行的时候还会将原本的三个依赖删除掉，这样在生成的目录下我们将只会看到我们最终期望的程序集 Walterlv.Demo.AssemblyLoading.exe 而没有其他依赖程序集。 &amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;OutputType&amp;gt;Exe&amp;lt;/OutputType&amp;gt; &amp;lt;TargetFramework&amp;gt;net48&amp;lt;/TargetFramework&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;PackageReference Include=&quot;Ben.Demystifier&quot; Version=&quot;0.1.4&quot; /&amp;gt; &amp;lt;PackageReference Include=&quot;ILMerge&quot; Version=&quot;3.0.29&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;Target Name=&quot;ILMerge&quot;&amp;gt; &amp;lt;Exec Command=&quot;&amp;amp;quot;$(ILMergeConsolePath)&amp;amp;quot; /ndebug /target:exe /out:$(OutputPath)$(AssemblyName).exe /log $(OutputPath)$(AssemblyName).exe /log $(OutputPath)Ben.Demystifier.dll /log $(OutputPath)System.Collections.Immutable.dll /log $(OutputPath)System.Reflection.Metadata.dll /targetplatform:v4&quot; /&amp;gt; &amp;lt;/Target&amp;gt;++ &amp;lt;Target Name=&quot;_ProjectRemoveDependencyFiles&quot; AfterTargets=&quot;AfterBuild&quot; DependsOnTargets=&quot;ILMerge&quot;&amp;gt;++ &amp;lt;ItemGroup&amp;gt;++ &amp;lt;_ProjectDependencyFile Include=&quot;$(OutputPath)Ben.Demystifier.dll&quot; /&amp;gt;++ &amp;lt;_ProjectDependencyFile Include=&quot;$(OutputPath)System.Collections.Immutable.dll&quot; /&amp;gt;++ &amp;lt;_ProjectDependencyFile Include=&quot;$(OutputPath)System.Reflection.Metadata.dll&quot; /&amp;gt;++ &amp;lt;/ItemGroup&amp;gt;++ &amp;lt;Delete Files=&quot;@(_ProjectDependencyFile)&quot; /&amp;gt;++ &amp;lt;/Target&amp;gt; &amp;lt;/Project&amp;gt;最终生成的输出目录下只有我们最终期望生成的程序集：以命令行工具的形式使用 ILMerge你可以在这里下载到 ILMerge： Download ILMerge from Official Microsoft Download Center实际上 ILMerge 已经开源，你可以在 GitHub 上找到它： dotnet/ILMerge: ILMerge is a static linker for .NET Assemblies.装完之后，如果将 ILMerge 的可执行目录加入到环境变量，那么你将可以在任意的目录下在命令行中直接使用 ILMerge 命令了。加入环境变量的方法我就不用说了，可以在网上搜索到非常多的资料。ILMerge 装完的默认目录在 C:\\Program Files (x86)\\Microsoft\\ILMerge，所以如果你保持默认路径安装，那么几乎可以直接把这个路径加入到环境变量中。那么 ILMerge 的命令行如何使用呢？它的参数列表是怎样的呢？我们来写一个简单的例子：ilmerge /ndebug /target:exe /out:Walterlv.Demo.AssemblyLoading.exe /log Walterlv.Demo.AssemblyLoading.exe /log Ben.Demystifier.dll /log System.Collections.Immutable.dll /log System.Reflection.Metadata.dll /targetplatform:v4其中： /ndebug 表示以非调试版本编译，如果去掉，将会生成 pdb 文件 /target 合并之后的程序集类型，如果是控制台程序，则为 exe /out 输出文件的名称（或路径）（此路径可以和需要合并的程序集名称相同，这样在合并完之后会覆盖同名称的那个程序集） /log 所有需要合并的程序集名称（或路径） /targetplatform 目标平台，如果是 .NET Framework 4.0 - .NET Framework 4.8 之间，则都是 v4在合并完成之后，我们反编译可以发现程序集中已经包含了依赖程序集中的全部类型了。以封装的 NuGet 包来使用 ILRepack安装 NuGet 包： NuGet Gallery - ILRepack.Lib.MSBuild.Task之后，你就能直接使用 ILRepack 这个编译任务了，而不是在 MSBuild 中使用 Exec 来间接执行 ILRepack 的任务。关于此 NuGet 包的使用，GitHub 中有很棒的例子，可以查看： peters/ILRepack.MSBuild.Task: MSBuild task for ILRepack which is an open-source alternative to ILMerge.需要注意如果使用新的基于 Sdk 的项目文件，那么默认生成的 PDB 是 Portable PDB，但是 ILMerge 暂时不支持 Portable PDB，会在编译时提示错误：An exception occurred during merging:ILMerge.Merge: There were errors reported in dotnetCampus.EasiPlugin.Sample&#39;s metadata. 数组维度超过了支持的范围。 在 ILMerging.ILMerge.Merge() 在 ILMerging.ILMerge.Main(String[] args)或者英文提示：An exception occurred during merging:ILMerge.Merge: There were errors reported in ReferencedProject&#39;s metadata. Array dimensions exceeded supported range. at ILMerging.ILMerge.Merge() at ILMerging.ILMerge.Main(String[] args)目前，GitHub 上有 issue 在追踪此问题： Support for portable PDBs · Issue #11 · dotnet/ILMerge参考资料 [C#]使用ILMerge将源DLL合并到目标EXE(.NET4.6.2) - cnc - 博客园 dotnet/ILMerge: ILMerge is a static linker for .NET Assemblies. NuGet Gallery - ilmerge jbevain/cecil: Cecil is a library to inspect, modify and create .NET programs and libraries. gluck/il-repack: Open-source alternative to ILMerge Support for portable PDBs · Issue #11 · dotnet/ILMerge Merging assemblies using ILRepack - Meziantou’s blog peters/ILRepack.MSBuild.Task: MSBuild task for ILRepack which is an open-source alternative to ILMerge." }, { "title": ".NET 使用 ILRepack 合并多个程序集（替代 ILMerge），避免引入额外的依赖", "url": "/post/merge-assemblies-using-ilrepack.html", "categories": "", "tags": "dotnet, csharp", "date": "2019-06-17 21:30:46 +0800", "snippet": "我们有多种工具可以将程序集合并成为一个。比如 ILMerge、Mono.Merge。前者不可定制、运行缓慢、消耗资源（不过好消息是现在开源了）；后者已被弃用、不受支持且基于旧版本的 Mono.Cecil。而本文介绍用来替代它们的 ILRepack，使用 ILRepack 来合并程序集。以 NuGet 包的形式使用 ILRepackILRepack 提供了可供你项目使用的 NuGet 包。如果你在团队项目当中安装了 ILRepack 的 NuGet 包，那么无论团队其他人是否安装了 ILRepack 的工具，都可以使用 ILRepack 工具。这可以避免要求团队所有成员安装工具或者将工具内置到项目的源代码管理中。要以 NuGet 包的形式来使用 ILRepack，需要首先安装 ILRepack 的 NuGet 包： [NuGet Gallery ILRepack](https://www.nuget.org/packages/ILRepack/) 或者直接在你的项目的 csproj 文件中添加 PackageReference：&amp;lt;ItemGroup&amp;gt; &amp;lt;PackageReference Include=&quot;ILRepack&quot; Version=&quot;2.0.17&quot; /&amp;gt;&amp;lt;/ItemGroup&amp;gt;我现在有一个项目 Walterlv.Demo.AssemblyLoading，这是一个控制台程序。这个程序引用了一个 NuGet 包 Ben.Demystifier。为此带来了三个额外的依赖。- Walterlv.Demo.AssemblyLoading.exe- Ben.Demystifier.dll- System.Collections.Immutable.dll- System.Reflection.Metadata.dll而我们可以使用 ILRepack 将这些依赖和我们生成的主程序合并成一个程序集，这样分发程序的时候只需要一个程序集即可。那么，我们现在需要编辑我们的项目文件： &amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;OutputType&amp;gt;Exe&amp;lt;/OutputType&amp;gt; &amp;lt;TargetFramework&amp;gt;net48&amp;lt;/TargetFramework&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;PackageReference Include=&quot;Ben.Demystifier&quot; Version=&quot;0.1.4&quot; /&amp;gt; &amp;lt;PackageReference Include=&quot;ILRepack&quot; Version=&quot;2.0.17&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt;++ &amp;lt;Target Name=&quot;ILRepack&quot;&amp;gt;++ &amp;lt;Exec Command=&quot;&amp;amp;quot;$(ILRepack)&amp;amp;quot; /out:$(OutputPath)$(AssemblyName).exe $(OutputPath)$(AssemblyName).exe $(OutputPath)Ben.Demystifier.dll $(OutputPath)System.Collections.Immutable.dll $(OutputPath)System.Reflection.Metadata.dll&quot; /&amp;gt;++ &amp;lt;/Target&amp;gt; &amp;lt;/Project&amp;gt;我们只增加了三行，添加了一个名称为 ILRepack 的 Target。（注意到项目文件中我有额外引用一个其他的 NuGet 包 Ben.Demystifier，这是为了演示将依赖进行合并而添加的 NuGet 包，具体是什么都没有关系，我们只是在演示依赖的合并。）在这个 Target 里面，我们使用 Exec 的 Task 来执行 ILRepack 命令。具体这个命令代表的含义我们在下一节介绍 ILRepack 工具的时候会详细介绍。如果你希望在你的项目当中进行尝试，可以把后面那些代表程序集的名称改为你自己项目中依赖程序集的名称。现在在编译的时候使用命令 msbuild /t:ILRepack 就可以完成程序集的合并了。注意，你普通编译的话是不会进行 IL 合并的。如果你希望常规编译也可以进行 IL 合并，或者说希望在 Visual Studio 里面点击生成按钮的时候也能完成 IL 合并的话，那么你还需要增加一个跳板的编译目标 Target。我将这个名为 _ProjectRemoveDependencyFiles 的 Target 增加到了下面。它的目的是在 AfterBuild 这个编译目标完成之后（AfterTargets）执行，然后执行前需要先执行（DependsOnTargets）ILRepack 这个 Target。在这个编译目标执行的时候还会将原本的三个依赖删除掉，这样在生成的目录下我们将只会看到我们最终期望的程序集 Walterlv.Demo.AssemblyLoading.exe 而没有其他依赖程序集。 &amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;OutputType&amp;gt;Exe&amp;lt;/OutputType&amp;gt; &amp;lt;TargetFramework&amp;gt;net48&amp;lt;/TargetFramework&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;PackageReference Include=&quot;Ben.Demystifier&quot; Version=&quot;0.1.4&quot; /&amp;gt; &amp;lt;PackageReference Include=&quot;ILRepack&quot; Version=&quot;2.0.17&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;Target Name=&quot;ILRepack&quot;&amp;gt; &amp;lt;Exec Command=&quot;&amp;amp;quot;$(ILRepack)&amp;amp;quot; /out:$(OutputPath)$(AssemblyName).exe $(OutputPath)$(AssemblyName).exe $(OutputPath)Ben.Demystifier.dll $(OutputPath)System.Collections.Immutable.dll $(OutputPath)System.Reflection.Metadata.dll&quot; /&amp;gt; &amp;lt;/Target&amp;gt;++ &amp;lt;Target Name=&quot;_ProjectRemoveDependencyFiles&quot; AfterTargets=&quot;AfterBuild&quot; DependsOnTargets=&quot;ILRepack&quot;&amp;gt;++ &amp;lt;ItemGroup&amp;gt;++ &amp;lt;_ProjectDependencyFile Include=&quot;$(OutputPath)Ben.Demystifier.dll&quot; /&amp;gt;++ &amp;lt;_ProjectDependencyFile Include=&quot;$(OutputPath)System.Collections.Immutable.dll&quot; /&amp;gt;++ &amp;lt;_ProjectDependencyFile Include=&quot;$(OutputPath)System.Reflection.Metadata.dll&quot; /&amp;gt;++ &amp;lt;/ItemGroup&amp;gt;++ &amp;lt;Delete Files=&quot;@(_ProjectDependencyFile)&quot; /&amp;gt;++ &amp;lt;/Target&amp;gt; &amp;lt;/Project&amp;gt;最终生成的输出目录下只有我们最终期望生成的程序集：ILRepack 的命令行使用相比于 ILMerge，ILRepack 的命令行在尽量贴近 ILMerge 的情况下做得更加简化了。ilrepack /out:Walterlv.Demo.AssemblyLoading.exe Walterlv.Demo.AssemblyLoading.exe Ben.Demystifier.dll System.Collections.Immutable.dll System.Reflection.Metadata.dll其中，/out 表示最终的输出程序集的名称或路径，后面没有前缀的参数都是需要合并的程序集的名称或路径。这些需要合并的参数中，第一个参数是主程序集，而后续其他的都是待合并的程序集。区别主程序集和其他程序集的原因是输出的程序集需要有名称、版本号等等信息，而这些信息将使用主程序集中的信息。如果希望使用 ILRepack 的其他命令，可以考虑使用帮助命令：ilrepack /help或者直接访问 ILRepack 的 GitHub 仓库来查看用法： gluck/il-repack: Open-source alternative to ILMerge如果解决合并错误？缺少依赖如果你在使用 ILRepack 合并程序集的过程中出现了缺少依赖的错误，例如下面这样：Mono.Cecil.AssemblyResolutionException: Failed to resolve assembly: &#39;xxxxxxxxx&#39;那么你需要做以下两种事情中的任何一种： 将所有依赖合并； 将依赖加入搜索目录。将所有依赖合并指的是将缺少的依赖也一起作为命令行参数传入要合并的程序集中。而另一种是增加一个参数 /lib，即添加一个被搜索的依赖程序集的目录。将这个目录指定后，则可以正确解析依赖完成合并。而且这些依赖将成为合并后的程序集的依赖，不会合并到程序集中。ilrepack /lib:D:\\Dependencies /out:Walterlv.Demo.AssemblyLoading.exe Walterlv.Demo.AssemblyLoading.exe Ben.Demystifier.dll System.Collections.Immutable.dll System.Reflection.Metadata.dll没有生成 PDB 文件如果使用新的基于 Sdk 的项目文件，那么默认生成的 PDB 是 Portable PDB，但是 ILRepack 暂时不支持 Portable PDB，其在内部捕获了异常以至于可以完成合并但不会生成 PDB 文件。目前此问题在 ILRepack 中还处于打开状态，且持续两年都没关闭了。同时很早就有支持 Portable PDB 的拉取请求，但至今未合并。以下是 GitHub 社区中的讨论： Mono.Cecil 0.10 support · Issue #182 · gluck/il-repack Migrate to vanilla 0.10 cecil by Alexx999 · Pull Request #236 · gluck/il-repack ERROR: Failed to load assembly while merging .NET Core assembly · Issue #230 · gluck/il-repack Support for portable PDBs · Issue #11 · dotnet/ILMerge参考资料 gluck/il-repack: Open-source alternative to ILMerge Is it expected that pdb files are not merged? · Issue #217 · gluck/il-repack" }, { "title": "Windows 10 解决无法完整下载安装语言包（日语输入法无法下载使用）", "url": "/post/fix-downloading-and-installing-windows-language-pack-issues.html", "categories": "", "tags": "windows", "date": "2019-06-16 20:53:20 +0800", "snippet": "最近我想在我的 Windows 10 上安装一个新的语言包，在 “设置” -&amp;gt; “时间和语言” -&amp;gt; “语言” 中，添加了新的语言之后，语言进入了下载状态。但是没过一小会儿，下载进度条就结束了，提示语言已经下载安装完成。但实际上只能作为显示使用，（日语）输入法却不能使用。我找了很多的资料试图解决这个问题，但发现竟然没有任何一种现有方法可以解决我的问题（这可能是日语输入法特有的问题吧）。最终解决后，我将网上搜集到的方法以及我实际解决所使用的方法都收录进来，方便大家后续解决问题。问题描述网上找到了一段跟我几乎一样的描述，可以前往这里查看。我发现他描述得非常准确，所以就直接引用了他的原话： 添加语言的时候能下载显示语言，点进选项后发现输入语言没有自动下载和安装，手动点下载，进度条在卡在前半不动，几秒后自动跳掉。 造成的影响是：1.日文输入法能出现，但无法切换到假名状态，只能输入英文；……我能够添加完成日语，并且它也能作为我的显示语言正常显示。但是进入语言之后，发现里面的三个可供下载的扩展选项都没有下载。而如果手动点击下载，无论如何也没有反应。由于输入法就是这里的第一个扩展选项，所以虽然可以切换到日语的微软输入法，但是只能输入英文字母，而无法输入任何日语文字（にほんご）。如下图，无论怎么点击都不会下载。重启无效。解决网上的解决方案有很多种，我这里整理最有可能解决问题的两种。 删除下载缓存（通用解决方案） 暂时关闭 UAC（本次我是此方法成功的） 其他方法（请点击本文最后的参考链接，包含我的各种参考资料）删除下载缓存前往文件夹：C:\\Windows\\SoftwareDistribution\\Download。这里面的内容都是 Windows 的各种下载的缓存。如果是因为下载的文件损坏，那么删除此文件夹中的全部内容通常可以解决问题。你不用担心删除此文件夹会出现什么问题，因为重新下载那些缓存所付出的代价往往比修复的问题本身更小。在时机尝试中，我删除了此文件夹后，重新启动计算机。我发现再点击语言下载之后不会是没有反应了，而是出现了一小会儿的进度条；再随后才继续恢复成没有下载的状态。再之后，也是怎么点击下载也没有反应了。于是几乎可以认定语言包的下载缓存确认是在这个路径中的，但是导致无法下载安装的本质原因却不是这个。暂时关闭 UAC后来我尝试了网上的其他各种方案，都没有解决。包括删除重新安装语言包，包括使用 PowerShell 脚本删除语言列表项，包括清理注册表项等等。我突然间异想天开认为有可能是 UAC（用户账户控制）的问题，但是无论使用中文还是英文搜索，无论使用谷歌还是必应搜索引擎，无论翻了多少页，都没有找到此问题与 UAC 有关的文章、帖子或解决方案。但我还是尝试了。我打开了 UAC 设置，临时把滑块从最顶部拖到最底部，以关闭 UAC。点击“下载”后，终于有反应可以继续完成下载了。看起来是解决了，但这三个下载按钮只有一个可以继续下载安装。但是我重启计算机之后，三个按钮都可以正常点击下载安装了。最后，我把 UAC 拖到最顶部还原我的设置。关于为什么我会拖到最顶部，你可以阅读我的另一篇博客： Windows 的 UAC 设置中的通知等级实际上只有两个档而已进程监控与调试当然，我还尝试过使用 Visual Studio 附加 SystemSettings.exe 进程进行调试，发现在每次点击“下载”没有反应的时候会看到出现了一个“线程已结束”的输出，并没有实际上的意义。我也希望通过 Process Monitor 查看下载失败时是否涉及到 IO，结果也没有什么线索。其他方法另外，有小伙伴说可以去另一台可以下载安装的电脑上拷贝 C:\\Windows\\IME\\IMEJP 目录过来也可以使用。期望幸好最终解决了问题，希望可以帮到读者。如果你有其他方法解决了问题，或者说你试过了各种方法也没有解决问题，欢迎在本文原文的评论区留言，也许能找到更合适的解决办法。参考资料 WIN10无法完整下载日语语言包，不能下载基本输入语言，不能下载日语补充字库。。&amp;amp;# - Microsoft Community Windows 10（1903）无法下载英语基本输入法、手写、语音功能 - Microsoft Community (Fixed) How to Download and Install Windows 10 Language Pack Win10的日语输入法无法安装功能 - Microsoft Community win10输入法可选功能无法安装 - Microsoft Community win10 可选功能更新（输入法）失败 - Microsoft Community 解决Windows10专业版无法安装语言包！！！ - Antrn的博客 - CSDN博客 Win10 1803日文输入法问题 - Kevin的博客 - CSDN博客" }, { "title": ".NET 的程序集加载上下文", "url": "/post/assembly-loading-context.html", "categories": "", "tags": "dotnet, csharp", "date": "2019-06-13 13:49:44 +0800", "snippet": "我们编写的 .NET 应用程序会使用到各种各样的依赖库。我们都知道 CLR 会在一些路径下帮助我们程序找到依赖，但如果我们需要手动控制程序集加载路径的话，需要了解程序集加载上下文。如果你不了解程序集加载上下文，你可能会发现你加载了程序集却不能使用其中的类型；或者把同一个程序集加载了两次，导致使用到两个明明是一样的类型时却抛出异常提示不是同一个类型的问题。程序集加载上下文当你向应用程序域中加载一个程序集时，可能会加载到以下四种不同的上下文中的一种： 默认加载上下文（the Default Load Context） 加载位置加载上下文（the Load-From Context） 仅反射上下文（the Reflection-Only Context） 无上下文你需要了解这些加载上下文，因为跨不同加载上下文加载的程序集是不能访问其中的类型的。默认加载上下文 在全局程序集缓存中发现的类型会加载到默认加载上下文中 位于应用程序探测路径中的程序集会加载到默认加载上下文中，这包括了 ApplicationBase 和 PrivateBinPath 目录中发现的程序集 Assembly.Load 方法的大多数重载都将程序集加载到此上下文中ApplicationBase 和 PrivateBinPath 这两个属性虽然允许被设置，但它们只对新生成的 AppDomain 生效，直接设置当前 AppDomain 中这两个属性的值并不会产生任何效果。虽然我们不能直接设置这两个属性，但可以在应用程序的 App.config 文件这配置 configuration -&amp;gt; runtime -&amp;gt; assemblyBinding -&amp;gt; probing.privatePath 属性来设置多个应用程序执行时的依赖探测路径。将程序集加载到默认加载上下文中时，会自动加载其依赖项。使用默认加载上下文时，加载到其他上下文中的依赖项将不可用，并且不能将位于探测路径外部位置的程序集加载到默认加载上下文中。加载位置上下文当使用 Assembly.LoadFrom 方法加载程序集时，程序集会加载到加载位置上下文中。如果程序集包含依赖，也会自动从加载位置上下文中加载依赖。另外，在加载位置上下文中加载的程序集，可以使用到默认加载上下文中的依赖；注意，反过来却不成立！加载位置上下文的使用需要谨慎，因为它会产生一些可能让你感觉到意外的行为。以下意外的行为列表照抄自文档 Best Practices for Assembly Loading： 如果已加载一个具有相同标识的程序集，则即使指定了不同的路径，LoadFrom 仍返回已加载的程序集。 如果用 LoadFrom 加载一个程序集，随后默认加载上下文中的一个程序集尝试按显示名称加载同一程序集，则加载尝试将失败。 对程序集进行反序列化时，可能发生这种情况。 如果用 LoadFrom 加载一个程序集，并且探测路径包括一个具有相同标识但位置不同的程序集，则将发生 InvalidCastException、MissingMethodException 或其他意外行为。 LoadFrom 需要对指定路径的 FileIOPermissionAccess.Read 和 FileIOPermissionAccess.PathDiscovery 或 WebPermission。 无上下文使用反射发出生成的瞬态程序集只能选择在没有下文的情况下进行加载。在没有上下文的情况下进行加载是将具有同一标识的多个程序集加载到一个应用程序域中的唯一方式。这将省去探测成本。从字节数组加载的程序集都是在没有上下文的情况下加载的，除非程序集的标识（在应用策略后建立）与全局程序集缓存中的程序集标识匹配；在此情况下，将会从全局程序集缓存加载程序集。在没有上下文的情况下加载程序集具有以下缺点，以下摘抄自 Best Practices for Assembly Loading： 无法将其他程序集绑定到在没有上下文的情况下加载的程序集，除非处理 AppDomain.AssemblyResolve 事件。 依赖项无法自动加载。 可以在没有上下文的情况下预加载依赖项、将依赖项预加载到默认加载上下文中或通过处理 AppDomain.AssemblyResolve 事件来加载依赖项。 在没有上下文的情况下加载具有同一标识的多个程序集会导致出现类型标识问题，这些问题与将具有同一标识的多个程序集加载到多个上下文中所导致的问题类似。 请参阅避免将一个程序集加载到多个上下文中。 带来的问题.NET 加载程序集的这种机制可能让你的程序陷入一点点坑：你可以让你的程序加载任意路径下的一个程序集（dll/exe），并且可以执行其中的代码，但你不能依赖那些路径中程序集的特定类型或接口等。具体一点，比如你定义了一个接口 IPlugin，任意路径中的程序集可以实现这个接口，你加载这个程序集之后也可以通过 IPlugin 接口调用到程序集中的方法，因为这个接口的定义所在的程序集依然在你的探测路径中，而不是在插件程序集中。位于任意路径下的插件程序集可以访问到位于探测路径中所有程序集的所有 API，但反过来探测路径下的程序集不能访问到其他目录下插件程序集的特定类型或接口等。但是，如果这个程序集中有一些特定的类型如 WalterlvPlugin，那么你将不能依赖于这个特定的类型。我创建了一个控制台程序，用以说明这样的加载上下文机制将带来问题。相关代码可以在我的 GitHub 仓库中找到： walterlv.demo/Walterlv.Demo.AssemblyLoading其中 Program.cs 文件如下：using System;using System.Diagnostics;using System.IO;using System.Reflection;using System.Threading.Tasks;namespace Walterlv.Demo.AssemblyLoading{ class Program { static async Task Main(string[] args) { await LoadDependencyAssembliesAsync(); await RunAsync(); Console.ReadLine(); } private static async Task RunAsync() { try { await ThrowAsync(); } catch (Exception ex) { Console.WriteLine(ex.Demystify()); } async Task ThrowAsync() =&amp;gt; throw new InvalidOperationException(); } private static async Task LoadDependencyAssembliesAsync() { var folder = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), &quot;Dependencies&quot;); Assembly.LoadFile(Path.Combine(folder, &quot;Ben.Demystifier.dll&quot;)); Assembly.LoadFile(Path.Combine(folder, &quot;System.Collections.Immutable.dll&quot;)); Assembly.LoadFile(Path.Combine(folder, &quot;System.Reflection.Metadata.dll&quot;)); } }}项目文件 csproj 文件如下：&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;OutputType&amp;gt;Exe&amp;lt;/OutputType&amp;gt; &amp;lt;TargetFramework&amp;gt;net48&amp;lt;/TargetFramework&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;PackageReference Include=&quot;Ben.Demystifier&quot; Version=&quot;0.1.4&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;Target Name=&quot;_ProjectMoveDependencies&quot; AfterTargets=&quot;AfterBuild&quot;&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;_ProjectToMoveFile Include=&quot;$(OutputPath)Ben.Demystifier.dll&quot; /&amp;gt; &amp;lt;_ProjectToMoveFile Include=&quot;$(OutputPath)System.Collections.Immutable.dll&quot; /&amp;gt; &amp;lt;_ProjectToMoveFile Include=&quot;$(OutputPath)System.Reflection.Metadata.dll&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;Move SourceFiles=&quot;@(_ProjectToMoveFile)&quot; DestinationFolder=&quot;$(OutputPath)Dependencies&quot; /&amp;gt; &amp;lt;/Target&amp;gt; &amp;lt;/Project&amp;gt;在这个程序中，我们引用了一个 NuGet 包 Ben.Demystifier。这个包具体是什么其实并不重要，我只是希望引入一个依赖而已。但是，在项目文件 csproj 中，我写了一个 Target，将这些依赖全部都移动到了 Dependencies 文件夹中。这样，我们就可以获得这样目录结构的输出：- Walterlv.exe- Dependencies - Ben.Demystifier.dll - System.Collections.Immutable.dll - System.Reflection.Metadata.dll如果我们不进行其他设置，那么直接运行程序的话，应该是找不到依赖然后崩溃的。但是现在我们有 LoadDependencyAssembliesAsync 方法，里面通过 Assembly.LoadFile 加载了这三个程序集。但时机运行时依然会崩溃：明明已经加载了这三个程序集，为什么使用其内部的类型的时候还会抛出异常呢？明明在 Visual Studio 中检查已加载的模块可以发现这些模块都已经加载完毕，但依然无法使用到里面的类型呢？本文将介绍原因和解决办法。解决方法实际上 .NET 推荐的唯一解决方法是创建新的应用程序域来解决非探测路径下 dll 的依赖问题，在创建新应用程序域的时候设置此应用程序域的探测路径。但是，我们其实有其他的方法依然在原来的应用程序域中解决依赖问题。使用被遗弃的 API（不推荐）AppDomain 有一个已经被遗弃的 API AppendPrivatePath，可以将一个路径加入到探测路径列表中。这样，我们不需要考虑去任意路径加载程序集的问题了，因为我们可以将任意路径设置成探测路径。// 注意，这是一个被遗弃的 API。AppDomain.CurrentDomain.AppendPrivatePath(folder);关于此 API 为什么会被遗弃，你可以阅读微软的官方博客：Why is AppDomain.AppendPrivatePath Obsolete? - .NET Blog。因为你随时可以指定应用程序的探测路径，所以它可能让你的程序以各种不确定的方式加载程序集，于是你的程序将变得很不稳定；可能完全崩溃到你无法预知的程度。另外，.NET Core 中已经不能使用此 API 了，这非常好！使用 ILRepack / ILMerge 合并依赖前面我们说过，加载位置上下文中的程序集可以依赖默认加载上下文中的程序集，而反过来却不行。通常默认加载上下文中的程序集是我们的主程序程序集和附属程序集，而加载位置上下文中加载的程序是插件程序集。如果插件程序集依赖了一些主程序没有的依赖，那么插件可以考虑将所有的依赖合并入插件单个程序集中，避免依赖其他程序集，导致不得不去非探测路径加载程序集。关于使用 ILRepack 合并依赖的内容，可以阅读我的另一篇博客： .NET 使用 ILRepack 合并多个程序集（替代 ILMerge），避免引入额外的依赖 - walterlv首先推荐使用 ILRepack 来进行合并，如果你愿意，也可以使用 ILMerge： .NET 使用 ILMerge 合并多个程序集，避免引入额外的依赖参考资料 Loading .NET Assemblies out of Seperate Folders - Rick Strahl’s Web Log Best Practices for Assembly Loading - Microsoft Docs Why is AppDomain.AppendPrivatePath Obsolete? - .NET Blog" }, { "title": "WPF 程序的编译过程", "url": "/post/how-wpf-assemblies-are-compiled.html", "categories": "", "tags": "wpf, dotnet, csharp, msbuild, visualstudio, roslyn", "date": "2019-06-11 16:05:22 +0800", "snippet": "基于 Sdk 的项目进行编译的时候，会使用 Sdk 中附带的 props 文件和 targets 文件对项目进行编译。Microsoft.NET.Sdk.WindowsDesktop 的 Sdk 包含 WPF 项目的编译过程。而本文介绍 WPF 项目的编译过程，包含 WPF 额外为编译过程添加的那些扩展编译目标，以及这些扩展的编译目标如何一步步完成 WPF 项目的过程。提前准备在阅读本文之前，你可能需要提前了解编译过程到底是怎样的。可以阅读： 理解 C# 项目 csproj 文件格式的本质和编译流程如果你不明白上面文章中的一些术语（例如 Target / Task），可能不能理解本文后面的内容。另外，除了本文所涉及的内容之外，你也可以自己探索编译过程： 解读 Microsoft.NET.Sdk 的源码，你能定制各种奇怪而富有创意的编译过程WPF 的编译代码都在 Microsoft.WinFx.targets 文件中，你可以通过上面这一篇博客找到这个文件。接下来，我们会一一介绍这个文件里面的编译目标（Target），然后统一说明这些 Target 是如何协同工作，将 WPF 程序编译出来的。Microsoft.WinFx.targets 的源码可以查看： wpf/Microsoft.WinFx.targets at master · dotnet/wpfTargetWPF 在编译期间会执行以下这些 Target，当然 Target 里面实际用于执行任务的是 Task。知道 Target 名称的话，你可以扩展 WPF 的编译过程；而知道 Task 名称的话，可以帮助理解编译过程实际做的事情。本文都会列举出来。FileClassification Target 名称：FileClassification Task 名称：FileClassifier用于将资源嵌入到程序集。如果资源没有本地化，则嵌入到主程序集；如果有本地化，则嵌入到附属程序集。在 WPF 项目中，这个 Target 是一定会执行的；但里面的 Task 则是有 Resource 类型的编译项的时候才会执行。GenerateTemporaryTargetAssemblyTarget 名称和 Task 名称相同，都是 GenerateTemporaryTargetAssembly。只要项目当中包含任何一个生成类型为 Page 的 XAML 文件，则会执行此 Target。关于生成临时程序集的原因比较复杂，可以阅读本文后面的 WPF 程序的编译过程部分来了解。MarkupCompilePass1Target 名称和 Task 名称相同，都是 MarkupCompilePass1。将非本地化的 XAML 文件编译成二进制格式。MarkupCompilePass2Target 名称和 Task 名称相同，都是 MarkupCompilePass2。对 XAML 文件进行第二轮编译，而这一次会引用同一个程序集中的类型。DesignTimeMarkupCompilation这是一个仅在有设计器执行时才会执行的 Target，当这个编译目标执行时，将会直接调用 MarkupCompilePass1。实际上，如果在 Visual Studio 中编译项目，则会调用到这个 Target。而判断是否在 Visual Studio 中编译的方法可以参见： MSBuild 在编写编译任务的时候判断当前是否在 Visual Studio 中编译&amp;lt;Target Name=&quot;DesignTimeMarkupCompilation&quot;&amp;gt; &amp;lt;!-- Only if we are not actually performing a compile i.e. we are in design mode --&amp;gt; &amp;lt;CallTarget Condition=&quot;&#39;$(BuildingProject)&#39; != &#39;true&#39;&quot; Targets=&quot;MarkupCompilePass1&quot; /&amp;gt;&amp;lt;/Target&amp;gt;MergeLocalizationDirectivesTarget 名称和 Task 名称相同，都是 MergeLocalizationDirectives。将本地化属性和一个或多个 XAML 二进制格式文件的注释合并到整个程序集的单一文件中。&amp;lt;Target Name=&quot;MergeLocalizationDirectives&quot; Condition=&quot;&#39;@(GeneratedLocalizationFiles)&#39; !=&#39;&#39;&quot; Inputs=&quot;@(GeneratedLocalizationFiles)&quot; Outputs=&quot;$(IntermediateOutputPath)$(AssemblyName).loc&quot;&amp;gt; &amp;lt;MergeLocalizationDirectives GeneratedLocalizationFiles=&quot;@(GeneratedLocalizationFiles)&quot; OutputFile=&quot;$(IntermediateOutputPath)$(AssemblyName).loc&quot;/&amp;gt; &amp;lt;!-- Add the merged loc file into _NoneWithTargetPath so that it will be copied to the output directory --&amp;gt; &amp;lt;CreateItem Condition=&quot;Exists(&#39;$(IntermediateOutputPath)$(AssemblyName).loc&#39;)&quot; Include=&quot;$(IntermediateOutputPath)$(AssemblyName).loc&quot; AdditionalMetadata=&quot;CopyToOutputDirectory=PreserveNewest; TargetPath=$(AssemblyName).loc&quot; &amp;gt; &amp;lt;Output ItemName=&quot;_NoneWithTargetPath&quot; TaskParameter=&quot;Include&quot;/&amp;gt; &amp;lt;Output ItemName=&quot;FileWrites&quot; TaskParameter=&quot;Include&quot;/&amp;gt; &amp;lt;/CreateItem&amp;gt;&amp;lt;/Target&amp;gt;MainResourcesGeneration、SatelliteResourceGeneration Target 有两个，MainResourcesGeneration 和 SatelliteResourceGeneration，分别负责主资源生成和附属资源生成。 Task 名称：ResourcesGenerator将一个或多个资源（二进制格式的 .jpg、.ico、.bmp、XAML 以及其他扩展名类型）嵌入 .resources 文件中。CheckUid、UpdateUid、RemoveUid Target 有三个，CheckUid、UpdateUid 和 RemoveUid，分别负责主资源生成和附属资源生成。 Task 名称：ResourcesGenerator检查、更新或移除 UID，以便将 XAML 文件中所有的 XAML 元素进行本地化。&amp;lt;Target Name=&quot;CheckUid&quot; Condition=&quot;&#39;@(Page)&#39; != &#39;&#39; or &#39;@(ApplicationDefinition)&#39; != &#39;&#39;&quot;&amp;gt; &amp;lt;UidManager MarkupFiles=&quot;@(Page);@(ApplicationDefinition)&quot; Task=&quot;Check&quot; /&amp;gt;&amp;lt;/Target&amp;gt;&amp;lt;Target Name=&quot;UpdateUid&quot; Condition=&quot;&#39;@(Page)&#39; != &#39;&#39; or &#39;@(ApplicationDefinition)&#39; != &#39;&#39;&quot;&amp;gt; &amp;lt;UidManager MarkupFiles=&quot;@(Page); @(ApplicationDefinition)&quot; IntermediateDirectory =&quot;$(IntermediateOutputPath)&quot; Task=&quot;Update&quot; /&amp;gt;&amp;lt;/Target&amp;gt;&amp;lt;Target Name=&quot;RemoveUid&quot; Condition=&quot;&#39;@(Page)&#39; != &#39;&#39; or &#39;@(ApplicationDefinition)&#39; != &#39;&#39;&quot;&amp;gt; &amp;lt;UidManager MarkupFiles=&quot;@(Page); @(ApplicationDefinition)&quot; IntermediateDirectory =&quot;$(IntermediateOutputPath)&quot; Task=&quot;Remove&quot; /&amp;gt;&amp;lt;/Target&amp;gt;UpdateManifestForBrowserApplication当编译基于 XAML 的浏览器项目的时候，会给 manifest 文件中添加一个配置 &amp;lt;hostInBrowser /&amp;gt;。WPF 程序的编译过程编译过程图示上面列举出来的那些 Target 主要是 WPF 几个关键的 Target，在实际编译时会有更多编译 Target 执行。另外有些也不在常规的编译过程中，而是被专门的编译过程执行。图的阅读方法是这样的： 箭头代表依赖关系，如 CoreCompile 有一个指向 DesignTimeMarkupCompilation 的箭头，表示 CoreCompile 执行前会确保 DesignTimeMarkupCompilation 执行完毕； 如果一个 Target 有多个依赖，则这些依赖会按顺序执行还没执行的依赖，如 PrepareResources 指向了多个 Target MarkupCompilePass1、GenerateTemporaryTargetAssembly、MarkupCompilePass2、AfterMarkupCompilePass2、CleanupTemporaryTargetAssembly，那么在 PrepareResources 执行之前，如果还有没有执行的依赖，会按顺序依次执行； WPF 所有的 Target 扩展都是通过依赖来指定的，也就是说必须基于现有的核心编译过程，图中从绿色或黄色的节点向前倒退的所有依赖都会被执行。各种颜色代表的含义： 蓝色，表示 WPF 扩展的 Target 浅蓝色，表示 WPF 扩展的 Target，但是没有执行任何实际的任务，只是提供一个扩展点 绿色，表示核心的编译过程，但是被 WPF 编译过程重写了 黄色，表示核心的编译过程（即便不是 WPF 程序也会执行的 Target） 浅黄色，表示在这张图里面不关心的 Target（不然整个画下来就太多了） 紫色，仅在 Visual Studio 编译期间会执行的 WPF 扩展的 Target编译过程描述我们都知道 XAML 是可以引用 CLR 类型的；如果 XAML 所引用的 CLR 类型在其他被引用的程序集，那么编译 XAML 的时候就可以直接引用这些程序集，因为他们已经编译好了。但是我们也知道，XAML 还能引用同一个程序集中的 CLR 类型，而此时这个程序集还没有编译，XAML 编译过程并不知道可以如何使用这些类型。同时我们也知道 CLR 类型可是使用 XAML 生成的类型，如果 XAML 没有编译，那么 CLR 类型也无法正常完成编译。这是矛盾的，这也是 WPF 扩展的编译过程会比较复杂的原因之一。WPF 编译过程有两个编译传递，MarkupCompilePass1 和 MarkupCompilePass2。MarkupCompilePass1 的作用是将 XAML 编译成二进制格式。如果 XAML 文件包含 x:Class 属性，那么就会根据语言生成一份代码文件；对于 C# 语言，会生成“文件名.g.cs”文件。但是 XAML 文件中也有可能包含对同一个程序集中的 CLR 类型的引用，然而这一编译阶段 CLR 类型还没有开始编译，因此无法提供程序集引用。所以如果这个 XAML 文件包含对同一个程序集中 CLR 类型的引用，则这个编译会被推迟到 MarkupCompilePass2 中继续。而在 MarkupCompilePass1 和 MarkupCompilePass2 之间，则插入了 GenerateTemporaryTargetAssembly 这个编译目标。GenerateTemporaryTargetAssembly 的作用是生成一个临时的程序集，这个临时的程序集中包含了 MarkupCompilePass1 推迟到 MarkupCompilePass2 中编译时需要的 CLR 类型。这样，在 MarkupCompilePass2 执行的时候，会获得一个包含原本在统一程序集的 CLR 类型的临时程序集引用，这样就可以继续完成 XAML 格式的编译了。在 MarkupCompilePass2 编译完成之后，XAML 文件就完全编译完成了。之后，会执行 CleanupTemporaryTargetAssembly 清除之前临时编译的程序集。编译临时程序集时，会生成一个新的项目文件，名字如：$(项目名)_$(随机字符)_wpftmp.csproj，在与原项目相同的目录下。在需要编译一个临时程序集的时候，CoreCompile 这样的用于编译 C# 代码文件的编译目标会执行两次，第一次是编译这个临时生成的项目，而第二次才是编译原本的项目。现在，我们看一段 WPF 程序的编译输出，可以看到看到这个生成临时程序集的过程。随后，就是正常的其他的编译过程。关于临时生成程序集在 WPF 的编译过程中，我想单独将临时生成程序集的部分进行特别说明。因为如果你不了解这一部分的细节，可能在未来的使用中遇到一些临时生成程序集相关的坑。下面这几篇博客就是在讨论其中的一些坑： 制作通过 NuGet 分发的源代码包时，如果目标项目是 WPF 则会出现一些问题 Roslyn 如何基于 Microsoft.NET.Sdk 制作源代码包我需要摘抄生成临时程序集的一部分源码：&amp;lt;PropertyGroup&amp;gt; &amp;lt;_CompileTargetNameForLocalType Condition=&quot;&#39;$(_CompileTargetNameForLocalType)&#39; == &#39;&#39;&quot;&amp;gt;_CompileTemporaryAssembly&amp;lt;/_CompileTargetNameForLocalType&amp;gt;&amp;lt;/PropertyGroup&amp;gt;&amp;lt;Target Name=&quot;_CompileTemporaryAssembly&quot; DependsOnTargets=&quot;BuildOnlySettings;ResolveKeySource;CoreCompile&quot; /&amp;gt;&amp;lt;Target Name=&quot;GenerateTemporaryTargetAssembly&quot; Condition=&quot;&#39;$(_RequireMCPass2ForMainAssembly)&#39; == &#39;true&#39; &quot; &amp;gt; &amp;lt;Message Text=&quot;MSBuildProjectFile is $(MSBuildProjectFile)&quot; Condition=&quot;&#39;$(MSBuildTargetsVerbose)&#39; == &#39;true&#39;&quot; /&amp;gt; &amp;lt;GenerateTemporaryTargetAssembly CurrentProject=&quot;$(MSBuildProjectFullPath)&quot; MSBuildBinPath=&quot;$(MSBuildBinPath)&quot; ReferencePathTypeName=&quot;ReferencePath&quot; CompileTypeName=&quot;Compile&quot; GeneratedCodeFiles=&quot;@(_GeneratedCodeFiles)&quot; ReferencePath=&quot;@(ReferencePath)&quot; IntermediateOutputPath=&quot;$(IntermediateOutputPath)&quot; AssemblyName=&quot;$(AssemblyName)&quot; CompileTargetName=&quot;$(_CompileTargetNameForLocalType)&quot; GenerateTemporaryTargetAssemblyDebuggingInformation=&quot;$(GenerateTemporaryTargetAssemblyDebuggingInformation)&quot; &amp;gt; &amp;lt;/GenerateTemporaryTargetAssembly&amp;gt; &amp;lt;CreateItem Include=&quot;$(IntermediateOutputPath)$(TargetFileName)&quot; &amp;gt; &amp;lt;Output TaskParameter=&quot;Include&quot; ItemName=&quot;AssemblyForLocalTypeReference&quot; /&amp;gt; &amp;lt;/CreateItem&amp;gt;&amp;lt;/Target&amp;gt;我们需要关注这些点： 生成临时程序集时，会调用一个编译目标（Target），这个编译目标的名称由 _CompileTargetNameForLocalType 这个私有属性来决定； 当 _CompileTargetNameForLocalType 没有指定时，会设置其默认值为 _CompileTemporaryAssembly 这个编译目标； _CompileTemporaryAssembly 这个编译目标执行时，仅会执行三个依赖的编译目标，BuildOnlySettings、ResolveKeySource、CoreCompile，至于这些依赖目标所依赖的其他编译目标，则会根据新生成的项目文件动态计算。 生成临时程序集和临时程序集的编译过程并不在同一个编译上下文中，这也是为什么只能通过传递名称 _CompileTargetNameForLocalType 来执行，而不能直接调用这个编译目标或者设置编译目标的依赖。新生成的临时项目文件相比于原来的项目文件，包含了这些修改： 添加了第一轮 XAML 编译传递（MarkupCompilePass1）时生成的 .g.cs 文件； 将所有引用方式收集到的引用全部换成 ReferencePath，这样就可以避免临时项目编译期间再执行一次 ResolveAssemblyReference 编译目标来收集引用，避免降低太多性能。关于引用换成 ReferencePath 的内容，可以阅读我的另一篇博客了解更多： 在 Target 中获取项目引用的所有依赖（dll/NuGet/Project）的路径在使用 ReferencePath 的情况下，无论是项目引用还是 NuGet 包引用，都会被换成普通的 dll 引用，因为这个时候目标项目都已经编译完成，包含可以被引用的程序集。以下是我在示例程序中抓取到的临时生成的项目文件的内容，与原始项目文件之间的差异： &amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk.WindowsDesktop&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;OutputType&amp;gt;Exe&amp;lt;/OutputType&amp;gt; &amp;lt;TargetFramework&amp;gt;net48&amp;lt;/TargetFramework&amp;gt; &amp;lt;UseWPF&amp;gt;true&amp;lt;/UseWPF&amp;gt; &amp;lt;GenerateTemporaryTargetAssemblyDebuggingInformation&amp;gt;True&amp;lt;/GenerateTemporaryTargetAssemblyDebuggingInformation&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;PackageReference Include=&quot;Walterlv.SourceYard.Demo&quot; Version=&quot;0.1.0-alpha&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt;++ &amp;lt;ItemGroup&amp;gt;++ &amp;lt;ReferencePath Include=&quot;C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.8\\mscorlib.dll&quot; /&amp;gt;++ &amp;lt;ReferencePath Include=&quot;C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.8\\PresentationCore.dll&quot; /&amp;gt;++ &amp;lt;ReferencePath Include=&quot;C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.8\\PresentationFramework.dll&quot; /&amp;gt;++ &amp;lt;ReferencePath Include=&quot;C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.8\\System.Core.dll&quot; /&amp;gt;++ &amp;lt;ReferencePath Include=&quot;C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.8\\System.Data.dll&quot; /&amp;gt;++ &amp;lt;ReferencePath Include=&quot;C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.8\\System.dll&quot; /&amp;gt;++ &amp;lt;ReferencePath Include=&quot;C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.8\\System.Drawing.dll&quot; /&amp;gt;++ &amp;lt;ReferencePath Include=&quot;C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.8\\System.IO.Compression.FileSystem.dll&quot; /&amp;gt;++ &amp;lt;ReferencePath Include=&quot;C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.8\\System.Numerics.dll&quot; /&amp;gt;++ &amp;lt;ReferencePath Include=&quot;C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.8\\System.Runtime.Serialization.dll&quot; /&amp;gt;++ &amp;lt;ReferencePath Include=&quot;C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.8\\System.Windows.Controls.Ribbon.dll&quot; /&amp;gt;++ &amp;lt;ReferencePath Include=&quot;C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.8\\System.Xaml.dll&quot; /&amp;gt;++ &amp;lt;ReferencePath Include=&quot;C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.8\\System.Xml.dll&quot; /&amp;gt;++ &amp;lt;ReferencePath Include=&quot;C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.8\\System.Xml.Linq.dll&quot; /&amp;gt;++ &amp;lt;ReferencePath Include=&quot;C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.8\\UIAutomationClient.dll&quot; /&amp;gt;++ &amp;lt;ReferencePath Include=&quot;C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.8\\UIAutomationClientsideProviders.dll&quot; /&amp;gt;++ &amp;lt;ReferencePath Include=&quot;C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.8\\UIAutomationProvider.dll&quot; /&amp;gt;++ &amp;lt;ReferencePath Include=&quot;C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.8\\UIAutomationTypes.dll&quot; /&amp;gt;++ &amp;lt;ReferencePath Include=&quot;C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.8\\WindowsBase.dll&quot; /&amp;gt;++ &amp;lt;/ItemGroup&amp;gt;++ &amp;lt;ItemGroup&amp;gt;++ &amp;lt;Compile Include=&quot;D:\\Developments\\Open\\Walterlv.Demo\\Walterlv.GettingStarted.SourceYard\\Walterlv.GettingStarted.SourceYard.Sample\\obj\\Debug\\net48\\Demo.g.cs&quot; /&amp;gt;++ &amp;lt;/ItemGroup&amp;gt; &amp;lt;/Project&amp;gt;你可能已经注意到了我在项目中设置了 GenerateTemporaryTargetAssemblyDebuggingInformation 属性，这个属性可以让 WPF 临时生成的项目文件保留下来，便于进行研究和调试。在前面 GenerateTemporaryTargetAssembly 的源码部分我们已经贴出了这个属性使用的源码，只是前面我们没有说明其用途。注意，虽然新生成的项目文件中有 PackageReference 来表示包引用，但由于只有 _CompileTargetNameForLocalType 指定的编译目标和相关依赖可以被执行，而 NuGet 包中自动 Import 的部分没有加入到依赖项中，所以实际上包中的 .props 和 .targets 文件都不会被 Import 进来，这可能造成部分 NuGet 包在 WPF 项目中不能正常工作。比如下面这个： 制作通过 NuGet 分发的源代码包时，如果目标项目是 WPF 则会出现一些问题更典型的，就是 SourceYard 项目，这个 Bug 给 SourceYard 造成了不小的困扰： walterlv.demo/Walterlv.GettingStarted.SourceYard at master · walterlv/walterlv.demo参考资料 WPF MSBuild Task Reference - Visual Studio - Microsoft Docs GenerateTemporaryTargetAssembly.cs Localization Attributes and Comments - Microsoft Docs" }, { "title": "制作通过 NuGet 分发的源代码包时，如果目标项目是 WPF 则会出现一些问题（探索篇，含解决方案）", "url": "/post/issues-of-nuget-package-import-for-wpf-projects.html", "categories": "", "tags": "dotnet, csharp, wpf, nuget, visualstudio, msbuild, roslyn", "date": "2019-06-11 15:30:40 +0800", "snippet": "在使用 NuGet 包来分发源代码时，如果目标项目是 WPF 项目，那么会有一大堆的问题。本文将这些问题列举出来并进行分析。源代码包源代码包不是 NuGet 官方的概念，而是林德熙和我在 GitHub 上做的一个项目，目的是将你的项目以源代码的形式发布成 NuGet 包。在安装此 NuGet 包后，目标项目将获得这些源代码。你可以通过以下博客了解如何制作一个源代码包。 将 .NET Core 项目打一个最简单的 NuGet 源码包，安装此包就像直接把源码放进项目一样 - 吕毅 Roslyn 如何基于 Microsoft.NET.Sdk 制作源代码包 - 林德熙 SourceYard 制作源代码包 - 林德熙这可以避免因为安装 NuGet 包后带来的大量程序集引用，因为程序集数量太多对程序的启动性能有很大的影响： C# 程序集数量对软件启动性能的影响 - 林德熙然而制作一个 NuGet 的坑很多，详见： MSBuild/Roslyn 和 NuGet 的 100 个坑基础代码：最小的例子为了让 NuGet 源代码包对 WPF 项目问题暴露得更彻底一些，我们需要一个最简单的例子来说明这一问题。我将它放在了我的 Demo 项目中： walterlv.demo/Walterlv.GettingStarted.SourceYard at master · walterlv/walterlv.demo但为了让博客理解起来更顺畅，我还是将关键的源代码贴出来。用于打源代码包的项目 Walterlv.SourceYard.Demo为了尽可能避免其他因素的影响，我们这个源码包只做这些事情： 包含一个 targets 文件，用于给目标项目引入源代码； 包含一个几乎没有什么代码的 C# 代码文件，用于测试是否正常引入了源代码包； 项目的 csproj 文件，用于控制源代码包的编译过程。具体来说，我们的目录结构是这样的：- Walterlv.SourceYard.Demo - Assets - build - Package.targets - src - Foo.csWalterlv.SourceYard.Demo.targets 中的内容如下：&amp;lt;Project&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;MSBuildAllProjects&amp;gt;$(MSBuildAllProjects);$(MSBuildThisFileFullPath)&amp;lt;/MSBuildAllProjects&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;Target Name=&quot;_WalterlvIncludeSomeCode&quot; BeforeTargets=&quot;CoreCompile&quot;&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;Compile Include=&quot;$(MSBuildThisFileDirectory)..\\src\\Foo.cs&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;/Target&amp;gt; &amp;lt;/Project&amp;gt;Foo.cs 中的内容如下：using System;namespace Walterlv.SourceYard{ internal class Foo { public static void Run() =&amp;gt; Console.WriteLine(&quot;walterlv is a 逗比.&quot;); }}而项目文件（csproj）如下：&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;TargetFramework&amp;gt;net48&amp;lt;/TargetFramework&amp;gt; &amp;lt;PackageOutputPath&amp;gt;..\\bin\\$(Configuration)&amp;lt;/PackageOutputPath&amp;gt; &amp;lt;GeneratePackageOnBuild&amp;gt;true&amp;lt;/GeneratePackageOnBuild&amp;gt; &amp;lt;BuildOutputTargetFolder&amp;gt;tools&amp;lt;/BuildOutputTargetFolder&amp;gt; &amp;lt;PackageRequireLicenseAcceptance&amp;gt;false&amp;lt;/PackageRequireLicenseAcceptance&amp;gt; &amp;lt;Version&amp;gt;0.1.0-alpha&amp;lt;/Version&amp;gt; &amp;lt;Authors&amp;gt;walterlv&amp;lt;/Authors&amp;gt; &amp;lt;Company&amp;gt;dotnet-campus&amp;lt;/Company&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;!-- 在编译结束后将需要的源码拷贝到 NuGet 包中 --&amp;gt; &amp;lt;Target Name=&quot;IncludeAllDependencies&quot; BeforeTargets=&quot;_GetPackageFiles&quot;&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;None Include=&quot;Assets\\build\\Package.targets&quot; Pack=&quot;True&quot; PackagePath=&quot;build\\$(PackageId).targets&quot; /&amp;gt; &amp;lt;None Include=&quot;Assets\\src\\**&quot; Pack=&quot;True&quot; PackagePath=&quot;src&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;/Target&amp;gt; &amp;lt;/Project&amp;gt;这样，编译完成之后，我们可以在 ..\\bin\\Debug 目录下找到我们已经生成好的 NuGet 包，其目录结构如下：- Walterlv.SourceYard.Demo.nupkg - build - Walterlv.SourceYard.Demo.targets - src - Foo.cs - tools - net48 - Walterlv.SourceYard.Demo.dll其中，那个 Walterlv.SourceYard.Demo.dll 完全没有作用。我们是通过项目中设置了属性 BuildOutputTargetFolder 让生成的文件跑到这里来的，目的是避免安装此 NuGet 包之后，引用了我们生成的 dll 文件。因为我们要引用的是源代码，而不是 dll。用于验证源代码包的项目 Walterlv.GettingStarted.SourceYard.Sample现在，我们新建另一个简单的控制台项目用于验证这个 NuGet 包是否正常工作。项目文件就是很简单的项目文件，只是我们安装了刚刚生成的 NuGet 包 Walterlv.SourceYard.Demo.nupkg。&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;OutputType&amp;gt;Exe&amp;lt;/OutputType&amp;gt; &amp;lt;TargetFramework&amp;gt;net48&amp;lt;/TargetFramework&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;PackageReference Include=&quot;Walterlv.SourceYard.Demo&quot; Version=&quot;0.1.0-alpha&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt;&amp;lt;/Project&amp;gt;而 Program.cs 文件中的内容很简单，只是简单地调用了我们源码包中的 Foo.Run() 方法。using System;using Walterlv.SourceYard;namespace Walterlv.GettingStarted.SourceYard.Sample{ class Program { static void Main(string[] args) { Foo.Run(); Console.WriteLine(&quot;Hello World!&quot;); } }}编译现在，编译我们的项目，发现完全可以正常编译，就像我在这篇博客中说到的一样： 将 .NET Core 项目打一个最简单的 NuGet 源码包，安装此包就像直接把源码放进项目一样 - 吕毅但是，事情并不那么简单。接下来全部剩下的都是问题。不可思议的错误普通控制台项目当我们不进行任何改变，就是以上的代码，对 Walterlv.GettingStarted.SourceYard.Sample 项目进行编译（记得提前 nuget restore），我们可以得到正常的控制台输出。注意，我使用了 msbuild /t:Rebuild 命令，在编译前进行清理。PS D:\\Walterlv.Demo\\Walterlv.GettingStarted.SourceYard.Sample&amp;gt; msbuild /t:Rebuild用于 .NET Framework 的 Microsoft (R) 生成引擎版本 16.1.76+g14b0a930a7版权所有(C) Microsoft Corporation。保留所有权利。生成启动时间为 2019/6/10 17:32:50。项目“D:\\Walterlv.Demo\\Walterlv.GettingStarted.SourceYard.Sample\\Walterlv.GettingStarted.SourceYard.Sample.csproj”在节点 1 上(Rebuild 个目标)。_CheckForNETCoreSdkIsPreview:C:\\Program Files\\dotnet\\sdk\\3.0.100-preview5-011568\\Sdks\\Microsoft.NET.Sdk\\targets\\Microsoft.NET.RuntimeIdentifierInference.targets(157,5): message NETSDK1057: 你正在使用 .NET Core 的预览版。请查看 https://aka.ms/dotnet-core-preview [D:\\Walterlv.Demo\\Walterlv.GettingStarted.SourceYard.Sample\\Walterlv.GettingStarted.SourceYard.Sample.csproj]CoreClean: 正在创建目录“obj\\Debug\\net48\\”。PrepareForBuild: 正在创建目录“bin\\Debug\\net48\\”。GenerateBindingRedirects: ResolveAssemblyReferences 中没有建议的绑定重定向。GenerateTargetFrameworkMonikerAttribute:正在跳过目标“GenerateTargetFrameworkMonikerAttribute”，因为所有输出文件相对于输入文件而言都是最新的。CoreCompile: C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\MSBuild\\Current\\Bin\\Roslyn\\csc.exe /noconfig /unsafe - /checked- /nowarn:1701,1702,1701,1702 /nostdlib+ /platform:AnyCPU /errorreport:prompt /warn:4 /define:TRACE;DEBUG;N ETFRAMEWORK;NET48 /highentropyva+ /reference:&quot;C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFra mework\\v4.8\\mscorlib.dll&quot; /reference:&quot;C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v 4.8\\System.Core.dll&quot; /reference:&quot;C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.8\\S ystem.Data.dll&quot; /reference:&quot;C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.8\\System .dll&quot; /reference:&quot;C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.8\\System.Drawing.d ll&quot; /reference:&quot;C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.8\\System.IO.Compress ion.FileSystem.dll&quot; /reference:&quot;C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.8\\Sy stem.Numerics.dll&quot; /reference:&quot;C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.8\\Sys tem.Runtime.Serialization.dll&quot; /reference:&quot;C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramew ork\\v4.8\\System.Xml.dll&quot; /reference:&quot;C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4 .8\\System.Xml.Linq.dll&quot; /debug+ /debug:portable /filealign:512 /optimize- /out:obj\\Debug\\net48\\Walterlv.GettingStarte d.SourceYard.Sample.exe /ruleset:&quot;C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\Team Tools\\Static Analysis Tools\\\\Rule Sets\\MinimumRecommendedRules.ruleset&quot; /subsystemversion:6.00 /target:exe /warnaserror- /utf8outp ut /deterministic+ Program.cs &quot;C:\\Users\\lvyi\\AppData\\Local\\Temp\\.NETFramework,Version=v4.8.AssemblyAttributes.cs&quot; C:\\ Users\\lvyi\\.nuget\\packages\\walterlv.sourceyard.demo\\0.1.0-alpha\\build\\..\\src\\Foo.cs obj\\Debug\\net48\\Walterlv.GettingS tarted.SourceYard.Sample.AssemblyInfo.cs /warnaserror+:NU1605 对来自后列目录的编译器使用共享编译: C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\MSBuild\\Current\\Bin\\Roslyn_CopyAppConfigFile: 正在将文件从“D:\\Developments\\Open\\Walterlv.Demo\\Walterlv.GettingStarted.SourceYard\\Walterlv.GettingStarted.SourceYard.Sampl e\\obj\\Debug\\net48\\Walterlv.GettingStarted.SourceYard.Sample.exe.withSupportedRuntime.config”复制到“D:\\Developments\\Open\\ Walterlv.Demo\\Walterlv.GettingStarted.SourceYard\\Walterlv.GettingStarted.SourceYard.Sample\\bin\\Debug\\net48\\Walterlv.G ettingStarted.SourceYard.Sample.exe.config”。CopyFilesToOutputDirectory: 正在将文件从“D:\\Developments\\Open\\Walterlv.Demo\\Walterlv.GettingStarted.SourceYard\\Walterlv.GettingStarted.SourceYard.Sampl e\\obj\\Debug\\net48\\Walterlv.GettingStarted.SourceYard.Sample.exe”复制到“D:\\Developments\\Open\\Walterlv.Demo\\Walterlv.Getti ngStarted.SourceYard\\Walterlv.GettingStarted.SourceYard.Sample\\bin\\Debug\\net48\\Walterlv.GettingStarted.SourceYard.Sam ple.exe”。 Walterlv.GettingStarted.SourceYard.Sample -&amp;gt; D:\\Developments\\Open\\Walterlv.Demo\\Walterlv.GettingStarted.SourceYard\\Wa lterlv.GettingStarted.SourceYard.Sample\\bin\\Debug\\net48\\Walterlv.GettingStarted.SourceYard.Sample.exe 正在将文件从“D:\\Developments\\Open\\Walterlv.Demo\\Walterlv.GettingStarted.SourceYard\\Walterlv.GettingStarted.SourceYard.Sampl e\\obj\\Debug\\net48\\Walterlv.GettingStarted.SourceYard.Sample.pdb”复制到“D:\\Developments\\Open\\Walterlv.Demo\\Walterlv.Getti ngStarted.SourceYard\\Walterlv.GettingStarted.SourceYard.Sample\\bin\\Debug\\net48\\Walterlv.GettingStarted.SourceYard.Sam ple.pdb”。已完成生成项目“D:\\Developments\\Open\\Walterlv.Demo\\Walterlv.GettingStarted.SourceYard\\Walterlv.GettingStarted.SourceYard.Sample\\Walterlv.GettingStarted.SourceYard.Sample.csproj”(Rebuild 个目标)的操作。已成功生成。 0 个警告 0 个错误已用时间 00:00:00.59当然，贴一张图片可能更能体现编译通过：上面的输出非常多，但我们提取一下关键的点： 有输出的 Target 有这些：CoreClean -&amp;gt; PrepareForRebuild -&amp;gt; GenerateBindingRedirects -&amp;gt; GenerateTargetFrameworkMonikerAttribute -&amp;gt; CoreCompile -&amp;gt; _CopyAppConfigFile -&amp;gt; CopyFilesToOutputDirectory。 在 CoreCompile 这个编译任务里面，所有需要编译的 C# 代码有这些：Program.cs &quot;C:\\Users\\lvyi\\AppData\\Local\\Temp\\.NETFramework,Version=v4.8.AssemblyAttributes.cs&quot; C:\\ Users\\lvyi\\.nuget\\packages\\walterlv.sourceyard.demo\\0.1.0-alpha\\build\\..\\src\\Foo.cs obj\\Debug\\net48\\Walterlv.GettingStarted.SourceYard.Sample.AssemblyInfo.cs。可以注意到，编译期间成功将 Foo.cs 文件加入了编译。WPF 项目现在，我们将我们的项目升级成 WPF 项目。编辑项目文件。-- &amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt;++ &amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk.WindowsDesktop&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;OutputType&amp;gt;Exe&amp;lt;/OutputType&amp;gt; &amp;lt;TargetFramework&amp;gt;net48&amp;lt;/TargetFramework&amp;gt;++ &amp;lt;UseWPF&amp;gt;true&amp;lt;/UseWPF&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;PackageReference Include=&quot;Walterlv.SourceYard.Demo&quot; Version=&quot;0.1.0-alpha&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;/Project&amp;gt;现在编译，依然不会出现任何问题，跟控制台程序一模一样。但一旦在你的项目中放上一个 XAML 文件，问题立刻变得不一样了。&amp;lt;UserControl x:Class=&quot;Walterlv.GettingStarted.SourceYard.Sample.DemoControl&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:local=&quot;clr-namespace:Walterlv.GettingStarted.SourceYard.Sample&quot;&amp;gt;&amp;lt;/UserControl&amp;gt;PS D:\\Walterlv.Demo\\Walterlv.GettingStarted.SourceYard.Sample&amp;gt; msbuild /t:Rebuild用于 .NET Framework 的 Microsoft (R) 生成引擎版本 16.1.76+g14b0a930a7版权所有(C) Microsoft Corporation。保留所有权利。生成启动时间为 2019/6/10 17:43:18。项目“D:\\Walterlv.Demo\\Walterlv.GettingStarted.SourceYard.Sample\\Walterlv.GettingStarted.SourceYard.Sample.csproj”在节点 1 上(Rebuild 个目标)。_CheckForNETCoreSdkIsPreview:C:\\Program Files\\dotnet\\sdk\\3.0.100-preview5-011568\\Sdks\\Microsoft.NET.Sdk\\targets\\Microsoft.NET.RuntimeIdentifierInference.targets(157,5): message NETSDK1057: 你正在使用 .NET Core 的预览版。请查看 https://aka.ms/dotnet-core-preview [D:\\Walterlv.Demo\\Walterlv.GettingStarted.SourceYard.Sample\\Walterlv.GettingStarted.SourceYard.Sample.csproj]CoreClean: 正在删除文件“D:\\Developments\\Open\\Walterlv.Demo\\Walterlv.GettingStarted.SourceYard\\Walterlv.GettingStarted.SourceYard.Sampl e\\obj\\Debug\\net48\\Walterlv.GettingStarted.SourceYard.Sample.csprojAssemblyReference.cache”。 正在删除文件“D:\\Developments\\Open\\Walterlv.Demo\\Walterlv.GettingStarted.SourceYard\\Walterlv.GettingStarted.SourceYard.Sampl e\\obj\\Debug\\net48\\Demo.g.cs”。 正在删除文件“D:\\Developments\\Open\\Walterlv.Demo\\Walterlv.GettingStarted.SourceYard\\Walterlv.GettingStarted.SourceYard.Sampl e\\obj\\Debug\\net48\\Walterlv.GettingStarted.SourceYard.Sample_MarkupCompile.cache”。 正在删除文件“D:\\Developments\\Open\\Walterlv.Demo\\Walterlv.GettingStarted.SourceYard\\Walterlv.GettingStarted.SourceYard.Sampl e\\obj\\Debug\\net48\\Walterlv.GettingStarted.SourceYard.Sample_MarkupCompile.lref”。GenerateBindingRedirects: ResolveAssemblyReferences 中没有建议的绑定重定向。项目“D:\\Developments\\Open\\Walterlv.Demo\\Walterlv.GettingStarted.SourceYard\\Walterlv.GettingStarted.SourceYard.Sample\\Walterlv.GettingStarted.SourceYard.Sample.csproj”(1)正在节点 1 上生成“D:\\Developments\\Open\\Walterlv.Demo\\Walterlv.GettingStarted.SourceYard\\Walterlv.GettingStarted.SourceYard.Sample\\Walterlv.GettingStarted.SourceYard.Sample_vobqk5lg_wpftmp.csproj”(2) (_CompileTemporaryAssembly 个目标)。CoreCompile: C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\MSBuild\\Current\\Bin\\Roslyn\\csc.exe /noconfig /unsafe - /checked- /nowarn:1701,1702,1701,1702 /nostdlib+ /platform:AnyCPU /errorreport:prompt /warn:4 /define:TRACE;DEBUG;N ETFRAMEWORK;NET48 /highentropyva+ /reference:&quot;C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFra mework\\v4.8\\mscorlib.dll&quot; /reference:&quot;C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v 4.8\\PresentationCore.dll&quot; /reference:&quot;C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v 4.8\\PresentationFramework.dll&quot; /reference:&quot;C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramew ork\\v4.8\\System.Core.dll&quot; /reference:&quot;C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v 4.8\\System.Data.dll&quot; /reference:&quot;C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.8\\S ystem.dll&quot; /reference:&quot;C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.8\\System.Draw ing.dll&quot; /reference:&quot;C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.8\\System.IO.Com pression.FileSystem.dll&quot; /reference:&quot;C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4 .8\\System.Numerics.dll&quot; /reference:&quot;C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4. 8\\System.Runtime.Serialization.dll&quot; /reference:&quot;C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETF ramework\\v4.8\\System.Windows.Controls.Ribbon.dll&quot; /reference:&quot;C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\F ramework\\.NETFramework\\v4.8\\System.Xaml.dll&quot; /reference:&quot;C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framew ork\\.NETFramework\\v4.8\\System.Xml.dll&quot; /reference:&quot;C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.N ETFramework\\v4.8\\System.Xml.Linq.dll&quot; /reference:&quot;C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NE TFramework\\v4.8\\UIAutomationClient.dll&quot; /reference:&quot;C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\. NETFramework\\v4.8\\UIAutomationClientsideProviders.dll&quot; /reference:&quot;C:\\Program Files (x86)\\Reference Assemblies\\Micros oft\\Framework\\.NETFramework\\v4.8\\UIAutomationProvider.dll&quot; /reference:&quot;C:\\Program Files (x86)\\Reference Assemblies\\Mi crosoft\\Framework\\.NETFramework\\v4.8\\UIAutomationTypes.dll&quot; /reference:&quot;C:\\Program Files (x86)\\Reference Assemblies\\M icrosoft\\Framework\\.NETFramework\\v4.8\\WindowsBase.dll&quot; /debug+ /debug:portable /filealign:512 /optimize- /out:obj\\Deb ug\\net48\\Walterlv.GettingStarted.SourceYard.Sample.exe /ruleset:&quot;C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\ Professional\\Team Tools\\Static Analysis Tools\\\\Rule Sets\\MinimumRecommendedRules.ruleset&quot; /subsystemversion:6.00 /tar get:exe /warnaserror- /utf8output /deterministic+ Program.cs D:\\Developments\\Open\\Walterlv.Demo\\Walterlv.GettingStart ed.SourceYard\\Walterlv.GettingStarted.SourceYard.Sample\\obj\\Debug\\net48\\Demo.g.cs obj\\Debug\\net48\\Walterlv.GettingSta rted.SourceYard.Sample_vobqk5lg_wpftmp.AssemblyInfo.cs /warnaserror+:NU1605 对来自后列目录的编译器使用共享编译: C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\MSBuild\\Current\\Bin\\RoslynProgram.cs(2,16): error CS0234: 命名空间“Walterlv”中不存在类型或命名空间名“SourceYard”(是否缺少程序集引用?) [D:\\Developments\\Open\\Walterlv.Demo\\Walterlv.GettingStarted.SourceYard\\Walterlv.GettingStarted.SourceYard.Sample\\Walterlv.GettingStarted.SourceYard.Sample_vobqk5lg_wpftmp.csproj]已完成生成项目“D:\\Developments\\Open\\Walterlv.Demo\\Walterlv.GettingStarted.SourceYard\\Walterlv.GettingStarted.SourceYard.Sample\\Walterlv.GettingStarted.SourceYard.Sample_vobqk5lg_wpftmp.csproj”(_CompileTemporaryAssembly 个目标)的操作 - 失败。已完成生成项目“D:\\Developments\\Open\\Walterlv.Demo\\Walterlv.GettingStarted.SourceYard\\Walterlv.GettingStarted.SourceYard.Sample\\Walterlv.GettingStarted.SourceYard.Sample.csproj”(Rebuild 个目标)的操作 - 失败。生成失败。“D:\\Developments\\Open\\Walterlv.Demo\\Walterlv.GettingStarted.SourceYard\\Walterlv.GettingStarted.SourceYard.Sample\\Walterlv.GettingStarted.SourceYard.Sample.csproj”(Rebuild 目标) (1) -&amp;gt;“D:\\Developments\\Open\\Walterlv.Demo\\Walterlv.GettingStarted.SourceYard\\Walterlv.GettingStarted.SourceYard.Sample\\Walterlv.GettingStarted.SourceYard.Sample_vobqk5lg_wpftmp.csproj”(_CompileTemporaryAssembly 目标) (2) -&amp;gt;(CoreCompile 目标) -&amp;gt; Program.cs(2,16): error CS0234: 命名空间“Walterlv”中不存在类型或命名空间名“SourceYard”(是否缺少程序集引用?) [D:\\Developments\\Open\\Walterlv.Demo\\Walterlv.GettingStarted.SourceYard\\Walterlv.GettingStarted.SourceYard.Sample\\Walterlv.GettingStarted.SourceYard.Sample_vobqk5lg_wpftmp.csproj] 0 个警告 1 个错误已用时间 00:00:00.87因为上面有编译错误但看不出来，所以我们贴一张图，可以很容易看出来有编译错误。并且，如果对比两张图，会发现 CoreCompile 中的内容已经不一样了。变化主要是 /reference 参数和要编译的文件列表参数。/reference 参数增加了 WPF 需要的库。 mscorelib.dll++ PresentationCore.dll++ PresentationFramework.dll System.Core.dll System.Data.dll System.dll System.Drawing.dll System.IO.Compression.FileSystem.dll System.Numerics.dll System.Runtime.Serialization.dll++ System.Windows.Controls.Ribbon.dll++ System.Xaml.dll System.Xml.dll System.Xml.Linq.dll++ UIAutomationClient.dll++ UIAutomationClientsideProviders.dll++ UIAutomationProvider.dll++ UIAutomationTypes.dll++ WindowsBase.dll但是要编译的文件却既有新增，又有减少： Program.cs++ D:\\Developments\\Open\\Walterlv.Demo\\Walterlv.GettingStarted.SourceYard\\Walterlv.GettingStarted.SourceYard.Sample\\obj\\Debug\\net48\\Demo.g.cs-- &quot;C:\\Users\\lvyi\\AppData\\Local\\Temp\\.NETFramework,Version=v4.8.AssemblyAttributes.cs&quot;-- C:\\Users\\lvyi\\.nuget\\packages\\walterlv.sourceyard.demo\\0.1.0-alpha\\build\\..\\src\\Foo.cs-- obj\\Debug\\net48\\Walterlv.GettingStarted.SourceYard.Sample.AssemblyInfo.cs++ obj\\Debug\\net48\\Walterlv.GettingStarted.SourceYard.Sample_vobqk5lg_wpftmp.AssemblyInfo.cs同时，我们还能注意到还临时生成了一个新的项目文件： 项目“D:\\Walterlv.Demo\\Walterlv.GettingStarted.SourceYard.Sample\\Walterlv.GettingStarted.SourceYard.Sample.csproj”(1)正在节点 1 上生成“D:\\Walterlv.Demo\\Walterlv.GettingStarted.SourceYard.Sample\\Walterlv.GettingStarted.SourceYard.Sample_vobqk5lg_wpftmp.csproj”(2) (_CompileTemporaryAssembly 个目标)。新的项目文件有一个后缀 _vobqk5lg_wpftmp，同时我们还能注意到编译的 AssemblyInfo.cs 文件前面也有相同的后缀 _vobqk5lg_wpftmp： $(项目名)_$(随机字符)_wpftmp.csproj $(项目名)_$(随机字符)_wpftmp.AssemblyInfo.cs我们几乎可以认为，当项目是编译成 WPF 时，执行了不同的编译流程。修复错误找出原因要了解问题到底出在哪里了，我们需要知道 WPF 究竟在编译过程中做了哪些额外的事情。WPF 额外的编译任务主要在 Microsoft.WinFX.targets 文件中。在了解了 WPF 的编译过程之后，这个临时的程序集将非常容易理解。我写了一篇讲解 WPF 编译过程的博客，在解决这个问题之前，建议阅读这篇博客了解 WPF 是如何进行编译的： WPF 程序的编译过程在了解了 WPF 程序的编译过程之后，我们知道了前面一些疑问的答案： 那个临时的项目文件是如何生成的； 那个临时项目文件和原始的项目文件有哪些不同； 编译临时项目文件时，哪些编译目标会执行，哪些编译目标不会执行。在那篇博客中，我们解释到新生成的项目文件会使用 ReferencePath 替代其他方式收集到的引用，这就包含项目引用和 NuGet 包的引用。在使用 ReferencePath 的情况下，无论是项目引用还是 NuGet 包引用，都会被换成普通的 dll 引用，因为这个时候目标项目都已经编译完成，包含可以被引用的程序集。以下是我在示例程序中抓取到的临时生成的项目文件的内容，与原始项目文件之间的差异： &amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk.WindowsDesktop&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;OutputType&amp;gt;Exe&amp;lt;/OutputType&amp;gt; &amp;lt;TargetFramework&amp;gt;net48&amp;lt;/TargetFramework&amp;gt; &amp;lt;UseWPF&amp;gt;true&amp;lt;/UseWPF&amp;gt; &amp;lt;GenerateTemporaryTargetAssemblyDebuggingInformation&amp;gt;True&amp;lt;/GenerateTemporaryTargetAssemblyDebuggingInformation&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;PackageReference Include=&quot;Walterlv.SourceYard.Demo&quot; Version=&quot;0.1.0-alpha&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt;++ &amp;lt;ItemGroup&amp;gt;++ &amp;lt;ReferencePath Include=&quot;C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.8\\mscorlib.dll&quot; /&amp;gt;++ &amp;lt;ReferencePath Include=&quot;C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.8\\PresentationCore.dll&quot; /&amp;gt;++ &amp;lt;ReferencePath Include=&quot;C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.8\\PresentationFramework.dll&quot; /&amp;gt;++ &amp;lt;ReferencePath Include=&quot;C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.8\\System.Core.dll&quot; /&amp;gt;++ &amp;lt;ReferencePath Include=&quot;C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.8\\System.Data.dll&quot; /&amp;gt;++ &amp;lt;ReferencePath Include=&quot;C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.8\\System.dll&quot; /&amp;gt;++ &amp;lt;ReferencePath Include=&quot;C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.8\\System.Drawing.dll&quot; /&amp;gt;++ &amp;lt;ReferencePath Include=&quot;C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.8\\System.IO.Compression.FileSystem.dll&quot; /&amp;gt;++ &amp;lt;ReferencePath Include=&quot;C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.8\\System.Numerics.dll&quot; /&amp;gt;++ &amp;lt;ReferencePath Include=&quot;C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.8\\System.Runtime.Serialization.dll&quot; /&amp;gt;++ &amp;lt;ReferencePath Include=&quot;C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.8\\System.Windows.Controls.Ribbon.dll&quot; /&amp;gt;++ &amp;lt;ReferencePath Include=&quot;C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.8\\System.Xaml.dll&quot; /&amp;gt;++ &amp;lt;ReferencePath Include=&quot;C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.8\\System.Xml.dll&quot; /&amp;gt;++ &amp;lt;ReferencePath Include=&quot;C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.8\\System.Xml.Linq.dll&quot; /&amp;gt;++ &amp;lt;ReferencePath Include=&quot;C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.8\\UIAutomationClient.dll&quot; /&amp;gt;++ &amp;lt;ReferencePath Include=&quot;C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.8\\UIAutomationClientsideProviders.dll&quot; /&amp;gt;++ &amp;lt;ReferencePath Include=&quot;C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.8\\UIAutomationProvider.dll&quot; /&amp;gt;++ &amp;lt;ReferencePath Include=&quot;C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.8\\UIAutomationTypes.dll&quot; /&amp;gt;++ &amp;lt;ReferencePath Include=&quot;C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.8\\WindowsBase.dll&quot; /&amp;gt;++ &amp;lt;/ItemGroup&amp;gt;++ &amp;lt;ItemGroup&amp;gt;++ &amp;lt;Compile Include=&quot;D:\\Developments\\Open\\Walterlv.Demo\\Walterlv.GettingStarted.SourceYard\\Walterlv.GettingStarted.SourceYard.Sample\\obj\\Debug\\net48\\Demo.g.cs&quot; /&amp;gt;++ &amp;lt;/ItemGroup&amp;gt; &amp;lt;/Project&amp;gt;你可能已经注意到了我在项目中设置了 GenerateTemporaryTargetAssemblyDebuggingInformation 属性，这个属性可以让 WPF 临时生成的项目文件保留下来，便于进行研究和调试。在前面 GenerateTemporaryTargetAssembly 的源码部分我们已经贴出了这个属性使用的源码，只是前面我们没有说明其用途。注意，虽然新生成的项目文件中有 PackageReference 来表示包引用，但由于只有 _CompileTargetNameForLocalType 指定的编译目标和相关依赖可以被执行，而 NuGet 包中自动 Import 的部分没有加入到依赖项中，所以实际上包中的 .props 和 .targets 文件都不会被 Import 进来，这可能造成部分 NuGet 包在 WPF 项目中不能正常工作。比如本文正片文章都在探索的这个 Bug。更典型的，就是 SourceYard 项目，这个 Bug 给 SourceYard 造成了不小的困扰： walterlv.demo/Walterlv.GettingStarted.SourceYard at master · walterlv/walterlv.demo解决问题这个问题解决起来其实并不如想象当中那么简单，因为： WPF 项目的编译包含两个编译上下文，一个是正常的编译上下文，另一个是临时生成的项目文件编译的上下文；正常的编译上下文编译到 MarkupCompilePass1 和 MarkupCompilePass2 之间的 GenerateTemporaryTargetAssembly 编译目标时，会插入一段临时项目文件的编译； 临时项目文件的编译中，会执行 _CompileTargetNameForLocalType 内部属性指定的编译目标，虽然相当于开放了修改，但由于临时项目文件中不会执行 NuGet 相关的编译目标，所以不会自动 Import NuGet 包中的任何编译目标和属性定义；换句话说，我们几乎没有可以自动 Import 源码的方案。如果我们强行将 _CompileTargetNameForLocalType 替换成我们自己定义的类型会怎么样？这是通过 NuGet 包中的 .targets 文件中的内容，用来强行替换：&amp;lt;Project&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;MSBuildAllProjects&amp;gt;$(MSBuildAllProjects);$(MSBuildThisFileFullPath)&amp;lt;/MSBuildAllProjects&amp;gt; &amp;lt;_CompileTargetNameForLocalType&amp;gt;_WalterlvCompileTemporaryAssembly&amp;lt;/_CompileTargetNameForLocalType&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;Target Name=&quot;_WalterlvCompileTemporaryAssembly&quot; /&amp;gt; &amp;lt;/Project&amp;gt;我们在属性中将临时项目的编译目标改成了我们自己的目标，但会直接出现编译错误，找不到我们定义的编译目标。当然这个编译错误出现在临时生成的程序集上。原因就在于这个 .targets 文件没有自动被 Import 进来，于是我们定义的 _WalterlvCompileTemporaryAssembly 在临时生成的项目编译中根本就不存在。我们失去了通过 NuGet 自动被 Import 的时机！既然我们失去了通过 NuGet 被自动 Import 的时机，那么我们只能另寻它法： 帮助微软修复 NuGet 在 WPF 临时生成的项目中依然可以自动 Import 编译文件 .props 和 .targets； 直接修改项目文件，使其直接或间接 Import 我们希望 Import 进来的编译文件 .props 和 .targets。 寻找其他可以被自动 Import 的时机进行自动 Import； 不管时机了，从 GenerateTemporaryTargetAssembly 这个编译任务入手，修改其需要的参数；方案一：帮助微软修复（等待中）// TODO：正在组织 issues 和 pull request无论结果如何，等待微软将这些修改发布也是需要一段时间的，这段时间我们需要使用方案二和方案三来顶替一段时间。方案二：修改项目文件（可行，但不好）方案二的其中一种实施方案是下面这篇文章在最后一小节说到的方法： Roslyn 如何基于 Microsoft.NET.Sdk 制作源代码包具体来说，就是修改项目文件，在项目文件的首尾各加上 NuGet 自动生成的那些 Import 来自 NuGet 中的所有编译文件：&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;Import Condition=&quot;Exists(&#39;obj\\$(MSBuildProjectName).csproj.nuget.g.props&#39;) &quot; Project=&quot;obj\\$(MSBuildProjectName).csproj.nuget.g.props&quot; /&amp;gt; &amp;lt;!-- 项目文件中的原有其他代码。 --&amp;gt; &amp;lt;Import Condition=&quot;Exists(&#39;obj\\$(MSBuildProjectName).csproj.nuget.g.targets&#39;) &quot; Project=&quot;obj\\$(MSBuildProjectName).csproj.nuget.g.targets&quot; /&amp;gt;&amp;lt;/Project&amp;gt;另外，可以直接在这里 Import 我们 NuGet 包中的编译文件，但这些不如以上方案来得靠谱，因为上面的代码可以使得项目文件的修改完全确定，不用随着开发计算机的不同或者 NuGet 包的数量和版本不同而变化。如果打算选用方案二，那么上面这种实施方式是最推荐的实施方式。当然需要注意，此方案的副作用是会多出重复导入的编译警告。在清楚了 WPF 的编译过程之后，是不是能理解了这个警告的原因了呢？是的，对临时项目来说，由于没有自动 Import，所以这里的 Import 不会导致临时项目出现问题；但对于原项目来说，由于默认就会 Import NuGet 中的那两个文件，所以如果再次 Import 就会重复导入。方案三：寻找其他自动 Import 的时机（不可行）Directory.Build.props 和 Directory.Build.targets 也是可以被自动 Import 的文件，这也是在 Microsoft.NET.Sdk 中将其自动导入的。关于这两个文件的自动导入，可以阅读博客： Roslyn 使用 Directory.Build.props 文件定义编译但是，如果我们使用这两个文件帮助自动导入，将造成导入循环，这会形成编译错误！方案四：设置 GenerateTemporaryTargetAssembly 编译任务GenerateTemporaryTargetAssembly 的代码如下：&amp;lt;GenerateTemporaryTargetAssembly CurrentProject=&quot;$(MSBuildProjectFullPath)&quot; MSBuildBinPath=&quot;$(MSBuildBinPath)&quot; ReferencePathTypeName=&quot;ReferencePath&quot; CompileTypeName=&quot;Compile&quot; GeneratedCodeFiles=&quot;@(_GeneratedCodeFiles)&quot; ReferencePath=&quot;@(ReferencePath)&quot; IntermediateOutputPath=&quot;$(IntermediateOutputPath)&quot; AssemblyName=&quot;$(AssemblyName)&quot; CompileTargetName=&quot;$(_CompileTargetNameForLocalType)&quot; GenerateTemporaryTargetAssemblyDebuggingInformation=&quot;$(GenerateTemporaryTargetAssemblyDebuggingInformation)&quot; &amp;gt;&amp;lt;/GenerateTemporaryTargetAssembly&amp;gt;可以看到它的的参数有： CurrentProject，传入了 $(MSBuildProjectFullPath)，表示项目文件的完全路径，修改无效。 MSBuildBinPath，传入了 $(MSBuildBinPath)，表示 MSBuild 程序的完全路径，修改无效。 ReferencePathTypeName，传入了字符串常量 ReferencePath，这是为了在生成临时项目文件时使用正确的引用路径项的名称。 CompileTypeName，传入了字符串常量 Compile，这是为了在生成临时项目文件时使用正确的编译项的名称。 GeneratedCodeFiles，传入了 @(_GeneratedCodeFiles)，包含生成的代码文件，也就是那些 .g.cs 文件。 ReferencePath，传入了 @(ReferencePath)，也就是目前已收集到的所有引用文件的路径。 IntermediateOutputPath，传入了 $(IntermediateOutputPath)，表示临时输出路径，当使用临时项目文件编译时，生成的临时程序集将放在这个目录中。 AssemblyName，传入了 $(AssemblyName)，表示程序集名称，当生成临时程序集的时候，将参考这个程序集名称。 CompileTargetName，传入了 $(_CompileTargetNameForLocalType)，表示当生成了新的项目文件后，要使用哪个编译目标来编译这个项目。 GenerateTemporaryTargetAssemblyDebuggingInformation，传入了 $(GenerateTemporaryTargetAssemblyDebuggingInformation)，表示是否要为了调试保留临时生成的项目文件和程序集。可能为我们所用的有： @(_GeneratedCodeFiles)，我们可以把我们需要 Import 进来的源代码伪装成生成的 .g.cs 文件好吧，就这一个了。其他的并不会对我们 Import 源代码造成影响。于是回到我们本文一开始的 Walterlv.SourceYard.Demo.targets 文件，我们将内容修改一下，增加了一个 _ENSdkImportInTempProject 编译目标。它在 MarkupCompilePass1 之后执行，因为这是 XAML 的第一轮编译，会创造 _GeneratedCodeFiles 这个集合，将 XAML 生成 .g.cs 文件；在 GenerateTemporaryTargetAssembly 之前执行，因为这里会生成一个新的临时项目，然后立即对其进行编译。我们选用这个之间的时机刚好可以在产生 _GeneratedCodeFiles 集合之后修改其内容。 &amp;lt;Project&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;MSBuildAllProjects&amp;gt;$(MSBuildAllProjects);$(MSBuildThisFileFullPath)&amp;lt;/MSBuildAllProjects&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;Target Name=&quot;_WalterlvIncludeSomeCode&quot; BeforeTargets=&quot;CoreCompile&quot;&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;Compile Include=&quot;$(MSBuildThisFileDirectory)..\\src\\Foo.cs&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;/Target&amp;gt; ++ &amp;lt;Target Name=&quot;_ENSdkImportInTempProject&quot; AfterTargets=&quot;MarkupCompilePass1&quot; BeforeTargets=&quot;GenerateTemporaryTargetAssembly&quot;&amp;gt;++ &amp;lt;ItemGroup&amp;gt;++ &amp;lt;_GeneratedCodeFiles Include=&quot;$(MSBuildThisFileDirectory)..\\src\\Foo.cs&quot; /&amp;gt;++ &amp;lt;/ItemGroup&amp;gt;++ &amp;lt;/Target&amp;gt;++ &amp;lt;/Project&amp;gt;现在重新再编译，我们本文一开始疑惑的各种问题，现在终于无警告无错误地解决掉了。解决关键如果你觉得本文略长，希望立刻获得解决办法，可以： 直接使用 “方案四” 中新增的那一段代码； 阅读我的另一篇专门的只说解决方案的博客：如何为 WPF 项目制作源代码包（SourceYard 基础原理篇，解决 WPF 项目编译问题和 NuGet 包中的各种问题）参考资料 msbuild is adding a random hash and wpftmp to my AssemblyName during build - Developer Community WPF .Targets Files - Visual Studio - Microsoft Docs MarkupCompilePass2 Task - Visual Studio - Microsoft Docs" }, { "title": "MSBuild 在编写编译任务的时候判断当前是否在 Visual Studio 中编译", "url": "/post/determine-building-in-visual-studio-during-building.html", "categories": "", "tags": "dotnet, msbuild, visualstudio", "date": "2019-06-04 22:23:50 +0800", "snippet": "我们这里说的编译任务是 MSBuild 的 Target。虽然只有少部分，但确实有一些情况需要判断是否在 Visual Studio 中编译的时候才需要执行的编译任务，典型的如某些仅为设计器准备的代码。本文需要理解的前置知识是： 解读 Microsoft.NET.Sdk 的源码，你能定制各种奇怪而富有创意的编译过程 - walterlv而使用 Visual Studio 编译的时候，会自动帮我们设置 BuildingInsideVisualStudio 的值为 True，所以实际上我们可以使用这个值进行判断。我们可以在 Microsoft.NET.Sdk 中找到不少使用此属性的编译任务。比如为了 IO 性能考虑的硬连接，在 Visual Studio 中即便打开也不会使用：&amp;lt;!-- ============================================================ CopyFilesToOutputDirectory Copy all build outputs, satellites and other necessary files to the final directory. ============================================================ --&amp;gt;&amp;lt;PropertyGroup&amp;gt; &amp;lt;!-- By default we&#39;re not using Hard or Symbolic Links to copy to the output directory, and never when building in VS --&amp;gt; &amp;lt;CreateHardLinksForCopyAdditionalFilesIfPossible Condition=&quot;&#39;$(BuildingInsideVisualStudio)&#39; == &#39;true&#39; or &#39;$(CreateHardLinksForCopyAdditionalFilesIfPossible)&#39; == &#39;&#39;&quot;&amp;gt;false&amp;lt;/CreateHardLinksForCopyAdditionalFilesIfPossible&amp;gt; &amp;lt;CreateSymbolicLinksForCopyAdditionalFilesIfPossible Condition=&quot;&#39;$(BuildingInsideVisualStudio)&#39; == &#39;true&#39; or &#39;$(CreateSymbolicLinksForCopyAdditionalFilesIfPossible)&#39; == &#39;&#39;&quot;&amp;gt;false&amp;lt;/CreateSymbolicLinksForCopyAdditionalFilesIfPossible&amp;gt;&amp;lt;/PropertyGroup&amp;gt;另外 Visual Studio 接管了一部分引用项目的清理工作，所以编译任务里面也将其过滤掉了。&amp;lt;!-- ============================================================ CleanReferencedProjects Call Clean target on all Referenced Projects. ============================================================ --&amp;gt;&amp;lt;Target Name=&quot;CleanReferencedProjects&quot; DependsOnTargets=&quot;PrepareProjectReferences&quot;&amp;gt; &amp;lt;!-- When building the project directly from the command-line, clean those referenced projects that exist on disk. For IDE builds and command-line .SLN builds, the solution build manager takes care of this. --&amp;gt; &amp;lt;MSBuild Projects=&quot;@(_MSBuildProjectReferenceExistent)&quot; Targets=&quot;Clean&quot; Properties=&quot;%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform); %(_MSBuildProjectReferenceExistent.SetTargetFramework)&quot; BuildInParallel=&quot;$(BuildInParallel)&quot; Condition=&quot;&#39;$(BuildingInsideVisualStudio)&#39; != &#39;true&#39; and &#39;$(BuildProjectReferences)&#39; == &#39;true&#39; and &#39;@(_MSBuildProjectReferenceExistent)&#39; != &#39;&#39;&quot; ContinueOnError=&quot;$(ContinueOnError)&quot; RemoveProperties=&quot;%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)&quot;/&amp;gt;&amp;lt;/Target&amp;gt;关于如何探索 Microsoft.NET.Sdk 可以阅读我的另一篇博客： 解读 Microsoft.NET.Sdk 的源码，你能定制各种奇怪而富有创意的编译过程 - walterlv" }, { "title": "git 配置错误导致无法推送远端仓库？本文介绍各种修复方式", "url": "/post/fix-credential-issues-of-git.html", "categories": "", "tags": "git, windows", "date": "2019-06-04 15:31:18 +0800", "snippet": "无论你使用原生的 git 命令行，还是使用其他的 GUI 客户端来管理你的 git 仓库，都会遇到 git 远程仓库的身份认证机制。如果在某个远程仓库第一次认证的时候输入了错误的信息，那么 git 以及一部分 git GUI 客户端会记住这个错误的身份认证信息，使得以后也不能继续与远程仓库进行交互了。本文介绍如何清除 git 的身份认证信息，以便你可以重新获得输入正确身份认证的机会。凭据管理器如果你使用基于 https 的身份认证方式操作 git 远端，并且输入了错误的密码，那么这部分密码将保存在 Windows 的凭据管理器中。在 Windows 搜索框中搜索“凭据管理器”或者在控制面板中进入“用户账户”-&amp;gt;“凭据管理器”可以打开凭据管理界面。我们需要选择右边的“Windows 凭据”标签。随后，在下方的“普通凭据”中，找到出现问题的 git 远程仓库地址，然后展开，将其删除。删除之后，再次在 git 命令行或者基于 git 命令行的客户端的 GUI 客户端中使用 git 操作远端仓库将会重新提示输入这个远端仓库的用户名和密码。.ssh基于 SSH 的身份认证方式需要自己手工方式都是需要自己手动配置好才可以正常使用的，不会给你像 https 那样输错密码的机会。如果配置错误则不能操作远端仓库。当然，配错了直接删掉重新再来一次就好了。参见网上一大堆的配置方法：git-ssh 配置和使用 - fedl - SegmentFault 思否。TortoiseGitPlink另外，有一些客户端如 Tortoise 会自带一份认证管理工具。TortoiseGit 自带了 TortoiseGitPlink，它声称比自带的 SSH 要好用但问题是你得单独为它配置一遍……（逃命名 SSH 配好了而没有配 TortoiseGitPlink 的时候，它分分钟挂给你看：那么如何修复呢？方法一：替换 SSH 客户端替换为与 git 命令行相同的 SSH 客户端可以避免重复配置公私钥对。打开 TortoiseGit 的设置页面，切换到“网络”标签，然后将 SSH 客户端改为 SSH。通常在 C:\\Program Files\\Git\\usr\\bin 目录中，如果没找到，也可以去 C:\\Program Files (x86)\\Git\\bin\\ssh.exe 目录寻找。方法二：导入已有的 SSH 配置打开 C:\\Program Files\\TortoiseGit\\bin\\puttygen.exe 程序，然后点击“Load”，选择 git 客户端早已配好的 ssh 私钥。如果打开文件对话框中你找不到密钥文件，可能需要将过滤器设置为所有文件（*.*）。（如果之前没配好 SSH，那么建议去配置一下，不然 SSH 的认证方式将只有 TortoiseGit 客户端工具可用。本节接下来的内容将默认你已经配好 SSH，在远端仓库添加了公钥。）导入成功之后，点击保存私钥，选择一个合适的路径存下来。随后，打开 C:\\Program Files\\TortoiseGit\\bin\\puttygen.exe 程序。打开之后，你会在任务栏通知区域看到它的图标，右键点击 Add Key 然后选择我们刚刚保存的私钥。随后，你需要保持 puttygen.exe 一直处于运行状态，以便 TortoiseGit 可以一直使用。参考资料 git - Remove saved credentials from TortoiseGit - Stack Overflow git - my old username is still in use - Stack Overflow windows - How to solve TortoiseGitPlink Fatal Error? - Stack Overflow" }, { "title": "使用 ProcessMonitor 找到进程所操作的文件的路径", "url": "/post/find-process-operated-files-using-process-monitor.html", "categories": "", "tags": "windows", "date": "2019-06-01 13:49:15 +0800", "snippet": "很多系统问题都是可以修的，不需要重装系统，但是最近我还是重装了。发现之前正在玩的一款游戏的存档没有了……因为我原有系统的数据并没有删除，所以我还是能找回原来的游戏存档的。但是，我怎么知道这款游戏将存档放在了那个路径下呢？搜索当然是好方法，不过我喜欢玩的游戏大多是冷门游戏，有些搜不到。于是我就用 Process Monitor 找到了存档所在，恢复了我的游戏进度。本文介绍如何使用 ProcessMonitor 找出进程创建和修改的文件路径。下载 Process MonitorProcess Monitor 是微软极品工具箱的一部分，你可以在此页面下载： Process Monitor - Windows Sysinternals - Microsoft Docs打开 Process Monitor当你一开始打开 Process Monitor 的时候，列表中会立刻刷出大量的进程的操作记录。这么多的记录会让我们找到目标进程操作的文件有些吃力，于是我们需要设置规则。Process Monitor 的工具栏按钮并不多，而且我们这一次的目标只会用到其中的两个： 清除列表（将已经记录的所有数据清空，便于聚焦到我们最关心的数据中） 设置过滤器（防止大量无关的进程操作进入列表中干扰我们的查找）设置过滤规则我启动了我想要玩的游戏，在任务管理器中发现它的进程名称是 RIME.exe。呃……如果你也想玩，给你个链接： RiME - Explore the beautiful yet rugged world of RiME点击设置过滤规则按钮，可以看到下面的界面：可以选定 某个名词 与另一个字符串 进行某种操作 之后 引入 (Include) 或 排除 (Exclude)。我希望找到 RIME 这款游戏的游戏存档位置，所以我需要进入游戏，玩到第一个会存档的地方之后观察监视的操作记录。所以我希望的过滤器规则是： 将所有不是 RIME.exe 进程的记录全部排除； 将不是文件操作的记录全部排除； 将读文件的记录排除（这样剩下的只会是写文件，毕竟游戏读文件很频繁的）。于是我设置了这些规则：[ProcessName] is [RIME.exe] then [Exclude][Operation] is [RegOpenKey] then [Exclude][Operation] is [RegCloseKey] then [Exclude][Operation] is [RegQueryKey] then [Exclude][Operation] is [RegQueryValue] then [Exclude][Operation] is [RegEnumKey] then [Exclude][Operation] is [RegSetInfoKey] then [Exclude][Operation] is [ReadFile] then [Exclude]这样，剩下的记录将主要是文件写入以及一些不常见的操作了。分析记录现在，我在游戏里面玩到了第一个存档点，终于在 Process Monitor 的进程列表中看到了创建文件和写入文件相关的操作了。通过观察 Path 的值，我可以知道 RIME 游戏的存档放在了 %LocalAppData%\\SirenGame 文件夹下。于是我关掉 RIME 游戏，将原来系统中的此文件夹覆盖到新系统中的此文件夹之后，再次打开游戏，我恢复了我的全部游戏存档了。" }, { "title": "如何为 Win32 的打开和保存对话框编写文件过滤器（Filter）", "url": "/post/how-to-write-win32-file-dialog-filter.html", "categories": "", "tags": "windows, dotnet, csharp, wpf, uwp", "date": "2019-05-31 20:36:03 +0800", "snippet": "在使用 Win32 / WPF / Windows Forms 的打开或保存文件对话框的时候，多数情况下我们都会考虑编写文件过滤器。UWP 中有 FileTypeFilter 集合可以添加不同的文件种类，但 Win32 中却是一个按一定规则组合而成的字符串。因为其包含一定的格式，所以可能写错。本文介绍如何编写 Filter。编写 FilterFilter 使用竖线分隔不同种类的过滤器，比如 图片|*.png;*.jpg|文本|*.txt|walterlv 的自定义格式|*.lvyi。var dialog = new OpenFileDialog();dialog.Filter = &quot;图片|*.png;*.jpg|文本|*.txt|walterlv 的自定义格式|*.lvyi&quot;;dialog.ShowDialog(this);有时我们会看到一些程序的过滤器里面显示了过滤器本身，而不止是名称，实际上是因为名称中包含了过滤器：图片 (png, jpg)|*.png;*.jpg|文本 (txt)|*.txt|walterlv 的自定义格式 (lvyi)|*.lvyi你不可以在过滤器中省略名称或者过滤器任何一个部分，否则会抛出异常。附：如何显示对话框对于 .NET Core 版本的 WPF 或者 Windows Forms 程序来说，需要安装 Windows 兼容 NuGet 包： Microsoft.Windows.Compatibility安装后可以使用 Windows Forms 版本的 OpenFileDialog 或者 WPF 版本的 Microsoft.Win32.OpenFileDialog。参考资料 FileDialog.Filter Property (Microsoft.Win32) - Microsoft Docs" }, { "title": "将基于 .NET Framework 的 WPF 项目迁移到基于 .NET Core 3", "url": "/post/migrate-wpf-project-from-dotnet-framework-to-dotnet-core.html", "categories": "", "tags": "dotnet, wpf", "date": "2019-05-31 20:11:59 +0800", "snippet": "在 Connect(); 2018 大会上，微软发布了 .NET Core 3 Preview，以及基于 .NET Core 3 的 WPF；同时还发布了 Visual Studio 2019 预览版。你可以基于 .NET Core 3 创建 WPF 程序。不过，如果你已经有基于 .NET Framework 的 WPF 项目，那么如何快速迁移到基于 .NET Core 的版本呢？本文将指导大家将现有基于 .NET Framework 的 WPF 项目迁移到基于 .NET Core 3 的版本。安装 .NET Core 3.0 Preview SDK前往官网下载：.NET Core 3.0 downloads for Linux, macOS, and Windows。然后安装。如果你没有安装 Visual Studio 2019 Preview，请前往下载：Visual Studio 2019。编辑 csproj 文件卸载你原有的 WPF 项目，然后右键“编辑 csproj 文件”。将里面所有的内容改为以下代码：&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk.WindowsDesktop&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;TargetFramework&amp;gt;netcoreapp3.0&amp;lt;/TargetFramework&amp;gt; &amp;lt;UseWPF&amp;gt;true&amp;lt;/UseWPF&amp;gt; &amp;lt;!-- 如果你的项目是 Exe，则设为 WinExe；如果是 WPF 类库，则删掉这一行 --&amp;gt; &amp;lt;OutputType&amp;gt;WinExe&amp;lt;/OutputType&amp;gt; &amp;lt;!-- 如果你的原有项目中有 App.manifest 文件，则在此加入 --&amp;gt; &amp;lt;!-- &amp;lt;ApplicationManifest&amp;gt;Properties\\App.manifest&amp;lt;/ApplicationManifest&amp;gt; --&amp;gt; &amp;lt;!-- 如果你的原有项目中有 App.ico 图标，则在此加入 --&amp;gt; &amp;lt;!-- &amp;lt;ApplicationIcon&amp;gt;Properties\\App.ico&amp;lt;/ApplicationIcon&amp;gt; --&amp;gt; &amp;lt;!-- 如果你的原有项目中有自定义的 Main 函数，则在此加入 --&amp;gt; &amp;lt;!-- &amp;lt;StartupObject&amp;gt;Walterlv.Whitman.Program&amp;lt;/StartupObject&amp;gt; --&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;!-- 如果你的原有项目中有自己添加的图标文件，则在此加入 --&amp;gt; &amp;lt;Resource Include=&quot;Properties\\App.ico&quot; /&amp;gt; &amp;lt;!-- 如果你的原有项目中有其他非 .cs、.xaml 文件，则需要在这里加入 --&amp;gt; &amp;lt;/ItemGroup&amp;gt;&amp;lt;/Project&amp;gt;编辑 AssemblyInfo.cs 文件由于在 .NET Core 中，程序集相关的信息是自动生成的，所以原有 AssemblyInfo.cs 中的大量程序集信息是需要删掉的，不然会出现重复 Attribute 的错误。看以下代码，红色标记 “–” 的代码是需要删掉的，其他的代码保留。-- using System.Reflection;-- using System.Resources;-- using System.Runtime.CompilerServices; using System.Runtime.InteropServices; using System.Windows; -- // General Information about an assembly is controlled through the following-- // set of attributes. Change these attribute values to modify the information-- // associated with an assembly.-- [assembly: AssemblyTitle(&quot;Whitman&quot;)]-- [assembly: AssemblyDescription(&quot;&quot;)]-- [assembly: AssemblyConfiguration(&quot;&quot;)]-- [assembly: AssemblyCompany(&quot;&quot;)]-- [assembly: AssemblyProduct(&quot;Whitman&quot;)]-- [assembly: AssemblyCopyright(&quot;Copyright © walterlv 2018&quot;)]-- [assembly: AssemblyTrademark(&quot;&quot;)]-- [assembly: AssemblyCulture(&quot;&quot;)]-- // Setting ComVisible to false makes the types in this assembly not visible // to COM components. If you need to access a type in this assembly from // COM, set the ComVisible attribute to true on that type. [assembly: ComVisible(false)] -- //In order to begin building localizable applications, set-- //&amp;lt;UICulture&amp;gt;CultureYouAreCodingWith&amp;lt;/UICulture&amp;gt; in your .csproj file-- //inside a &amp;lt;PropertyGroup&amp;gt;. For example, if you are using US english-- //in your source files, set the &amp;lt;UICulture&amp;gt; to en-US. Then uncomment-- //the NeutralResourceLanguage attribute below. Update the &quot;en-US&quot; in-- //the line below to match the UICulture setting in the project file.-- -- //[assembly: NeutralResourcesLanguage(&quot;en-US&quot;, UltimateResourceFallbackLocation.Satellite)]-- -- [assembly: ThemeInfo( ResourceDictionaryLocation.None, //where theme specific resource dictionaries are located //(used if a resource is not found in the page, // or application resource dictionaries) ResourceDictionaryLocation.SourceAssembly //where the generic resource dictionary is located //(used if a resource is not found in the page, // app, or any theme specific resource dictionaries) )]-- -- -- // Version information for an assembly consists of the following four values:-- //-- // Major Version-- // Minor Version-- // Build Number-- // Revision-- //-- // You can specify all the values or you can default the Build and Revision Numbers-- // by using the &#39;*&#39; as shown below:-- // [assembly: AssemblyVersion(&quot;1.0.*&quot;)]-- [assembly: AssemblyVersion(&quot;1.0.0.0&quot;)]-- [assembly: AssemblyFileVersion(&quot;1.0.0.0&quot;)]恢复 NuGet 包打开你原有项目的 packages.config 文件。这里记录了你的项目中已经安装的 NuGet 包。&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;packages&amp;gt; &amp;lt;package id=&quot;Microsoft.Toolkit.Wpf.UI.XamlHost&quot; version=&quot;5.0.0&quot; targetFramework=&quot;net471&quot; /&amp;gt;&amp;lt;/packages&amp;gt;我们需要把这个文件里面的内容转换成 PackageReference。按照如下的方式逐一将 package 转换成 PackageReference。&amp;lt;PackageReference Include=&quot;Microsoft.Toolkit.Wpf.UI.XamlHost&quot; Version=&quot;5.0.0&quot; /&amp;gt;这时，csproj 项目文件的内容如下： &amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk.WindowsDesktop&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;TargetFramework&amp;gt;netcoreapp3.0&amp;lt;/TargetFramework&amp;gt; &amp;lt;UseWPF&amp;gt;true&amp;lt;/UseWPF&amp;gt; &amp;lt;OutputType&amp;gt;WinExe&amp;lt;/OutputType&amp;gt; &amp;lt;ApplicationManifest&amp;gt;Properties\\App.manifest&amp;lt;/ApplicationManifest&amp;gt; &amp;lt;ApplicationIcon&amp;gt;Properties\\App.ico&amp;lt;/ApplicationIcon&amp;gt; &amp;lt;StartupObject&amp;gt;Walterlv.Whitman.Program&amp;lt;/StartupObject&amp;gt; &amp;lt;/PropertyGroup&amp;gt;++ &amp;lt;ItemGroup&amp;gt;++ &amp;lt;PackageReference Include=&quot;Microsoft.Toolkit.Wpf.UI.XamlHost&quot; Version=&quot;5.0.0&quot; /&amp;gt;++ &amp;lt;/ItemGroup&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;Resource Include=&quot;Properties\\App.ico&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;/Project&amp;gt;如果你觉得这一步骤比较繁琐，那么可以在本文一开始就按照这篇博客的方式进行操作：自动将 NuGet 包的引用方式从 packages.config 升级为 PackageReference - walterlv。添加 Windows 兼容包如果你原有的 WPF 项目引用了一些注册表等 Windows 特有的功能，那么你还需要引用一个 Windows 兼容 NuGet 包： Microsoft.Windows.Compatibility编译、运行和修复其他错误对于比较简单的项目，在经过以上步骤之后，你可能已经可以可以直接跑起来了。对于复杂一些的项目，你可能会遇到其他的编译或运行错误，你需要适当进行一些修复。而产生这些错误的原因是 csproj 文件中删除了太多的东西。你需要将 &amp;lt;ItemGroup /&amp;gt; 中的一些没有默认添加进来的文件加入进来。更多如果你只是希望创建基于 .NET Core 3 的新 WPF 项目，那么请阅读我的另一篇博客：如何创建一个基于 .NET Core 3 的 WPF 项目。可以持续关注官方 WPF on .NET Core 的例子：samples/wpf/WPF-WinRT at master · dotnet/samples。" }, { "title": ".NET/C# 编译期能确定的字符串会在字符串暂存池中不会被 GC 垃圾回收掉", "url": "/post/compile-time-strings-are-in-the-string-intern-pool.html", "categories": "", "tags": "dotnet, csharp", "date": "2019-05-28 21:31:24 +0800", "snippet": "当我们不再使用某个对象的时候，此对象会被 GC 垃圾回收掉。当然前提是你没有写出内存泄漏的代码。我们也知道如果生成了大量的字符串，会对 GC 造成很大的压力。但是，如果在编译期间能够确定的字符串，就不会被 GC 垃圾回收掉了。示例代码下面，我创建了几个字符串，我关心的字符串是 &quot;walterlv&quot;，&quot;lindexi&quot; 以及一个当前时间。于是使用下面的代码来验证：using System;using System.Linq;using System.Runtime.CompilerServices;namespace Walterlv.Demo{ class Program { static void Main(string[] args) { var table = new ConditionalWeakTable&amp;lt;string, Foo&amp;gt; { {&quot;walterlv&quot;, new Foo(&quot;吕毅&quot;)}, {&quot;lindexi&quot;, new Foo(&quot;林德熙&quot;)}, }; var time = DateTime.Now.ToString(&quot;T&quot;); table.Add(time, new Foo(&quot;时间&quot;)); time = null; Console.WriteLine($&quot;开始个数：{table.Count()}&quot;); GC.Collect(); Console.WriteLine($&quot;剩余个数：{table.Count()}&quot;); } } public class Foo { public string Value { get; } public Foo(string value) =&amp;gt; Value = value; }}&quot;walterlv&quot; 和 &quot;lindexi&quot; 是在编译期间能够完全确定的字符串，而当前时间字符串我们都知道是编译期间不能确定的字符串。在 GC 收集之前和之后，ConditionalWeakTable 中的对象数量从三个降到了两个。并没有清除成 0 个，说明字符串现在仍然是被引用着的。那被什么引用着呢？是字符串暂存池。要理解字符串暂存池，可以阅读我的另一篇博客： .NET/C# 的字符串暂存池另外，即便设置了 CompilationRelaxations.NoStringInterning，编译期间能确定的字符串在上述代码中也是不会被垃圾回收的。参考资料 c# - Strings and Garbage Collection - Stack Overflow" }, { "title": ".NET/C# 的字符串暂存池", "url": "/post/string-intern-pool.html", "categories": "", "tags": "dotnet, csharp", "date": "2019-05-28 21:26:27 +0800", "snippet": "本文介绍 .NET 中的字符串暂存池。字符串暂存池.NET 的 CLR 运行时会在运行期间管理一个字符串暂存池（string intern pool），在字符串暂存池中的字符串只有一个实例。例如，在下面的代码中，变量 a、b、c 都是同一个实例：var a = &quot;walterlv&quot;;var b = &quot;walterlv&quot;;var c = &quot;walterlv&quot;;我有另一篇博客说到了此问题，可以参见： .NET/C# 编译期间能确定的相同字符串，在运行期间是相同的实例字符串暂存池的出现是为了避免分配大量的字符串对象造成的过多的内存空间浪费。编译期间确定默认进入字符串暂存池中的字符串是那些写程序的时候直接声明或者直接写入代码中的字符串。上一节中列举的三个变量中的字符串就是直接写到代码中的字符串。默认情况下编译期间能确定出来的字符串会写入到程序集中，运行时能直接将其放入字符串暂存池。从暂存池中获取字符串现在，我们要制造出编译期间不能确定出来的字符串，以便进行一些试验。我们当然不能使用简单的 &quot;walter&quot; + &quot;lv&quot; 这样简单的字符串拼接的方式来生成字符串，因为实际上这样的字符串依然可以在编译期间完全确定。所以这里使用 StringBuilder 来在运行期间生成字符串。var a = &quot;walterlv&quot;;var b = new StringBuilder(&quot;walter&quot;).Append(&quot;lv&quot;).ToString();var c = string.Intern(b);Console.WriteLine(ReferenceEquals(a, b));Console.WriteLine(ReferenceEquals(a, c));在这段代码中，虽然 a、b、c 三个字符串的值都是相等的，但 a、b 两个字符串是不同的实例，而 a、c 两个字符串是相同的实例。我们使用了 string.Intern 方法从字符串池中取出了一个字符串的实例。另外，string 类型还提供了 string.IsInterned 来判断一个字符串是否在字符串暂存池中。不要池化你可以在程序集中标记 CompilationRelaxations.NoStringInterning，这样，此程序集中的字符串就不会被池化。即便是在编译期间写下的字符串也会在运行时生成新的实例。方法是在一个 C# 代码文件中添加特性标记。[assembly: CompilationRelaxations(CompilationRelaxations.NoStringInterning)]垃圾回收在字符串暂存池中的字符串不会被垃圾回收，你可以阅读另一篇博客： .NET/C# 编译期能确定的字符串会在字符串暂存池中不会被 GC 垃圾回收掉参考资料 String.Intern(String) Method (System) - Microsoft Docs" }, { "title": ".NET/C# 避免调试器不小心提前计算本应延迟计算的值", "url": "/post/avoid-value-been-evaluated-by-debugger.html", "categories": "", "tags": "dotnet, csharp", "date": "2019-05-28 18:51:13 +0800", "snippet": "延迟计算属性的值，应该很多小伙伴都经常使用。比如在属性的 get 方法中判断是否已初始化，如果没有初始化则立即开始初始化。但这样的写法存在一个很大的问题——如果你使用 Visual Studio 调试，当你把鼠标划到对象的实例上的时候，属性就会立刻开始进行初始化。而此时对你的代码来说可能就过早初始化了。我们不应该让调试器非预期地影响到我们程序的执行结果。本文介绍如何避免调试器不小心提前计算本应延迟计算的值。方法是在属性上添加一个特性 DebuggerBrowsableAttribute。private Walterlv _foo;[DebuggerBrowsable(DebuggerBrowsableState.Never)]public Walterlv Walterlv =&amp;gt; _foo ?? (_foo = new Walterlv());public bool IsInitialized =&amp;gt; !(_foo is null);当指定为不再显示的话，在调试器中查看此实例的属性的时候就看不到这个属性了，也就不会因为鼠标划过导致提前计算了值。当然，如果你希望为你的类型定制更多的调试器显示方式，可以参考我的另一篇博客： C#/.NET 调试的时候显示自定义的调试信息（DebuggerDisplay 和 DebuggerTypeProxy） - walterlv参考资料 Lazy.cs" }, { "title": "cmd.exe 的命令行启动参数（可用于执行命令、传参或进行环境配置）", "url": "/post/cmd-startup-arguments.html", "categories": "", "tags": "windows, powershell", "date": "2019-05-25 09:50:48 +0800", "snippet": "有一些程序不支持被直接启动，而要求通过命令行启动。这个时候，你就需要使用 cmd.exe 来启动这样的程序。我们都知道如何在 cmd.exe 中启动一个程序，但是当你需要自动启动这个程序的时候，你就需要知道如何通过 cmd.exe 来启动一个程序，而不是手工输入然后回车运行了。本文就介绍 cmd.exe 的命令行启动参数。利用这些参数，你可以自动化地通过 cmd.exe 程序来完成一些原本需要通过手工执行的操作或者突破一些限制。一些必须通过命令行启动的程序一般来说，编译生成的 exe 程序都可以直接启动，即便是命令行程序也是如此。但是有一些程序就是要做一些限制。比如下面的 FRP 反向代理程序：那么我们如何能够借助于 cmd.exe 来启动它呢？接下来说明。顺便，使用 PowerShell 来启动的方法可以参见我的另一篇博客： PowerShell 的命令行启动参数（可用于执行命令、传参或进行环境配置） - 吕毅cmd.exe 的帮助文档先打开一个 cmd，然后输入：&amp;gt; cmd /?你就可以看到 cmd.exe 的使用说明： 启动 Windows 命令解释器的一个新实例 CMD [/A | /U] [/Q] [/D] [/E:ON | /E:OFF] [/F:ON | /F:OFF] [/V:ON | /V:OFF] [[/S] [/C | /K] string] 你可以随时输入上面的 cmd /? 命令来查看这些参数详细说明，所以本文不会非常详细地列举各个参数的含义，只会列出一些常见的使用示例。cmd.exe 的启动参数示例使用 cmd.exe 间接启动一个程序并传入参数下面的命令，使用 cmd 间接启动 frpc.exe 反向代理程序，并给 frpc.exe 程序传入 -c ./frpc.ini 的启动参数：&amp;gt; cmd /c D:\\walterlv\\frp\\frpc.exe -c ./frpc.ini关于为什么会用这种方式启动 frpc.exe，则是为了设置 frpc.exe 为开机自动启动。因为我写了一些 Asp.NET Core 的服务，详见： dotnet core 通过 frp 发布自己的网站 - 林德熙另外，间接启动一个程序的时候也可以传入 /k 参数。与 /c 参数不同的是： /c 在执行完程序之后，cmd.exe 也会终止 /k 在执行完程序之后，cmd.exe 依然会继续运行所以 /c 命令会更适用于自动化的脚本，而 /k 命令则更适用于半自动化的脚本。cmd.exe 启动参数使用中的坑在上面的例子中，我们的路径中不涉及到空格。我们知道，路径中有空格的话，在命令行中使用需要加上引号。但实际上如果你真的给路径加上了引号，会发现 cmd.exe 就开始不识别你的命令路径了。这个时候，你需要在整个传给 cmd.exe 的命令外层再加一层引号：&amp;gt; cmd /c &quot; &quot;D:\\walterlv folders\\frp\\frpc.exe&quot; -c ./frpc.ini &quot;以上，感谢 林德熙 挥泪踩出来的坑，详见： 如何在 CMD 启动的软件传入带空格的路径 - 林德熙附 cmd.exe 的全部启动参数说明 启动 Windows 命令解释器的一个新实例 CMD [/A | /U] [/Q] [/D] [/E:ON | /E:OFF] [/F:ON | /F:OFF] [/V:ON | /V:OFF] [[/S] [/C | /K] string] /C 执行字符串指定的命令然后终止/K 执行字符串指定的命令但保留/S 修改 /C 或 /K 之后的字符串处理(见下)/Q 关闭回显/D 禁止从注册表执行 AutoRun 命令(见下)/A 使向管道或文件的内部命令输出成为 ANSI/U 使向管道或文件的内部命令输出成为 Unicode/T:fg 设置前台/背景颜色(详细信息见 COLOR /?)/E:ON 启用命令扩展(见下)/E:OFF 禁用命令扩展(见下)/F:ON 启用文件和目录名完成字符(见下)/F:OFF 禁用文件和目录名完成字符(见下)/V:ON 使用 ! 作为分隔符启用延迟的环境变量 扩展。例如，/V:ON 会允许 !var! 在执行时 扩展变量 var。var 语法会在输入时 扩展变量，这与在一个 FOR 循环内不同。/V:OFF 禁用延迟的环境扩展。 注意，如果字符串加有引号，可以接受用命令分隔符 “&amp;amp;&amp;amp;”分隔多个命令。另外，由于兼容性原因，/X 与 /E:ON 相同，/Y 与 /E:OFF 相同，且 /R 与/C 相同。任何其他开关都将被忽略。 如果指定了 /C 或 /K，则会将该开关之后的命令行的剩余部分作为一个命令行处理，其中，会使用下列逻辑处理引号(“)字符: 1. 如果符合下列所有条件，则会保留 命令行上的引号字符: - 不带 /S 开关 - 正好两个引号字符 - 在两个引号字符之间无任何特殊字符， 特殊字符指下列字符: &amp;amp;&amp;lt;&amp;gt;()@^| - 在两个引号字符之间至少有 一个空格字符 - 在两个引号字符之间的字符串是某个 可执行文件的名称。2. 否则，老办法是看第一个字符 是否是引号字符，如果是，则去掉首字符并 删除命令行上最后一个引号，保留 最后一个引号之后的所有文本。 如果 /D 未在命令行上被指定，当 CMD.EXE 开始时，它会寻找以下 REG_SZ/REG_EXPAND_SZ 注册表变量。如果其中一个或两个都存在，这两个变量会先被执行。 HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Command Processor\\AutoRun 和/或HKEY_CURRENT_USER\\Software\\Microsoft\\Command Processor\\AutoRun 命令扩展是按默认值启用的。你也可以使用 /E:OFF ，为某一特定调用而停用扩展。你可以在机器上和/或用户登录会话上启用或停用 CMD.EXE 所有调用的扩展，这要通过设置使用REGEDIT.EXE 的注册表中的一个或两个 REG_DWORD 值: HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Command Processor\\EnableExtensions 和/或HKEY_CURRENT_USER\\Software\\Microsoft\\Command Processor\\EnableExtensions 到 0x1 或 0x0。用户特定设置比机器设置有优先权。命令行开关比注册表设置有优先权。 在批处理文件中，SETLOCAL ENABLEEXTENSIONS 或 DISABLEEXTENSIONS 参数比 /E:ON 或 /E:OFF 开关有优先权。请参阅 SETLOCAL /? 获取详细信息。 命令扩展包括对下列命令所做的更改和/或添加: DEL or ERASECOLORCD or CHDIRMD or MKDIRPROMPTPUSHDPOPDSETSETLOCALENDLOCALIFFORCALLSHIFTGOTOSTART (同时包括对外部命令调用所做的更改)ASSOCFTYPE 有关特定详细信息，请键入 commandname /? 查看。 延迟环境变量扩展不按默认值启用。你可以用/V:ON 或 /V:OFF 开关，为 CMD.EXE 的某个调用而启用或停用延迟环境变量扩展。你可以在机器上和/或用户登录会话上启用或停用 CMD.EXE 所有调用的延迟扩展，这要通过设置使用 REGEDIT.EXE 的注册表中的一个或两个 REG_DWORD 值: HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Command Processor\\DelayedExpansion 和/或HKEY_CURRENT_USER\\Software\\Microsoft\\Command Processor\\DelayedExpansion 到 0x1 或 0x0。用户特定设置比机器设置有优先权。命令行开关比注册表设置有优先权。 在批处理文件中，SETLOCAL ENABLEDELAYEDEXPANSION 或 DISABLEDELAYEDEXPANSION参数比 /V:ON 或 /V:OFF 开关有优先权。请参阅 SETLOCAL /?获取详细信息。 如果延迟环境变量扩展被启用，惊叹号字符可在执行时间被用来代替一个环境变量的数值。 你可以用 /F:ON 或 /F:OFF 开关为 CMD.EXE 的某个调用而启用或禁用文件名完成。你可以在计算上和/或用户登录会话上启用或禁用 CMD.EXE 所有调用的完成，这可以通过使用 REGEDIT.EXE 设置注册表中的下列 REG_DWORD 的全部或其中之一: HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Command Processor\\CompletionCharHKEY_LOCAL_MACHINE\\Software\\Microsoft\\Command Processor\\PathCompletionChar 和/或HKEY_CURRENT_USER\\Software\\Microsoft\\Command Processor\\CompletionCharHKEY_CURRENT_USER\\Software\\Microsoft\\Command Processor\\PathCompletionChar 由一个控制字符的十六进制值作为一个特定参数(例如，0x4是Ctrl-D，0x6 是 Ctrl-F)。用户特定设置优先于机器设置。命令行开关优先于注册表设置。 如果完成是用 /F:ON 开关启用的，两个要使用的控制符是:目录名完成用 Ctrl-D，文件名完成用 Ctrl-F。要停用注册表中的某个字符，请用空格(0x20)的数值，因为此字符不是控制字符。 如果键入两个控制字符中的一个，完成会被调用。完成功能将路径字符串带到光标的左边，如果没有通配符，将通配符附加到左边，并建立相符的路径列表。然后，显示第一个相符的路径。如果没有相符的路径，则发出嘟嘟声，不影响显示。之后，重复按同一个控制字符会循环显示相符路径的列表。将 Shift键跟控制字符同时按下，会倒着显示列表。如果对该行进行了任何编辑，并再次按下控制字符，保存的相符路径的列表会被丢弃，新的会被生成。如果在文件和目录名完成之间切换，会发生同样现象。两个控制字符之间的唯一区别是文件完成字符符合文件和目录名，而目录完成字符只符合目录名。如果文件完成被用于内置式目录命令(CD、MD 或 RD)，就会使用目录完成。用引号将相符路径括起来，完成代码可以正确处理含有空格或其他特殊字符的文件名。同时，如果备份，然后从行内调用文件完成，完成被调用时位于光标右方的文字会被调用。 需要引号的特殊字符是: &amp;lt;space&amp;gt; ()[]{}^=;!&#39;+,~(&amp;amp;()`" }, { "title": "在 Visual Studio 中重新将高级保存功能放出来，便于强制指定文件编码格式", "url": "/post/make-advanced-save-out-in-visual-studio.html", "categories": "", "tags": "visualstudio", "date": "2019-05-23 20:25:30 +0800", "snippet": "Visual Studio 的早期版本中有一个高级保存功能，但是升级到 Visual Studio 2019 之后这个功能就不在菜单项里面了。本文将带你把它找出来继续使用。第一步：工具 -&amp;gt; 自定义打开 Visual Studio 2019，然后进入“工具 -&amp;gt; 自定义”菜单项。对于英文版本，是“Tools -&amp;gt; Customize”菜单项。第二步：自定义命令按照下图一个个点击，把“高级保存选项”放出来：当刚刚添加出来的时候，位置可能不太正确，但是我们可以点击窗口旁边的“上移”和“下移”按钮将其放在合适的位置。为了照顾英文版，我也放出英文版的界面：" }, { "title": "WPF 使用 AppBar 将窗口停靠在桌面上，让其他程序不占用此窗口的空间（附我封装的附加属性）", "url": "/post/dock-window-into-windows-desktop.html", "categories": "", "tags": "windows, dotnet, csharp, wpf", "date": "2019-05-23 18:53:39 +0800", "snippet": "本文介绍如何使用 Windows 的 AppBar 相关 API 实现固定停靠在桌面上的特殊窗口。停靠窗口你可能并不明白停靠窗口是什么意思。看下图，你可能使用过 OneNote 的停靠窗口功能。当打开一个新的 OneNote 停靠窗口之后，这个新的 OneNote 窗口将固定显示在桌面的右侧，其他的窗口就算最大化也只会占据剩余的空间。OneNote 的这种功能可以让你在一边浏览网页或做其他事情的时候，以便能够做笔记。同时又不用担心其他窗口最大化的时候会占据记笔记的一部分空间。这其实也是 Windows 任务栏所使用的方法。OneNote 中给出的名称叫做“停靠窗口”，于是这可以代表微软希望用户对这个概念的理解名词。只是，这个概念在 Windows API 中的名称叫做 AppBar。AppBar要做出停靠窗口的效果，最核心的 API 是 SHAppBarMessage，用于发送 AppBar 消息给操作系统，以便让操作系统开始处理此窗口已形成一个 AppBar 窗口。也就是我们在用户交互上所说的“停靠窗口”。虽然说要让一个窗口变成 AppBar 只需要一点点代码，但是要让整个停靠窗口工作得真的像一个停靠窗口，依然需要大量的辅助代码。所以我将其封装成了一个 DesktopAppBar 类，方便 WPF 程序来调用。如何使用以下使用，你需要先获取我封装的源码才可以编译通过： https://gist.github.com/walterlv/1169952f73f44a8623bbbf7e1ca1a342你可以在 XAML 中使用：&amp;lt;Window x:Class=&quot;Walterlv.Demo.DesktopDocking.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:dock=&quot;clr-namespace:Walterlv.Demo.DesktopDocking&quot; mc:Ignorable=&quot;d&quot; Title=&quot;Walterlv 的停靠窗口&quot; Height=&quot;450&quot; Width=&quot;500&quot; dock:DesktopAppBar.AppBar=&quot;Right&quot;&amp;gt; &amp;lt;StackPanel Background=&quot;#ffcd42&quot;&amp;gt; &amp;lt;TextBlock FontSize=&quot;64&quot; Margin=&quot;64&quot; TextAlignment=&quot;Center&quot; Text=&quot;walterlv 的停靠窗口&quot; /&amp;gt; &amp;lt;Button Content=&quot;再停靠一个 - blog.walterlv.com&quot; FontSize=&quot;32&quot; Padding=&quot;32&quot; Margin=&quot;32&quot; Background=&quot;#f9d77b&quot; BorderThickness=&quot;0&quot; Click=&quot;Button_Click&quot;/&amp;gt; &amp;lt;/StackPanel&amp;gt;&amp;lt;/Window&amp;gt;核心代码是其中的一处属性赋值 dock:DesktopAppBar.AppBar=&quot;Right&quot;，以及前面的命名空间声明 xmlns:dock=&quot;clr-namespace:Walterlv.Demo.DesktopDocking&quot;。你也可以在 C# 代码中使用：using System;using System.Windows;namespace Walterlv.Demo.DesktopDocking{ public partial class MainWindow : Window { public MainWindow() { InitializeComponent(); } protected override void OnSourceInitialized(EventArgs e) { base.OnSourceInitialized(e); DesktopAppBar.SetAppBar(this, AppBarEdge.Right); } }}使用以上代码中的任何一种方式，你就可以让你的窗口在右边停靠了。从图中我们可以发现，我们的示例窗口停靠在了右边，其宽度就是我们在 XAML 中设置的窗口宽度（当然这是我封装的逻辑，而不是 AppBar 的原生逻辑）。同时我们还能注意到，Visual Studio 的窗口是处于最大化的状态的——这是停靠窗口的最大优势——可以让其他窗口的工作区缩小，在最大化的时候不会覆盖到停靠窗口的内容。另外，如果设置了第二个停靠窗口，那么第二个停靠窗口会挤下第一个窗口的位置。如何还原Windows AppBar 的 API 有一个很不好的设定，如果进程退出了，那么 AppBar 所占用的空间 并不会还原！！！不过不用担心，我在封装的代码里面加入了窗口关闭时还原空间的代码，如果你正常关闭窗口，那么停靠窗口占用的空间就会及时还原回来。当然，你也可以适时调用下面的代码：DesktopAppBar.SetAppBar(this, AppBarEdge.None);附源码由于源码一直在持续改进，所以本文中贴的源代码可能不是最新的。你可以在以下仓库找到这段源码的最新版本： walterlv.demo/Walterlv.Demo.DesktopDocking/Walterlv.Demo.DesktopDocking at master · walterlv/walterlv.demousing System;using System.ComponentModel;using System.Diagnostics.CodeAnalysis;using System.Runtime.InteropServices;using System.Threading.Tasks;using System.Windows;using System.Windows.Interop;// ReSharper disable IdentifierTypo// ReSharper disable InconsistentNaming// ReSharper disable EnumUnderlyingTypeIsInt// ReSharper disable MemberCanBePrivate.Local// ReSharper disable UnusedMember.Local// ReSharper disable UnusedMember.Globalnamespace Walterlv.Demo.DesktopDocking{ /// &amp;lt;summary&amp;gt; /// 表示窗口停靠到桌面上时的边缘方向。 /// &amp;lt;/summary&amp;gt; public enum AppBarEdge { /// &amp;lt;summary&amp;gt; /// 窗口停靠到桌面的左边。 /// &amp;lt;/summary&amp;gt; Left = 0, /// &amp;lt;summary&amp;gt; /// 窗口停靠到桌面的顶部。 /// &amp;lt;/summary&amp;gt; Top, /// &amp;lt;summary&amp;gt; /// 窗口停靠到桌面的右边。 /// &amp;lt;/summary&amp;gt; Right, /// &amp;lt;summary&amp;gt; /// 窗口停靠到桌面的底部。 /// &amp;lt;/summary&amp;gt; Bottom, /// &amp;lt;summary&amp;gt; /// 窗口不停靠到任何方向，而是成为一个普通窗口占用剩余的可用空间（工作区）。 /// &amp;lt;/summary&amp;gt; None } /// &amp;lt;summary&amp;gt; /// 提供将窗口停靠到桌面某个方向的能力。 /// &amp;lt;/summary&amp;gt; public class DesktopAppBar { /// &amp;lt;summary&amp;gt; /// 标识 Window.AppBar 的附加属性。 /// &amp;lt;/summary&amp;gt; public static readonly DependencyProperty AppBarProperty = DependencyProperty.RegisterAttached( &quot;AppBar&quot;, typeof(AppBarEdge), typeof(DesktopAppBar), new PropertyMetadata(AppBarEdge.None, OnAppBarEdgeChanged)); /// &amp;lt;summary&amp;gt; /// 获取 &amp;lt;paramref name=&quot;window&quot;/&amp;gt; 当前的停靠边缘。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;window&quot;&amp;gt;要获取停靠边缘的窗口。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;停靠边缘。&amp;lt;/returns&amp;gt; public static AppBarEdge GetAppBar(Window window) =&amp;gt; (AppBarEdge)window.GetValue(AppBarProperty); /// &amp;lt;summary&amp;gt; /// 设置 &amp;lt;paramref name=&quot;window&quot;/&amp;gt; 的停靠边缘方向。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;window&quot;&amp;gt;要设置停靠的窗口。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&quot;value&quot;&amp;gt;要设置的停靠边缘方向。&amp;lt;/param&amp;gt; public static void SetAppBar(Window window, AppBarEdge value) =&amp;gt; window.SetValue(AppBarProperty, value); private static readonly DependencyProperty AppBarProcessorProperty = DependencyProperty.RegisterAttached( &quot;AppBarProcessor&quot;, typeof(AppBarWindowProcessor), typeof(DesktopAppBar), new PropertyMetadata(null)); [SuppressMessage(&quot;ReSharper&quot;, &quot;ConditionIsAlwaysTrueOrFalse&quot;)] private static void OnAppBarEdgeChanged(DependencyObject d, DependencyPropertyChangedEventArgs e) { if (DesignerProperties.GetIsInDesignMode(d)) { return; } var oldValue = (AppBarEdge) e.OldValue; var newValue = (AppBarEdge) e.NewValue; var oldEnabled = oldValue is AppBarEdge.Left || oldValue is AppBarEdge.Top || oldValue is AppBarEdge.Right || oldValue is AppBarEdge.Bottom; var newEnabled = newValue is AppBarEdge.Left || newValue is AppBarEdge.Top || newValue is AppBarEdge.Right || newValue is AppBarEdge.Bottom; if (oldEnabled &amp;amp;&amp;amp; !newEnabled) { var processor = (AppBarWindowProcessor) d.GetValue(AppBarProcessorProperty); processor.Detach(); } else if (!oldEnabled &amp;amp;&amp;amp; newEnabled) { var processor = new AppBarWindowProcessor((Window) d); d.SetValue(AppBarProcessorProperty, processor); processor.Attach(newValue); } else if (oldEnabled &amp;amp;&amp;amp; newEnabled) { var processor = (AppBarWindowProcessor) d.GetValue(AppBarProcessorProperty); processor.Update(newValue); } } /// &amp;lt;summary&amp;gt; /// 包含对 &amp;lt;see cref=&quot;Window&quot;/&amp;gt; 进行操作以便使其成为一个桌面停靠窗口的能力。 /// &amp;lt;/summary&amp;gt; private class AppBarWindowProcessor { /// &amp;lt;summary&amp;gt; /// 创建 &amp;lt;see cref=&quot;AppBarWindowProcessor&quot;/&amp;gt; 的新实例。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;window&quot;&amp;gt;需要成为停靠窗口的 &amp;lt;see cref=&quot;Window&quot;/&amp;gt; 的实例。&amp;lt;/param&amp;gt; public AppBarWindowProcessor(Window window) { _window = window; _callbackId = RegisterWindowMessage(&quot;AppBarMessage&quot;); _hwndSourceTask = new TaskCompletionSource&amp;lt;HwndSource&amp;gt;(); var source = (HwndSource) PresentationSource.FromVisual(window); if (source == null) { window.SourceInitialized += OnSourceInitialized; } else { _hwndSourceTask.SetResult(source); } _window.Closed += OnClosed; } private readonly Window _window; private readonly TaskCompletionSource&amp;lt;HwndSource&amp;gt; _hwndSourceTask; private readonly int _callbackId; private WindowStyle _restoreStyle; private Rect _restoreBounds; private ResizeMode _restoreResizeMode; private bool _restoreTopmost; private AppBarEdge Edge { get; set; } /// &amp;lt;summary&amp;gt; /// 在可以获取到窗口句柄的时候，给窗口句柄设置值。 /// &amp;lt;/summary&amp;gt; private void OnSourceInitialized(object sender, EventArgs e) { _window.SourceInitialized -= OnSourceInitialized; var source = (HwndSource) PresentationSource.FromVisual(_window); _hwndSourceTask.SetResult(source); } /// &amp;lt;summary&amp;gt; /// 在窗口关闭之后，需要恢复窗口设置过的停靠属性。 /// &amp;lt;/summary&amp;gt; private void OnClosed(object sender, EventArgs e) { _window.Closed -= OnClosed; _window.ClearValue(AppBarProperty); } /// &amp;lt;summary&amp;gt; /// 将窗口属性设置为停靠所需的属性。 /// &amp;lt;/summary&amp;gt; private void ForceWindowProperties() { _window.WindowStyle = WindowStyle.None; _window.ResizeMode = ResizeMode.NoResize; _window.Topmost = true; } /// &amp;lt;summary&amp;gt; /// 备份窗口在成为停靠窗口之前的属性。 /// &amp;lt;/summary&amp;gt; private void BackupWindowProperties() { _restoreStyle = _window.WindowStyle; _restoreBounds = _window.RestoreBounds; _restoreResizeMode = _window.ResizeMode; _restoreTopmost = _window.Topmost; } /// &amp;lt;summary&amp;gt; /// 使一个窗口开始成为桌面停靠窗口，并开始处理窗口停靠消息。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;value&quot;&amp;gt;停靠方向。&amp;lt;/param&amp;gt; public async void Attach(AppBarEdge value) { var hwndSource = await _hwndSourceTask.Task; BackupWindowProperties(); var data = new APPBARDATA(); data.cbSize = Marshal.SizeOf(data); data.hWnd = hwndSource.Handle; data.uCallbackMessage = _callbackId; SHAppBarMessage((int) ABMsg.ABM_NEW, ref data); hwndSource.AddHook(WndProc); Update(value); } /// &amp;lt;summary&amp;gt; /// 更新一个窗口的停靠方向。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;value&quot;&amp;gt;停靠方向。&amp;lt;/param&amp;gt; public async void Update(AppBarEdge value) { var hwndSource = await _hwndSourceTask.Task; Edge = value; var bounds = TransformToAppBar(hwndSource.Handle, _window.RestoreBounds, value); ForceWindowProperties(); Resize(_window, bounds); } /// &amp;lt;summary&amp;gt; /// 使一个窗口从桌面停靠窗口恢复成普通窗口。 /// &amp;lt;/summary&amp;gt; public async void Detach() { var hwndSource = await _hwndSourceTask.Task; var data = new APPBARDATA(); data.cbSize = Marshal.SizeOf(data); data.hWnd = hwndSource.Handle; SHAppBarMessage((int) ABMsg.ABM_REMOVE, ref data); _window.WindowStyle = _restoreStyle; _window.ResizeMode = _restoreResizeMode; _window.Topmost = _restoreTopmost; Resize(_window, _restoreBounds); } private IntPtr WndProc(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam, ref bool handled) { if (msg == _callbackId) { if (wParam.ToInt32() == (int) ABNotify.ABN_POSCHANGED) { var hwndSource = _hwndSourceTask.Task.Result; var bounds = TransformToAppBar(hwndSource.Handle, _window.RestoreBounds, Edge); Resize(_window, bounds); handled = true; } } return IntPtr.Zero; } private static void Resize(Window window, Rect bounds) { window.Left = bounds.Left; window.Top = bounds.Top; window.Width = bounds.Width; window.Height = bounds.Height; } private Rect TransformToAppBar(IntPtr hWnd, Rect area, AppBarEdge edge) { var data = new APPBARDATA(); data.cbSize = Marshal.SizeOf(data); data.hWnd = hWnd; data.uEdge = (int) edge; if (data.uEdge == (int) AppBarEdge.Left || data.uEdge == (int) AppBarEdge.Right) { data.rc.top = 0; data.rc.bottom = (int) SystemParameters.PrimaryScreenHeight; if (data.uEdge == (int) AppBarEdge.Left) { data.rc.left = 0; data.rc.right = (int) Math.Round(area.Width); } else { data.rc.right = (int) SystemParameters.PrimaryScreenWidth; data.rc.left = data.rc.right - (int) Math.Round(area.Width); } } else { data.rc.left = 0; data.rc.right = (int) SystemParameters.PrimaryScreenWidth; if (data.uEdge == (int) AppBarEdge.Top) { data.rc.top = 0; data.rc.bottom = (int) Math.Round(area.Height); } else { data.rc.bottom = (int) SystemParameters.PrimaryScreenHeight; data.rc.top = data.rc.bottom - (int) Math.Round(area.Height); } } SHAppBarMessage((int) ABMsg.ABM_QUERYPOS, ref data); SHAppBarMessage((int) ABMsg.ABM_SETPOS, ref data); return new Rect(data.rc.left, data.rc.top, data.rc.right - data.rc.left, data.rc.bottom - data.rc.top); } [StructLayout(LayoutKind.Sequential)] private struct RECT { public int left; public int top; public int right; public int bottom; } [StructLayout(LayoutKind.Sequential)] private struct APPBARDATA { public int cbSize; public IntPtr hWnd; public int uCallbackMessage; public int uEdge; public RECT rc; public readonly IntPtr lParam; } private enum ABMsg : int { ABM_NEW = 0, ABM_REMOVE, ABM_QUERYPOS, ABM_SETPOS, ABM_GETSTATE, ABM_GETTASKBARPOS, ABM_ACTIVATE, ABM_GETAUTOHIDEBAR, ABM_SETAUTOHIDEBAR, ABM_WINDOWPOSCHANGED, ABM_SETSTATE } private enum ABNotify : int { ABN_STATECHANGE = 0, ABN_POSCHANGED, ABN_FULLSCREENAPP, ABN_WINDOWARRANGE } [DllImport(&quot;SHELL32&quot;, CallingConvention = CallingConvention.StdCall)] private static extern uint SHAppBarMessage(int dwMessage, ref APPBARDATA pData); [DllImport(&quot;User32.dll&quot;, CharSet = CharSet.Auto)] private static extern int RegisterWindowMessage(string msg); } }}参考资料 c# - How do you do AppBar docking (to screen edge, like WinAmp) in WPF? - Stack Overflow mgaffigan/WpfAppBar: AppBar implementation for WPF .net - How to dock an application in the Windows desktop? - Stack Overflow AppBar using C# - CodeProject SHAppBarMessage function (shellapi.h) - Microsoft Docs RegisterWindowMessageA function (winuser.h) - Microsoft Docs" }, { "title": "在整个 Git 仓库的历史（包括所有分支和标签）中修改提交作者的信息（姓名和邮箱）", "url": "/post/modify-author-info-of-the-whole-git-history.html", "categories": "", "tags": "git", "date": "2019-05-23 16:15:26 +0800", "snippet": "一般情况下不建议修改 git 仓库的历史。但是现在我计划开源我的一个项目，于是自己个人使用的姓名和邮箱就需要在开源的时候改为使用我公开的姓名和邮箱。对于旧仓库，我将废弃，将来所有的精力都将在开源版本的仓库中；而对于开源版本的新仓库，由于此前没有人克隆过，所以也不会因为历史的修改产生问题。所以，我可以很放心地更改全部的 git 仓库历史。我打算将整个 Git 仓库历史中的名称和邮箱。第一步：打开 Git Bash进入本地的 Git 仓库目录，然后打开 Git Bash。第二步：输入 Git 命令接下来，我们需要输入一段多行命令。请先复制以下命令到你的临时编辑器中，然后修改这段多行命令中的几个变量的值。多行命令：git filter-branch --env-filter &#39;OLD_EMAIL=&quot;your-old-email@example.com&quot;CORRECT_NAME=&quot;Your Correct Name&quot;CORRECT_EMAIL=&quot;your-correct-email@example.com&quot;if [ &quot;$GIT_COMMITTER_EMAIL&quot; = &quot;$OLD_EMAIL&quot; ]then export GIT_COMMITTER_NAME=&quot;$CORRECT_NAME&quot; export GIT_COMMITTER_EMAIL=&quot;$CORRECT_EMAIL&quot;fiif [ &quot;$GIT_AUTHOR_EMAIL&quot; = &quot;$OLD_EMAIL&quot; ]then export GIT_AUTHOR_NAME=&quot;$CORRECT_NAME&quot; export GIT_AUTHOR_EMAIL=&quot;$CORRECT_EMAIL&quot;fi&#39; --tag-name-filter cat -- --branches --tags请注意上面那几个变量： OLD_EMAIL 修改为你的旧邮箱（也就是需要替换掉的 Git 历史中的邮箱） CORRECT_NAME 修改为你的新名称 CORRECT_EMAIL 修改为你的新邮箱对我来说，新名称也就是我在 GitHub 上的名称 walterlv，新邮箱也就是我在 GitHub 上公开使用的提交邮箱。将以上修改后的命令粘贴到 Git Bash 中，然后按下回车键执行命令：等待命令执行结束，你就能看到你的仓库中所有的分支（Branches）、所有的标签（Tags）中的旧作者信息全部被替换为了新作者信息了。第三步：推送仓库如果你只是准备开源这个仓库，还没开始推送，那么直接推送即可。使用以下命令推送所有的分支和所有的标签。git push --force --tags origin &#39;refs/heads/*&#39;如果你已经将仓库推送出去了，那么就需要强制推送来覆盖远端的仓库。使用以下命令推送所有的分支和所有的标签。git push --tags origin &#39;refs/heads/*&#39;参考资料 Changing author info - GitHub Help" }, { "title": ".NET/C# 使用 ConditionalWeakTable 附加字段（CLR 版本的附加属性，也可用用来当作弱引用字典 WeakDictionary）", "url": "/post/conditional-weak-table.html", "categories": "", "tags": "dotnet, csharp", "date": "2019-05-23 13:17:23 +0800", "snippet": "如果你使用过 WPF/UWP 等 XAML UI 框架，那么应该了解到附加属性的概念。那么没有依赖属性支持的时候如何做附加属性的功能呢？你可能会想到弱引用。但这需要做一个弱引用字典，要写的代码还是非常麻烦的。本文介绍 .NET 的 ConditionalWeakTable&amp;lt;TKey,TValue&amp;gt; 类型，适用于 .NET Framework 4.0 以上和全部 .NET Core 的版本。这不是字典现成可用的弱引用字典，即 ConditionalWeakTable&amp;lt;TKey,TValue&amp;gt;。然而实际上这个类的原本作用并不是当作字典使用！如果你使用过 WPF/UWP 等 XAML UI 框架，那么应该了解到附加属性的概念。这其实是 .NET 为我们提供的一种附加字段的机制。比如你有一个类：class Foo{ // 请忽略这里公有字段带来的设计问题，只是为了演示。 public string A;}我们希望为它增加一个字段 Bar：class Foo{ public string A; public Bar Bar;}那么我们需要修改类 Foo 本身以实现这个效果；但是这样就使得 Foo 耦合了 Bar，从而破坏了内聚性/依赖倒置原则。典型的情况是 Foo 类表示一个人 Person，它里面不应该包含一个 某行账号 这样的字段，因为很多人是没有那家银行账号的。这个信息让那家银行存起来才是比较符合设计原则的设计。我们可以通过一个字典 Dictionary&amp;lt;Foo, Bar&amp;gt; 来存储所有 Foo 实例额外增加的 Bar 的值可以避免让 Foo 类中增加 Bar 字段从而获得更好的设计。但这样就引入了一个静态字典从而使得所有的 Foo 和 Bar 的实例无法得到释放。我们想当然希望拥有一个弱引用字典来解决问题。然而这是一个 X-Y 问题。实际上 .NET 中提供了 ConditionalWeakTable&amp;lt;TKey,TValue&amp;gt; 帮我们解决了最本质的问题——在部分场景下期望为 Foo 类添加一个字段。虽然它不是弱引用字典，但能解决此类问题，同时也能当作一个弱引用字典来使用，仅此而已。你需要注意的是，ConditionalWeakTable&amp;lt;TKey,TValue&amp;gt; 并不实现 IDictionary&amp;lt;TKey,TValue&amp;gt; 接口，只是里面有一些像 IDictionary&amp;lt;TKey, TValue&amp;gt; 的方法，可以当作字典使用，也可以遍历取出剩下的所有值。验证ConditionalWeakTable&amp;lt;TKey,TValue&amp;gt; 中的所有 Key 和所有的 Value 都是弱引用的，并且会在其 Key 被回收或者 Key 和 Value 都被回收之后自动从集合中消失。这意味着当你使用它来为一个类型附加一些字段或者属性的时候完全不用担心内存泄漏的问题。下面我写了一段代码用于验证其内存泄漏问题： 向 ConditionalWeakTable&amp;lt;TKey,TValue&amp;gt; 中添加了三个键值对； 将后两个的 key 设为 null； 进行垃圾回收。using System;using System.Linq;using System.Runtime.CompilerServices;namespace Walterlv.Demo.Weak{ class Program { public static void Main() { var key1 = new Key(&quot;Key1&quot;); var key2 = new Key(&quot;Key2&quot;); var key3 = new Key(&quot;Key3&quot;); var table = new ConditionalWeakTable&amp;lt;Key, WalterlvValue&amp;gt; { {key1, new WalterlvValue()}, {key2, new WalterlvValue()}, {key3, new WalterlvValue()} }; var weak2 = new WeakReference(key2); key2 = null; key3 = null; GC.Collect(); Console.WriteLine($@&quot;key1 = {key1?.ToString() ?? &quot;null&quot;}key2 = {key2?.ToString() ?? &quot;null&quot;}, weak2 = {weak2.Target ?? &quot;null&quot;}key3 = {key3?.ToString() ?? &quot;null&quot;}Table = {{{string.Join(&quot;, &quot;, table.Select(x =&amp;gt; $&quot;{x.Key} = {x.Value}&quot;))}}}&quot;); } } public class Key { private readonly string _name; public Key(string name) =&amp;gt; _name = name; public override string ToString() =&amp;gt; _name; } public class WalterlvValue { public DateTime CreationTime = DateTime.Now; public override string ToString() =&amp;gt; CreationTime.ToShortTimeString(); }}这段代码的运行结果如下图：从中我们可以发现： 当某个 Key 被回收后，ConditionalWeakTable&amp;lt;TKey,TValue&amp;gt; 中就没有那一项键值对了； 当 Key 的实例依然在的时候，ConditionalWeakTable&amp;lt;TKey,TValue&amp;gt; 中的 Value 依然还会存在。另外，我们这里在调查内存泄漏问题，你需要在 Release 配置下执行此代码才能得到最符合预期的结果。参考资料 ConditionalWeakTable&amp;lt;TKey,TValue&amp;gt; Class (System.Runtime.CompilerServices) - Microsoft Docs Good implementation of weak dictionary in .Net - Stack Overflow Presenting WeakDictionary[TKey, TValue] – Nick Guerrera’s blog .net - Understanding ConditionalWeakTable - Stack Overflow" }, { "title": "WPF 判断一个对象是否是设计时的窗口类型，而不是运行时的窗口", "url": "/post/check-dependency-object-is-a-design-time-window.html", "categories": "", "tags": "wpf, dotnet, csharp", "date": "2019-05-22 19:53:07 +0800", "snippet": "当我们对 Window 类型写一个附加属性的时候，在属性变更通知中我们需要判断依赖对象是否是一个窗口。但是，如果直接判断是否是 Window 类型，那么在设计器中这个属性的设置就会直接出现异常。那么有没有什么方法能够得知这是一个设计时的窗口呢？这样就不会抛出异常，而能够完美支持设计器了。方法一：判断设计时属性WPF 原生自带一个附加属性可以判断一个依赖对象是否来源于设计器。而这个属性就是 DesignerProperties.IsInDesignMode。在 WPF 的设计器中，这个属性会被设计器重写元数据，指定其值为 true，而其他默认的情况下，它的默认值都是 false。所以通过判断这个值可以得知此时是否是在设计器中使用此附加属性。if (DesignerProperties.GetIsInDesignMode(d)){ // 通常我们考虑在设计器中不做额外的任何事情是最偷懒不会出问题的代码了。 return;}我在这些博客中使用过这样的判断方法，可以参见源码： 流畅设计 Fluent Design System 中的光照效果 RevealBrush，WPF 也能模拟实现啦！ 如何编写 WPF 的标记扩展 MarkupExtension，即便在 ControlTemplate/DataTemplate 中也能生效方法二：判断设计时窗口上面的方法是个通用的判断设计器中的方法。不过，如果我们希望得到更多的设计器支持，而不是像上面那样直接 return 导致此属性在设计器中一点效果都没有的话，我们需要进行更精确的判断。然而设计器中的类型我们不能直接引用到，所以可以考虑进行类型名称判断的方式。类型名称判断的方式会与 Visual Studio 的版本相关，所以实际上代码并不怎么好看。我将判断方法整理如下：public static class WalterlvDesignTime{ /// &amp;lt;summary&amp;gt; /// 判断一个依赖对象是否是设计时的 &amp;lt;see cref=&quot;Window&quot;/&amp;gt;。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;window&quot;&amp;gt;要被判断设计时的 &amp;lt;see cref=&quot;Window&quot;/&amp;gt; 对象。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;如果对象是设计时的 &amp;lt;see cref=&quot;Window&quot;/&amp;gt;，则返回 true，否则返回 false。&amp;lt;/returns&amp;gt; private static bool IsDesignTimeWindow(DependencyObject window) { const string vs201920172015Window = &quot;Microsoft.VisualStudio.DesignTools.WpfDesigner.InstanceBuilders.WindowInstance&quot;; const string vs2013Window = &quot;Microsoft.Expression.WpfPlatform.InstanceBuilders.WindowInstance&quot;; if (DesignerProperties.GetIsInDesignMode(window)) { var typeName = window.GetType().FullName; if (Equals(vs201920172015Window, typeName) || Equals(vs2013Window, typeName)) { return true; } } return false; }}于是，只需要调用一下这个方法即可得到此窗口实例是否是设计时的窗口：if (WalterlvDesignTime.IsDesignTimeWindow(d)){ // 检测到如果是设计时的窗口，就跳过一些句柄等等一些真的需要一个窗口的代码调用。}else if (d is Window){ // 检测到真的是窗口，做一些真实窗口初始化需要做的事情。}else{ // 这不是一个窗口，需要抛出异常。}" }, { "title": "通过修改环境变量修改当前进程使用的系统 Temp 文件夹的路径", "url": "/post/redirect-environment-temp-folder.html", "categories": "", "tags": "windows, dotnet, csharp, wpf", "date": "2019-05-16 20:03:57 +0800", "snippet": "Windows 系统提供了一个在 Windows 单个用户下全局的 Temp 文件夹，用于给各种不同的应用程序提供一个临时目录。但是，直到 Windows 10 推出存储感知功能之前，这个文件夹都一直只归各个应用程序自己管理，应用自己需要删除里面的文件。另外，进程多了，临时文件也会互相影响（例如个数过多、进程读写竞争等等）。本文介绍将自己当前进程的 Temp 文件夹临时修改到应用程序自己的一个临时目录下，避免与其他程序之间的各种影响，同时也比较容易自行清理。如何修改 Temp 文件夹的路径在程序启动的时候，调用如下方法：var newTempFolder = @&quot;C:\\Walterlv\\ApplicationTemp&quot;;Environment.SetEnvironmentVariable(&quot;TEMP&quot;, newTempFolder);Environment.SetEnvironmentVariable(&quot;TMP&quot;, newTempFolder);这样，可以将当前进程的临时文件夹设置到 C:\\Walterlv\\ApplicationTemp 文件夹下。上面设置了两个环境变量，实际上 .NET Framework 中主要使用的临时文件夹环境变量是 TMP 那个。使用临时文件夹中的临时文件使用 Path.GetTempPath() 可以获取临时文件夹的路径：var tempPath = Path.GetTempPath();使用 Path.GetTempFileName() 可以生成一个唯一的临时文件文件名：var tempPath = Path.GetTempFileName();不过，使用此方法需要注意，这要求临时文件夹必须存在。如果你使用了前面的方法修改了临时文件夹的地址，请务必确保文件夹存在。扩展阅读如果使用 Path.GetTempFileName() 方法创建的临时文件数量达到了 65535 个，而又不及时删除掉创建的文件的话，那么再调用此方法将抛出异常 IOException。需要注意的是，此 API 调用创建的文件数量是当前用户账户下所有程序共同累计的，其他程序用“满”了你的进程也一样会挂。当然，如果你使用的不是 .NET 的 API，而是使用原生 Win32 API，那么你可以指定临时文件名前缀，相同临时文件名前缀的程序会累计数量。而 .NET 中此 API 使用的是 tmp 前缀，所以所有的 .NET 程序会共享这 65535 个文件累计；其他程序使用其他前缀使则分别累计。另外，如果此方法无法再生成一个唯一的文件名的时候也会抛出异常。为了解决这些异常，在用户端的解决方案是删除临时文件夹。而在程序端的解决方案是 —— 本文。本文是为了和 林德熙 一起解决一个光标问题时提出的解决方案的一种。更多关于光标问题的内容可以阅读以下链接： Full temporary folder will crash cursor initialization · Issue #696 · dotnet/wpf WPF 光标初始化的时候 temp 文件夹满了无法创建参考资料 c# - System.IO.IOException: “The file exists” when using System.IO.Path.GetTempFileName() - resolutions? - Stack Overflow azure - .NET Change Temp Path - Stack Overflow GetTempFileNameA function (fileapi.h) - Microsoft Docs Path.GetTempFileName Method (System.IO) - Microsoft Docs" }, { "title": "Markdown 如何在内联代码或者代码块中使用代码开始符号反引号（`）", "url": "/post/markdown-code-escape-backtick.html", "categories": "", "tags": "markdown", "date": "2019-05-15 22:09:44 +0800", "snippet": "我们都知道如何在 Markdown 中使用反引号 ` 来包裹一段代码。无论是内联的代码还是单独的代码块，都需要使用它，只是个数的差别，比如 ` 和 ```。那么如何能够在代码片中输入反引号（backtick）呢？方法是：用两个反引号来包裹。内联代码中包含反引号例如，你想输入这段代码中包含`符号，那么你应该这么输入：``这段代码中包含`符号``内联代码中只有反引号例如，你希望输入`，那么你应该这么输入：`` ` ``注意，这里有 5 个 ` 符号，其中前后各两个 `` 是代码块的开始和结束符，中间的 ` 则是代码块中的 ` 符号，代码块和内容之间必须有空格。内联代码中只有反引号且有多个如果你读到上面一节，你可能好奇为什么我能打出两个 `` 符号来，是因为我输入了：``` `` ```注意，这里有 8 个 ` 符号，其中前后各两个 ``` 是代码块的开始和结束符，中间的 `` 则是代码块中的 `` 符号，代码块和内容之间必须有空格。更多个，则以此类推。内联代码中首尾包含反引号有时候你希望示意 Markdown 的代码块的用法，你需要告诉别人使用 `&amp;lt;code&amp;gt;` 这样的写法。那么，你可以输入：`` `&amp;lt;code&amp;gt;` ``由于 ` 符号就在内容的开始和结尾，所以 `` 的开头和结尾也是需要输入一个空格的。代码块中的反引号只要代码块中的反引号数量小于三个，就能直接在代码块中使用反引号而不用担心转义问题：```但是，如果反引号的数量大于或等于三个，那么代码块的包裹就需要更多的反引号了：```` 四个反引号开始的代码块` 有一个`` 有两个``` 有三个```` 四个反引号结束的代码块反正，包括代码块的反引号可以一直重复，比里面用到的多就好了。参考资料 Daring Fireball: Markdown Syntax Documentation" }, { "title": "在编译期间使用 Roslyn/MSBuild 自带的方法/函数判断、计算和修改属性", "url": "/post/msbuild-property-functions.html", "categories": "", "tags": "msbuild, visualstudio, roslyn", "date": "2019-05-15 21:41:27 +0800", "snippet": "充分利用 MSBuild 自带的方法，可以在编译期间完成大多数常见的属性转换，而不再需要自己专门写库来完成。本文介绍如何使用 MSBuild 自带的方法，并列举 MSBuild 中各种自带的方法。如何在编译期间使用 MSBuild 自带的方法当然，在修改编译期间的代码的时候，你可能需要提前了解项目文件相关的知识： 理解 C# 项目 csproj 文件格式的本质和编译流程以下是使用 MSBuild 自带方法的最简单的一个例子，执行 5-1 的数学运算。&amp;lt;Walterlv&amp;gt;$([MSBuild]::Subtract(5, 1))&amp;lt;/Walterlv&amp;gt;更复杂的，可能是 MSBuild 方法调用的嵌套了：&amp;lt;WalterlvPath Condition=&quot;HasTrailingSlash(&#39;$(WalterlvPath)&#39;)&quot;&amp;gt;$(WalterlvPath.Substring(0, $([MSBuild]::Add($(WalterlvPath.Length), -1))))&amp;lt;/WalterlvPath&amp;gt;以上两段示例分别来自我的另外两篇博客，如果不明白，可以参考这两篇博客的内容： 在 Roslyn/MSBuild 中进行基本的数学运算 Roslyn/MSBuild 在编译期间处理路径中的斜杠与反斜杠MSBuild 自带的方法数学运算MSBuild 中数学运算的部分可以参考我的另一篇博客： 在 Roslyn/MSBuild 中进行基本的数学运算EnsureTrailingSlash确保路径结尾有斜杠。可参考我的另一篇博客： Roslyn/MSBuild 在编译期间处理路径中的斜杠与反斜杠GetDirectoryNameOfFileAbove &amp;amp; GetPathOfFileAbove这两个是非常有用却又非常容易被忽视的 API，非常有必要介绍一下。可以阅读我的另一篇博客了解其用途和用法： Roslyn/MSBuild 在编译期间从当前文件开始查找父级文件夹，直到找到包含特定文件的文件夹MakeRelative计算两个路径之间的相对路径表示。&amp;lt;PropertyGroup&amp;gt; &amp;lt;Path1&amp;gt;C:\\Walterlv\\&amp;lt;/Path1&amp;gt; &amp;lt;Path2&amp;gt;C:\\Walterlv\\Demo\\&amp;lt;/Path2&amp;gt; &amp;lt;WalterlvPath1&amp;gt;$([MSBuild]::MakeRelative($(Path1), $(Path2)))&amp;lt;/WalterlvPath1&amp;gt; &amp;lt;WalterlvPath2&amp;gt;$([MSBuild]::MakeRelative($(Path2), $(Path1)))&amp;lt;/WalterlvPath2&amp;gt;&amp;lt;/PropertyGroup&amp;gt;WalterlvPath1 的值会计算为 Demo\\，而 WalterlvPath2 的值会计算为 ..\\。ValueOrDefault如果赋值了，就使用所赋的值；否则使用参数指定的值：&amp;lt;PropertyGroup&amp;gt; &amp;lt;WalterlvValue1&amp;gt;$([MSBuild]::ValueOrDefault(&#39;$(FooBar)&#39;, &#39;walterlv&#39;))&amp;lt;/WalterlvValue1&amp;gt; &amp;lt;WalterlvValue2&amp;gt;$([MSBuild]::ValueOrDefault(&#39;$(WalterlvValue1)&#39;, &#39;lindexi&#39;))&amp;lt;/WalterlvValue2&amp;gt;&amp;lt;/PropertyGroup&amp;gt;第一行，因为我们没有定义任何一个名为 FooBar 的属性，所以 WalterlvValue1 属性会计算得到 walterlv 值。第二行，因为 WalterlvValue1 已经得到了一个值，所以 WalterlvValue2 也会得到 WalterlvValue1 的值，也就是 walterlv，不会得到 lindexi。其他MSBuild 剩下的一些方法使用场景非常有限（不懂就别瞎装懂了），这里做一些简单的介绍。 $([MSBuild]::DoesTaskHostExist(string theRuntime, string theArchitecture)) 可参见：msbuild/Microsoft.Common.overridetasks at master · microsoft/msbuild GetRegistryValue GetRegistryValueFromView参考资料 Property Functions - Visual Studio - Microsoft Docs" }, { "title": "Roslyn/MSBuild 在编译期间从当前文件开始查找父级文件夹，直到找到包含特定文件的文件夹", "url": "/post/msbuild-get-directory-name-of-file-above.html", "categories": "", "tags": "dotnet, visualstudio, msbuild, roslyn", "date": "2019-05-15 21:16:11 +0800", "snippet": "大家在进行各种开发的时候，往往都不是写一个单纯项目就完了的，通常都会有一个解决方案，里面包含了多个项目甚至是大量的项目。我们经常会考虑输出一些文件或者处理一些文件，例如主项目的输出目录一般会选在仓库的根目录，文档文件夹一般会选在仓库的根目录。然而，我们希望输出到这些目录或者读取这些目录的项目往往在很深的代码文件夹中。如果直接通过 ..\\..\\.. 来返回仓库根目录非常不安全，你会数不过来的。现在，我们有了一个好用的 API：GetDirectoryNameOfFileAbove，可以直接找到仓库的根目录，无需再用数不清又容易改出问题的 ..\\..\\.. 了。你只需要编写这样的代码，即可查找 Walterlv.DemoSolution.sln 文件所在的文件夹的完全路径了。&amp;lt;PropertyGroup&amp;gt; &amp;lt;WalterlvSolutionRoot&amp;gt;$([MSBuild]::GetDirectoryNameOfFileAbove($(MSBuildThisFileDirectory), Walterlv.DemoSolution.sln))&amp;lt;/BuildRoot&amp;gt;&amp;lt;/PropertyGroup&amp;gt;而这段代码所在的文件，可能是这样的目录结构（里面的 Walterlv.DemoProject.csproj 文件）：- D:\\walterlv\\root - \\src - \\Walterlv.DemoProject + \\Walterlv.DemoProject.csproj - \\Walterlv.DemoProject2 + README.md - \\docs - \\bin + \\Walterlv.DemoSolution.sln + README.md这样，我们便可以找到 D:\\walterlv\\root 文件夹。另外还有一个 API GetPathOfFileAbove，只传入一个参数，找到文件后，返回文件的完全路径：&amp;lt;PropertyGroup&amp;gt; &amp;lt;WalterlvSolutionRoot&amp;gt;$([MSBuild]::GetPathOfFileAbove(Walterlv.DemoSolution.sln))&amp;lt;/BuildRoot&amp;gt;&amp;lt;/PropertyGroup&amp;gt;最终可以得到 D:\\walterlv\\root\\Walterlv.DemoSolution.sln 路径。需要注意的是： 此方法不支持通配符，也就是说不能使用 *.sln 来找路径 此方法不支持通过文件夹去找，也就是说不能使用我们熟知的 .git 等等文件夹去找路径 此方法传入的文件支持使用路径，也就是说可以使用类似于 \\src\\README.md 的方式来查找路径参考资料 Finding the Root Build Folder with MSBuild - Mode 13h" }, { "title": "Directory Opus 使用命令编辑器添加 PowerShell / CMD / Bash 等多种终端到自定义菜单", "url": "/post/directory-opus-integrate-with-terminals.html", "categories": "", "tags": "windows", "date": "2019-05-15 17:27:32 +0800", "snippet": "使用 Directory Opus 替代 Windows 自带的文件资源管理器来管理你计算机上的文件可以极大地提高你的文件处理效率。本文将教你如何使用 Directory Opus 的命令编辑器功能编写一组菜单，我们将在这组菜单里面集成各种各样的终端。命令编辑器如果你是从下面这篇文章阅读过来的，那么你现在应该正好已经打开了一个命令编辑器： 在 Directory Opus 中添加自定义的工具栏按钮提升效率如果你并没有打开命令编辑器，那么可以再阅读上面这篇文章打开一个。设置 -&amp;gt; 自定义工具栏，新建 -&amp;gt; 新建按钮，编辑。添加三个终端命令请参考 Directory Opus 使用命令编辑器集成 TortoiseGit 的各种功能 一文中添加自定义按钮的方法，同样地添加另外的三个按钮。这里，我将三个不同终端的添加参数放到了下面，你可以参考添加：PowerShell CoreGit Bash特别注意，在函数一栏的参数中，我们传入了一个路径参数。那个参数的末尾必须加上 \\.，否则 Git Bash 是无法启动的。CMD添加一个菜单在添加完上面的三个命令之后，你应该可以在工具栏上看到三个可以启动不同终端的窗口。现在我们需要将它们都集成到一个菜单中。新建一个菜单在工具栏上空白处右键，新建 -&amp;gt; 新建菜单，然后右键，编辑这个菜单：然后，我们又可以弹出一个命令编辑器窗口，由于菜单本身不打开命令只会显示子菜单，所以里面非常简单。设置图标和显示的文字即可。然后，依然保持在工具栏的编辑状态，将我们前面创建的三个按钮依次拖入菜单中即可形成一个菜单：新建一个菜单按钮在工具栏上空白处右键，新建 -&amp;gt; 新建菜单按钮，这样的菜单除了显示子项之外，还可以执行命令。然后右键，编辑这个菜单：然后，我们又可以弹出一个命令编辑器窗口，如果我们不打算让这个菜单按钮额外具备一些功能，则值设置图标和文字即可。当然，我更期望在这里将你希望默认打开的终端参数设进去，比较方便一些。然后，依然保持在工具栏的编辑状态，将我们前面创建的三个按钮依次拖入菜单中即可形成一个菜单：后续关于命令设置的详细细节，可以继续阅读我的另一篇博客： Directory Opus 使用命令编辑器集成 TortoiseGit 的各种功能最后，在自定义完按钮之后，不要忘了关闭最开始弹出来的“自定义工具栏”的对话框。" }, { "title": "C# 8.0 中开启默认接口实现", "url": "/post/default-interface-members-practise.html", "categories": "", "tags": "csharp, dotnet", "date": "2019-05-15 14:57:35 +0800", "snippet": "当你升级到 C# 8.0 和 .NET Core 3.0 之后，你就可以开始使用默认接口实现的功能了。从现在开始，你可以在接口里面添加一些默认实现的成员，避免在接口中添加成员导致大量对此接口的实现崩溃。最低要求要写出并且正常使用接口的默认实现，你需要： C# 8.0 .NET Core 3.0 Visual Studio 2019 Preview (16.1 以上版本)下载安装 Visual Studio 2019 Preview 版本 前往下载安装 Visual Studio Preview开启 .NET Core 3.0 的支持对于预览版的 Visual Studio 2019 来说，.NET Core 的预览版是默认打开且无法关闭的，所以不需要关心。开启 C# 8.0 支持请设置你项目的属性，修改 C# 语言版本为 8.0（对于预览版的语言来说，这是必要的）：或者直接修改你的项目文件，加上 LangVersion 属性的设置，设置为 8.0。&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;OutputType&amp;gt;Exe&amp;lt;/OutputType&amp;gt; &amp;lt;TargetFramework&amp;gt;netcoreapp3.0&amp;lt;/TargetFramework&amp;gt; &amp;lt;LangVersion&amp;gt;8.0&amp;lt;/LangVersion&amp;gt; &amp;lt;/PropertyGroup&amp;gt;&amp;lt;/Project&amp;gt;默认接口实现以前的做法比如，我们现在有下面这样一个简单的接口：public interface IWalterlv{ void Print(string text);}这个接口被大量实现了。现在，我们需要在接口中新增一个方法 DouBPrint，其作用是对 Print 方法进行标准化，避免各种不同实现带来的标准差异。于是我们新增一个方法： public interface IWalterlv { void Print(string text);++ void DouBPrint(string text); }然而我们都知道，这样的修改是破坏性的： 会使得所有实现这个接口的代码全部失败（无法编译通过，或者运行时抛出异常） 我们依然很难将接口的实现标准化，靠文档来规约默认接口实现那么现在，我们可以这样来新增此方法： public interface IWalterlv { void Print(string text); -- void DouBPrint(string text);++ public void DouBPrint(string text) =&amp;gt; Print($&quot;Walterlv 逗比 {text}&quot;); }在使用此方法来定义此接口中的方法后，那些没来得及实现此方法的类型也可以编译通过并获得标准化的实现。class Program{ static void Main(string[] args) { IWalterlv walterlv = new Foo(); walterlv.DouBPrint(&quot;walterlv&quot;); }}public class Foo : IWalterlv{ public void Print(string text) { }}当然，对于 Foo 类型来说，实现也是可以的：public class Foo : IWalterlv{ public void Print(string text) { } public void DouBPrint(string text) =&amp;gt; Print($&quot;Walterlv 逗比 {text}&quot;);}静态字段和方法除此之外，在接口中还可以编写静态字段和静态方法，这可以用来统一接口中的一些默认实现。意味着，如果类没有实现接口中带有默认实现的方法，那么具有默认的实现；而如果类中打算实现接口中的带有默认实现的方法，那么也可以调用接口中的静态方法来进行实现。 public interface IWalterlv { void Print(string text);-- public void DouBPrint(string text) =&amp;gt; Print($&quot;Walterlv 逗比 {text}&quot;);++ public void DouBPrint(string text) =&amp;gt; DefaultDouBPrint(this, text);++++ private static readonly string _name = &quot;walterlv&quot;;++++ protected static void DefaultDouBPrint(IWalterlv walterlv, string text)++ =&amp;gt; walterlv.Print($&quot;{_name} 逗比 {text}&quot;); }然后，对于实现方，则需要使用接口名来调用接口中的静态成员： public class Foo : IWalterlv { public void Print(string text) { }-- public void DouBPrint(string text) =&amp;gt; Print($&quot;Walterlv 逗比 {text}&quot;);++ public void DouBPrint(string text)++ {++ // Do Other things.++ IWalterlv.DefaultDouBPrint(this, text);++ }++ }参考资料 Default implementations in interfaces - .NET Blog Visual Studio 2019 version 16.1 Preview 3 - The Visual Studio Blog Safely update interfaces using default interface members in C# - Microsoft Docs" }, { "title": "Directory Opus 使用命令编辑器集成 TortoiseGit 的各种功能", "url": "/post/directory-opus-integrate-with-tortoise-git.html", "categories": "", "tags": "windows", "date": "2019-05-15 10:41:39 +0800", "snippet": "使用 Directory Opus 替代 Windows 自带的文件资源管理器来管理你计算机上的文件可以极大地提高你的文件处理效率。本文将教你如何使用 Directory Opus 的命令编辑器功能创建一个命令——跟 TortoiseGit 进行集成。命令编辑器如果你是从下面这篇文章阅读过来的，那么你现在应该正好已经打开了一个命令编辑器： 在 Directory Opus 中添加自定义的工具栏按钮提升效率如果你并没有打开命令编辑器，那么可以再阅读上面这篇文章打开一个。设置 -&amp;gt; 自定义工具栏，新建 -&amp;gt; 新建按钮，编辑。寻找命令我在 Windows 系统上使用任务管理器查看进程的各项属性 一文中告诉大家可以在任务管理器中查看某个正在运行中的进程的命令行参数，于是我们可以通过这样的方式得知如何集成 TortoiseGit 的各项功能。比如，我们在一个文件夹中从文件资源管理器中右键，选择 Git 克隆...，等待打开一个 TortoiseGit 的克隆窗口。这时，我们去任务管理器中查看此任务的命令行参数：&amp;gt; TortoiseGitProc.exe /command:clone /path:&quot;D:\\walterlv&quot; /hwnd:0000000000161264那么接下来，我们将这些信息逐一填入到命令编辑器窗格中。填写命令函数函数一栏，如果你只是简单地希望启动一个程序传入参数的话，那么称之为“启动程序”可能更合适一些。但是，我依然倾向于在后面继续保持“函数”的称呼，因为这才能体现出 Directory Opus 自定义按钮命令的强大。所以如果你后面看到我提及“函数”，那么指的就是这里的功能。Directory Opus 相比于 Total Commander 的一大特点便是其鼠标支持，这在“函数”一栏的填写中也有所体现。你可以在函数一栏的最右侧看到一个文件夹图标，点击之后可以选择你想启动的程序。现在，我们通过这个按钮找到 TortoiseGitProc.exe 程序，于是我们就可以在“函数”一栏中自动填入 TortoiseGitProc.exe 的程序路径。我们在任务管理器中看到了应该给 TortoiseGitProc.exe 传入的参数，所以我们直接在此文本框的后面继续添加参数。添加后的整个文本框中的内容应该是下面这样的：&quot;C:\\Program Files\\TortoiseGit\\bin\\TortoiseGitProc.exe&quot; /command:clone /path:&quot;{sourcepath}&quot;这里出现了一个 {sourcepaht}，这是一个表示当前路径的变量，稍后会作详细的说明。图标、说明、显示说明、提示信息我们在“函数”一栏中添加了一个可以启动的程序之后，Directory Opus 的命令编辑窗口会自动帮我们从主程序中获取一个可以显示的图标。点击一下这个图标，可以选择此程序的其他图标。我们现在正在做的是一个 Git Clone 的按钮，所以我们选择一个表示克隆仓库的图标：接着，我们需要进行一些基础的设置： 图标：将显示大图标打勾，可以使用更大更清晰的图标，这对于我这种 UI 党来说会更加友好。 说明：这是最终会出现在按钮上的文字。我填写了“Git 克隆…”，后面的三个点在 Windows 系统中是一种交互惯例，表示点击后还需要用户给出额外的信息才能完成指定的任务。 显示说明：说明文字会出现在图标的哪个方向。我选择了右侧，这跟 Directory Opus 上的多数已有工具栏是保持一致的。 提示信息：上你把鼠标移动到按钮上的时候，将显示的工具提示说明。可以使用比较长的一段话清晰地说明这个按钮是干什么用的。开始于开始于，指的是点击此按钮运行我们指定的“函数”时，如果函数打开了一个进程，那么此进程的工作路径是什么。我们先填入 {sourcepath}。这里，我们再次使用了 {sourcepath} 这个变量。稍后会进行说明。实际上到此为止，如果你按下“确定”按钮，你将在工具栏上看见一个“Git 克隆…”按钮。高级如果你没有关闭此窗口，那么点击“高级…”，我们将打开高级的命令编辑器。现在我们可以注意到下面出现了一个非常大的函数编辑窗口，而此前的“函数”、“开始于”、“运行”选项都消失了。这是因为此函数编辑窗口涵盖了消失的这些按钮的所有功能，而且更为强大，因为可以使用更多种类的命令。留意命令编辑器中的命令，我们此前用鼠标点击的操作实际上对应了两行命令：cd {sourcepath}C:\\Program Files\\TortoiseGit\\bin\\TortoiseGitProc.exe /command:clone /path:&quot;{sourcepath}&quot;第一行是将路径转换到 {sourcepath} 变量所指示的路径中，第二行是启动一个程序并传入适当的参数。而这个参数是什么意思呢？如何可以输入呢？请点击命令编辑器上面的“参数”按钮，这时会弹出一个菜单，对各种各样可以输入的参数放在一起进行了分类存放。因为我们要克隆 Git 仓库需要现在 Directory Opus 里面先进入一个文件夹，然后将 Git 仓库克隆到此仓库中，所以我们实际上是希望拿到 Directory Opus 当前正在浏览的文件夹。而 {sourcepath} 表示正在操作的源路径，而正在操作的源路径就是 Directory Opus 的当前文件夹（如果你有多个文件夹窗格，则是当前激活的那个窗口所在的文件夹）。所以我们选用了此参数。最后一步在自定义完按钮之后，不要忘了关闭最开始弹出来的“自定义工具栏”的对话框。" }, { "title": "在 Directory Opus 中添加自定义的工具栏按钮提升效率", "url": "/post/directory-opus-custom-toolbar-buttons.html", "categories": "", "tags": "windows", "date": "2019-05-15 10:41:09 +0800", "snippet": "使用 Directory Opus 替代 Windows 自带的文件资源管理器来管理你计算机上的文件可以极大地提高你的文件处理效率。Directory Opus 自定义的工具栏按钮可以执行非常复杂的命令，所以充分利用自定义工具栏按钮的功能可以更大程度上提升工作效率。Directory Opus 的工具栏这是我的 Directory Opus 的界面（暂时将左侧的树关掉了）：下图是我目前添加的一些工具栏按钮：自定义工具栏按钮自定义的方法是，点击顶部的 设置 -&amp;gt; 自定义工具栏：这时，会弹出自定义工具栏的对话框，并且所有可以被定制的工具栏现在都会进入编辑状态等待着我们对其进行编辑：添加一个自定义按钮你并不需要在自定义工具栏对话框上进行任何操作，只需要在一个现有的工具栏上点击右键，然后点击 新建 -&amp;gt; 新建按钮：这时，你会看到一个新的按钮已经出现在了工具栏上：现在，在此按钮上点击右键，“编辑”，就打开了 Directory Opus 的命令编辑器：接下来，我们的操作就进入了本文的主要内容，也是最复杂的一部分内容了。命令编辑器要定义一个能够极大提升效率的按钮，命令编辑器中的多数框我们都是要使用的。接下来我会通过两个示例来说明如何使用这个命令编辑器。 Directory Opus 使用命令编辑器集成 TortoiseGit 的各种功能 Directory Opus 使用命令编辑器添加 PowerShell / CMD / Bash 等多种终端到自定义菜单在自定义完按钮之后，不要忘了关闭最开始弹出来的“自定义工具栏”的对话框。一切皆命令在阅读上面的博客定义完一些自己的命令之后，你再观察 Directory Opus 的其他工具栏按钮，包括左上角的菜单，你会发现其实 Directory Opus 中所有的功能按钮和菜单都是使用相同的机制建立起来的。一切皆命令。这些命令组成了 Directory Opus 主界面的绝大多数功能。" }, { "title": "让 Directory Opus 支持 Windows 10 的暗色主题", "url": "/post/directory-opus-customize-theme.html", "categories": "", "tags": "csharp", "date": "2019-05-14 16:17:51 +0800", "snippet": "使用 Directory Opus 替代 Windows 自带的文件资源管理器来管理你计算机上的文件可以极大地提高你的文件处理效率。由于我自己的 Windows 10 系统使用的是暗色主题，所以我希望 Directory Opus 也能搭配我系统的纯暗色主题。本文介绍如何将 Directory Opus 打造成搭配 Windows 10 的暗色主题。Directory Opus 主题支持Directory Opus 在安装完之后的默认主题样式是下面这样的：然而，我的 Windows 10 的主要界面都是暗黑色的：那么，请在 Directory Opus 顶部菜单中选择 设置 -&amp;gt; 主题：然后点击左下角的下载主题去网上下载一款主题。Windows 10 暗色风格的主题你可以直接使用下面的链接下载 Windows 10 暗色风格的主题： Simple Windows 10 Dark Theme - Downloads / Themes - Directory Opus Resource Centre然后，依然进入我们一开始说的 设置 -&amp;gt; 主题 对话框中，导入刚刚我们下载好的主题：点击“应用”，随后 Directory Opus 会重新启动，你将看到全新的 Windows 10 暗色风格主题。微调主题样式等等！为什么重启之后看起来样式怪怪的？有一些文件的文字其实在暗色主题下看不太清。这当然是主题设计者没有考虑到所有的情况导致的，实际上你下载的任何一款主题可能都有各种考虑不周的情况，那么如何修复这些考虑不周的细节呢？我们需要前往 设置 -&amp;gt; 选项 中微调这些细节。在“选项”对话框中，选择“颜色和字体”标签。微调文件组标题在我一开始的暗色主题应用后，我们注意到我的文件是分组的，组标题是深蓝色，看不清。于是修改“文件组标题”中的颜色：微调压缩的文件和文件夹另外，我的多数文件是加入了 NTFS 压缩的，这部分文件被主题设置了很难看清的深紫色，我将它改为其他的颜色：微调其他部件里面还有大量可以微调的部件，如果你遇到了不符合你要求的颜色设置，则将其修改即可。以下是我进行了微调之后的主题效果预览：还原成默认的主题你可能会注意到在主题选择窗格中只有我们刚刚下载的那一个主题，我们不能选择回默认的主题样式。那如果一个主题被我们改残了，或者就是想重新体验原生效果的时候该如何做呢？我们依然需要进入到 设置 -&amp;gt; 选项 中，然后选择“颜色和字体”标签。这时，选择顶部的 文件 -&amp;gt; 重置该页到默认值。于是，我们的主题就会还原到最初没有修改任何字体和颜色的版本。如果主题涉及到图标等其他资源，也需要进入对应的标签页然后还原对应标签页的设置。参考资料 Latest Themes topics - Directory Opus Resource Centre Simple Windows 10 Dark Theme - Downloads / Themes - Directory Opus Resource Centre Plain / Default Theme - Themes - Directory Opus Resource Centre" }, { "title": "通过分析 WPF 的渲染脏区优化渲染性能", "url": "/post/wpf-rendering-dirty-region.html", "categories": "", "tags": "wpf, dotnet, csharp", "date": "2019-05-13 09:50:23 +0800", "snippet": "本文介绍通过发现渲染脏区来提高渲染性能。脏区 Dirty Region在计算机图形渲染中，可以每一帧绘制全部的画面，但这样对计算机的性能要求非常高。脏区（Dirty Region）的引入便是为了降低渲染对计算机性能的要求。每一帧绘制的时候，仅仅绘制改变的部分，在软件中可以节省大量的渲染资源。而每一帧渲染时，改变了需要重绘的部分就是脏区。以下是我的一款 WPF 程序 Walterlv.CloudKeyboard 随着交互的进行不断需要重绘的脏区。可以看到，脏区几乎涉及到整个界面，而且刷新非常频繁。这显然对渲染性能而言是不利的。当然这个程序很小，就算一直全部重新渲染性能也是可以接受的。不过当程序中存在比较复杂的部分，如大量的 Geometry 以及 3D 图形的时候，重新渲染这一部分将带来严重的性能问题。WPF 性能套件先下载 WPF 性能套件： 下载 Performance Profiling Tools for Windows Presentation Foundation 下载 补丁脏区监视启动 WPF Performance Suite，选择工具 Perforator，然后在 Action 菜单中启动一个待分析的 WPF 进程。虽然工具很久没有更新，但依然可以支持基于 .NET Core 3 版本的 WPF 程序。当程序运行起来后，可以看到 WPF 程序的各种性能数据图表。现在将 Show dirty-region update overlay 选项打勾即可看到本文一开始的脏区叠加层的显示。与脏区有关的选项有三个： Show dirty-region update overlay 显示脏区叠加层，每一次脏区出现需要重新渲染时会叠加一层新的半透明颜色。 Disable dirty region support 禁用脏区支持。这时，每次渲染都将重绘整个窗口。 Clear back-buffer before rendering 每次重绘之前都将清除之前所有的绘制，使用此选项，你可以迅速找到界面中频繁刷新的部分，而重绘频率不高的部分多数时候都是纯黑。 优化脏区重绘一开始的程序中，因为我使用了模拟 UWP 的高光效果，导致大量的控件在重绘高光部分，这是导致每一帧都在重新渲染的罪魁祸首。于是我将高光渲染关闭，脏区的重新渲染将仅仅几种在控件样式改变的时候（例如焦点改变）：光照效果可以参见我的另一篇博客： 流畅设计 Fluent Design System 中的光照效果 RevealBrush，WPF 也能模拟实现啦！参考资料 WPF Performance Suite - Microsoft Docs" }, { "title": "Roslyn/MSBuild 在编译期间处理路径中的斜杠与反斜杠", "url": "/post/msbuild-path-trailing-slash.html", "categories": "", "tags": "msbuild, roslyn, visualstudio", "date": "2019-05-12 14:47:08 +0800", "snippet": "本文介绍如何在项目文件 csproj，或者 MSBuild 的其他文件（props、targets）中处理路径中的斜杠与反斜杠。路径中的斜杠与反斜杠我们都知道文件路径的层级之间使用斜杠（/）或者反斜杠（\\）来分隔，具体使用哪一个取决于操作系统。本文不打算对具体使用哪一种特别说明，不过示例都是使用 Windows 操作系统中的反斜杠（\\）。对于一个文件夹的路径，末尾无论是否有反斜杠都不会影响找到这个路径对应的文件夹，但是有时我们又因为一些特殊的用途需要知道末尾的反斜杠的情况。在 MSBuild 中，通常有一个在文件夹路径末尾添加反斜杠 \\ 的惯例，这样可以直接使用属性拼接来形成新的路径而不用担心路径中的不同层级的文件夹会连接在一起。例如属性 WalterlvPath1 的值为 bin，属性 WalterlvPath2 的值为 Debug。为了确保两个可以直接使用 $(WalterlvPath1)$(WalterlvPath2) 来拼接，我们需要在这两个属性的末尾都加上反斜杠 \\。不过由于需要照顾到各式各样的开发者，包括大多数的那些从来不看文档的开发者，我们需要进行本文所述的处理。判断路径末尾是否有斜杠或反斜杠如果路径末尾没有反斜杠，那么我们现在就添加一个反斜杠。&amp;lt;WalterlvPath Condition=&quot;!HasTrailingSlash(&#39;$(WalterlvPath)&#39;)&quot;&amp;gt;$(WalterlvPath)\\&amp;lt;/WalterlvPath&amp;gt;这样，如果 WalterlvPath 的值为 bin，则会在这一个属性重新计算值的时候变成 bin\\；如果已经是 bin\\，则不会重新计算值，于是保持不变。确保路径末尾有斜杠或反斜杠另外，也有方法可以不用做判断，直接给末尾根据情况加上反斜杠。通过调用 MSBuild.EnsureTrailingSlash 可以确保路径的末尾已经有一个斜杠或者反斜杠。例如，我们有一个 WalterlvPath 属性，值可能是 bin\\Debug 也有可能是 bin\\Debug\\，那么可以统一将其处理成 bin\\Debug\\。&amp;lt;WalterlvPath&amp;gt;$([MSBuild]::EnsureTrailingSlash(&#39;$(WalterlvPath)&#39;))&amp;lt;/WalterlvPath&amp;gt;确保路径末尾没有斜杠或反斜杠正常情况下，我们都是需要 MSBuild 中文件夹路径的末尾有斜杠或者反斜杠。不过，当我们需要将这个路径作为命令行参数的一部分传给一个可执行程序的时候，就没那么容易了。因为为了确保路径中间的空格不会被命令行参数解析给分离，我们需要在路径的周围加上引号。具体来说，是使用 &amp;amp;quot; 转义字符来添加引号：&amp;lt;Target Name=&quot;WalterlvDemoTarget&quot; BeforeTargets=&quot;BeforeBuild&quot;&amp;gt; &amp;lt;Exec Command=&quot;&amp;amp;quot;$(WalterlvDemoTool)&amp;amp;quot; --option &amp;amp;quot;$(WalterlvPath)&amp;amp;quot;&quot; /&amp;gt;&amp;lt;/Target&amp;gt;以上的 Target 是我在另一篇博客中的简化版本：如何创建一个基于命令行工具的跨平台的 NuGet 工具包 - walterlv。但是这样，如果 WalterlvPath 中存在反斜杠，那么这个命令行将变成这样：&amp;gt; &quot;walterlv.tool.exe&quot; --option &quot;bin\\&quot;后面的 \\&quot; 将使得引号成为路径中的一部分，而这样的路径是不合法的路径！我们可以确保路径的末尾添加一个空格来避免将引号也解析成命令行的一部分：&amp;lt;Target Name=&quot;WalterlvDemoTarget&quot; BeforeTargets=&quot;BeforeBuild&quot;&amp;gt; &amp;lt;Exec Command=&quot;&amp;amp;quot;$(WalterlvDemoTool)&amp;amp;quot; --option &amp;amp;quot;$([MSBuild]::EnsureTrailingSlash(&#39;$(BasePathInInstaller)&#39;)) &amp;amp;quot;&quot; /&amp;gt;&amp;lt;/Target&amp;gt;不过也可以通过 SubString 来对末尾的斜杠或反斜杠进行裁剪。&amp;lt;WalterlvPath Condition=&quot;HasTrailingSlash(&#39;$(WalterlvPath)&#39;)&quot;&amp;gt;$(WalterlvPath.Substring(0, $([MSBuild]::Add($(WalterlvPath.Length), -1))))&amp;lt;/WalterlvPath&amp;gt;解释一下这里 $(WalterlvPath.Substring(0, $([MSBuild]::Add($(WalterlvPath.Length), -1)))) 所做的事情： $(WalterlvPath.Length) 计算出 WalterlvPath 属性的长度； $([MSBuild]::Add(length, -1)) 调用加法，将前面计算所得的长度 -1，用于提取无斜杠或反斜杠的路径长度。 $(WalterlvPath.Substring(0, length-1) 将路径字符串取出子串。这里的解释里面，length 只是表意，并不是为了编译通过。要编译的代码还是上面代码块中的完整代码。更多关于在 Roslyn/MSBuild 中进行数学运算的内容，可以阅读我的另一篇博客： 在 Roslyn/MSBuild 中进行数学运算 - walterlv" }, { "title": "在 Roslyn/MSBuild 中进行基本的数学运算", "url": "/post/msbuild-numeric-methods.html", "categories": "", "tags": "msbuild, visualstudio, roslyn", "date": "2019-05-11 14:53:09 +0800", "snippet": "在任何一种编程语言中，做基本的数学运算都是非常容易的事情。不过，不知道 .NET 项目的项目文件 csproj 文件中进行数学运算就不像一般的编程语言那样直观了，毕竟这不是一门语言，而只是一种项目文件格式而已。本文介绍如何在 Roslyn/MSBuild 的项目文件中使用基本的数学运算。Roslyn/MSBuild 中的数学运算在 MSBuild 中，数学运算需要使用 MSBuild 内建的方法调用来实现。你只需要给 MSBuild 中那些数学计算方法中传入看起来像是数字的属性，就可以真的计算出数字出来。加减乘除模 Add 两个数相加，实现 a + b Subtract 第一个数减去第二个数，实现 a - b Multiply 两个数相乘，实现 a * b Divide 第一个数除以第二个数，实现 a / b Modulo 第一个数与第二个数取模，实现 a % b而具体到 MSBuild 中的使用，则是这样的：&amp;lt;!-- 计算 5 - 1 的数学运算结果 --&amp;gt;&amp;lt;Walterlv&amp;gt;$([MSBuild]::Subtract(5, 1))&amp;lt;/Walterlv&amp;gt;&amp;lt;!-- 取出 Walterlv 属性的字符串值，然后计算其长度减去 1，将数学运算结果存入 Walterlv2 属性中 --&amp;gt;&amp;lt;Walterlv&amp;gt;walterlv is a 逗比&amp;lt;/Walterlv&amp;gt;&amp;lt;Walterlv2&amp;gt;$([MSBuild]::Subtract($(Walterlv.Length), 1))&amp;lt;/Walterlv2&amp;gt;不要试图在 MSBuild 中使用传统的数学运算符号不同于一般编程语言可以写的 + - * /，如果你直接在项目文件中使用这样的符号来进行数学计算，要么你将得到一个数学运算的字符串，要么你将得到编译错误。例如，如果你在你的项目文件中写了下面这样的代码，那么无一例外全部不能得到正确的数学运算结果。&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;TargetFramework&amp;gt;netcoreapp3.0&amp;lt;/TargetFramework&amp;gt; &amp;lt;!-- 这个属性将得到一个 “1 + 1” 字符串 --&amp;gt; &amp;lt;Walterlv&amp;gt;1 + 1&amp;lt;/Walterlv&amp;gt; &amp;lt;!-- 无法编译此属性 --&amp;gt; &amp;lt;!-- 无法计算表达式“&quot;1 + 1&quot;.Length + 1”。未找到方法“System.String.Length + 1” --&amp;gt; &amp;lt;Walterlv2&amp;gt;$(Walterlv.Length + 1)&amp;lt;/Walterlv2&amp;gt; &amp;lt;!-- 这个属性将得到一个 “5 + 1” 字符串 --&amp;gt; &amp;lt;Walterlv3&amp;gt;$(Walterlv.Length) + 1&amp;lt;/Walterlv3&amp;gt; &amp;lt;/PropertyGroup&amp;gt;&amp;lt;/Project&amp;gt;参考资料 Property Functions - Visual Studio 2015 - Microsoft Docs" }, { "title": "使用 DISM 工具检查并修复 Windows 系统文件", "url": "/post/dism-restore-health.html", "categories": "", "tags": "windows", "date": "2019-05-10 09:02:34 +0800", "snippet": "DISM，Deployment Image Servicing and Management，部署映像服务和管理。本文介绍使用此工具检查并修复 Windows 的系统文件。系统要求Windows 8/8.1 和 Windows 10 开始提供 DISM 工具。相比于我在另一篇博客中提及的 sfc，DISM 利用 Windows 系统镜像来完成修复，所以更容易修复成功。关于 sfc（System File Check）可以参见： 使用 System File Check (SFC) 工具检查并修复 Windows 系统文件使用方法使用管理员权限启动 CMD，然后输入命令：DISM.exe /Online /Cleanup-image /Restorehealth运行后等待其运行完成。使用本地镜像上面的命令依赖于 Windows Update 服务来获取在线的镜像进行恢复。如果 Windows Update 服务已经挂了，那么这个命令是无法正常完成的。这时需要额外添加 /Source: 来指定修复所使用的本地文件：DISM.exe /Online /Cleanup-Image /RestoreHealth /Source:C:\\RepairSource\\Windows /LimitAccessC:\\RepairSource\\Windows 需要换成自己的本地镜像路径。参考资料 Fix corrupted Windows Update system files using DISM Tool How to use DISM command-line utility to repair a Windows 10 image - Windows Central Fix Windows Update errors by using the DISM or System Update Readiness tool" }, { "title": "使用 System File Check (SFC) 工具检查并修复 Windows 系统文件", "url": "/post/system-file-check-scan-and-repair-system-files.html", "categories": "", "tags": "windows", "date": "2019-05-09 21:02:40 +0800", "snippet": "sfc.exe 这个程序的名称指的是 System File Check，用于做系统文件检查。本文介绍使用此命令检查并修复 Windows 系统文件。系统要求Windows Vista 及以上的操作系统才具有 sfc.exe 工具。 相比于 Windows 7 开始提供 dism 工具。当然，虽然系统要求如此，但如果你使用的是 Windows 8/8.1 或者 Windows 10，那么便建议使用 DISM。可以阅读： 使用 DISM 工具检查并修复 Windows 系统文件使用方法使用管理员权限启动 CMD，然后输入命令：sfc /scannow接下来等待命令执行完成即可。命令结果如果以上命令可以正常完成，那么你可能会遇到三种不同的提示（以下为中英双语版本） Windows Resource Protection did not find any integrity violations. Windows 资源保护找不到任何完整性冲突。 Windows Resource Protection could not perform the requested operation. Windows 资源保护无法执行请求的操作。 Windows Resource Protection found corrupt files and successfully repaired them. Details are included in the CBS.Log %WinDir%\\Logs\\CBS\\CBS.log. Windows 资源保护找到了损坏的文件并已成功将其修复。 详细信息包含在 CBS.Log（路径为 %WinDir%\\Logs\\CBS\\CBS.log）中。 Windows Resource Protection found corrupt files but was unable to fix some of them. Details are included in the CBS.Log %WinDir%\\Logs\\CBS\\CBS.log. Windows 资源保护找到了损坏的文件但无法修复其中的某些文件。 详细信息包含在 CBS.Log（路径为 %WinDir%\\Logs\\CBS\\CBS.log）中。 出现第一种提示，则说明没有任何丢失或损坏的系统文件。如果系统存在其他问题，则需要找其他方法来修复。出现第二种提示，你需要确保 %WinDir%\\WinSxS\\Temp 下存在 PendingDeletes 和 PendingRenames 文件夹；然后去安全模式中重新尝试此命令。出现第三种提示，则已经修复了损坏的文件。而出现第四种提示的话，你可以多次尝试执行此命令。可能多次执行后逐渐修复了所有的文件，也可能毫无作用。这个时候需要考虑其他的方法来修复系统了。此工具的其他命令可以只做检查而不用尝试修复。sfc /verifyonly参考资料 System file check (SFC) Scan and Repair System Files - Microsoft Community Use the System File Checker tool to repair missing or corrupted system files" }, { "title": "Visual Studio 使用 Parallel Builds Monitor 插件迅速找出编译速度慢的瓶颈，优化编译速度", "url": "/post/visual-studio-extension-parallel-builds-monitor.html", "categories": "", "tags": "visualstudio, dotnet", "date": "2019-05-05 21:42:43 +0800", "snippet": "嫌项目编译太慢？不一定是 Visual Studio 的问题，有可能是你项目的引用关系决定这个编译时间真的省不下来。可是，编译瓶颈在哪里呢？本文介绍 Parallel Builds Monitor 插件，帮助你迅速找出编译瓶颈。下载安装 Parallel Builds Monitor前往 Parallel Builds Monitor - Visual Studio Marketplace 下载插件安装。之后启动 Visual Studio 2019，你就能在 “其他窗口” 中找到 “Parallel Builds Monitor” 窗口了。请点击打开它。编译项目现在，使用 Visual Studio 编译一个项目，点开这个窗口，一个正在进行中的甘特图将呈现出来：寻找瓶颈我们可以通过此插件寻找到多种可能的瓶颈： 项目依赖瓶颈 CPU 瓶颈 IO 瓶颈项目依赖瓶颈看上面的那张图，这里存在典型的项目依赖瓶颈。因为在编译的中后期，几个编译时间最长的项目，其编译过程完全是串联起来编译的。这里串联起来的每一个项目，都是依赖于前一个项目的。所以要解决掉这部分的性能瓶颈，我们需要断开这几个项目之间的依赖关系，这样它们能变成并行的编译。CPU 瓶颈通常，CPU 成为瓶颈在编译中是个好事情，这意味着无关不必要的编译过程非常少，主要耗时都在编译代码的部分。当然，如果你有一些自定义的编译过程浪费了 CPU 占用那是另外一回事。比如我之前写过自己可以做一个工具包，在编译期间会执行一些代码： 如何创建一个基于 MSBuild Task 的跨平台的 NuGet 工具包IO 瓶颈IO 本不应该成为瓶颈。如果你的项目就是存在非常多的依赖文件需要拷贝，那么应该尽可能利用差量编译来避免重复拷贝文件。参考资料 Parallel Builds Monitor - Visual Studio Marketplace KrzysztofBuchacz/ParallelBuildsMonitor" }, { "title": "使用 EnumWindows 找到满足你要求的窗口", "url": "/post/find-specific-window-by-enum-windows.html", "categories": "", "tags": "windows, dotnet, csharp, wpf", "date": "2019-04-30 21:11:32 +0800", "snippet": "在 Windows 应用开发中，如果需要操作其他的窗口，那么可以使用 EnumWindows 这个 API 来枚举这些窗口。本文介绍使用 EnumWindows 来枚举并找到自己关心的窗口（如 QQ/TIM 窗口）。EnumWindows你可以在微软官网了解到 EnumWindows。要在 C# 代码中使用 EnumWindows，你需要编写平台调用 P/Invoke 代码。使用我在另一篇博客中的方法可以自动生成这样的平台调用代码： 使用 PInvoke.net Visual Studio Extension 辅助编写 Win32 函数签名我这里直接贴出来：[DllImport(&quot;user32.dll&quot;)]public static extern int EnumWindows(WndEnumProc lpEnumFunc, int lParam);遍历所有的顶层窗口官方文档对此 API 的描述是： Enumerates all top-level windows on the screen by passing the handle to each window, in turn, to an application-defined callback function.遍历屏幕上所有的顶层窗口，然后给回调函数传入每个遍历窗口的句柄。不过，并不是所有遍历的窗口都是顶层窗口，有一些非顶级系统窗口也会遍历到，详见：EnumWindows 中的备注节。所以，如果需要遍历得到所有窗口的集合，那么可以使用如下代码：public static IReadOnlyList&amp;lt;int&amp;gt; EnumWindows(){ var windowList = new List&amp;lt;int&amp;gt;(); EnumWindows(OnWindowEnum, 0); return windowList; bool OnWindowEnum(int hwnd, int lparam) { // 可自行加入一些过滤条件。 windowList.Add(hwnd); return true; }}遍历具有指定类名或者标题的窗口我们需要添加一些可以用于过滤窗口的 Win32 API。以下是我们即将用到的两个：// 获取窗口的类名。[DllImport(&quot;user32.dll&quot;)]private static extern int GetClassName(int hWnd, StringBuilder lpString, int nMaxCount);// 获取窗口的标题。[DllImport(&quot;user32&quot;)]public static extern int GetWindowText(int hwnd, StringBuilder lptrString, int nMaxCount);于是根据类名找到窗口的方法：public static IReadOnlyList&amp;lt;int&amp;gt; FindWindowByClassName(string className){ var windowList = new List&amp;lt;int&amp;gt;(); EnumWindows(OnWindowEnum, 0); return windowList; bool OnWindowEnum(int hwnd, int lparam) { var lpString = new StringBuilder(512); GetClassName(hwnd, lpString, lpString.Capacity); if (lpString.ToString().Equals(className, StringComparison.InvariantCultureIgnoreCase)) { windowList.Add(hwnd); } return true; }}使用此方法，我们可以传入 &quot;txguifoundation&quot; 找到 QQ/TIM 的窗口：var qqHwnd = FindWindowByClassName(&quot;txguifoundation&quot;);要获取窗口的标题，或者把标题作为过滤条件，则使用 GetWindowText。在 QQ/TIM 中，窗口的标题是聊天对方的名字或者群聊名称。var lptrString = new StringBuilder(512);GetWindowText(hwnd, lptrString, lptrString.Capacity);参考资料 EnumWindows function (winuser.h) - Microsoft Docs GetClassName function (winuser.h) - Microsoft Docs" }, { "title": "安装和运行 .NET Core 版本的 PowerShell", "url": "/post/install-and-run-powershell-core.html", "categories": "", "tags": "dotnet, powershell", "date": "2019-04-30 19:37:52 +0800", "snippet": "Windows 自带一个强大的 PowerShell，不过自带的 PowerShell 一直是基于 .NET Framework 的版本。你可以下载安装一个 .NET Core 版本的 PowerShell，以便获得 .NET Core 的各种好处。包括跨平台，以及更好的性能。本文将介绍在你的 Windows 系统上安装一个 .NET Core 版本的 PowerShell。下载和安装前往 .NET Core 版本 PowerShell 的发布页面来下载 PowerShell 全平台的安装包： Releases · PowerShell/PowerShellWindows 平台上建议下载 msi 格式的安装包，这样它可以帮助你完成大多数的安装任务。运行在安装完成之后启动新的 .NET Core 版本的 PowerShell 可以看见新的 PowerShell。在任何一个文件夹中右键可打开 PowerShell 或者以管理员权限打开 PowerShell。这与自带的 PowerShell 的玩法是类似的。在其他终端使用 PowerShell Core如果你要在其他的终端使用 PowerShell Core，直接输入 pwsh 即可。其原理可以参考我的另一篇博客： 让你的 Windows 应用程序在任意路径也能够直接通过文件名执行 - 吕毅" }, { "title": "XAML 很少人知道的科技", "url": "/post/those-people-dont-know-about-xaml.html", "categories": "", "tags": "dotnet, csharp, wpf, uwp", "date": "2019-04-30 19:08:20 +0800", "snippet": "本文介绍不那么常见的 XAML 相关的知识。Thickness 可以用空格分隔当你用设计器修改元素的 Margin 时，你会看到用逗号分隔的 Thickness 属性。使用设计器或者属性面板时，使用逗号是默认的行为。不过你有试过，使用空格分隔吗？&amp;lt;Button Margin=&quot;10 12 0 0&quot; /&amp;gt;使用逗号（,）设置多值枚举有一些枚举标记了 [Flags] 特性，这样的枚举可以通过位运算设置多个值。[Flags]enum NonClientFrameEdges{ // 省略枚举内的值。}那么在 XAML 里面如何设置多个枚举值呢？使用逗号（,）即可，如下面的例子：&amp;lt;WindowChrome NonClientFrameEdges=&quot;Left,Bottom,Right&quot; GlassFrameThickness=&quot;0 64 0 0&quot; UseAeroCaptionButtons=&quot;False&quot; /&amp;gt;使用加号（+）设置多值枚举使用逗号（,） 设置多值枚举是通用的写法，但是在 WPF/UWP 中设置按键/键盘快捷键的时候又有加号（+）的写法。如下面的例子：&amp;lt;KeyBinding Command=&quot;{x:Static WalterlvCommands.Foo}&quot; Modifiers=&quot;Control+Shift&quot; Key=&quot;W&quot; /&amp;gt;这里的 Modifiers 属性的类型是 ModifierKeys，实际上是因为这个类型特殊地编写了一个 TypeConverter 来转换字符串，所以键盘快捷键多值枚举使用的位或运算用的是加号（+）。设置 Url 型的 XAML 命名空间（xmlns）WPF/UWP 中原生控件的 XAML 命名空间是 http://schemas.microsoft.com/winfx/2006/xaml/presentation，与 XAML 编译器相关的 XAML 命名空间是 http://schemas.microsoft.com/winfx/2006/xaml，还有其他 Url 形式的 XAML 命名空间。只需要在库中写如下特性（Attribute）即可将命名空间指定为一个 url：using System.Windows.Markup;[assembly: XmlnsDefinition(&quot;http://walterlv.github.io/demo&quot;, &quot;Walterlv.NewCsprojDemo&quot;)]详情请阅读博客： 让你编写的控件库在 XAML 中有一个统一的漂亮的命名空间（xmlns）和命名空间前缀此写法要生效，定义的组件与使用的组件不能在同一程序集。设置默认的 XAML 命名空间前缀WPF/UWP XAML 编译器的命名空间前缀是 x。如果你写了自己的控件，希望给控件指定一个默认的命名空间前缀，那么可以通过在库中写如下特性（Attribute）实现：using System.Windows.Markup;[assembly: XmlnsPrefix(&quot;http://walterlv.github.io/demo&quot;, &quot;w&quot;)]这样，当 XAML 设计器帮助你自动添加命名空间时，将会使用 w 前缀。虽然实际上你也能随便改。详情请阅读博客： 让你编写的控件库在 XAML 中有一个统一的漂亮的命名空间（xmlns）和命名空间前缀此写法要生效，定义的组件与使用的组件不能在同一程序集。让你做的控件库不需要 XAML 命名空间前缀自己写了一个 DemoPage，要在 XAML 中使用，一般需要添加命名空间前缀才可以。但是也可以不写：&amp;lt;UserControl x:Class=&quot;HuyaHearhira.UserControl1&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;&amp;gt; &amp;lt;Grid&amp;gt; &amp;lt;DemoPage /&amp;gt; &amp;lt;/Grid&amp;gt;&amp;lt;/UserControl&amp;gt;方法是在库中定义命名空间前缀为 http://schemas.microsoft.com/winfx/2006/xaml/presentation。using System.Windows.Markup;[assembly: XmlnsDefinition(&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;, &quot;Walterlv.NewCsprojDemo&quot;)]此写法要生效，定义的组件与使用的组件不能在同一程序集。" }, { "title": "WPF 程序鼠标在窗口之外的时候，控件拿到的鼠标位置在哪里？", "url": "/post/wpf-mouse-position-when-mouse-is-out-of-window.html", "categories": "", "tags": "wpf, dotnet, csharp", "date": "2019-04-30 14:53:52 +0800", "snippet": "在 WPF 程序中，我们有 Mouse.GetPosition(IInputElement relativeTo) 方法可以拿到鼠标当前相对于某个 WPF 控件的位置，也可以通过在 MouseMove 事件中通过 e.GetPosition(IInputElement relativeTo) 方法拿到同样的信息。不过，在任意时刻去获取鼠标位置的时候，如果鼠标在窗口之外，将获取到什么点呢？本文将介绍鼠标在窗口之外时获取到的鼠标位置。可用于演示的 DEMO直接使用 Visual Studio 2019 创建一个空的 WPF 应用程序。默认 .NET Core 版本的 WPF 会带一个文本框和一个按钮。我们现在就用这两个按钮来显示 Mouse.GetPosition 获取到的值。using System;using System.Windows;using System.Windows.Input;using System.Windows.Media;namespace Walterlv.Demo{ public partial class MainWindow : Window { public MainWindow() { InitializeComponent(); CompositionTarget.Rendering += OnRendering; } private void OnRendering(object sender, EventArgs e) { DebugTextBlock.Text = Mouse.GetPosition(DebugTextBlock).ToString(); DebugButton.Content = Mouse.GetPosition(DebugButton).ToString(); } }}观察现象我们运行这个最简单的 Demo，然后不断移动鼠标，可以观察到一旦鼠标脱离窗口客户区，获取到的坐标点将完全固定。如果不知道客户区是什么，可以阅读下面我的另一篇博客： WPF 使用 WindowChrome，在自定义窗口标题栏的同时最大程度保留原生窗口样式（类似 UWP/Chrome）在以上图中，我拖动改变了窗口的位置，这时将鼠标移动至离开客户区后，获取到的坐标点又被固定为另一个数值。推断结论从上面的动图中以及我实际的测量发现，当鼠标移出窗口的客户区之后，获取鼠标的坐标的时候始终拿到的是屏幕的 (0, 0) 点。如果有多个屏幕，是所有屏幕组合起来的虚拟屏幕的 (0, 0) 点。验证这一点，我们把窗口移动到屏幕的左上角后，将鼠标移出客户区，左上角的控件其获取到的鼠标位置已经变成了 (0, 31)，而这个是窗口标题栏非客户区的高度。原理Mouse.GetPosition 获取鼠标相对于控件的坐标点的方法在内部的最终实现是 user32.dll 中的 ClientToScreen。[DllImport(&quot;user32.dll&quot;)]static extern bool ClientToScreen(IntPtr hWnd, ref Point lpPoint);此方法需要使用到一个窗口句柄参数，此参数的含义： A handle to the window whose client area is used for the conversion.用于转换坐标点的窗口句柄，坐标会被转换到窗口的客户区部分。 If the function succeeds, the return value is nonzero.If the function fails, the return value is zero.如果此方法成功，将返回非零的坐标值；如果失败，将返回 0。而鼠标在窗口客户区之外的时候，此方法将返回 0，并且经过后面的 ToPoint() 方法转换到控件的坐标下。于是这才得到了我们刚刚观察到的坐标值。[SecurityCritical, SecurityTreatAsSafe]public static Point ClientToScreen(Point pointClient, PresentationSource presentationSource){ // For now we only know how to use HwndSource. HwndSource inputSource = presentationSource as HwndSource; if(inputSource == null) { return pointClient; } HandleRef handleRef = new HandleRef(inputSource, inputSource.CriticalHandle); NativeMethods.POINT ptClient = FromPoint(pointClient); NativeMethods.POINT ptClientRTLAdjusted = AdjustForRightToLeft(ptClient, handleRef); UnsafeNativeMethods.ClientToScreen(handleRef, ptClientRTLAdjusted); return ToPoint(ptClientRTLAdjusted);}参考资料 How do I get the current mouse screen coordinates in WPF? - Stack Overflow pinvoke.net: clienttoscreen (user32) c# - ClientToScreen unexpected return values? - Stack Overflow ClientToScreen function (winuser.h) - Microsoft Docs" }, { "title": "如何修改 Visual Studio 新建项目时的默认路径", "url": "/post/change-visual-studio-default-project-location.html", "categories": "", "tags": "visualstudio", "date": "2019-04-30 10:29:19 +0800", "snippet": "Visual Studio 创建新项目的时候，默认位置在 C:\\Users\\lvyi\\source\\repos\\ 下。多数时候，我们都希望将其改为一个更适合自己开发习惯的路径。实际上修改默认路径并不是一个麻烦的事情，但是当紧急需要修改的时候，你可能找不到设置项在哪里。本文介绍如何修改这个默认路径。默认位置默认位置在 C:\\Users\\lvyi\\source\\repos\\ 下。Visual Studio 的设置项在 Visual Studio 中打开菜单 “工具” -&amp;gt; “选项”；然后找到 “项目和解决方案” -&amp;gt; “位置” 标签。“项目位置” 一栏就是设置新建项目默认路径的地方。如果是英文本，则打开菜单 “Tools” -&amp;gt; “Options”；然后找到 “Projects and Solutions” -&amp;gt; “Locations” 标签。“Projects location” 一栏就是设置新建项目默认路径的地方。修改后的默认位置修改完后，再次新建项目，就可以看到修改后的默认路径了。" }, { "title": "使用 dotnet 命令行配合 vscode 完成一个完整 .NET 解决方案的编写和调试", "url": "/post/develop-an-app-using-vscode-and-dotnet-cli.html", "categories": "", "tags": "dotnet, vscode, csharp", "date": "2019-04-29 11:09:50 +0800", "snippet": "如果你是开发个人项目，那就直接用 Visual Studio Community 版本吧，对个人免费，对小团体免费，不需要这么折腾。如果你是 Mac / Linux 用户，不想用 Visual Studio for Mac 版；或者不想用 Visual Studio for Windows 版那么重磅的 IDE 来开发简单的 .NET Core 程序；或者你就是想像我这么折腾，那我们就开始吧！安装必要的软件和插件 点击这里下载正式或者预览版的 .NET Core 然后安装 点击这里下载 Visual Studio Code 然后安装 在 Visual Studio Code 里安装 C# for Visual Studio Code 插件（步骤如下图所示）搜索的时候，推荐使用 OmniSharp 关键字，因为这可以得到唯一的结果，你不会弄混淆。如果你使用 C# 作为关键字，那需要小心，你得找到名字只有 C#，点开之后是 C# for Visual Studio Code 的那款插件。因为可能装错，所以我不推荐这么做。对于新版的 Visual Studio Code，装完会自动启用，所以你不用担心。我们可以后续步骤了。创建一个 .NET Core 控制台项目准备一个空的文件夹，这个文件夹将会成为我们解决方案所在的文件夹，也就是 sln 文件所在的文件夹。在这个空的文件夹中打开 VSCode，然后打开 VSCode 的终端。在 VSCode 中的终端中输入：&amp;gt; dotnet new console -o Walterlv.Demo这样会在当前的文件夹中创建一个 Walterlv.Demo 的子文件夹，并且在此文件夹中新建一个名为 Walterlv.Demo 的控制台项目。如果你观察我们刚刚创建的项目，你会发现里面有一个 csproj 文件和一个 Program.cs 文件。csproj 文件是 Sdk 风格的项目文件，而 Program.cs 里面包含最简单的 Hello World 代码：using System;namespace Walterlv.Demo{ class Program { static void Main(string[] args) { Console.WriteLine(&quot;Hello World!&quot;); } }}我们会考虑在一个子文件夹中创建项目，是因为我们会一步步创建一个比较复杂的解决方案，用以演示比较完整的使用 VSCode 开发 .NET 程序的过程。添加一个解决方案我们现在创建一个在 Visual Studio 会特别熟悉的解决方案，sln 文件。使用以下命令创建一个解决方案文件：&amp;gt; dotnet new sln现在，这个解决方案文件还是空的，不包含任何项目，于是我们把我们一开始创建的 Walterlv.Demo 项目加入到此 sln 文件中。使用以下命令添加：&amp;gt; dotnet sln add .\\Walterlv.Demo\\Walterlv.Demo.csproj于是，我们的解决方案中，就存在一个可以运行的控制台项目了。开始调试最简单的程序理论上，你按下 F5，选择 .NET Core 后就能自动生成调试所需的 launch.json 和 tasks.json 文件： 让你的 VSCode 具备调试 C# 语言 .NET Core 程序的能力如果不能生成所需的文件，你可以使用以下博客中的方法，手动添加这两个文件： 手工编辑 tasks.json 和 launch.json，让你的 VSCode 具备调试 .NET Core 程序的能力在经过以上两篇博客中的方法之后，你将可以跑起来你的程序。如果遇到了编译错误……呃这么简单的程序怎么可能遇到编译错误呢？一定是因为之前的操作有问题。可以考虑删除 bin 和 obj 文件夹，然后输入以下命令自行编译：&amp;gt; dotnet build这个命令会还原 NuGet 包，然后使用 .NET Core 版本的 MSBuild 编译你的解决方案。在此之后，你并不需要总是输入此命令，只需要像 Visual Studio 一样按下 F5 即可调试。引用项目现在我们演示如何引用项目。首先使用以下命令创建一个类库项目：&amp;gt; dotnet new classlib -o Walterlv.Library将其添加到 sln 中。&amp;gt; dotnet sln add .\\Walterlv.Library\\Walterlv.Library.csproj于是我们的目录结构现在是这样的（稍微改了一点代码）。然后让我们的 Walterlv.Demo 项目引用这个刚刚创建的项目：&amp;gt; dotnet add Walterlv.Demo reference .\\Walterlv.Library\\现在，我们即可在 Program.cs 中使用到刚刚 Class1.cs 中编写的方法（见上面截图中写的方法）。不过，当你写下 Class1 后，会没有此名称，但有快速操作提示可以自动添加命名空间（就像没有装 ReSharper 的 Visual Studio 的效果一样）。这时再按下 F5 运行，可以看到多输出了一个 walterlv is a 逗比 这样的提示，我们成功使用到了刚刚引用的类。引用 NuGet 包接下来介绍如何引用 NuGet 包。&amp;gt; dotnet add Walterlv.Demo package Newtonsoft.Json这样可以给 Walterlv.Demo 项目引用 Newtonsoft.Json 包。接下来就像前面一节我们所描述的那样使用这个包里面的类就好了。" }, { "title": "Visual Studio 通过修改项目的调试配置文件做到临时调试的时候不要编译（解决大项目编译缓慢问题）", "url": "/post/debug-project-without-building-via-launch-settings.html", "categories": "", "tags": "visualstudio, dotnet, csharp", "date": "2019-04-26 12:22:57 +0800", "snippet": ".NET 托管程序的编译速度比非托管程序要快非常多，即便是 .NET Core，只要不编译成 Native 程序，编译速度也是很快的。然而总是有一些逗比大项目编译速度非常缓慢（我指的是分钟级别的），而且还没做好差量编译；于是每一次编译都需要等待几十秒到数分钟。这显然是非常影响效率的。在解决完项目的编译速度问题之前，如何能够临时进行快速调试改错呢？本文将介绍在 Visual Studio 中不进行编译就调试的方法。我找到了两种临时调试而不用编译的方法： 在 Visual Studio 的设置界面设置启动前不编译 通过修改项目调试配置文件（本文）新建一个普通的类库项目，右击项目，属性，打开属性设置页面。进入“调试”标签：现在，将默认的启动从“项目”改为“可执行文件”，然后将我们本来调试时输出的程序路径贴上去。现在，如果你不希望编译大项目而直接进行调试，那么将启动项目改为这个小项目即可。" }, { "title": "Visual Studio 如何能够不进行编译就调试 .NET/C# 项目（用于解决大项目编译缓慢的问题）", "url": "/post/debug-without-building-for-visual-studio-project.html", "categories": "", "tags": "dotnet, csharp, visualstudio", "date": "2019-04-26 08:11:44 +0800", "snippet": ".NET 托管程序的编译速度比非托管程序要快非常多，即便是 .NET Core，只要不编译成 Native 程序，编译速度也是很快的。然而总是有一些逗比大项目编译速度非常缓慢（我指的是分钟级别的），而且还没做好差量编译；于是每一次编译都需要等待几十秒到数分钟。这显然是非常影响效率的。在解决完项目的编译速度问题之前，如何能够临时进行快速调试改错呢？本文将介绍在 Visual Studio 中不进行编译就调试的方法。我找到了两种临时调试而不用编译的方法： 在 Visual Studio 的设置界面设置启动前不编译（本文） 通过修改项目调试配置文件不编译直接调试有时候只是为了定位 Bug 不断重复运行以调试程序，并没有修改代码。然而如果 Visual Studio 的差量编译因为逗比项目失效的话，就需要手动告诉 Visual Studio 不需要进行编译，直接进行调试。在 Visual Studio 中设置编译选项进入 工具 -&amp;gt; 选项 -&amp;gt; 项目和解决方案 -&amp;gt; 生成并运行。“当项目过期时”，选择“从不生成”。顺便附中文版截图：这时，你再点击运行你的项目的时候，就不会再编译了，而是直接进入调试状态。这特别适合用来定位 Bug，因为这时基本不改什么代码，都是在尝试复现问题以及查看各种程序的中间状态。" }, { "title": "WPF 获取元素（Visual）相对于屏幕设备的缩放比例，可用于清晰显示图片", "url": "/post/get-wpf-visual-scaling-ratio-to-device.html", "categories": "", "tags": "dotnet, csharp, wpf", "date": "2019-04-25 17:24:19 +0800", "snippet": "我们知道，在 WPF 中的坐标单位不是屏幕像素单位，所以如果需要知道某个控件的像素尺寸，以便做一些与屏幕像素尺寸相关的操作，就需要经过一些计算（例如得到屏幕的 DPI）。更繁琐的是，我们的控件可能外面有一些其他的控件做了 RenderTransform 进行了一些缩放，于是了解到屏幕像素单位就更不容易了。本文将提供一套计算方法，帮助计算某个 WPF 控件相比于屏幕像素尺寸的缩放比例，用于进行屏幕像素级别的渲染控制。一个 WPF 控件会经历哪些缩放？如下图，我画了一个屏幕，屏幕里面有一个 WPF 窗口，WPF 窗口里面有一个或者多个 ViewBox 或者设置了 RenderTransform 这样的缩放的控件，一层层嵌套下有我们的最终控件。于是，我们的控件如何得知此时相比于屏幕像素的缩放比呢？换句话说，如何得知此时此控件的显示占了多少个屏幕像素的宽高呢？分别计算所有的缩放从上面的图中，我们可以得知，有两种不同种类的缩放： 屏幕到 WPF 窗口的缩放 WPF 窗口内部的缩放屏幕到 WPF 窗口的缩放我们知道 WPF 的单位叫做 DIP 设备无关单位。不过，我更希望引入 UWP 中的有效像素单位。实际上 WPF 和 UWP 的像素单位含义是一样的，只是 WPF 使用了一个画饼式的叫法，而 UWP 中的叫法就显得现实得多。你可以阅读我的另一篇博客了解到有效像素单位： 将 UWP 的有效像素（Effective Pixels）引入 WPF有效像素主要就是考虑了 DPI 缩放。于是实际上我们就是在计算 DPI 缩放。// visual 是我们准备找到缩放量的控件。var ct = PresentationSource.FromVisual(visual)?.CompositionTarget;var matrix = ct == null ? Matrix.Identity : ct.TransformToDevice;这里，我们使用的是 PresentationSource.FromVisual(visual)?.CompositionTarget 因为不同屏幕可能存在不同的 DPI。 支持 Windows 10 最新 PerMonitorV2 特性的 WPF 多屏高 DPI 应用开发WPF 窗口内部的缩放WPF 窗口内部的缩放，肯定不会是一层层自己去叠加。实际上 WPF 提供了方法 TransformToAncestor 可以计算一个两个具有父子关系的控件的相对变换量。于是我们需要找到 WPF 窗口中的根元素，可以通过不断查找可视化树的父级来找到根。// VisualRoot 方法用于查找 visual 当前的可视化树的根，如果 visual 已经显示，则根会是窗口中的根元素。var root = VisualRoot(visual);var transform = ((MatrixTransform)visual.TransformToAncestor(root)).Value;我封装的源码为了方便使用，我进行了一些封装。要获取某个 Visual 相比于屏幕的缩放量，则调用 GetScalingRatioToDevice 方法即可。代码已经上传至 gits：https://gist.github.com/walterlv/6015ea19c9338b9e45ca053b102cf456。using System;using System.Windows;using System.Windows.Media;namespace Walterlv{ public static class VisualScalingExtensions { /// &amp;lt;summary&amp;gt; /// 获取一个 &amp;lt;paramref name=&quot;visual&quot;/&amp;gt; 在显示设备上的尺寸相对于自身尺寸的缩放比。 /// &amp;lt;/summary&amp;gt; public static Size GetScalingRatioToDevice(this Visual visual) { return visual.GetTransformInfoToDevice().size; } /// &amp;lt;summary&amp;gt; /// 获取一个 &amp;lt;paramref name=&quot;visual&quot;/&amp;gt; 在显示设备上的尺寸相对于自身尺寸的缩放比和旋转角度（顺时针为正角度）。 /// &amp;lt;/summary&amp;gt; public static (Size size, double angle) GetTransformInfoToDevice(this Visual visual) { if (visual == null) throw new ArgumentNullException(nameof(visual)); // 计算此 Visual 在 WPF 窗口内部的缩放（含 ScaleTransform 等）。 var root = VisualRoot(visual); var transform = ((MatrixTransform)visual.TransformToAncestor(root)).Value; // 计算此 WPF 窗口相比于设备的外部缩放（含 DPI 缩放等）。 var ct = PresentationSource.FromVisual(visual)?.CompositionTarget; if (ct != null) { transform.Append(ct.TransformToDevice); } // 如果元素有旋转，则计算旋转分量。 var unitVector = new Vector(1, 0); var vector = transform.Transform(unitVector); var angle = Vector.AngleBetween(unitVector, vector); transform.Rotate(-angle); // 计算考虑了旋转的综合缩放比。 var rect = new Rect(new Size(1, 1)); rect.Transform(transform); return (rect.Size, angle); } /// &amp;lt;summary&amp;gt; /// 寻找一个 &amp;lt;see cref=&quot;Visual&quot;/&amp;gt; 连接着的视觉树的根。 /// 通常，如果这个 &amp;lt;see cref=&quot;Visual&quot;/&amp;gt; 显示在窗口中，则根为 &amp;lt;see cref=&quot;Window&quot;/&amp;gt;； /// 不过，如果此 &amp;lt;see cref=&quot;Visual&quot;/&amp;gt; 没有显示出来，则根为某一个包含它的 &amp;lt;see cref=&quot;Visual&quot;/&amp;gt;。 /// 如果此 &amp;lt;see cref=&quot;Visual&quot;/&amp;gt; 未连接到任何其它 &amp;lt;see cref=&quot;Visual&quot;/&amp;gt;，则根为它自身。 /// &amp;lt;/summary&amp;gt; private static Visual VisualRoot(Visual visual) { if (visual == null) throw new ArgumentNullException(nameof(visual)); var root = visual; var parent = VisualTreeHelper.GetParent(visual); while (parent != null) { if (parent is Visual r) { root = r; } parent = VisualTreeHelper.GetParent(parent); } return root; } }}" }, { "title": "MSBuild 中的特殊字符（$ @ % 等）：含义、用法以及转义", "url": "/post/msbuild-special-characters.html", "categories": "", "tags": "msbuild, visualstudio, dotnet", "date": "2019-04-24 20:48:21 +0800", "snippet": "在 MSBuild 中有一些特殊字符，如 $ @ % &#39; 等，本文介绍他们的含义，如何使用他们，以及你真的需要这些字符的时候如何编写他们。特殊字符MSBuild 中有这些特殊字符： $ @ % &#39; ; ? *含义和用法$引用一个属性或者环境变量。&amp;lt;Project&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;TargetFramework&amp;gt;netcoreapp3.0&amp;lt;/TargetFramework&amp;gt; &amp;lt;OutputPath&amp;gt;bin\\$(Configuration)&amp;lt;/OutputPath&amp;gt; &amp;lt;/ItemGroup&amp;gt;&amp;lt;/Project&amp;gt;比如以下两篇博客列出了一些最典型的使用场景。 如何更精准地设置 C# / .NET Core 项目的输出路径？（包括添加和删除各种前后缀） 在 csproj 文件中使用系统环境变量的值（示例将 dll 生成到 AppData 目录下）@引用一个集合。&amp;lt;Target Name=&quot;WalterlvDemoTarget&quot; BeforeTargets=&quot;CoreCompile&quot;&amp;gt; &amp;lt;Message Text=&quot;References:&quot; /&amp;gt; &amp;lt;Message Text=&quot;@(Reference)&quot; /&amp;gt;&amp;lt;/Target&amp;gt;比如以下两篇博客列出了一些最典型的使用场景： 在 Target 中获取项目引用的所有依赖（dll/NuGet/Project）的路径 在制作跨平台的 NuGet 工具包时，如何将工具（exe/dll）的所有依赖一并放入包中%引用集合中某一个项的某个属性。&amp;lt;Target Name=&quot;Xxx&quot; AfterTargets=&quot;AfterBuild&quot;&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;Walterlv Include=&quot;@(Compile)=%(Compile.CopyToOutputDirectory)&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;Warning Text=&quot;@(Walterlv)&quot; /&amp;gt;&amp;lt;/Target&amp;gt;比如下面两篇博客列出了此字符的一些使用： 在项目文件 csproj 中或者 MSBuild 的 Target 中使用 % 引用集合中每一项的属性&#39;在形成一个字符串的时候，会使用到此字符。下面这篇博客列出了此字符的一些使用： MSBuild 如何编写带条件的属性、集合和任务 Condition？;如果存在分号，那么在形成一个集合的时候，会被识别为集合中的各个项之间的分隔符。有时候你真的需要分号而不是作为分隔符的时候，需要进行转义： Roslyn how to use WriteLinesToFile to write the semicolons to file - 林德熙? 和 *作为通配符使用。一个 * 表示文件或者文件夹通配符，而 ** 则表示任意层级的文件或文件夹。下面这篇博客虽然古老，却也说明了其用法： 为 Visual Studio 使用通配符批量添加项目文件转义在 MSBuild 中，由于这些特殊字符其实非常常见，所以与一些已有的值很容易冲突，所以需要转义。转义可以使用 ASCII 编码： $ - %24 @ - %40 % - %25 &#39; - %27 ; - %3B ? - %3F * - %2A转义方法一：&amp;lt;Compile Include=&quot;Walterlv1%3BWalterlv2.cs&quot;/&amp;gt;这样得到的将是一个名字为 Walterlv1;Walterlv2.cs 的文件，而不是两个文件。转义方法二：&amp;lt;Compile Include=&quot;$([MSBuild]::Escape(&#39;Walterlv1;Walterlv2.cs&#39;))&quot; /&amp;gt;详细方法可参见： Roslyn how to use WriteLinesToFile to write the semicolons to file - 林德熙参考资料 MSBuild Special Characters - Visual Studio - Microsoft Docs How to: Escape Special Characters in MSBuild - Visual Studio - Microsoft Docs" }, { "title": "在项目文件 csproj 中或者 MSBuild 的 Target 中使用 % 引用集合中每一项的属性", "url": "/post/msbuild-referencing-metadata.html", "categories": "", "tags": "msbuild, visualstudio, dotnet", "date": "2019-04-24 20:35:25 +0800", "snippet": "在编写项目文件或者 MSBuild Target 文件的时候，我们经常会使用 &amp;lt;Foo Include=&quot;Identity&quot; /&amp;gt; 来定义集合中的一项。在定义的同时，我们也会额外指定一些属性。然而这些属性如何拿到并且使用呢？本文将介绍使用方法。将下面的代码放到你项目文件的末尾，最后一个 &amp;lt;/Project&amp;gt; 的前面，可以在编译的时候看到两个新的警告。&amp;lt;Target Name=&quot;Xxx&quot; AfterTargets=&quot;AfterBuild&quot;&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;WalterlvX Include=&quot;@(Compile)&quot; /&amp;gt; &amp;lt;WalterlvY Include=&quot;%(Compile.FileName)&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;Warning Text=&quot;@(WalterlvX)&quot; /&amp;gt; &amp;lt;Warning Text=&quot;@(WalterlvY)&quot; /&amp;gt;&amp;lt;/Target&amp;gt;在定义 WalterlvX 集合的时候，我们使用了 @(Compile) 来获取所有需要编译的文件。在定义 WalterlvY 集合的时候，我们使用了 %(Compile.FileName) 来获取编译文件的文件名。于是，你在警告信息中看到的两个警告信息里面，一个输出了 Compile 集合中每一项的标识符（通常是相对于项目文件的路径），另一个输出了每一个 Compile 项中的 FileName 属性。FileName 属性是 Compile 会被 Microsoft.NET.Sdk 自动填充。需要注意，如果 % 得到的项中某个属性为空，那么这一项在最终形成的新集合中是不存在的。所以，如果存在可能不存在的属性，那么建议先进行拼接再统一处理拼接后的值：&amp;lt;Target Name=&quot;Xxx&quot; AfterTargets=&quot;AfterBuild&quot;&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;Walterlv Include=&quot;@(Compile)=%(Compile.CopyToOutputDirectory)&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;Warning Text=&quot;@(Walterlv)&quot; /&amp;gt;&amp;lt;/Target&amp;gt;这里的 CopyToOutputDirectory 不是一个总是会设置的属性。" }, { "title": "使用 7-Zip 的命令行版本来压缩和解压文件", "url": "/post/command-line-usages-of-7z.html", "categories": "", "tags": "windows, dotnet", "date": "2019-04-24 09:55:21 +0800", "snippet": "7-Zip 也有一个简短的名称 7z。它的原生 UI 确实不怎么好看，非常有年代感；不过 7-Zip 的强大之处不在于 UI，而在于其算法和各种文件的支持情况。不过，7-Zip 提供了命令行的版本，让你摒除一切杂念，专心处理压缩文件的工作。本文介绍如何通过命令行来使用 7-Zip。因为使用命令行，所以你甚至可以自动化地完成压缩文件的各种处理。如何找到 7-Zip 的命令行版本请前往官方网站下载 7-Zip： 7-Zip - Download下载安装完去其安装目录下可以找到 7-Zip 的命令行版本：这些文件作用分别是： 7zFM.exe 7-Zip 文件管理器的主 UI，直接从开始菜单打开 7-Zip 时的 UI 界面。依赖 7z.dll 7zG.exe 7-Zip 的 GUI 模块，需要通过命令行指定参数调用。依赖 7z.dll 7-zip.dll 与 Windows Shell 以及 7zFM.exe 集成。 7z.exe 7-Zip 的命令行版本，需要通过命令行指定参数调用。 7z.dll 7-Zip 的核心执行引擎。 7z.sfx SFX 模块（Windows 版本）。 7zCon.sfx SFX 模块（控制台版本）。 7-zip.chm 7-Zip 的帮助说明文件。命令行版本的 7z.exe 不依赖与其他 dll，所以我们将 7z.exe 文件拷出来即可使用完整的命令行版本的 7z。使用命令行操作 7z.exe如果你希望使用 .NET/C# 代码来自动化地调用 7z.exe，可以参考我的另一篇博客： 编写 .NET/C# 代码来操作命令行程序 - 吕毅本文直接介绍 7z.exe 的命令行使用，你可以将其无缝地迁移至上面这篇博客中编写的 .NET/C# 代码中。解压一个文件&amp;gt; 7z x {fileName} -o{outputDirectory}以上： x 表示解压一个文件 {fileName} 是文件名称或者文件路径的占位符 {outputDirectory} 是解压后文件夹的占位符，必须是一个不存在的文件夹。 -o 表示指定输出路径特别注意：-o 和 {outputDirectory} 之间是 没有空格 的。一个例子：&amp;gt; 7z x C:\\Users\\walterlv\\demo.7z -oC:\\Users\\walterlv\\demo7z 的强大之处还有一点就是可以解压各种文件——包括解压安装包：&amp;gt; 7z x C:\\Users\\walterlv\\nsis_installer_1.0.0.0.exe -oC:\\Users\\walterlv\\nsis这也是为什么我们考虑使用 7z 来解压缩，而不是使用相关的 NuGet 包来调用。其他命令行操作运行 7z.exe 后可以看到命令行中列出了可用的命令行命令：a：将文件添加到压缩档案中b：测试压缩或解压算法执行时的 CPU 占用d：从压缩档案中删除文件e：将压缩档案中的所有文件解压到指定路径，所有文件将输出到同一个目录中h：计算文件的哈希值i：显示有关支持格式的信息l：列出压缩档案的内容rn：重命名压缩档案中的文件t：测试压缩档案的完整性u：更新要进入压缩档案中的文件x：将压缩档案中的所有文件解压到指定路径，并包含所有文件的完整路径下面列出几个常用的命令。a 添加文件如果你需要压缩文件，或者将文件添加到现有的压缩档案中，则使用此命令。将 subdir\\ 文件夹中的所有文件加入到 walterlv.zip 文件中，所有的子文件和文件夹将会在压缩档案的 subdir 文件夹中：7z a walterlv.zip subdir\\将 subdir\\ 文件夹中的所有文件加入到 walterlv.zip 文件中，所有的子文件和文件夹路径不会包含 subdir 前缀：7z a walterlv.zip .\\subdir\\*d 删除文件删除压缩档案 walterlv.zip 中的所有扩展名为 bak 的文件：7z d walterlv.zip *.bak -re 解压文件相比于 x，此命令会将压缩档案中的所有文件输出到同一个目录中。" }, { "title": "ClearType 的原理：Windows 上文本的亚像素控制", "url": "/post/the-subpixel-rendering-of-text.html", "categories": "", "tags": "windows", "date": "2019-04-23 19:17:48 +0800", "snippet": "有位小伙伴问我为什么他电脑上的文本看起来比较虚。我去看了下，发现他电脑上关掉了 ClearType。微软的 ClearType 技术通过控制亚像素来使得文本显示更为清晰。本文代理了解 Windows 系统上的文本是如何通过亚像素控制使得显示更为清晰的。ClearType 打开和关闭之后的效果看下图！同样的文本，在不同大小下以及开关 ClearType 下的显示效果：你应该能注意到，第 0x00 行，第 0x02 行是比较模糊的，第 0x01 行和第 0x03 行会更清晰一些。如果你看不出来我说的效果，那么你需要调整你看图的姿势： 请确保以 100% 比例显示此图片，正在在电脑上看我博客的时候，就会以 100% 比例显示； 如果你看博客的显示器 DPI 不是 100%，那么也看不出效果，建议在一个 100% DPI 的显示器设备上看。如果依然看不出来，至少你能感受到第 0x01 行和第 0x03 行的文本会更亮一些。现在，我们将图片放大。就像下面这张图片一样，左边一半是没有启用 ClearType 的文本，右边是启用了 ClearType 的文本。我将他们放到了一张图片上以便更容易比较效果。可以注意到，没有开启 ClearType 的文本，其发虚的边框周围是灰色；而开启了 ClearType 的文本，其发虚的边框周围是彩色。如何显示清晰的线条像素内的 RGB在开始显示线条之前，我们来看看显示器如何显示一个像素。下图是我放大的一个像素内的灯管。这是一种主流显示器上像素内的 RGB 排列。这三个灯管同时以规定的最大值亮起，我们将看到白色。当然，我放大这么大你是看不出来白色的，需要足够小才行。现在，我们缩小一点，观察 4×4 个像素：清晰显示 1px 线条我在另一篇博客中说过如何清晰显示一个线条： WPF 绘制对齐像素的清晰显示的线条要清晰显示 1 像素宽度的竖线，我们需要对齐像素显示，即在整数像素上显示这根线条。于是，我们需要点亮这一列像素中的所有 RGB：嗯，最终看起来会像这样：清晰显示 1.3 px 线条那么接下来，如何清晰显示 1.33 像素宽度的竖线呢？传统方法是借用旁边像素，点亮旁边像素 33% 的亮度，于是线条大概是这样的：对应到灯管，大概是这样：但是，这样显示 1.33 像素使用了 2 个像素的宽度，用了 6 个灯管。然而如果亮起的灯管是这样的：因为现在依然是 RGB 三个灯管紧挨着一起量的，所以人类依然会看出白色来。由于此时灯管亮起的依然是硬边缘，所以依然清晰。要控制这样亮起灯管，我们需要在左边像素显示白色，右边像素显示红色。在这个线条中，右边的线条因为是红色，所以只会亮起红色灯管，而这是最靠近左边像素的灯管。清晰显示 1.7 px 线条同样的，如果要清晰显示 1.67 像素宽度的竖线，我们需要使用 5 列灯管：这时，我们不止借用了右边像素显示红色，还借用了左边像素显示蓝色：当然，也可以是在右边借用一个黄色的像素，也就是亮起 RG 两列灯管。借用哪一边取决于需要从像素的哪个位置开始显示。文本的亚像素控制由于文本的显示不像简单图形显示可以随意选取起点，文本因为图形非常复杂，为了保持文本形状不至于变形太多，任何位置开始显示一个像素的起点都是可能的，所以文本需要更多地选择借用左右像素的相邻灯管。在这张图中，果字最中间的竖线，借用了左侧像素的蓝色灯管，借用了右侧像素的红色和绿色灯管。横线的最右边，借用了右侧像素的红色灯管。其他像素以此类推。ClearType实际上，本文使用的显示器是 RGB 排列的，其他显示器还有更多像素排列方式，Windows 系统会自动根据像素排列方式选择合适的 ClearType 借用临近灯管的方式。不过，识别错也是常态，你需要在 Windows 10 搜索框中输入 ClearType 打开 ClearType 的设置界面，选择最清晰的显示文字来调整这样的错误识别。" }, { "title": "C#/.NET 使用 git 命令行来操作 git 仓库", "url": "/post/run-commands-using-csharp.html", "categories": "", "tags": "dotnet, csharp, git", "date": "2019-04-21 20:36:42 +0800", "snippet": "我们可以在命令行中操作 git，但是作为一名程序员，如果在大量重复的时候还手动敲命令行，那就太笨了。本文介绍使用 C# 编写一个 .NET 程序来自动化地使用 git 命令行来操作 git 仓库。这是一篇很基础的入门文章。最简单的运行 git 命令的代码在 .NET 中，运行一个命令只需要使用 Process.Start 开启一个子进程就好了。于是要运行一个 git 命令，我们其实只需要这句足以：Process.Start(&quot;git&quot;, &quot;status&quot;);当然，直接能简写成 git 是因为 git.exe 在我的环境变量里面，一般开发者在安装 Git 客户端的时候，都会自动将此命令加入到环境变量。如果没有，你需要使用完整路径 C:\\Program Files\\Git\\mingw64\\bin\\git.exe 只是每个人的路径可能不同，所以这是不靠谱的。允许获得命令的输出对于上节中写的 Process.Start，你一眼就能看出来这是完全没有用的代码。因为 git status 命令只是获得仓库当前的状态，这个命令完全不影响仓库，只是为了看状态的。所以，命令最好要能够获得输出。而要获得输出，你需要使用 ProcessStartInfo 来指定如何启动一个进程。var info = new ProcessStartInfo(ExecutablePath, arguments){ CreateNoWindow = true, RedirectStandardOutput = true, UseShellExecute = false, WorkingDirectory = WorkingDirectory,};需要设置至少这四个属性： CreateNoWindow 表示不要为这个命令单独创建一个控制台窗口 实际上如果使用此代码的程序也是一个控制台程序，这句是没有必要的，因为子进程会共用父进程的控制台窗口；但是对于 GUI 程序来说，这句还是很重要的，这可以避免在执行命令的过程中意外弹出一个黑色的控制台窗口出来。 RedirectStandardOutput 进行输出的重定向 这是一定要设置为 true 的属性，因为我们希望拿到命令的输出结果。 WorkingDirectory 设置工作路径 本来这是一个可选设置，不过对于 git 命令来说，一般都是对一个已有的 git 仓库进行操作，所以当然要指定一个合理的 git 仓库了。 UseShellExecute 设置为 false 表示不要使用 ShellExecute 函数创建进程 此属性的详细说明，请阅读我的另一篇博客：ProcessStartInfo 中的 UseShellExecute - 吕毅。 这里我们必须指定为 false，因为要重定向输出的话，这是唯一有效值。顺便一提，此属性如果不设置，默认值是 true。 CommandRunner为了方便起见，我将全部运行一个命令的代码封装到了一个 CommandRunner 的类当中。using System;using System.Diagnostics;using System.IO;namespace Walterlv.GitDemo{ public class CommandRunner { public string ExecutablePath { get; } public string WorkingDirectory { get; } public CommandRunner(string executablePath, string? workingDirectory = null) { ExecutablePath = executablePath ?? throw new ArgumentNullException(nameof(executablePath)); WorkingDirectory = workingDirectory ?? Path.GetDirectoryName(executablePath); } public string Run(string arguments) { var info = new ProcessStartInfo(ExecutablePath, arguments) { CreateNoWindow = true, RedirectStandardOutput = true, UseShellExecute = false, WorkingDirectory = WorkingDirectory, }; var process = new Process { StartInfo = info, }; process.Start(); return process.StandardOutput.ReadToEnd(); } }}测试与结果以上 CommandRunner 命令的使用非常简单，new 出来之后，得到一个可以用来执行命令的实例，然后每次执行调用 Run 方法传入参数即可。var git = new CommandRunner(&quot;git&quot;, @&quot;D:\\Developments\\Blogs\\walterlv.github.io&quot;);git.Run(&quot;add .&quot;);git.Run(@&quot;commit -m &quot;&quot;这是自动提交的&quot;&quot;&quot;);如果需要获得命令的执行结果，直接使用 Run 方法的返回值即可。比如下面我贴了 Main 函数的完整代码，可以输出我仓库的当前状态：using System;namespace Walterlv.GitDemo{ class Program { static void Main(string[] args) { Console.WriteLine(&quot;walterlv 的自动 git 命令&quot;); var git = new CommandRunner(&quot;git&quot;, @&quot;D:\\Developments\\Blogs\\walterlv.github.io&quot;); var status = git.Run(&quot;status&quot;); Console.WriteLine(status); Console.WriteLine(&quot;按 Enter 退出程序……&quot;); Console.ReadLine(); } }}" }, { "title": "如何快速自定义 Visual Studio 中部分功能的快捷键", "url": "/post/customizing-keyboard-shortcuts-in-visual-studio.html", "categories": "", "tags": "visualstudio", "date": "2019-04-21 20:06:45 +0800", "snippet": "Visual Studio 中有些自带的快捷键与现有软件有冲突，那么如何修改这些快捷键让这些功能正常工作起来呢？打开快捷键设置界面在 Visual Studio 中打开 “工具 -&amp;gt; 选项”，打开选项设置界面。在其中找到 “环境 -&amp;gt; 键盘” 项。我们设置快捷键的地方就在这里。修改一个现有功能的快捷键默认情况下，在 Visual Studio 2019 中快速重构的快捷键是 Ctrl+.。然而，使用中文输入法的各位应该非常清楚，Ctrl+. 是输入法切换中英文符号的快捷键。于是，当使用中文输入法的时候，实际上是无法通过按下 Ctrl+. 来完成快速重构的。我们需要修改快捷键来避免这样的冲突。在“新快捷键”那个框框中，按下 Ctrl+.，正常会在“快捷键的当前使用对象”框中出现此快捷键的功能。不过，如果快捷键已经与输入法冲突，则不会出现，你需要先切换至英文输入法以避免此冲突。通过“快捷键的当前使用对象”下拉框，我们可以得知功能的名称，下拉框中的每一项都是此快捷键的功能。我们需要做的是，搜索这些功能，并为这些功能分配新的快捷键。每一个我们关心的功能都这么设置：于是新快捷键就设置好了。现在，可以使用新的快捷键来操作这些功能了。参考资料 Identify and customize keyboard shortcuts - Visual Studio - Microsoft Docs" }, { "title": "如何在 MSBuild 的项目文件 csproj 中获取绝对路径", "url": "/post/get-absolute-path-in-msbuild-targets.html", "categories": "", "tags": "msbuild", "date": "2019-04-16 18:16:07 +0800", "snippet": "通常我们能够在 csproj 文件中仅仅使用相对路径就完成大多数的编译任务。但是有些外部命令的执行需要用到绝对路径，或者对此外部工具来说，相对路径具有不同的含义。这个时候，就需要将相对路径在 csproj 中转换为绝对路径来使用。本文介绍如何在项目文件 csproj 中将一个相对路径转换为绝对路径。在 MSBuild 4.0 中，可以在 csproj 中编写调用 PowerShell 脚本的代码，于是获取一个路径的绝对路径就非常简单：[System.IO.Path]::GetFullPath(&#39;$(WalterlvRelativePath)&#39;)具体到 csproj 的代码中，是这样的：&amp;lt;Project&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;WalterlvRelativePath&amp;gt;$(OutputPath)&amp;lt;/WalterlvRelativePath&amp;gt; &amp;lt;_WalterlvAbsolutePath&amp;gt;$([System.IO.Path]::GetFullPath($(WalterlvRelativePath)))&amp;lt;/_WalterlvAbsolutePath&amp;gt; &amp;lt;/PropertyGroup&amp;gt;&amp;lt;/Project&amp;gt;这样，就可以使用 $(_WalterlvAbsolutePath) 属性来获取绝对路径。你可以阅读我的其他篇博客了解到 $(OutputPath) 其实最终都会是相对路径： 项目文件中的已知属性（知道了这些，就不会随便在 csproj 中写死常量啦） - walterlv 如何更精准地设置 C# / .NET Core 项目的输出路径？（包括添加和删除各种前后缀） - walterlv参考资料 How can I get MSBUILD to evaluate and print the full path when given a relative path? - Stack Overflow Demonstrates how you can convert a relative path to an absolute path in MSBuild" }, { "title": "MSBuild 如何编写带条件的属性、集合和任务 Condition？", "url": "/post/how-to-write-msbuild-conditions.html", "categories": "", "tags": "msbuild", "date": "2019-04-16 17:27:46 +0800", "snippet": "在项目文件 csproj 中，通过编写带条件的属性（PropertyGroup）、集合（ItemGroup）和任务（Target）可以完成更加复杂的项目文件的功能。本文介绍如何编写带条件的 MSBuild 项。Condition如果要给你的 MSBuild 项附加条件，那么加上 Condition 特性即可。Condition 可以写在任何地方，例如 PropertyGroup、ItemGroup、Target 或者内部的一个属性或一个项或者一个任务等。下面这段代码表示在 Debug 配置下计算一个属性的值，而这个逗比属性 DoubiNames 的属性仅在此属性从未被指定过值的时候赋一个值 吕毅。&amp;lt;Project&amp;gt; &amp;lt;PropertyGroup Condition=&quot; &#39;$(Configuration)&#39; == &#39;Debug&#39; &quot;&amp;gt; &amp;lt;DoubiNames Condition=&quot; &#39;$(DoubiNames)&#39; == &#39;&#39; &quot;&amp;gt;吕毅&amp;lt;/DoubiNames&amp;gt; &amp;lt;/PropertyGroup&amp;gt;&amp;lt;/Project&amp;gt;在单引号的前后，等号这些运算符的前后空格可加可不加，没有影响。单引号在上面的例子中，我们给条件中的所有字符串加上了包裹的单引号。单引号对于简单的字母数字字符串是不必要的，对于布尔值来说也是不必要的。但是，对于空值来说，是必须加上的，即 &#39;&#39;。== 和 !=== 符号左右两侧的字符串如果相等，则返回 true，否则返回 false。!= 符号左右两侧的字符串如果相等，则返回 false，否则返回 true。Condition=&quot; $(Configuration) == &#39;Debug&#39; &quot;&amp;lt;, &amp;gt;, &amp;lt;=, &amp;gt;=用于比较数值上的大小关系。当然，在项目文件中，用于表示数值的字符串在此操作符下表示的就是数值。 左右两侧比较的字符串必须是表示数值的字符串，例如 123 或者 0x7b； 只能是十进制或者十六进制字符串，而十六进制字符串必须以 0x 开头； 由于此比较是写在 XML 文件中的，所以必须转义，即 &amp;lt; 需要写成 &amp;amp;lt;，&amp;gt; 需要写成 &amp;amp;gt;。Exists, HasTrailingSlashExists 判断文件或者文件夹是否存在。存在则返回 true，否则返回 false。Condition=&quot; Exists(&#39;Foo\\walterlv.config&#39;) &quot;Condition=&quot; Exists(&#39;Foo\\WalterlvFolder&#39;) &quot;Condition=&quot; Exists(&#39;$(WalterlvFile)&#39;) &quot;HasTrailingSlash 如果字符串的尾部包含 / 或者 \\ 字符串，则返回 true，否则返回 false。Condition=&quot;!HasTrailingSlash($(OutputPath))&quot;与或非：And, Or, !就是计算机中常见的与或非的机制。&amp;lt;DoubiNames Condition=&quot; &#39;$(DoubiNames)&#39; == &#39;吕毅&#39; Or &#39;$(DoubiNames)&#39; == &#39;林德熙&#39; &quot;&amp;gt;组队逗比&amp;lt;/DoubiNames&amp;gt;组合：()就是计算机中通常用于修改运算优先级的括号，这可以先计算括号内的布尔结果。if 条件：$if$Condition=&quot; $if$ ( %expression% ), $else$, $endif$ &quot;参考资料 MSBuild Conditions - Visual Studio - Microsoft Docs Visual Studio Project/Item Template Parameter Logic - Stack Overflow" }, { "title": "NullReferenceException，就不应该存在！", "url": "/post/wipe-out-null-reference-exception.html", "categories": "", "tags": "csharp, dotnet", "date": "2019-04-16 10:47:57 +0800", "snippet": "如果要你说出 .NET 中的三个异常，NullReferenceException 一定会成为其中一个；如果说出 .NET 中的一个异常，NullReferenceException 也会被大多数人说出来。它让这么多人印象深刻，是因为它在项目中实在是太常见了，常见到每一个 C#/.NET 入门者必然会遇到。然而，这个异常本不应该存在！null The worst mistake of computer science - Lucidchart 计算机科学中的最严重错误，造成十亿美元损失 - 文章 - 伯乐在线NullReferenceException 的可恨之处你说 NullReferenceException 可以告诉你程序中某个字段为 null，告诉你程序发生了 BUG。可是这是真的吗？说真的一定是因为用 Visual Studio 调试了，Visual Studio 告诉了我们异常发生在哪一句，哪个字段为 null。然而从真实用户或其他日志那里收集回来的数据是没有也不可能有这些信息的。这是因为 NullReferenceException 异常除了调用栈（StackTrace）之外不能提供其他额外的异常信息，连变量或字段名都不能提供。于是，当从异常日志准备分析异常原因的时候，只能猜，猜到底为 null 的是谁！另外，NullReferenceException 异常发生的地方一定不是真正出错的地方！因为我们尝试去调用某个属性或方法时假设了它不为 null，这意味着它为 null 就是个错误。但是，从异常的调用栈中我们却找不到任何痕迹能够告诉我们是哪里给它设置成了 null（或者是从未赋值过）。现在，又只能猜，猜到底是什么时候通过什么方式将字段设为了 null！举个例子：public class Walterlv{ private string _value; public void SetValue(string value) { _value = value; } public void DoSomething() { Console.WriteLine(_value.Length); }}SetValue 可以在任何时候被任何方法调用，指不定某个时候 _value 就被设为 null 了。那么 DoSomething 被调用的时候，直接就会抛出 NullReferenceException。这个方法比较简单，我们猜 _value 为 null 基本不会有问题了，方法复杂一点儿就难猜了。然而真正让 _value 为 null 的罪魁祸首就找不到了，因为它发生在 SetValue 中。总结起来，可恨之处有亮点： 不能知道为 null 的是哪个变量、字段或属性； 不能知道为什么为 null。而这两点直接与异常机制相悖。异常就是要提供足够我们诊断错误的信息，让我们在开发中避免发生这样的错误。NullReferenceException 的替代方案既然 NullReferenceException 没能给我们提供足够的信息，那么我们就自己来提供这些信息。ArgumentNullException 就是一个不错的替代异常，说它好因为有两点： 在错误发生的最开始就报告了错误，避免错误的蔓延。 因为 SetValue 中发生了异常后，获取到的调用栈是导致 _value 为 null 的调用栈。 告知了为 null 的参数名称。靠以上两点，当发生异常时，我们能唯一确定 _value 为 null 的原因，而这才是本质错误。可是，如果并不是参数问题导致了 null，那我们还能用什么异常呢？InvalidOperationException 是个不错的方案，它的默认异常提示语是“对象当前的状态使得该操作无效”。当程序此时此刻的状态让我们获取不到某个数据致使数据为 null 时，可以写一个新的提示语告知此时到底是什么样的状态错误才使得获取到的数据为 null。当然，这比 ArgumentNullException 的信息准确性还是差了点儿。当然，还有一个替代方案，就是在 Console.WriteLine(_value.Length); 之前先对 _value 进行 null 判断。可是，你能说出 _value 为 null 代表什么意义吗？为什么为 null 时不应该输出？如果这个问题回答不上来，那么你的这个 null 判断为你的程序埋藏了一个更深的 BUG——当用户反馈软件行为不正常时，你甚至连异常信息都没收集到！硕大一个程序，你甚至都无法定位到底是哪个模块发生了错误！！！对待 null，建议的约定当了解了 NullReferenceException 的缺陷，再了解了其替代方案后，其实我们会发现一个问题： 其实多数时候根本就不应该存在 nullnull 带来了两个困惑： 意义不明确。相比于异常，null 并不能告知我们到底发生了什么。 使用方不知道究竟应不应该判空，也难以理清楚判空究竟意味着什么。所以，为了解决这些困惑，我建议在开发中以如下方式对待我们的 null： 对任何可被外部模块调用的方法的参数进行 null 判断，并在参数为 null 时抛出 ArgumentNullException。 不要在方法中返回 null。如果你无法根据现有状态完成方法承诺的任务，请抛出具体的异常并给出真实的原因。 如果确实要用 null 在程序中代表某种状态，请确定这能够代表某种唯一确定的状态，并强制要求使用方判空。其中，对于第 2 点，不用担心异常导致雪崩，因为 try-catch-finally 就是用来恢复错误防止雪崩的，在需要防止雪崩的地方恢复错误即可。但要注意异常依然需要报告，可由程序统一处理这些未经处理的异常。对于第 3 点，JetBrains 为我们提供了 JetBrains.Annotations，这是一组 100+ 个的 Attribute，以 NuGet 包的形式提供。强烈建议在 null 代表了某种特殊意义的地方标记 [CanBeNull]；这样，ReSharper 插件将提醒我们这些地方必须要进行判空。C# 8.0 极有可能为我们带来“可空引用类型”或者“非空引用类型”；如果真的带来了，这将比 JetBrains.Annotations 拥有更大的强制性，帮助我们避免出现意外的 null 引用，帮助我们在可能为 null 的地方强制判空。再次重申：我们使用 null 一定是因为它代表了某种确定的特殊含义，而不是代表了一堆不明所以的错误！" }, { "title": "C# 跨设备前后端开发探索", "url": "/post/april-event-everything-can-be-done-using-csharp.html", "categories": "", "tags": "csharp, dotnet, wpf, uwp, xamarin, web", "date": "2019-04-16 08:54:48 +0800", "snippet": "每个人都拥有 好奇心，好奇心驱使着我们总是去尝试做一些有趣的事情。带起你的好奇心，本文将使用 C# 开发各种各样好玩的东西。本文内容已加入 2019 年 4 月 13 日的广州 .NET 俱乐部第 2 届线下沙龙。0x00 序章好奇心每个人都拥有 好奇心，好奇心驱使着我们总是去尝试做一些有趣的事情。比如这件事：在好奇心的驱使下，我们立刻 尝试 我们的想法。我们需要用电脑打字，手机端出字；于是我们需要开发的是一款云输入法。而一个最简单的云驱动的软件需要至少一个 Web 后端、一个桌面端和一个移动端。还没开始呢，就这么复杂。先搞起来摆在我们面前的，有两条路可以选： 如果先搞起来，那么我们能够迅速出效果，出产品，出玩具，那么这种成就感会鼓励我们继续完善我们的代码，继续去做更多好玩的东西。而如果是先掌握所有理论知识再实践，这是我们从学校带来的学习方式，我们中的多数人在校期间就是这么学习的。虽然对学霸来说可以无视，但对于我们这样大多数的小伙伴来说，简直就是“从入门到放弃”。如果先搞起来呢？如果我们连“入门”都不需要呢？是不是就不需要放弃了！怎么才能够先搞起来？我们需要调整一下心态——我们不是在学，而是在玩！我们需要做的是降低学习成本，甚至入门不学习，那么立刻就能玩起来！我们有 C#，还有什么不能马上搞起来！0x01 C# 跨设备前后端开发打开 Visual Studio 2019，我们先搞起来！Web 后端对于简单的云服务来说，使用 Asp.NET Core 开发是非常简单快速的。你可以阅读林德熙的博客入门 Asp.NET Core 开发： win10 uwp 手把手教你使用 asp dotnet core 做 cs 程序 - 林德熙Windows 桌面端我们是要玩的呀，什么东西好玩。我们自己就是用户，用户看得到的部分才是最具有可玩性的。这就是指客户端或者 Web 前端。我们现在要拿 C# 写客户端，一般 C# 或者 .NET 的开发者拿什么来写桌面客户端呢？ WPF 或者 Windows Forms 应用程序公共代码我们现在已经有至少两个端了。由于我们是同一个软件系统，所以实际上非常容易出现公共代码。典型的就是一些数据模型的定义，以及 Web API 的访问代码，还有一些业务需要的其他公共代码等等。所以，我们最好使用一个新的项目将这些代码整合起来。我们选用 .NET Standard 项目来存放这些代码，这样可以在各种 .NET 中使用这些库。控制台由于我们多数的代码都可以放到 .NET Standard 类库中，以确保绝大多数的代码都是平台和框架无关的，所以实际上我们在其他各个端项目中的代码会是很少的。这个时候，写一个控制台程序来测试我们的项目，控制台程序的部分其实只需要很少的用于控制控制台输入输出的代码，其他多数的代码例如用来访问 Web API 的代码都是不需要放在控制台项目中的，放到 .NET Standard 的类库中编写就可以做到最大程度的共用了。iOS 端接下来要完成这个云键盘程序，我们还需要开发一个移动端。使用 Xamarin 可以帮助我们完成这样的任务。关于使用 Xamarin.Forms 开发一个键盘扩展，可以阅读我的另一篇博客： 使用 Xamarin 开发 iOS 键盘扩展（含网络访问）Web 前端于是，我们仅仅使用 C# 还有客户端开发者熟悉的 XAML 就开发出了三个端了。这三个端中，有两个都是客户端，于是就会存在向用户分发客户端的问题。虽然可以让用户去商店下载，但是提供一个官方下载页面可以让用户在一处地方找到所有端的下载和部署方法。这需要使用到前端。然而如何使用 C# 代码来编写去前端呢？使用 CSHTML5！你可以前往 CSHTML5 的官网 下载 Visual Studio 的插件，这样你就可以在 Visual Studio 中编写 CSHTML5 的代码了，还有设计器的支持。0x02 C# 还能做什么？于是我们使用 XAML + C# 就编写出了各个端了。如果没有 GUI，那么跨平台将是非常容易的一件事情。例如我们想要在 Mac 电脑上也做一个打字发送的一方，那么一个控制台应用也是能够直接完成的。不过，这并不是说，我们只能通过控制台来开发桌面端应用。我们还有： AvaloniaUI/Avalonia: A multi-platform .NET UI framework Xamarin 版的 WPF 桌面端 Xamarin.Mac - 开发 Mac 桌面端 GTK# - 开发 Linux 桌面端 Tizen .NET - 开发三星物联网系统的 GUI利用这些平台，我们能开发其他桌面平台的 GUI 客户端。另外，利用 ML.NET，我们还能用 C# 进行机器学习。可参见：Bean.Hsiang - 博客园。利用 Roslyn，我们还能用直接做编译器，然后你还有什么不能做的？关于 Roslyn 的入门，可以阅读：从零开始学习 dotnet 编译过程和 Roslyn 源码分析 - walterlv。还有 IoT。还有其他……0x03 终章每个人都拥有 好奇心，好奇心驱使着我们总是去尝试做一些有趣的事情。使用你熟悉的语言 C#，不需要太多额外的入门，即可玩转你身边各种你需要的技术栈，玩出各种各样你自己期望尝试开发的小东西。" }, { "title": "从零开始学习 dotnet 编译过程和 Roslyn 源码分析", "url": "/post/posts-for-learning-dotnet-build-nuget-roslyn.html", "categories": "", "tags": "dotnet, csharp, msbuild, roslyn, visualstudio, nuget", "date": "2019-04-12 09:41:03 +0800", "snippet": "本文整理我和 林德熙 学习的 dotnet 编译知识、Roslyn 源码分析知识，NuGet 知识。通过阅读本文可以从零散的碎片化博客中得到从零开始学习的轨迹。本文服务于 微软技术暨生态大会 2018 课程，你可以学习预编译框架相关的技术原理。SourceYard 性能数据SourceYard 通过将公共组件的源代码和产品源代码合并来提升性能。以下是这部分的性能数据： C# 程序集数量对软件启动性能的影响 - 林德熙不过，程序集中的类的数量对启动性能没有影响： C# 直接创建多个类和使用反射创建类的性能 - 林德熙SourceFusion 性能数据SourceFusion 的其中一个用途是收集原本会通过反射收集的类型信息。以下是这部分的性能数据： C# 性能分析 反射 VS 配置文件 VS 预编译 - 林德熙额外的，如果不是收集而单单只是使用的话，这里是性能数据： C# 直接创建多个类和使用反射创建类的性能 - 林德熙dotnet build 基础你需要先了解 csproj 文件的结构，以便进行后续的学习： 理解 C# 项目 csproj 文件格式的本质和编译流程 - 吕毅 项目文件中的已知属性（知道了这些，就不会随便在 csproj 中写死常量啦） - 吕毅 Roslyn 在项目文件使用条件判断 - 林德熙在了解到 csproj 文件结构之后，你可以通过迁移一些项目，并确保他们编译通过来练习： 将 WPF、UWP 以及其他各种类型的旧 csproj 迁移成 Sdk 风格的 csproj - 吕毅 Sdk 风格的 csproj 对 WPF/UWP 支持不太好？有第三方 SDK 可以用！MSBuild.Sdk.Extras - 吕毅接着，csproj 中的重要内容 Target 对理解编译过程非常重要，因为它决定了如何编译这个项目： Roslyn 如何使用 MSBuild Copy 复制文件 - 林德熙 如何使用 MSBuild Target（Exec）中的控制台输出 - 吕毅 如何在 MSBuild Target（Exec）中报告编译错误和编译警告 - 吕毅更高级的 Target 用法： 如何编写基于 Microsoft.NET.Sdk 的跨平台的 MSBuild Target（附各种自带的 Task） - 吕毅 Roslyn 使用 WriteLinesToFile 解决参数过长无法传入 - 林德熙 每次都要重新编译？太慢！让跨平台的 MSBuild/dotnet build 的 Target 支持差量编译 - 吕毅基于 Target 的一些应用： Roslyn 如何在 Target 引用 xaml 防止文件没有编译 - 林德熙当现有的知识和文档不足以帮助你完成现有功能的时候，也许你该考虑阅读官方源码了： 解读 Microsoft.NET.Sdk 的源码，你能定制各种奇怪而富有创意的编译过程 - 吕毅 Reading the Source Code of Microsoft.NET.Sdk, Writing the Creative Extension of Compiling - 吕毅还有一些 csproj 特性的使用： .NET/C# 中你可以在代码中写多个 Main 函数，然后按需要随时切换 - 吕毅 在 Visual Studio 的解决方案资源管理器中隐藏一些文件 - 吕毅 使用链接共享 Visual Studio 中的代码文件 - 吕毅 为 Visual Studio 使用通配符批量添加项目文件 - 吕毅 Roslyn 使用 Directory.Build.props 管理多个项目配置 - 林德熙 Roslyn 使用 Directory.Build.props 文件定义编译 - 林德熙 使用 MSBuild 响应文件 (rsp) 来指定 dotnet build 命令行编译时的大量参数 - 吕毅NuGet 基础 项目文件中的已知 NuGet 属性（使用这些属性，创建 NuGet 包就可以不需要 nuspec 文件啦） - 吕毅可以使用 NuGet 做一些不是传统 dll 引用的功能： Roslyn 通过 nuget 统一管理信息 - 林德熙 Roslyn 通过 Nuget 管理公司配置 - 林德熙现在，我们需要真的使用 NuGet 做一个自己的工具了： 如何创建一个基于 MSBuild Task 的跨平台的 NuGet 工具包 - 吕毅 如何创建一个基于命令行工具的跨平台的 NuGet 工具包 - 吕毅 在制作跨平台的 NuGet 工具包时，如何将工具（exe/dll）的所有依赖一并放入包中 - 吕毅NuGet 的坑很多，有些可以解，有些需要规避： 帮助官方 NuGet 解掉 Bug，制作绝对不会传递依赖的 NuGet 包 - 吕毅 MSBuild/Roslyn 和 NuGet 的 100 个坑 - 吕毅 Roslyn 通过 Nuget 引用源代码 在 VS 智能提示正常但是无法编译 - 林德熙如果你的 NuGet 格式是旧的，或者说引用方式是旧的，推荐升级： 自动将 NuGet 包的引用方式从 packages.config 升级为 PackageReference - 吕毅 如何最快速地将旧的 NuGet 包 (2.x, packages.config) 升级成新的 NuGet 包 (4.x, PackageReference) - 吕毅学会这些 NuGet 技能之后的一些应用： 阻止某个 NuGet 包意外升级 - 吕毅SourceYard 原理SourceYard 利用 NuGet 自动 Import 的 Target 来执行我们的代码： Roslyn 使用 Target 替换占位符方式生成 nuget 打包 - 林德熙 Roslyn 通过 Target 修改编译的文件 - 林德熙 将 .NET Core 项目打一个最简单的 NuGet 源码包，安装此包就像直接把源码放进项目一样 - 吕毅 Roslyn 如何基于 Microsoft.NET.Sdk 制作源代码包 - 林德熙Roslyn 基础Roslyn 由于其丰富且易用的 API，所以入门是比较容易的。推荐的入门文章有： Roslyn 入门：使用 Visual Studio 的语法可视化（Syntax Visualizer）窗格查看和了解代码的语法树 - 吕毅 Roslyn 静态分析 - 林德熙 Roslyn 入门：使用 Roslyn 静态分析现有项目中的代码 - 吕毅 Roslyn 入门：使用 .NET Core 版本的 Roslyn 编译并执行跨平台的静态的源码 - 吕毅额外的，你可以阅读更多 Roslyn 的资料以便快速应用于你的项目： Roslyn 语法树中的各种语法节点及每个节点的含义 - 吕毅 Roslyn 节点的 Span 和 FullSpan 有什么区别 - 林德熙 Roslyn NameSyntax 的 ToString 和 ToFullString 的区别 - 林德熙Roslyn 为何能够在提供如此友好的 API 的情况下依然有如此高的性能？ 理解 Roslyn 中的红绿树（Red-Green Trees） - 吕毅一些 Roslyn 的额外功能： Roslyn 的确定性构建 - 吕毅SourceFusion 预编译框架关于预编译框架的博客没有那么多，只有一些基本的使用： 都是用 DllImport？有没有考虑过自己写一个 extern 方法？ - 吕毅扩展阅读这里是是用到了 csproj / NuGet 等的额外博客： 语义版本号（Semantic Versioning） - 吕毅 (1/2) 为了理解 UWP 的启动流程，我从零开始创建了一个 UWP 程序 - 吕毅 dotnet core 通过修改文件头的方式隐藏控制台窗口 - 林德熙 使用 GitVersion 在编译或持续构建时自动使用语义版本号（Semantic Versioning） - 吕毅 Automatically increase the semantic version using GitVersion - 吕毅" }, { "title": "(1/2) 为了理解 UWP 的启动流程，我从零开始创建了一个 UWP 程序", "url": "/post/create-uwp-app-from-zero-0.html", "categories": "", "tags": "uwp, msbuild", "date": "2019-04-12 09:40:58 +0800", "snippet": "每次使用 Visual Studio 的模板创建一个 UWP 程序，我们会在项目中发现大量的项目文件、配置、应用启动流程代码和界面代码。然而这些文件在 UWP 程序中到底是如何工作起来的？我从零开始创建了一个 UWP 程序，用于探索这些文件的用途，了解 UWP 程序的启动流程。本文分为两个部分： 从零开始创建一个 UWP 项目并完成部署 从零开始编写一个 UWP 应用程序和窗口本文将一个普通项目改造成 UWP 项目，重点在了解 UWP 的项目文件组成。从最简单的项目模板开始虽然可以从零开始写一个 csproj 文件，不过这并没有什么技术含量，因为新的 csproj 文件实在是非常简单。参见： 理解 C# 项目 csproj 文件格式的本质和编译流程 将 WPF、UWP 以及其他各种类型的旧 csproj 迁移成 Sdk 风格的 csproj于是，我创建一个 .NET Core 控制台应用。当然，其它简单的如 .NET Standard 库都是一样的，反正最后都会被我改得面目全非。于是我得到了一个 csproj 项目文件和包含有应用程序入口的 Program.cs 文件。其中 csproj 文件内容非常简单：&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;OutputType&amp;gt;Exe&amp;lt;/OutputType&amp;gt; &amp;lt;TargetFramework&amp;gt;netcoreapp2.1&amp;lt;/TargetFramework&amp;gt; &amp;lt;/PropertyGroup&amp;gt;&amp;lt;/Project&amp;gt;Program.cs 文件也是：// using System;namespace Walterlv.Demo.ZeroUwp{ class Program { static void Main(string[] args) { // 这一句需要删除，因为 UWP 程序中不能使用控制台。 // Console.WriteLine(&quot;Hello World!&quot;); } }}不过，这两个文件都会被改掉的，已经无所谓里面是什么内容了。将项目改造成 UWP 项目UWP 程序的输出类型是 AppContainerExe，而不是一般的 Library 或者 Exe。另外，基于 Sdk 风格的 csproj 格式不支持 UWP 应用程序。所以我希望借助第三方的 MSBuild.Sdk.Extras 来编译 UWP 的项目。参见 Sdk 风格的 csproj 对 WPF/UWP 支持不太好？有第三方 SDK 可以用！MSBuild.Sdk.Extras。然而实际情况也不容乐观，因为此第三方 Sdk 只支持 UWP 的库程序，而不支持应用程序容器。所以即便修改为以下方式，最终也因为缺少 Visual Studio RunCommand 的支持，而导致无法启动。&amp;lt;Project Sdk=&quot;MSBuild.Sdk.Extras/1.6.41&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;OutputType&amp;gt;AppContainerExe&amp;lt;/OutputType&amp;gt; &amp;lt;TargetFrameworks&amp;gt;uap10.0.17134&amp;lt;/TargetFrameworks&amp;gt; &amp;lt;/PropertyGroup&amp;gt;&amp;lt;/Project&amp;gt;使用以上新 Sdk 的 csproj 格式，我完整地写完了整个 csproj 文件和后续步骤，依然无法解决下面这个错误提示框：▲ 无法启动所以我们依然只能使用传统的 csproj 文件格式。里面大部分的内容从模板中复制而来。事实上，我寻找了很多资料，都没有找到让 Sdk 风格的 csproj 格式支持 UWP 的主程序。&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;Project ToolsVersion=&quot;15.0&quot; DefaultTargets=&quot;Build&quot; xmlns=&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;&amp;gt; &amp;lt;Import Project=&quot;$(MSBuildExtensionsPath)\\$(MSBuildToolsVersion)\\Microsoft.Common.props&quot; Condition=&quot;Exists(&#39;$(MSBuildExtensionsPath)\\$(MSBuildToolsVersion)\\Microsoft.Common.props&#39;)&quot; /&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;Configuration Condition=&quot; &#39;$(Configuration)&#39; == &#39;&#39; &quot;&amp;gt;Debug&amp;lt;/Configuration&amp;gt; &amp;lt;Platform Condition=&quot; &#39;$(Platform)&#39; == &#39;&#39; &quot;&amp;gt;x86&amp;lt;/Platform&amp;gt; &amp;lt;ProjectGuid&amp;gt;{09A58639-DC50-41C1-8BCE-A2217A1D3327}&amp;lt;/ProjectGuid&amp;gt; &amp;lt;OutputType&amp;gt;AppContainerExe&amp;lt;/OutputType&amp;gt; &amp;lt;AppDesignerFolder&amp;gt;Properties&amp;lt;/AppDesignerFolder&amp;gt; &amp;lt;RootNamespace&amp;gt;Walterlv.Demo.ZeroUwp&amp;lt;/RootNamespace&amp;gt; &amp;lt;AssemblyName&amp;gt;Walterlv.Demo.ZeroUwp&amp;lt;/AssemblyName&amp;gt; &amp;lt;DefaultLanguage&amp;gt;en-US&amp;lt;/DefaultLanguage&amp;gt; &amp;lt;TargetPlatformIdentifier&amp;gt;UAP&amp;lt;/TargetPlatformIdentifier&amp;gt; &amp;lt;TargetPlatformVersion Condition=&quot; &#39;$(TargetPlatformVersion)&#39; == &#39;&#39; &quot;&amp;gt;10.0.17134.0&amp;lt;/TargetPlatformVersion&amp;gt; &amp;lt;TargetPlatformMinVersion&amp;gt;10.0.15063.0&amp;lt;/TargetPlatformMinVersion&amp;gt; &amp;lt;MinimumVisualStudioVersion&amp;gt;14&amp;lt;/MinimumVisualStudioVersion&amp;gt; &amp;lt;FileAlignment&amp;gt;512&amp;lt;/FileAlignment&amp;gt; &amp;lt;ProjectTypeGuids&amp;gt;{A5A43C5B-DE2A-4C0C-9213-0A381AF9435A};{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}&amp;lt;/ProjectTypeGuids&amp;gt; &amp;lt;WindowsXamlEnableOverview&amp;gt;true&amp;lt;/WindowsXamlEnableOverview&amp;gt; &amp;lt;DebugSymbols&amp;gt;true&amp;lt;/DebugSymbols&amp;gt; &amp;lt;OutputPath&amp;gt;bin\\x86\\Debug\\&amp;lt;/OutputPath&amp;gt; &amp;lt;DefineConstants&amp;gt;DEBUG;TRACE;NETFX_CORE;WINDOWS_UWP&amp;lt;/DefineConstants&amp;gt; &amp;lt;DebugType&amp;gt;full&amp;lt;/DebugType&amp;gt; &amp;lt;PlatformTarget&amp;gt;x86&amp;lt;/PlatformTarget&amp;gt; &amp;lt;UseVSHostingProcess&amp;gt;false&amp;lt;/UseVSHostingProcess&amp;gt; &amp;lt;ErrorReport&amp;gt;prompt&amp;lt;/ErrorReport&amp;gt; &amp;lt;Prefer32Bit&amp;gt;true&amp;lt;/Prefer32Bit&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;RestoreProjectStyle&amp;gt;PackageReference&amp;lt;/RestoreProjectStyle&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;Compile Include=&quot;Program.cs&quot; /&amp;gt; &amp;lt;Compile Include=&quot;Properties\\AssemblyInfo.cs&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;AppxManifest Include=&quot;Package.appxmanifest&quot;&amp;gt; &amp;lt;SubType&amp;gt;Designer&amp;lt;/SubType&amp;gt; &amp;lt;/AppxManifest&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;PackageReference Include=&quot;Microsoft.NETCore.UniversalWindowsPlatform&quot;&amp;gt; &amp;lt;Version&amp;gt;6.1.5&amp;lt;/Version&amp;gt; &amp;lt;/PackageReference&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;PropertyGroup Condition=&quot; &#39;$(VisualStudioVersion)&#39; == &#39;&#39; or &#39;$(VisualStudioVersion)&#39; &amp;amp;lt; &#39;14.0&#39; &quot;&amp;gt; &amp;lt;VisualStudioVersion&amp;gt;14.0&amp;lt;/VisualStudioVersion&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;Import Project=&quot;$(MSBuildExtensionsPath)\\Microsoft\\WindowsXaml\\v$(VisualStudioVersion)\\Microsoft.Windows.UI.Xaml.CSharp.targets&quot; /&amp;gt;&amp;lt;/Project&amp;gt;编写 AppxManifest项目改造成 UWP 项目后，似乎已经完成了大部分了，但此时直接运行会有编译错误，因为我缺少 UWP 程序必要的 AppxManifest.xml 文件。事实上，AppxManifest.xml 的创建是非常繁琐的；通常是编译过程帮我们根据 Package.appxmanifest 文件自动生成的。然而创建一个 Package.appxmanifest 也是很麻烦的。至少，要让 Visual Studio 能够直接打开这个文件所需的最小代码量是下面这些（不能编译通过）：&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;Package xmlns=&quot;http://schemas.microsoft.com/appx/manifest/foundation/windows10&quot; xmlns:mp=&quot;http://schemas.microsoft.com/appx/2014/phone/manifest&quot; xmlns:uap=&quot;http://schemas.microsoft.com/appx/manifest/uap/windows10&quot; xmlns:uap2=&quot;http://schemas.microsoft.com/appx/manifest/uap/windows10/2&quot; xmlns:uap3=&quot;http://schemas.microsoft.com/appx/manifest/uap/windows10/3&quot; xmlns:iot=&quot;http://schemas.microsoft.com/appx/manifest/iot/windows10&quot; xmlns:mobile=&quot;http://schemas.microsoft.com/appx/manifest/mobile/windows10&quot; IgnorableNamespaces=&quot;uap mp uap3 iot uap2 mobile&quot;&amp;gt; &amp;lt;Identity Name=&quot;walterlv.zerouwp&quot; Publisher=&quot;CN=walterlv&quot; Version=&quot;0.1.0.0&quot; /&amp;gt; &amp;lt;mp:PhoneIdentity PhoneProductId=&quot;97f5137d-c6be-4395-9af0-bbfdcea40fa7&quot; PhonePublisherId=&quot;00000000-0000-0000-0000-000000000000&quot; /&amp;gt; &amp;lt;Properties&amp;gt; &amp;lt;DisplayName&amp;gt;Walterlv.ZeroUwp&amp;lt;/DisplayName&amp;gt; &amp;lt;PublisherDisplayName&amp;gt;walterlv&amp;lt;/PublisherDisplayName&amp;gt; &amp;lt;Logo&amp;gt;Assets\\StoreLogo.png&amp;lt;/Logo&amp;gt; &amp;lt;/Properties&amp;gt; &amp;lt;Dependencies&amp;gt; &amp;lt;TargetDeviceFamily Name=&quot;Windows.Universal&quot; MinVersion=&quot;10.0.0.0&quot; MaxVersionTested=&quot;10.0.0.0&quot; /&amp;gt; &amp;lt;/Dependencies&amp;gt; &amp;lt;Resources&amp;gt; &amp;lt;Resource Language=&quot;x-generate&quot; /&amp;gt; &amp;lt;/Resources&amp;gt; &amp;lt;Applications&amp;gt; &amp;lt;Application Id=&quot;App&quot; Executable=&quot;$targetnametoken$.exe&quot; EntryPoint=&quot;Walterlv.ZeroUwp.Program&quot;&amp;gt; &amp;lt;uap:VisualElements DisplayName=&quot;Walterlv.ZeroUwp&quot;&amp;gt; &amp;lt;/uap:VisualElements&amp;gt; &amp;lt;/Application&amp;gt; &amp;lt;/Applications&amp;gt;&amp;lt;/Package&amp;gt;可以阅读这些文档了解如何完成这份文件的编写： Identity (Windows 10) - UWP app developer - Microsoft Docs pm:PhoneIdentity (Windows 10) - UWP app developer - Microsoft Docs具体来说，&amp;lt;Identity /&amp;gt; 是此程序包的标识符，需要在整个应用商店范围内唯一（如果将此包与应用商店关联，这个值会自动更新，所以不用在意填成什么）。&amp;lt;mp:PhoneIdentity /&amp;gt; 是此程序包在移动设备上的标识符，应用的更新会依据此标识符的 GUID 来唯一确定，格式必须是 GUID。事实上，虽然依然无法完成编译，但此时可以通过在 Visual Studio 中打开这份文件来观察还缺少哪些必要的信息需要填写。事实上，我们缺少的信息并不多，只有四个，都从 Package/Applications/Application 开始： uap:VisualElements@Description uap:VisualElements@BackgroundColor uap:VisualElements@Square150x150Logo uap:VisualElements@Square44x44Logo uap:VisualElements/uap:DefaultTile@Wide310x150Logo这是 XPath 语法，详见：XML 的 XPath 语法同时，我们还真的需要相应的图片：建议从 UWP 程序模板中复制，也可以去这里下载：UWP 程序所需的最少 Logo 资源-CSDN下载。补充完毕之后，完整的文件如下：&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;Package xmlns=&quot;http://schemas.microsoft.com/appx/manifest/foundation/windows10&quot; xmlns:mp=&quot;http://schemas.microsoft.com/appx/2014/phone/manifest&quot; xmlns:uap=&quot;http://schemas.microsoft.com/appx/manifest/uap/windows10&quot; xmlns:uap2=&quot;http://schemas.microsoft.com/appx/manifest/uap/windows10/2&quot; xmlns:uap3=&quot;http://schemas.microsoft.com/appx/manifest/uap/windows10/3&quot; xmlns:iot=&quot;http://schemas.microsoft.com/appx/manifest/iot/windows10&quot; xmlns:mobile=&quot;http://schemas.microsoft.com/appx/manifest/mobile/windows10&quot; IgnorableNamespaces=&quot;uap mp uap3 iot uap2 mobile&quot;&amp;gt; &amp;lt;Identity Name=&quot;walterlv.zerouwp&quot; Publisher=&quot;CN=walterlv&quot; Version=&quot;0.1.0.0&quot; /&amp;gt; &amp;lt;Properties&amp;gt; &amp;lt;DisplayName&amp;gt;Walterlv.ZeroUwp&amp;lt;/DisplayName&amp;gt; &amp;lt;PublisherDisplayName&amp;gt;walterlv&amp;lt;/PublisherDisplayName&amp;gt; &amp;lt;Logo&amp;gt;Assets\\StoreLogo.png&amp;lt;/Logo&amp;gt; &amp;lt;/Properties&amp;gt; &amp;lt;Dependencies&amp;gt; &amp;lt;TargetDeviceFamily Name=&quot;Windows.Universal&quot; MinVersion=&quot;10.0.0.0&quot; MaxVersionTested=&quot;10.0.0.0&quot; /&amp;gt; &amp;lt;/Dependencies&amp;gt; &amp;lt;Resources&amp;gt; &amp;lt;Resource Language=&quot;x-generate&quot; /&amp;gt; &amp;lt;/Resources&amp;gt; &amp;lt;Applications&amp;gt; &amp;lt;Application Id=&quot;App&quot; Executable=&quot;$targetnametoken$.exe&quot; EntryPoint=&quot;Walterlv.ZeroUwp.Program&quot;&amp;gt; &amp;lt;uap:VisualElements DisplayName=&quot;Walterlv.ZeroUwp&quot; Description=&quot;Walterlv.ZeroUwp is a demo application to learn how uwp application runs.&quot; BackgroundColor=&quot;transparent&quot; Square150x150Logo=&quot;Assets\\Square150x150Logo.png&quot; Square44x44Logo=&quot;Assets\\Square44x44Logo.png&quot;&amp;gt; &amp;lt;uap:DefaultTile Wide310x150Logo=&quot;Assets\\Wide310x150Logo.png&quot;&amp;gt; &amp;lt;/uap:DefaultTile&amp;gt; &amp;lt;/uap:VisualElements&amp;gt; &amp;lt;/Application&amp;gt; &amp;lt;/Applications&amp;gt;&amp;lt;/Package&amp;gt;不能忘掉，这份文件还需要添加到 csproj 项目文件中：&amp;lt;!-- 新增了此节点，即 AppxManifest 和相关资源。 --&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;AppxManifest Include=&quot;Package.appxmanifest&quot;&amp;gt; &amp;lt;SubType&amp;gt;Designer&amp;lt;/SubType&amp;gt; &amp;lt;/AppxManifest&amp;gt; &amp;lt;Content Include=&quot;Assets\\Square150x150Logo.scale-200.png&quot; /&amp;gt; &amp;lt;Content Include=&quot;Assets\\Square44x44Logo.scale-200.png&quot; /&amp;gt; &amp;lt;Content Include=&quot;Assets\\StoreLogo.png&quot; /&amp;gt; &amp;lt;Content Include=&quot;Assets\\Wide310x150Logo.scale-200.png&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt;编写 AssemblyInfo.cs由于没有新的基于 Sdk 的 csproj 文件支持，所以我们需要自己编写 AssemblyInfo.cs 文件，并放入到 Properties 文件夹中。using System.Reflection;using System.Runtime.InteropServices;[assembly: AssemblyTitle(&quot;Walterlv.Demo.ZeroUwp&quot;)][assembly: AssemblyProduct(&quot;Walterlv.Demo.ZeroUwp&quot;)][assembly: AssemblyCopyright(&quot;Copyright © walterlv 2018&quot;)][assembly: AssemblyVersion(&quot;0.1.0.0&quot;)][assembly: AssemblyFileVersion(&quot;0.1.0.0&quot;)][assembly: ComVisible(false)]最后，csproj 文件会如下面这样。&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;Project ToolsVersion=&quot;15.0&quot; DefaultTargets=&quot;Build&quot; xmlns=&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;&amp;gt; &amp;lt;Import Project=&quot;$(MSBuildExtensionsPath)\\$(MSBuildToolsVersion)\\Microsoft.Common.props&quot; Condition=&quot;Exists(&#39;$(MSBuildExtensionsPath)\\$(MSBuildToolsVersion)\\Microsoft.Common.props&#39;)&quot; /&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;Configuration Condition=&quot; &#39;$(Configuration)&#39; == &#39;&#39; &quot;&amp;gt;Debug&amp;lt;/Configuration&amp;gt; &amp;lt;Platform Condition=&quot; &#39;$(Platform)&#39; == &#39;&#39; &quot;&amp;gt;x86&amp;lt;/Platform&amp;gt; &amp;lt;ProjectGuid&amp;gt;{7B81D14B-6094-44E1-9B2F-F577995A3CAF}&amp;lt;/ProjectGuid&amp;gt; &amp;lt;OutputType&amp;gt;AppContainerExe&amp;lt;/OutputType&amp;gt; &amp;lt;AppDesignerFolder&amp;gt;Properties&amp;lt;/AppDesignerFolder&amp;gt; &amp;lt;RootNamespace&amp;gt;Walterlv.Demo.ZeroUwp&amp;lt;/RootNamespace&amp;gt; &amp;lt;AssemblyName&amp;gt;Walterlv.Demo.ZeroUwp&amp;lt;/AssemblyName&amp;gt; &amp;lt;DefaultLanguage&amp;gt;en-US&amp;lt;/DefaultLanguage&amp;gt; &amp;lt;TargetPlatformIdentifier&amp;gt;UAP&amp;lt;/TargetPlatformIdentifier&amp;gt; &amp;lt;TargetPlatformVersion Condition=&quot; &#39;$(TargetPlatformVersion)&#39; == &#39;&#39; &quot;&amp;gt;10.0.17134.0&amp;lt;/TargetPlatformVersion&amp;gt; &amp;lt;TargetPlatformMinVersion&amp;gt;10.0.17134.0&amp;lt;/TargetPlatformMinVersion&amp;gt; &amp;lt;MinimumVisualStudioVersion&amp;gt;14&amp;lt;/MinimumVisualStudioVersion&amp;gt; &amp;lt;FileAlignment&amp;gt;512&amp;lt;/FileAlignment&amp;gt; &amp;lt;ProjectTypeGuids&amp;gt;{A5A43C5B-DE2A-4C0C-9213-0A381AF9435A};{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}&amp;lt;/ProjectTypeGuids&amp;gt; &amp;lt;WindowsXamlEnableOverview&amp;gt;true&amp;lt;/WindowsXamlEnableOverview&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;PropertyGroup Condition=&quot;&#39;$(Configuration)|$(Platform)&#39; == &#39;Debug|x86&#39;&quot;&amp;gt; &amp;lt;DebugSymbols&amp;gt;true&amp;lt;/DebugSymbols&amp;gt; &amp;lt;OutputPath&amp;gt;bin\\x86\\Debug\\&amp;lt;/OutputPath&amp;gt; &amp;lt;DefineConstants&amp;gt;DEBUG;TRACE;NETFX_CORE;WINDOWS_UWP&amp;lt;/DefineConstants&amp;gt; &amp;lt;NoWarn&amp;gt;;2008&amp;lt;/NoWarn&amp;gt; &amp;lt;DebugType&amp;gt;full&amp;lt;/DebugType&amp;gt; &amp;lt;PlatformTarget&amp;gt;x86&amp;lt;/PlatformTarget&amp;gt; &amp;lt;UseVSHostingProcess&amp;gt;false&amp;lt;/UseVSHostingProcess&amp;gt; &amp;lt;ErrorReport&amp;gt;prompt&amp;lt;/ErrorReport&amp;gt; &amp;lt;Prefer32Bit&amp;gt;true&amp;lt;/Prefer32Bit&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;PropertyGroup Condition=&quot;&#39;$(Configuration)|$(Platform)&#39; == &#39;Release|x86&#39;&quot;&amp;gt; &amp;lt;OutputPath&amp;gt;bin\\x86\\Release\\&amp;lt;/OutputPath&amp;gt; &amp;lt;DefineConstants&amp;gt;TRACE;NETFX_CORE;WINDOWS_UWP&amp;lt;/DefineConstants&amp;gt; &amp;lt;Optimize&amp;gt;true&amp;lt;/Optimize&amp;gt; &amp;lt;NoWarn&amp;gt;;2008&amp;lt;/NoWarn&amp;gt; &amp;lt;DebugType&amp;gt;pdbonly&amp;lt;/DebugType&amp;gt; &amp;lt;PlatformTarget&amp;gt;x86&amp;lt;/PlatformTarget&amp;gt; &amp;lt;UseVSHostingProcess&amp;gt;false&amp;lt;/UseVSHostingProcess&amp;gt; &amp;lt;ErrorReport&amp;gt;prompt&amp;lt;/ErrorReport&amp;gt; &amp;lt;Prefer32Bit&amp;gt;true&amp;lt;/Prefer32Bit&amp;gt; &amp;lt;UseDotNetNativeToolchain&amp;gt;true&amp;lt;/UseDotNetNativeToolchain&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;PropertyGroup Condition=&quot;&#39;$(Configuration)|$(Platform)&#39; == &#39;Debug|ARM&#39;&quot;&amp;gt; &amp;lt;DebugSymbols&amp;gt;true&amp;lt;/DebugSymbols&amp;gt; &amp;lt;OutputPath&amp;gt;bin\\ARM\\Debug\\&amp;lt;/OutputPath&amp;gt; &amp;lt;DefineConstants&amp;gt;DEBUG;TRACE;NETFX_CORE;WINDOWS_UWP&amp;lt;/DefineConstants&amp;gt; &amp;lt;NoWarn&amp;gt;;2008&amp;lt;/NoWarn&amp;gt; &amp;lt;DebugType&amp;gt;full&amp;lt;/DebugType&amp;gt; &amp;lt;PlatformTarget&amp;gt;ARM&amp;lt;/PlatformTarget&amp;gt; &amp;lt;UseVSHostingProcess&amp;gt;false&amp;lt;/UseVSHostingProcess&amp;gt; &amp;lt;ErrorReport&amp;gt;prompt&amp;lt;/ErrorReport&amp;gt; &amp;lt;Prefer32Bit&amp;gt;true&amp;lt;/Prefer32Bit&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;PropertyGroup Condition=&quot;&#39;$(Configuration)|$(Platform)&#39; == &#39;Release|ARM&#39;&quot;&amp;gt; &amp;lt;OutputPath&amp;gt;bin\\ARM\\Release\\&amp;lt;/OutputPath&amp;gt; &amp;lt;DefineConstants&amp;gt;TRACE;NETFX_CORE;WINDOWS_UWP&amp;lt;/DefineConstants&amp;gt; &amp;lt;Optimize&amp;gt;true&amp;lt;/Optimize&amp;gt; &amp;lt;NoWarn&amp;gt;;2008&amp;lt;/NoWarn&amp;gt; &amp;lt;DebugType&amp;gt;pdbonly&amp;lt;/DebugType&amp;gt; &amp;lt;PlatformTarget&amp;gt;ARM&amp;lt;/PlatformTarget&amp;gt; &amp;lt;UseVSHostingProcess&amp;gt;false&amp;lt;/UseVSHostingProcess&amp;gt; &amp;lt;ErrorReport&amp;gt;prompt&amp;lt;/ErrorReport&amp;gt; &amp;lt;Prefer32Bit&amp;gt;true&amp;lt;/Prefer32Bit&amp;gt; &amp;lt;UseDotNetNativeToolchain&amp;gt;true&amp;lt;/UseDotNetNativeToolchain&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;PropertyGroup Condition=&quot;&#39;$(Configuration)|$(Platform)&#39; == &#39;Debug|x64&#39;&quot;&amp;gt; &amp;lt;DebugSymbols&amp;gt;true&amp;lt;/DebugSymbols&amp;gt; &amp;lt;OutputPath&amp;gt;bin\\x64\\Debug\\&amp;lt;/OutputPath&amp;gt; &amp;lt;DefineConstants&amp;gt;DEBUG;TRACE;NETFX_CORE;WINDOWS_UWP&amp;lt;/DefineConstants&amp;gt; &amp;lt;NoWarn&amp;gt;;2008&amp;lt;/NoWarn&amp;gt; &amp;lt;DebugType&amp;gt;full&amp;lt;/DebugType&amp;gt; &amp;lt;PlatformTarget&amp;gt;x64&amp;lt;/PlatformTarget&amp;gt; &amp;lt;UseVSHostingProcess&amp;gt;false&amp;lt;/UseVSHostingProcess&amp;gt; &amp;lt;ErrorReport&amp;gt;prompt&amp;lt;/ErrorReport&amp;gt; &amp;lt;Prefer32Bit&amp;gt;true&amp;lt;/Prefer32Bit&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;PropertyGroup Condition=&quot;&#39;$(Configuration)|$(Platform)&#39; == &#39;Release|x64&#39;&quot;&amp;gt; &amp;lt;OutputPath&amp;gt;bin\\x64\\Release\\&amp;lt;/OutputPath&amp;gt; &amp;lt;DefineConstants&amp;gt;TRACE;NETFX_CORE;WINDOWS_UWP&amp;lt;/DefineConstants&amp;gt; &amp;lt;Optimize&amp;gt;true&amp;lt;/Optimize&amp;gt; &amp;lt;NoWarn&amp;gt;;2008&amp;lt;/NoWarn&amp;gt; &amp;lt;DebugType&amp;gt;pdbonly&amp;lt;/DebugType&amp;gt; &amp;lt;PlatformTarget&amp;gt;x64&amp;lt;/PlatformTarget&amp;gt; &amp;lt;UseVSHostingProcess&amp;gt;false&amp;lt;/UseVSHostingProcess&amp;gt; &amp;lt;ErrorReport&amp;gt;prompt&amp;lt;/ErrorReport&amp;gt; &amp;lt;Prefer32Bit&amp;gt;true&amp;lt;/Prefer32Bit&amp;gt; &amp;lt;UseDotNetNativeToolchain&amp;gt;true&amp;lt;/UseDotNetNativeToolchain&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;RestoreProjectStyle&amp;gt;PackageReference&amp;lt;/RestoreProjectStyle&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;Compile Include=&quot;Properties\\AssemblyInfo.cs&quot; /&amp;gt; &amp;lt;Compile Include=&quot;Program.cs&quot; /&amp;gt; &amp;lt;Compile Include=&quot;VisualProperties.cs&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;AppxManifest Include=&quot;Package.appxmanifest&quot;&amp;gt; &amp;lt;SubType&amp;gt;Designer&amp;lt;/SubType&amp;gt; &amp;lt;/AppxManifest&amp;gt; &amp;lt;Content Include=&quot;Assets\\Square150x150Logo.scale-200.png&quot; /&amp;gt; &amp;lt;Content Include=&quot;Assets\\Square44x44Logo.scale-200.png&quot; /&amp;gt; &amp;lt;Content Include=&quot;Assets\\StoreLogo.png&quot; /&amp;gt; &amp;lt;Content Include=&quot;Assets\\Wide310x150Logo.scale-200.png&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;PackageReference Include=&quot;Microsoft.NETCore.UniversalWindowsPlatform&quot;&amp;gt; &amp;lt;Version&amp;gt;6.1.5&amp;lt;/Version&amp;gt; &amp;lt;/PackageReference&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;PropertyGroup Condition=&quot; &#39;$(VisualStudioVersion)&#39; == &#39;&#39; or &#39;$(VisualStudioVersion)&#39; &amp;amp;lt; &#39;14.0&#39; &quot;&amp;gt; &amp;lt;VisualStudioVersion&amp;gt;14.0&amp;lt;/VisualStudioVersion&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;Import Project=&quot;$(MSBuildExtensionsPath)\\Microsoft\\WindowsXaml\\v$(VisualStudioVersion)\\Microsoft.Windows.UI.Xaml.CSharp.targets&quot; /&amp;gt;&amp;lt;/Project&amp;gt;一个说明：如果运行时出现本机错误，那么可能是上面的 csproj 文件没有配置正确。如果出现下图所示的错误，建议先考虑将以上 csproj 文件中的所有内容复制到你的项目文件中再试。完成部署和运行以上所有内容是一个 UWP 程序完成编译并运行所需的最少信息了。此时运行，我们只会看到一个空的窗口，就像这样：Main 函数中的断点是可以进入的：不过，如果继续运行，会提示错误。因为我们的程序并没有显示任何 UWP 的界面。总结与后续在本文中，我们了解到 UWP 项目所需的最少文件有： *.csproj 项目文件 这是整个从零开始的 UWP 程序中最复杂的一个文件，因为目前没有找到任何一个 Sdk 支持 UWP 的主程序工程。 Package.appxmanifest 文件 这是 UWP 应用程序的清单文件。事实上，这不是最终的清单文件，而是用于在项目中填写信息的文件；从前面的错误信息中我们了解到，最终的清单文件是 AppxManifest.xml。 Assets 文件夹中的四张图片 StoreLogo、Square44x44Logo、Square150x150Logo 和 Wide310x150Logo 是清单文件能够正常生成所需的最少 Logo 资源 AssemblyInfo.cs 由于缺少 Project@Sdk 的支持，所以我们必须编写 AssemblyInfo.cs 文件来指定版本信息。 Program.cs 这是一开始我们就添加好的文件，就是放 Main 函数的地方。虽然我们什么都没写，但已经能够进入断点了。 接下来我们将从 Main 函数开始，完成一个 UWP 程序的启动：(2/2) 为了理解 UWP 的启动流程，我从零开始创建了一个 UWP 程序。" }, { "title": ".NET/C# 项目如何优雅地设置条件编译符号？", "url": "/post/how-to-define-preprocessor-symbols.html", "categories": "", "tags": "csharp, dotnet, visualstudio, msbuild", "date": "2019-04-12 09:40:26 +0800", "snippet": "条件编译符号指的是 Conditional Compilation Symbols。你可以在 Visual Studio 的项目属性中设置，也可以直接在项目文件中写入 DefineConstants 属性。不过对于不同种类的项目，我建议使用不同的设置方法。本文将介绍如何设置条件编译符。对于新旧格式的差别或者迁移，可以查看我的其他博客： 理解 C# 项目 csproj 文件格式的本质和编译流程 将 WPF、UWP 以及其他各种类型的旧 csproj 迁移成 Sdk 风格的 csproj新格式推荐：在 csproj 文件中设置在项目中设置 &amp;lt;DefineConstants /&amp;gt; 属性：&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;OutputType&amp;gt;Exe&amp;lt;/OutputType&amp;gt; &amp;lt;TargetFrameworks&amp;gt;netcoreapp2.1;net47&amp;lt;/TargetFrameworks&amp;gt; &amp;lt;DefineConstants&amp;gt;$(DefineConstants);WALTERLV&amp;lt;/DefineConstants&amp;gt; &amp;lt;/PropertyGroup&amp;gt;&amp;lt;/Project&amp;gt;这里我使用字符串拼接的方式 $(DefineConstants);WALTERLV 来设置，这样可以把预设的那些条件编译符号保留，比如通常 Visual Studio 会帮你生成的 TRACE 条件编译符。但即便你不做这种拼接也不用担心。因为基于框架或平台的条件编译符号是自动设置的。例如 NETCOREAPP2_1 等都是在你指定 DefineConstants 之后自动设置的。以下是 Microsoft.NET.Sdk 中的部分源码，可以证明这一点：&amp;lt;PropertyGroup Condition=&quot;&#39;$(DisableImplicitConfigurationDefines)&#39; != &#39;true&#39;&quot;&amp;gt; &amp;lt;ImplicitConfigurationDefine&amp;gt;$(Configuration.ToUpperInvariant())&amp;lt;/ImplicitConfigurationDefine&amp;gt; &amp;lt;!-- Replace dashes and periods in the configuration with underscores. This makes it more likely that the resulting compilation constant will be a valid C# conditional compilation symbol. As the set of characters that aren&#39;t allowed is essentially open-ended, there&#39;s probably not a good way to fully sanitize the Configuration in MSBuild evaluation. If the resulting string still isn&#39;t a valid conditional combilation symbol, then the compiler will generate the following error and the define will be ignored: warning MSB3052: The parameter to the compiler is invalid, &#39;/define:0BAD_DEFINE&#39; will be ignored. --&amp;gt; &amp;lt;ImplicitConfigurationDefine&amp;gt;$(ImplicitConfigurationDefine.Replace(&#39;-&#39;, &#39;_&#39;))&amp;lt;/ImplicitConfigurationDefine&amp;gt; &amp;lt;ImplicitConfigurationDefine&amp;gt;$(ImplicitConfigurationDefine.Replace(&#39;.&#39;, &#39;_&#39;))&amp;lt;/ImplicitConfigurationDefine&amp;gt; &amp;lt;DefineConstants&amp;gt;$(DefineConstants);$(ImplicitConfigurationDefine)&amp;lt;/DefineConstants&amp;gt;&amp;lt;/PropertyGroup&amp;gt;&amp;lt;PropertyGroup&amp;gt; &amp;lt;DefineConstants&amp;gt;$(DefineConstants);$(ImplicitFrameworkDefine)&amp;lt;/DefineConstants&amp;gt;&amp;lt;/PropertyGroup&amp;gt;旧格式推荐：在 Visual Studio 项目属性中设置你可以在项目属性的“生成”页中找到条件编译符号的设置。我自己用的 Visual Studio 是英文版的，但是也感谢小伙伴 林德熙 帮我截了一张中文版的图。你需要特别注意： 设置条件编译符号需要在各种配置下都设置，因为各种配置都是不一样的；具体来说是 Debug 下要设，Release 下也要设，x86 下要设，x64 下也要设。关于配置（Configuration）和条件编译符号（Conditional Compilation Symbols）你可能在你的代码中同时看到 Pascal 命名规则的 Debug 和全部大写的 DEBUG，或者看到 Release 和 RELEASE。这是两个不同的概念。Debug 和 Release 的名称来自于配置（Configuration）。你的项目有 Debug 配置和 Release 配置，或者你自己定义的其他配置。你的项目编译过程默认根据 Debug 和 Release 配置做了很多不同的编译选项。例如 Debug 下会禁用优化而 Release 下会开启优化。而 DEBUG 和 RELEASE 这样的全大写名称来自于条件编译符号（Conditional Compilation Symbols），是真正在 C# 代码中使用的符号。而这全大写符号的定义是分别在 Debug 和 Release 配置下设置了不同的值来实现的。所以这两个是不同的概念，不要弄混淆了。同时这也带来了一些命名建议： 条件编译符号使用全大写命名 例如：DEBUG, RELEASE, NET47, NETCOREAPP2_1 配置使用 Pascal 命名 例如：Debug, Release " }, { "title": ".NET 应用启用与禁用自动生成绑定重定向 (bindingRedirect)，解决不同版本 dll 的依赖问题", "url": "/post/disable-generating-binding-redirects.html", "categories": "", "tags": "dotnet, visualstudio, msbuild", "date": "2019-04-12 09:40:20 +0800", "snippet": "当你的项目中多个不同的项目以及不同的依赖存在不同的依赖程序集时，可能会因为依赖于不同版本的程序集而产生冲突。而绑定重定向可以帮助解决不同程序集的依赖版本不同的问题，使整个程序使用统一个版本的 dll 来运行整个应用程序。然而，如果我们就是需要使用一个分离的不同版本，那么我们就需要禁用掉自动生成绑定重定向。本文介绍如何禁用自动生成绑定重定向。本文的结论只有一句，就是在项目中设置属性 &amp;lt;AutoGenerateBindingRedirects&amp;gt;false&amp;lt;/AutoGenerateBindingRedirects&amp;gt;。阅读本文全文是了解更多与绑定重定向此场景相关的知识。绑定重定向从 .NET Framework 4.5.1 开始到后面的 .NET Core 所有版本，编译器会自动向你的程序集中插入绑定重定向。如果你升级使用了新的 csproj 格式，即便你用了旧的 .NET Framework 也会自动生成绑定重定向。关于新旧 csproj 格式，你可以参考我的另一篇博客：将 WPF、UWP 以及其他各种类型的旧 csproj 迁移成 Sdk 风格的 csproj - walterlv。你可以在你的应用程序的 App.config 文件中查看到自动生成的绑定重定向。当然，编译之后这个 App.config 文件会编程 “你的程序集名称.config” 文件，例如对于我的 Walterlv.Demo.exe 程序对应 Walterlv.Demo.exe.config 文件。一个典型的包含绑定重定向的文件大概是下面这样的：&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;configuration&amp;gt; &amp;lt;startup useLegacyV2RuntimeActivationPolicy=&quot;true&quot;&amp;gt; &amp;lt;supportedRuntime version=&quot;v4.0&quot; sku=&quot;.NETFramework,Version=v4.6&quot; /&amp;gt; &amp;lt;/startup&amp;gt; &amp;lt;runtime&amp;gt; &amp;lt;assemblyBinding xmlns=&quot;urn:schemas-microsoft-com:asm.v1&quot;&amp;gt; &amp;lt;dependentAssembly&amp;gt; &amp;lt;assemblyIdentity name=&quot;Newtonsoft.Json&quot; publicKeyToken=&quot;30ad4fe6b2a6aeed&quot; culture=&quot;neutral&quot; /&amp;gt; &amp;lt;bindingRedirect oldVersion=&quot;0.0.0.0-11.0.0.0&quot; newVersion=&quot;11.0.0.0&quot; /&amp;gt; &amp;lt;/dependentAssembly&amp;gt; &amp;lt;dependentAssembly&amp;gt; &amp;lt;assemblyIdentity name=&quot;System.ValueTuple&quot; publicKeyToken=&quot;cc7b13ffcd2ddd51&quot; culture=&quot;neutral&quot; /&amp;gt; &amp;lt;bindingRedirect oldVersion=&quot;0.0.0.0-4.0.3.0&quot; newVersion=&quot;4.0.3.0&quot; /&amp;gt; &amp;lt;/dependentAssembly&amp;gt; &amp;lt;/assemblyBinding&amp;gt; &amp;lt;/runtime&amp;gt;&amp;lt;/configuration&amp;gt;上面 dependentAssembly 以及 bindingRedirect 就是在描述绑定重定向。对于上面的代码，指的是： 如果依赖中发现了任何 0.0.0.0-11.0.0.0 区间版本号的 Newtonsoft.Json 程序集的引用，都将使用 11.0.0.0 版本的。 如果以来中发现了任何 0.0.0.0-4.0.3.0 区间版本号的 System.ValueTuple 程序集的引用，都将使用 4.0.3.0 版本的（这个其实使用的 NuGet 包版本是 4.5）。引用同名但不同版本的 dll绑定重定向多数时候都是在帮助我们解决依赖问题，然而我们总有一些时候不是按照常规的方式来使用依赖，例如下文这样的方式： 引用不用版本dll - dang13579的专栏 - CSDN博客 C# 引用不同版本dll - 晒太阳的猫 同一个解决方案或有依赖关系的两个项目引用同名但不同版本的DLL - gudi - 博客园以上文章的场景，是需要在同一个解决方案的不同项目中引用不同版本的同名 dll。解决方法是像下面这样：&amp;lt;dependentAssembly&amp;gt; &amp;lt;assemblyIdentity name=&quot;LiteDB&quot; publicKeyToken=&quot;4ee40123013c9f27&quot; culture=&quot;neutral&quot; /&amp;gt; &amp;lt;codeBase version=&quot;2.0.2.0&quot; href=&quot;LiteDB.2.0.2.0\\LiteDB.dll&quot; /&amp;gt; &amp;lt;codeBase version=&quot;4.0.0.0&quot; href=&quot;LiteDB.4.0.0.0\\LiteDB.dll&quot; /&amp;gt;&amp;lt;/dependentAssembly&amp;gt;于是，如果引用了 2.0.2.0 版本的 LiteDB 的时候，会去应用程序所在目录的 LiteDB.2.0.2.0 子目录中查找名为 LiteDB.dll 的引用 dll；而如果引用了 4.0.0.0 版本的 LiteDB 的时候，会去应用程序所在目录的 LiteDB.4.0.0.0 子目录中查找名为 LiteDB.dll 的引用 dll。这种方式使用两个 dll 互不干扰。禁用绑定重定向如果你的项目从 .NET Framework 4.5 或者更早版本升级到 .NET Framework 4.5.1 或者 .NET Core 的版本，或者 csproj 的格式升级到了新的基于 Microsoft.NET.Sdk 的版本，那么绑定重定向就会从之前的手动编程自动生成。但是如果你编写了上一节中我们讲到的你需要引用同名程序集的多个版本的时候，如果依然自动生成绑定重定向，那么上面的功能会失效。解决方法，便是禁用自动生成绑定重定向。在你的主项目中添加一个属性：&amp;lt;AutoGenerateBindingRedirects&amp;gt;false&amp;lt;/AutoGenerateBindingRedirects&amp;gt;参考资料 Enable or disable autogenerated binding redirects - Microsoft Docs" }, { "title": "在 Visual Studio 新旧不同的 csproj 项目格式中启用混合模式调试程序（开启本机代码调试）", "url": "/post/visual-studio-enable-native-code-debugging.html", "categories": "", "tags": "visualstudio, dotnet, csharp", "date": "2019-04-12 09:40:06 +0800", "snippet": "因为我使用 Visual Studio 主要用来编写 .NET 托管程序，所以平时调试的时候是仅限托管代码的。不过有时需要在托管代码中混合调试本机代码，那么就需要额外在项目中开启本机代码调试。本文介绍如何开启本机代码调试。本文涉及到新旧 csproj 项目格式，不懂这个也不影响你完成开启本机代码调试。不过如果你希望了解，可以阅读：将 WPF、UWP 以及其他各种类型的旧 csproj 迁移成 Sdk 风格的 csproj - walterlv。在旧格式的项目中开启旧格式指的是 Visual Studio 2015 及以前版本的 Visual Studio 使用的项目格式。目前 Visual Studio 2017 和 2019 对这种格式的支持还是很完善的。在项目上右键 -&amp;gt; 属性 -&amp;gt; Debug，这时你可以在底部的调试引擎中发现 Enable native code debugging 选项，开启它你就开启了本机代码调试，于是也就可以使用混合模式调试程序。在新格式的项目中开启如果你在你项目属性的 Debug 标签下没有找到上面那个选项，那么有可能你的项目格式是新格式的。这个时候，你需要在 lauchsettings.json 文件中设置。这个文件在你项目的 Properties 文件夹下。如果你没有找到这个文件，那么随便在上图那个框框中写点什么（比如在启动参数一栏中写 吕毅是逗比），然后保存。我们就能得到一个 lauchsettings.json 文件。打开它，然后删掉刚刚的逗比行为，添加 &quot;nativeDebugging&quot;: true。这时，你的 lauchsettings.json 文件影响像下面这样：{ &quot;profiles&quot;: { &quot;Walterlv.Debugging&quot;: { &quot;commandName&quot;: &quot;Project&quot;, &quot;nativeDebugging&quot;: true } }}这时你就可以开启本机代码调试了。当然，新的项目格式支持设置多个这样的启动项，于是你可以分别配置本机和非本机的多种配置：{ &quot;profiles&quot;: { &quot;Walterlv.Debugging&quot;: { &quot;commandName&quot;: &quot;Project&quot; }, &quot;本机调试&quot;: { &quot;commandName&quot;: &quot;Project&quot;, &quot;nativeDebugging&quot;: true } }}现在，你可以选择你项目的启动方式了，其中一个是开启了本机代码调试的方式。关于这些配置的更多博客，你可以阅读：VisualStudio 使用多个环境进行调试 - 林德熙。参考资料 How to: Debug in Mixed Mode - Visual Studio - Microsoft Docs Tutorial: Debug C# and C++ code (mixed mode) - Visual Studio - Microsoft Docs" }, { "title": "Visual Studio 2017 以前的旧格式的 csproj Import 进来的 targets 文件有时不能正确计算属性（PropertyGroup）和集合（ItemGroup）", "url": "/post/properties-not-correct-in-targets-file-imported-to-old-csproj-file.html", "categories": "", "tags": "dotnet, visualstudio, msbuild, roslyn, nuget", "date": "2019-04-12 09:40:00 +0800", "snippet": "我在之前的博客中有教大家如何编写 NuGet 工具包，其中就有编写 .targets 文件。我在实际的使用中，发现 Visual Studio 2017 带来的 Sdk 风格的 csproj 格式基本上没有多少坑；然而旧的 csproj 文件却总是不能完美的运行，总是出错。关键是，不是每台电脑都出错，不是每个时机都出错。本文将讲一些坑。本文的前置知识你可能需要了解 csproj 文件的格式和编译过程，才可能读懂本文，所以需要先阅读： 理解 C# 项目 csproj 文件格式的本质和编译流程问题下面的代码来自 SourceFusion 项目的早期版本。这是一个 .targets 文件，项目安装此 NuGet 包之后就会自动 Import 这个 targets 文件。&amp;lt;Project&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;_DefaultSourceFusionWorkingFolder Condition=&quot;&#39;$(_DefaultSourceFusionWorkingFolder)&#39; == &#39;&#39;&quot;&amp;gt;obj\\$(Configuration)\\&amp;lt;/_DefaultSourceFusionWorkingFolder&amp;gt; &amp;lt;SourceFusionWorkingFolder Condition=&quot;&#39;$(SourceFusionWorkingFolder)&#39; == &#39;&#39;&quot;&amp;gt;$(_DefaultSourceFusionWorkingFolder)&amp;lt;/SourceFusionWorkingFolder&amp;gt; &amp;lt;SourceFusionToolsFolder&amp;gt;$(SourceFusionWorkingFolder)SourceFusion.Tools\\&amp;lt;/SourceFusionToolsFolder&amp;gt; &amp;lt;SourceFusionGeneratedCodeFolder&amp;gt;$(SourceFusionWorkingFolder)SourceFusion.GeneratedCodes\\&amp;lt;/SourceFusionGeneratedCodeFolder&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;Target Name=&quot;_SourceFusionCreateDirectories&quot; BeforeTargets=&quot;_SourceFusionWriteCompilingArgs;_SourceFusionWriteFilterArgs&quot;&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;SourceFusionDirectory Include=&quot;$(SourceFusionWorkingFolder)&quot; /&amp;gt; &amp;lt;SourceFusionDirectory Include=&quot;$(SourceFusionToolsFolder)&quot; /&amp;gt; &amp;lt;SourceFusionDirectory Include=&quot;$(SourceFusionGeneratedCodeFolder)&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;MakeDir Directories=&quot;@(SourceFusionDirectory)&quot; ContinueOnError=&quot;false&quot; /&amp;gt; &amp;lt;/Target&amp;gt;&amp;lt;/Project&amp;gt;代码的解读如下： 创建了一个私有属性 _DefaultSourceFusionWorkingFolder，三个公有属性 SourceFusionWorkingFolder、SourceFusionToolsFolder、SourceFusionGeneratedCodeFolder。 在编译期间，执行一个私有的 Target，收集所有收集到的文件夹，形成一个 SourceFusionDirectory 集合。然后将集合中的所有字符串视为文件夹，创建这几个文件夹。在新的有 Sdk 的 csproj 中，这个 targets 文件的执行没有问题。但是，对于旧的 csproj 来说，就经常出现这几个属性为空或者部分为空的情况。额外的，就算修改这个文件，上面的属性也不会生效。不过，如果使用命令行进行编译，这个却又是生效的。原因究其原因，这是 MSBuild 对项目文件（csproj）的解析和 Visual Studio 对项目文件的解析是不同的。命令行使用的是 MSBuild 解析 csproj，而 Visual Studio 使用的是 VSProjectSystem。对于 VSProjectSystem 来说，Project 根节点下的 PropertyGroup 和 ItemGroup 对不会更新。有时清除 Visual Studio 的项目缓存可以解决这个问题，但有时清除也不能解决。真实的原因我并没有调查出来。但以上代码在大多数开发者的 Visual Studio 中是可以正常使用的，但有少数开发者使用这个会出现错误（没有创建任何文件夹）。解决办法既然问题出在 MSBuild 和 VSProjectSystem 对属性和集合处理的不同，那么我就不要创建动态的集合，而是在 Target 内部编写属性和集合。在 Target 内部的属性和集合将在编译期间进行计算，而不是在 Visual Studio 打开的时候就计算好。于是我们每次编译的时候都可以获得最新的属性和集合的值。衍生知识旧格式的 csproj 是不会自动计算属性和集合的变更的，这也是为什么项目文件改变的时候，Visual Studio 需要重新加载项目才可以正常显示和编译项目。同时，如果编辑旧格式的 csproj 文件，也需要先卸载掉项目才可以。而新格式的 csproj 是可以直接编辑而不需要卸载项目的，同时如果被外部改变，也不需要重新加载项目，而是可以直接计算出来新的属性和集合。" }, { "title": "csproj 文件中那个空的 NuGetPackageImportStamp 是干什么的？", "url": "/post/the-empty-nuget-package-import-stamp.html", "categories": "", "tags": "visualstudio, nuget", "date": "2019-04-12 09:39:51 +0800", "snippet": "当我们在传统格式的 csproj 项目文件中安装 NuGet 包后，有时会在项目文件中发现空的 NuGetPackageImportStamp 节点。这个空的节点让我们这波强迫症患者觉得有点难以接受，关键是手工删除之后也没发现有什么副作用。那么为什么会出现这个节点？它究竟有什么作用？空的 NuGetPackageImportStamp 节点NuGetPackageImportStamp 节点只会出现在传统的 csproj 文件中。如果你不清楚我这里指的传统的和新的 csproj 文件格式，那么可以阅读我的另一篇文章来了了解它们的区别：将 WPF、UWP 以及其他各种类型的旧 csproj 迁移成 Sdk 风格的 csproj。简单说来，在 Project 根节点中可以指定 Sdk 特性的 csproj 文件格式是新的 csproj 格式。由于 Sdk 特性的存在，使得很多的项目文件的功能得以有一个默认的实现。而传统的 csproj 由于没有指定 Sdk 特性，所以很多的特性如果需要执行，需要先 Import 到 csproj 中，或者不断地修改 csproj 文件的内容以添加新的功能。空的 NuGetPackageImportStamp 节点只会出现在传统的 csproj 文件中。如果你使用新格式的 csproj 文件，那么无论你如何安装 NuGet 包，都是不会看到 NuGetPackageImportStamp 节点出现的。NuGetPackageImportStamp 在传统 csproj 文件中是这样的： &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt; &amp;lt;Project ToolsVersion=&quot;15.0&quot; xmlns=&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt;++ &amp;lt;NuGetPackageImportStamp&amp;gt;++ &amp;lt;/NuGetPackageImportStamp&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;/Project&amp;gt;文件已经经过过度简化，肯定是编译不过的了。不过，你可以意会。它会在某些 NuGet 包安装完后出现在 csproj 文件中。什么情况下会出现 NuGetPackageImportStamp 节点你也许会发现，并不是所有的 NuGet 包安装完后都会出现 NuGetPackageImportStamp 节点。实际上，只有那些会导致新 Import 文件部件的 NuGet 包才会出现这样的节点。我们来了做个实验。不会新增 NuGetPackageImportStamp在项目中安装 Newtonsoft.Json。安装完后，你会看到仓库中有两个文件发生了变化：▲ 两个文件发生了变化一个是 packages.config 文件，这是传统的 NuGet 包管理方式所需要的一个文件，用于记录当前项目中管理的 NuGet 包信息。 &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt; &amp;lt;packages&amp;gt;++ &amp;lt;package id=&quot;Newtonsoft.Json&quot; version=&quot;11.0.2&quot; targetFramework=&quot;net473&quot; /&amp;gt; &amp;lt;/packages&amp;gt;另一个是 csproj 文件： &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt; &amp;lt;Project ToolsVersion=&quot;15.0&quot; xmlns=&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;&amp;gt; &amp;lt;ItemGroup&amp;gt;++ &amp;lt;Reference Include=&quot;Newtonsoft.Json, Version=11.0.0.0, Culture=neutral, PublicKeyToken=30ad4fe6b2a6aeed, processorArchitecture=MSIL&quot;&amp;gt;++ &amp;lt;HintPath&amp;gt;..\\..\\packages\\Newtonsoft.Json.11.0.2\\lib\\net45\\Newtonsoft.Json.dll&amp;lt;/HintPath&amp;gt;++ &amp;lt;/Reference&amp;gt; &amp;lt;Reference Include=&quot;System&quot; /&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;/Project&amp;gt;我们发现，安装 Newtonsoft.Json 是不会导致项目中新增 NuGetPackageImportStamp 节点的。会新增 NuGetPackageImportStamp现在，我们换另一个 NuGet 包来安装：StyleCop.MSBuild。同样是两个文件的变化，一个是 packages.config 文件。 &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt; &amp;lt;packages&amp;gt;++ &amp;lt;package id=&quot;StyleCop.MSBuild&quot; version=&quot;5.0.0&quot; targetFramework=&quot;net471&quot; developmentDependency=&quot;true&quot; /&amp;gt; &amp;lt;/packages&amp;gt;另一个是 csproj 文件： &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt; &amp;lt;Project ToolsVersion=&quot;15.0&quot; xmlns=&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;&amp;gt; &amp;lt;Import Project=&quot;..\\..\\packages\\StyleCop.MSBuild.5.0.0\\build\\StyleCop.MSBuild.targets&quot; Condition=&quot;Exists(&#39;..\\..\\packages\\StyleCop.MSBuild.5.0.0\\build\\StyleCop.MSBuild.targets&#39;)&quot; /&amp;gt; &amp;lt;PropertyGroup&amp;gt;++ &amp;lt;NuGetPackageImportStamp&amp;gt;++ &amp;lt;/NuGetPackageImportStamp&amp;gt; &amp;lt;/PropertyGroup&amp;gt;++ &amp;lt;Target Name=&quot;EnsureNuGetPackageBuildImports&quot; BeforeTargets=&quot;PrepareForBuild&quot;&amp;gt;++ &amp;lt;PropertyGroup&amp;gt;++ &amp;lt;ErrorText&amp;gt;This project references NuGet package(s) that are missing on this computer. Use NuGet Package Restore to download them. For more information, see http://go.microsoft.com/fwlink/?LinkID=322105. The missing file is {0}.&amp;lt;/ErrorText&amp;gt;++ &amp;lt;/PropertyGroup&amp;gt;++ &amp;lt;Error Condition=&quot;!Exists(&#39;..\\..\\packages\\StyleCop.MSBuild.5.0.0\\build\\StyleCop.MSBuild.targets&#39;)&quot; Text=&quot;$([System.String]::Format(&#39;$(ErrorText)&#39;, &#39;..\\..\\packages\\StyleCop.MSBuild.5.0.0\\build\\StyleCop.MSBuild.targets&#39;))&quot; /&amp;gt;++ &amp;lt;/Target&amp;gt; &amp;lt;/Project&amp;gt;我们发现，安装此 StyleCop.MSBuild NuGet 包的情况下，csproj 文件中新增了两个大的内容块： NuGetPackageImportStamp 用于 Import 一个 targets 文件的 TargetNuGetPackageImportStamp 的出现目的我们发现 NuGetPackageImportStamp 其实是伴随着 Import 而出现的。而微软官方的注释也是诡异地说出了它的原因： The overrides should ensure that Sets NuGetPackageImportStamp to a new random guid.This is a hack to let the project system know it is out of date.The value does not matter, it just needs to change.这是为了让 Visual Studio 运行的时候，能够检测到 csproj 文件改变，以便重新加载这个项目，因为需要 Import 新的内容。在以前的 Visual Studio 版本中，会随机写下一段字符串；在新的版本中，它是个空字符串。由于新的 csproj 文件能够识别到外部 Import 文件的改变，所以其实并不需要这样的机制来让 Visual Studio 感知到文件的改变。在 Visual Studio 2017（工具版本 15.0）中，这个值会设为空，而在较低版本（14.0 及以下）这个值会设为一个随机的 guid。以下是 NuGet 客户端设置此值的代码：/// &amp;lt;summary&amp;gt;/// This method should be on the UI thread. The overrides should ensure that/// Sets NuGetPackageImportStamp to a new random guid. This is a hack to let the project system know it is out/// of date./// The value does not matter, it just needs to change./// &amp;lt;/summary&amp;gt;protected static void UpdateImportStamp(IVsProjectAdapter vsProjectAdapter){ ThreadHelper.ThrowIfNotOnUIThread(); var propStore = vsProjectAdapter.VsHierarchy as IVsBuildPropertyStorage; if (propStore != null) { // &amp;lt;NuGetPackageImportStamp&amp;gt;af617720&amp;lt;/NuGetPackageImportStamp&amp;gt; var stamp = Guid.NewGuid().ToString().Split(&#39;-&#39;)[0]; try { propStore.SetPropertyValue(NuGetImportStamp, string.Empty, (uint)_PersistStorageType.PST_PROJECT_FILE, stamp); } catch (Exception ex1) { ExceptionHelper.WriteErrorToActivityLog(ex1); } // Remove the NuGetImportStamp so that VC++ project file won&#39;t be updated with this stamp on disk, // which causes unnecessary source control pending changes. try { propStore.RemoveProperty(NuGetImportStamp, string.Empty, (uint)_PersistStorageType.PST_PROJECT_FILE); } catch (Exception ex2) { ExceptionHelper.WriteErrorToActivityLog(ex2); } }}" }, { "title": ".NET/C# 中你可以在代码中写多个 Main 函数，然后按需要随时切换", "url": "/post/write-multiple-main-and-related-startup-codes.html", "categories": "", "tags": "dotnet, csharp, msbuild", "date": "2019-04-12 09:39:32 +0800", "snippet": ".NET/C# 程序从 Main 函数开始执行，基本上各种书籍资料都是这么写的。不过，我们可以写多个 Main 函数，然后在项目文件中设置应该选择哪一个 Main 函数。你可能会觉得这样没有什么用，不过如果你的应用程序在不同的编译条件下有不同的启动代码，或者你需要持续去大范围修改启动代码，那么做一个 Main 函数的选择器是一个不错的选择。在哪里选择 Main？在带有 Main 函数的项目上 “右键 -&amp;gt; 属性 -&amp;gt; 应用 -&amp;gt; 启动对象”，可以看到我们的 Main 函数，默认值是 “未设置”。▲ 选择 Main 函数在我们保持这个值没有设置的情况下，如果写两个 Main 函数，那么就会出现编译错误。Error CS0017Program has more than one entry point defined. Compile with /main to specify the type that contains the entry point.Walterlv.Demo.Main C:\\Users\\lvyi\\Desktop\\Walterlv.Demo.Main\\Walterlv.Demo.Main\\NewProgram.cs这时，从两个 Main 函数中选择一个就好了。▲ 选择一个 Main 函数我们准备一个 WPF 程序现在，我们来一些更复杂的操作。现在把我们的项目换成一个普通的 WPF 项目。▲ 普通 WPF 项目把启动对象换成 Walterlv.Demo.App：于是，我们可以启动我们的 WPF 项目。▲ 新启动的 WPF 程序这是个 Demo 程序，代码比较简单。值得注意的是，如果使用新的 csproj 文件，其内容如下：&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;OutputType&amp;gt;Exe&amp;lt;/OutputType&amp;gt; &amp;lt;TargetFramework&amp;gt;net472&amp;lt;/TargetFramework&amp;gt; &amp;lt;LanguageTargets&amp;gt;$(MSBuildToolsPath)\\Microsoft.CSharp.targets&amp;lt;/LanguageTargets&amp;gt; &amp;lt;RootNamespace&amp;gt;Walterlv.Demo&amp;lt;/RootNamespace&amp;gt; &amp;lt;StartupObject&amp;gt;Walterlv.Demo.App&amp;lt;/StartupObject&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;Reference Include=&quot;PresentationCore&quot; /&amp;gt; &amp;lt;Reference Include=&quot;PresentationFramework&quot; /&amp;gt; &amp;lt;Reference Include=&quot;System.Xaml&quot; /&amp;gt; &amp;lt;Reference Include=&quot;WindowsBase&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;ApplicationDefinition Include=&quot;App.xaml&quot; SubType=&quot;Designer&quot; Generator=&quot;MSBuild:Compile&quot; /&amp;gt; &amp;lt;Page Include=&quot;**\\*.xaml&quot; Exclude=&quot;App.xaml&quot; SubType=&quot;Designer&quot; Generator=&quot;MSBuild:Compile&quot; /&amp;gt; &amp;lt;Compile Update=&quot;**\\*.xaml.cs&quot; DependentUpon=&quot;%(Filename)&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt;&amp;lt;/Project&amp;gt;你可以通过阅读 将 WPF、UWP 以及其他各种类型的旧 csproj 迁移成 Sdk 风格的 csproj 完成这样的新旧格式迁移。App.xaml 中保持默认的代码即可：&amp;lt;Application x:Class=&quot;Walterlv.Demo.App&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;&amp;gt;&amp;lt;/Application&amp;gt;App.xaml.cs 中的代码比较简单，就是启动一个 MainWindow：using System.Windows;namespace Walterlv.Demo{ public partial class App : Application { protected override void OnStartup(StartupEventArgs e) { var window = new MainWindow(); window.Show(); base.OnStartup(e); } }}这时，我们的 Program 和 NewProgram 还是保持之前的代码不变，因为我们的启动对象已经被设置为了 Walterlv.Demo.App，所以这里的两个 Main 函数其实并没有起作用。根据启动对象的不同，控制不同的启动流程现在，我们即将实现一个功能： 当在属性页中切换启动对象的时候，我们的启动流也能跟着改变。具体来说，我们的 Program 启动一个 App，而 NewProgram 启动另一个 App。于是，我们在 App.xaml.cs 之外再新建一个 App.new.xaml.cs。这两个 App 类可以共用一个 App.xaml 文件。于是我们需要修改 csproj 的代码（以下红色表示删除的行，绿色表示新增的行）： &amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;OutputType&amp;gt;Exe&amp;lt;/OutputType&amp;gt; &amp;lt;TargetFramework&amp;gt;net472&amp;lt;/TargetFramework&amp;gt; &amp;lt;LanguageTargets&amp;gt;$(MSBuildToolsPath)\\Microsoft.CSharp.targets&amp;lt;/LanguageTargets&amp;gt; &amp;lt;RootNamespace&amp;gt;Walterlv.Demo&amp;lt;/RootNamespace&amp;gt;- &amp;lt;StartupObject&amp;gt;Walterlv.Demo.App&amp;lt;/StartupObject&amp;gt;+ &amp;lt;StartupObject&amp;gt;Walterlv.Demo.NewProgram&amp;lt;/StartupObject&amp;gt; &amp;lt;/PropertyGroup&amp;gt;+ &amp;lt;PropertyGroup Condition=&quot; &#39;$(StartupObject)&#39; == &#39;Walterlv.Demo.Program&#39; &quot;&amp;gt;+ &amp;lt;!-- 启用原启动流中的 App.xaml.cs 文件 --&amp;gt;+ &amp;lt;AppCsPath&amp;gt;App.xaml.cs&amp;lt;/AppCsPath&amp;gt;+ &amp;lt;/PropertyGroup&amp;gt;+ &amp;lt;PropertyGroup Condition=&quot; &#39;$(StartupObject)&#39; == &#39;Walterlv.Demo.NewProgram&#39; &quot;&amp;gt;+ &amp;lt;!-- 启用新启动流中的 App.xaml.cs 文件 --&amp;gt;+ &amp;lt;AppCsPath&amp;gt;App.new.xaml.cs&amp;lt;/AppCsPath&amp;gt;+ &amp;lt;/PropertyGroup&amp;gt;+ &amp;lt;ItemGroup&amp;gt; &amp;lt;Reference Include=&quot;PresentationCore&quot; /&amp;gt; &amp;lt;Reference Include=&quot;PresentationFramework&quot; /&amp;gt; &amp;lt;Reference Include=&quot;System.Xaml&quot; /&amp;gt; &amp;lt;Reference Include=&quot;WindowsBase&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;ApplicationDefinition Include=&quot;App.xaml&quot; SubType=&quot;Designer&quot; Generator=&quot;MSBuild:Compile&quot; /&amp;gt; &amp;lt;Page Include=&quot;**\\*.xaml&quot; Exclude=&quot;App.xaml&quot; SubType=&quot;Designer&quot; Generator=&quot;MSBuild:Compile&quot; /&amp;gt; &amp;lt;Compile Update=&quot;**\\*.xaml.cs&quot; DependentUpon=&quot;%(Filename)&quot; /&amp;gt;+ &amp;lt;!-- 删掉两个 App.xaml.cs 文件，以便后面可以重新添加 --&amp;gt;+ &amp;lt;Compile Remove=&quot;App.xaml.cs&quot; /&amp;gt;+ &amp;lt;Compile Remove=&quot;App.new.xaml.cs&quot; /&amp;gt;+ &amp;lt;Compile Include=&quot;$(AppCsPath)&quot; DependentUpon=&quot;App.xaml&quot; SubType=&quot;Designer&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;/Project&amp;gt;增加的判断其实是根据 $(StartupObject) 值的不同，设置不同的 App.xaml.cs 文件与 App.xaml 文件对应。于是，我们也可以有不同的 App.xaml.cs 文件了。比如我们的 App.new.xaml.cs 文件中的内容就与 App.xaml.cs 中的不一样。using System.Windows;namespace Walterlv.Demo{ public partial class App : Application { protected override void OnStartup(StartupEventArgs e) { var window = new MainWindow { Title = &quot;New Walterlv Demo&quot;, }; window.Show(); base.OnStartup(e); } }}在新的文件中，我们修改了窗口的标题。▲ 新设置的窗口标题通过切换启动对象，我们的解决方案窗格中也能显示不同的 App.xaml.cs 文件。（不过需要提醒，可能需要卸载然后重新加载项目才会看到修改；否则只是能够编译通过，但看不见文件。）▲ 可以看得见两个文件的切换由于 window 是局部变量，所以 Main 函数中是不能修改到的。而采用了这种根据启动对象不同动态改变 App.xaml.cs 的方式解决了这个问题。将不同的文件换成不同的条件编译符如果你的启动流程差异并不是那么大，那么也可以使用条件编译符的定义来替代整个文件的替换。 &amp;lt;PropertyGroup Condition=&quot; &#39;$(StartupObject)&#39; == &#39;Walterlv.Demo.Program&#39; &quot;&amp;gt;- &amp;lt;AppCsPath&amp;gt;App.xaml.cs&amp;lt;/AppCsPath&amp;gt;+ &amp;lt;DefineConstants&amp;gt;$(DefineConstants);OLD&amp;lt;/DefineConstants&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;PropertyGroup Condition=&quot; &#39;$(StartupObject)&#39; == &#39;Walterlv.Demo.NewProgram&#39; &quot;&amp;gt;- &amp;lt;AppCsPath&amp;gt;App.new.xaml.cs&amp;lt;/AppCsPath&amp;gt;+ &amp;lt;DefineConstants&amp;gt;$(DefineConstants);NEW&amp;lt;/DefineConstants&amp;gt; &amp;lt;/PropertyGroup&amp;gt;这时，可以通过条件编译符来控制新旧启动代码： using System.Windows; namespace Walterlv.Demo { public partial class App : Application { protected override void OnStartup(StartupEventArgs e) { var window = new MainWindow()+ #if NEW { Title = &quot;New Walterlv Demo&quot;, };+ #endif window.Show(); base.OnStartup(e); } } }" }, { "title": "阻止某个 NuGet 包意外升级", "url": "/post/prevent-nuget-package-upgrade.html", "categories": "", "tags": "dotnet, visualstudio, nuget", "date": "2019-04-12 09:38:45 +0800", "snippet": "出于兼容性考虑，我们可能不再更新某个项目的 NuGet 包。典型的情况是软件版本进行了大规模的不兼容的升级，需要对旧格式的数据进行读取，以便迁移到新格式的数据。然而，团队开发的软件可能因为某个小伙伴不知道这样的历史问题，从而手抖将某个不应该更新的 NuGet 包更新了，于是迁移就挂了。本文提供了一种方法来避免某些特定 NuGet 包的升级。如果你只关心结果，请直接前往最后一节：终极解决方案准备工作本文提供的方法仅适用于使用了 Sdk 风格的 csproj 项目文件。（当然并不是说旧的 csproj 不能使用这种方法，只是写法上会有差别，我没有去研究如何编写。）如果你的项目还在使用旧的 csproj 格式，推荐阅读 将 WPF、UWP 以及其他各种类型的旧 csproj 迁移成 Sdk 风格的 csproj 迁移成新格式之后再开始。作为例子，假设我们的项目文件是这样的：&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;TargetFramework&amp;gt;net47&amp;lt;/TargetFramework&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;PackageReference Include=&quot;LiteDB&quot; Version=&quot;2.0.2&quot; /&amp;gt; &amp;lt;PackageReference Include=&quot;Newtonsoft.Json&quot; Version=&quot;11.0.2&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt;&amp;lt;/Project&amp;gt;LiteDB 是一个不应该被升级的 NuGet 包，但是最新版本已经是 4.1.4 了，很容易被团队中的其他小伙伴误升级。▲ 当小伙伴打开包管理器的时候，会发现包版本不一致，然后就不小心升级了思路NuGet 使用 PackageReference 来管理所有的包引用，于是我试图通过隐藏 LiteDB 的 PackageReference 节点来达到目的。而一个典型的隐藏方法便是使用 Target。不在 Target 里面的属性和项是提前计算好的，而 Target 里面的属性和项是编译时才计算的。可以通过阅读 如何编写基于 Microsoft.NET.Sdk 的跨平台的 MSBuild Target 了解更多 Target 的知识。所以，我写了这样的 Target，然后去掉前面的 PackageReference。&amp;lt;!-- 其实这种改法并没有作用，可谁知道呢！ --&amp;gt;&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;TargetFramework&amp;gt;net47&amp;lt;/TargetFramework&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;!-- 在这里把之前的 LiteDB 去掉了。 --&amp;gt; &amp;lt;PackageReference Include=&quot;Newtonsoft.Json&quot; Version=&quot;11.0.2&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;!-- 这是新写的 Target，用来在编译期间引用 LiteDB。不过我不知道应该在什么时机执行。 --&amp;gt; &amp;lt;Target Name=&quot;ReferenceStaticLegacyPackage&quot; BeforeTargets=&quot;???&quot;&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;PackageReference Include=&quot;LiteDB&quot; Version=&quot;2.0.2&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;/Target&amp;gt;&amp;lt;/Project&amp;gt;还留了一个 BeforeTargets 没有填，因为并不知道应该填什么。于是我打开了 Microsoft.NET.Sdk 的文件夹 C:\\Program Files\\dotnet\\sdk\\2.1.300\\Sdks，试图寻找时机。搜索 @(PackageReference) 发现有很多的 Target 都依赖于一个名为 CollectPackageReferences 的 Target。&amp;lt;Target Name=&quot;CollectResolvedSDKReferencesDesignTime&quot; Returns=&quot;@(_ResolvedSDKReference)&quot; DependsOnTargets=&quot;ResolveSDKReferencesDesignTime;CollectPackageReferences&quot;&amp;gt; &amp;lt;!-- 省略 --&amp;gt;&amp;lt;/Target&amp;gt;从名称上可以猜测这是用来收集 PackageReference 的 Target。于是我可以将我们的 BeforeTargets 指定为 CollectPackageReferences。不过我发现在这种情况下，NuGet 包管理器的界面中能够发现这个项目使用了旧版本。并且在安装了新版本的包后，将因为多次引用不同版本而导致编译不通过。所以，方案否决。最终解决既然无法阻止发现这个 NuGet 包，那思路就换成无论如何更新，都无效好了。于是，通过 Remove 和重新 Include 固定版本来解决。下面是项目的最终解决源码：&amp;lt;!-- 其实这种改法并没有作用，可谁知道呢！ --&amp;gt;&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;TargetFramework&amp;gt;net47&amp;lt;/TargetFramework&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;!-- 无论这里版本填写多少，都不会有效。 --&amp;gt; &amp;lt;PackageReference Include=&quot;LiteDB&quot; Version=&quot;4.1.4&quot; /&amp;gt; &amp;lt;PackageReference Include=&quot;Newtonsoft.Json&quot; Version=&quot;11.0.2&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;!-- 通过移除正常的引用并替换成固定版本的引用，达到无论如何更新都无法生效的目的。 --&amp;gt; &amp;lt;Target Name=&quot;ReferenceStaticLegacyPackage&quot; BeforeTargets=&quot;CollectPackageReferences&quot;&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;PackageReference Remove=&quot;LiteDB&quot; /&amp;gt; &amp;lt;PackageReference Include=&quot;LiteDB&quot; Version=&quot;2.0.2&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;/Target&amp;gt;&amp;lt;/Project&amp;gt;在这种 Target 的帮助下，无论如何更新 LiteDB 的 NuGet 版本，都能更新成功，但无法生效。" }, { "title": "Sdk 风格的 csproj 对 WPF/UWP 支持不太好？有第三方 SDK 可以用！MSBuild.Sdk.Extras", "url": "/post/use-msbuild-sdk-extras-for-wpf-and-uwp.html", "categories": "", "tags": "visualstudio, dotnet, csharp, msbuild", "date": "2019-04-12 09:38:30 +0800", "snippet": "自从微软推出 .NET Core 以来，新的项目文件格式以其优秀的可扩展性正吸引着更多项目采用。然而——微软官方的 WPF/UWP 项目模板依然还在采用旧的 csproj 格式！这只是因为——在 .NET Core 3.0 以前，基于 Microsoft.NET.Sdk 的官方 SDK 依然对 WPF/UWP 支持不够友好。为什么要使用第三方的 SDK？关于项目文件格式的迁移，我和 林德熙 都写过文章： 从以前的项目格式迁移到 VS2017 新项目格式 - 林德熙 将 WPF、UWP 以及其他各种类型的旧 csproj 迁移成 Sdk 风格的 csproj - 吕毅不过，这两篇文章中的迁移方法都是手动或半自动迁移的。而且迁移完毕之后，对新增的 WPF/UWP XAML 文件的支持非常不友好——新增的 XAML 文件是看不见的，除非手工去 csproj 文件中去掉自动生成的 Remove XAML 的代码。这确实阻碍着我们在 WPF/UWP 项目中体会到新风格 csproj 的好处。微软在 Build 2018 大会上宣布，WPF/UWP 将能够在 .NET Core 3 中运行。想必，微软会为未来版本的 Microsoft.NET.Sdk 这样的官方 SDK 添加更多的 WPF/UWP 这类格式的支持吧！即便没有这样的原生支持，想必也会提供官方的扩展方案。但在此之前呢？感谢小伙伴 KodamaSakuno (神樹桜乃) 提醒我第三方 SDK 的存在 —— MSBuild.Sdk.Extras。我想，在 .NET Core 3 推出之前，这是一种不错的中转方案。既能体会到新风格 csproj 格式的好处，也能在将来 .NET Core 3 官方支持后较快地迁移成官方版本。如何使用 MSBuild.Sdk.Extras虽说是第三方 SDK，但实际使用的方便程度却如官方般简洁！只需要将 SDK 替换成 MSBuild.Sdk.Extras/1.6.41 即可。1.6.41 是目前 MSBuild.Sdk.Extras 在 NuGet 上的最新版本，建议访问 NuGet Gallery - MSBuild.Sdk.Extras 使用最新稳定版本。以下是最简同时支持 WPF 和 UWP 双框架的代码：&amp;lt;Project Sdk=&quot;MSBuild.Sdk.Extras/1.6.41&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;TargetFrameworks&amp;gt;net471;uap10.0.17134&amp;lt;/TargetFrameworks&amp;gt; &amp;lt;/PropertyGroup&amp;gt;&amp;lt;/Project&amp;gt;▲ 在刚刚指定完 uap10.0.17134 之后，等待 Visual Studio 还原需要等待好几分钟。另外，从 1.6.0 版本开始，为 WPF 和 Windows Forms 分别新增了一个属性，用于默认引用 WPF 或 Windows Forms 所需的程序集。&amp;lt;Project Sdk=&quot;MSBuild.Sdk.Extras/1.6.41&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;TargetFramework&amp;gt;net471&amp;lt;/TargetFramework&amp;gt; &amp;lt;!-- 以下是默认引用 WPF 相关依赖的属性 --&amp;gt; &amp;lt;ExtrasEnableWpfProjectSetup&amp;gt;true&amp;lt;/ExtrasEnableWpfProjectSetup&amp;gt; &amp;lt;!-- 以下是默认引用 Windows Forms 相关依赖的属性 --&amp;gt; &amp;lt;!-- &amp;lt;ExtrasEnableWinFormsProjectSetup &amp;gt;true&amp;lt;/ExtrasEnableWinFormsProjectSetup&amp;gt; --&amp;gt; &amp;lt;/PropertyGroup&amp;gt;&amp;lt;/Project&amp;gt;从下图我们可以看出，设置 ExtrasEnableWpfProjectSetup 为 true 后，WPF 的类型将直接可用，而无需额外引用。（当然，不设置也是可以的，只是需要手动引用。）没错，真的如此简单！在我们猜测的 .NET Core 3 支持 WPF/UWP 项目格式之前，这应该算是最简单的迁移方案了！至于项目结构的效果，可以看下图所示（包含 UWP 的多目标）：相比于此前的手工迁移，使用此新格式创建出来的 XAML 文件是可见的，而且 .xaml.cs 也是折叠在 .xaml 之下，且能正常编译！（当然，咱们还得考虑 UWP 和 WPF 在 XAML 书写上的细微差异）官方提供了更多的使用方法，例如更简单的是安装 NuGet 包，而不修改 SDK。详见：onovotny/MSBuildSdkExtras: Extra properties for MSBuild SDK projects。参考资料 onovotny/MSBuildSdkExtras: Extra properties for MSBuild SDK projects" }, { "title": "如何最快速地将旧的 NuGet 包 (2.x, packages.config) 升级成新的 NuGet 包 (4.x, PackageReference) ", "url": "/post/migrate-nuget-package-from-powershell-to-props-and-targets.html", "categories": "", "tags": "visualstudio, nuget, msbuild", "date": "2019-04-12 09:37:27 +0800", "snippet": "最近我将项目格式进行了升级，从旧的 csproj 升级成了新的 csproj；NuGet 包管理的方式也从 packages.config 升级成了 PackageReference。然而迁移完才发现，这个项目竟然还依赖了大量的从 NuGet 2.x 时代发布的 NuGet 包，这些包并不能在 PackageReference 下好好工作。于是，我准备将所有这些包都进行升级。本文将介绍最简单的升级步骤。回顾遇到的问题如果你之前迁移过 csproj 文件，可能会遇到问题。关于迁移 csproj 文件，可以阅读：将 WPF、UWP 以及其他各种类型的旧 csproj 迁移成 Sdk 风格的 csproj - 吕毅。如果你并没有迁移过 csproj 文件，只是升级了 NuGet 的包管理方式，也可能会遇到问题。关于自动迁移 NuGet 包管理方式，可以阅读：自动将 NuGet 包的引用方式从 packages.config 升级为 PackageReference - 吕毅。在自动迁移那篇文章中，我提到了一些兼容性问题，最大的莫过于 Install.ps1 脚本不再执行： 使用 PackageReference 后，在安装和写在的过程中 install.ps1 脚本将不再执行。如果有一些行为依赖于此脚本，那么这个 NuGet 包的行为可能不正常。 但是，不用担心！install.ps1 的存在是因为 packages.config 不支持 PackageReference 中的一些新特性（例如 NuGet 包中新的目录结构，例如包中自带的 msbuild targets）。所以，如果 NuGet 包在发布时满足目录要求，那么即便 install.ps1 不用执行也能保证包的行为正常。虽然我提到不用担心，但其实旧的一些包里并没有准备 build 文件夹，也没有准备 props 或者 targets 文件。所以一小部分特别依赖于 install.ps1 的 NuGet 包是没有办法在新格式中生效的。最简升级步骤知道了问题所在，那么我们的根本便是将 Install.ps1 升级成新的 props 或者 targets。如果你不清楚 props 或者 targets 是什么意思，或者不知道怎么写它们，可以阅读我的另一篇文章理解 C# 项目 csproj 文件格式的本质和编译流程 - 吕毅。第一步：将 install.ps1 翻译成 targets最简单的方法，直接去安装好 NuGet 的项目的 csproj 文件中去看究竟生成了那些代码。一般来说，这些 install.ps1 中多是生成 Target 节点。而我们要做的，就是新建一个 build 文件夹，在其中新建 PackageId.targets 文件，以便将生成的 Target 节点中的内容复制过去。前面那一句的 PackageId 指的是这个 NuGet 包的包 Id。比如，在我的例子中，是 Walterlv.NuGetDemo.targets。比如，生成的 Target 节点是这样的：&amp;lt;!-- 项目 csproj 文件 --&amp;gt;&amp;lt;Target Name=&quot;WalterlvNuGetDemo&quot; BeforeTargets=&quot;AfterCompile&quot;&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;BinCopyItems Include=&quot;..\\..\\packages\\Walterlv.NuGetDemo.1.2.3.0\\tools\\bin\\*.*&quot; /&amp;gt; &amp;lt;x64CopyItems Include=&quot;..\\..\\packages\\Walterlv.NuGetDemo.1.2.3.0\\tools\\bin_x64\\*.*&quot; /&amp;gt; &amp;lt;x86CopyItems Include=&quot;..\\..\\packages\\Walterlv.NuGetDemo.1.2.3.0\\tools\\bin_x86\\*.*&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;Copy SourceFiles=&quot;@(BinCopyItems)&quot; DestinationFolder=&quot;$(OutputPath)&quot; SkipUnchangedFiles=&quot;True&quot; /&amp;gt; &amp;lt;Copy SourceFiles=&quot;@(x86CopyItems)&quot; DestinationFolder=&quot;$(OutputPath)x86&quot; SkipUnchangedFiles=&quot;True&quot; /&amp;gt; &amp;lt;Copy SourceFiles=&quot;@(x64CopyItems)&quot; DestinationFolder=&quot;$(OutputPath)x64&quot; SkipUnchangedFiles=&quot;True&quot; /&amp;gt;&amp;lt;/Target&amp;gt;那么，直接将这些文件复制到 PackageId.targets 文件中：&amp;lt;!-- Walterlv.NuGetDemo.targets 文件 --&amp;gt;&amp;lt;Project&amp;gt; &amp;lt;Target Name=&quot;WalterlvNuGetDemo&quot; BeforeTargets=&quot;AfterCompile&quot;&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;BinCopyItems Include=&quot;..\\..\\packages\\Walterlv.NuGetDemo.1.2.3.0\\tools\\bin\\*.*&quot; /&amp;gt; &amp;lt;x64CopyItems Include=&quot;..\\..\\packages\\Walterlv.NuGetDemo.1.2.3.0\\tools\\bin_x64\\*.*&quot; /&amp;gt; &amp;lt;x86CopyItems Include=&quot;..\\..\\packages\\Walterlv.NuGetDemo.1.2.3.0\\tools\\bin_x86\\*.*&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;Copy SourceFiles=&quot;@(BinCopyItems)&quot; DestinationFolder=&quot;$(OutputPath)&quot; SkipUnchangedFiles=&quot;True&quot; /&amp;gt; &amp;lt;Copy SourceFiles=&quot;@(x86CopyItems)&quot; DestinationFolder=&quot;$(OutputPath)x86&quot; SkipUnchangedFiles=&quot;True&quot; /&amp;gt; &amp;lt;Copy SourceFiles=&quot;@(x64CopyItems)&quot; DestinationFolder=&quot;$(OutputPath)x64&quot; SkipUnchangedFiles=&quot;True&quot; /&amp;gt; &amp;lt;/Target&amp;gt;&amp;lt;/Project&amp;gt;然后，修改其中的路径，将相对于安装项目路径的地方更换成相对于此 targets 文件的路径：&amp;lt;!-- Walterlv.NuGetDemo.targets 文件 --&amp;gt;&amp;lt;Project&amp;gt; &amp;lt;Target Name=&quot;WalterlvNuGetDemo&quot; BeforeTargets=&quot;AfterCompile&quot;&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;BinCopyItems Include=&quot;$(MSBuildThisFileDirectory)..\\tools\\bin\\*.*&quot; /&amp;gt; &amp;lt;x64CopyItems Include=&quot;$(MSBuildThisFileDirectory)..\\tools\\bin_x64\\*.*&quot; /&amp;gt; &amp;lt;x86CopyItems Include=&quot;$(MSBuildThisFileDirectory)..\\tools\\bin_x86\\*.*&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;Copy SourceFiles=&quot;@(BinCopyItems)&quot; DestinationFolder=&quot;$(OutputPath)&quot; SkipUnchangedFiles=&quot;True&quot; /&amp;gt; &amp;lt;Copy SourceFiles=&quot;@(x86CopyItems)&quot; DestinationFolder=&quot;$(OutputPath)x86&quot; SkipUnchangedFiles=&quot;True&quot; /&amp;gt; &amp;lt;Copy SourceFiles=&quot;@(x64CopyItems)&quot; DestinationFolder=&quot;$(OutputPath)x64&quot; SkipUnchangedFiles=&quot;True&quot; /&amp;gt; &amp;lt;/Target&amp;gt;&amp;lt;/Project&amp;gt;第二步：修改 nuspec 文件，加入 targets接着，去 nuspec 文件中，删除 Install.ps1 和 Uninstall.ps1，然后新增我们刚刚写的 targets 文件。&amp;lt;files&amp;gt; &amp;lt;!-- 省略其他一些文件 --&amp;gt; &amp;lt;file src=&quot;tools\\bin\\DemoNativeLib.dll&quot; target=&quot;tools\\bin&quot;/&amp;gt; &amp;lt;!-- 删除 &amp;lt;file src=&quot;tools\\Install.ps1&quot; target=&quot;tools&quot;/&amp;gt; --&amp;gt; &amp;lt;!-- 删除 &amp;lt;file src=&quot;tools\\Uninstall.ps1&quot; target=&quot;tools&quot;/&amp;gt; --&amp;gt; &amp;lt;!-- 省略其他一些文件 --&amp;gt; &amp;lt;file src=&quot;build\\Walterlv.NuGetDemo.targets&quot; target=&quot;build&quot;/&amp;gt;&amp;lt;/files&amp;gt;重新打包和测试 NuGet 包以上改完了之后，基本上就迁移完了。这样的改动是最小的，既能够保证旧的 packages.config 能够顺利迁移，也能保证新的 PackageReference 行为保持不变。" }, { "title": "理解 C# 项目 csproj 文件格式的本质和编译流程", "url": "/post/understand-the-csproj.html", "categories": "", "tags": "visualstudio, msbuild", "date": "2019-04-12 09:37:21 +0800", "snippet": "写了这么多个 C# 项目，是否对项目文件 csproj 有一些了解呢？Visual Studio 是怎么让 csproj 中的内容正确显示出来的呢？更深入的，我能够自己扩展 csproj 的功能吗？本文将直接从 csproj 文件格式的本质来看以上这些问题。阅读本文，你将： 可以通读 csproj 文件，并说出其中每一行的含义 可以手工修改 csproj 文件，以实现你希望达到的高级功能（更高级的，可以开始写个工具自动完成这样的工作了） 理解新旧 csproj 文件的差异，不至于写工具解析和修改 csproj 文件的时候出现不兼容的错误csproj 里面是什么？总览 csproj 文件相信你一定见过传统的 csproj 文件格式。就算你几乎从来没主动去看过里面的内容，在版本管理工具中解冲突时也在里面修改过内容。不管你是新手还是老手，一定都会觉得这么长这么复杂的文件一定不是给人类阅读的。你说的是对的！传统 csproj 文件中有大量的重复或者相似内容，只为 msbuild 和 Visual Studio 能够识别整个项目的属性和结构，以便正确编译项目。不过，既然这篇文章的目标是理解 csproj 文件格式的本质，那我当然不会把这么复杂的文件内容直接给你去阅读。我已经将整个文件结构进行了极度简化，然后用思维导图进行了分割。总结成了下图，如果先不关注文件的细节，是不是更容易看懂了呢？如果你此前也阅读过我的其他博客，会发现我一直在试图推荐使用新的 csproj 格式： 将 WPF、UWP 以及其他各种类型的旧 csproj 迁移成 Sdk 风格的 csproj 让一个 csproj 项目指定多个开发框架那么新格式和旧格式究竟有哪些不同使得新的格式如此简洁？于是，我将新的 csproj 文件结构也进行简化，用思维导图进行了分割。总结成了下图：比较两个思维导图之后，是不是发现其实两者本是相同的格式。如果忽略我在文字颜色上做的标记，其实两者的差异几乎只在文件开头是否有一个 xml 文件标记（&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;）。我在文字颜色上的标记代表着这部分的部件是否是可选的，白色代表必须，灰色代表可选；而更接近背景色的灰色代表一般情况下都是不需要的。我把两个思维导图放到一起方便比较：会发现，传统格式中 xml 声明、Project 节点、Import (props)、PropertyGroup、ItemGroup、Import (targets) 都是必要的，而新格式中只有 Project 节点 和 PropertyGroup 是必要的。是什么导致了这样的差异？在了解 csproj 文件中各个部件的作用之前，这似乎很难回答。了解 csproj 中的各个部件的作用xml 声明部分完全没有在此解释的必要了，为兼容性提供了方便，详见：XML - Wikipedia。接下来，我们不会依照部件出现的顺序安排描述的顺序，而是按照关注程度排序。PropertyGroupPropertyGroup 是用来存放属性的地方，这与它的名字非常契合。那么里面放什么属性呢？答案是——什么都能放！在这里写属性就像在代码中定义属性或变量一样，只要写了，就会生成一个指定名称的属性。比如，我们写： &amp;lt;PropertyGroup&amp;gt; &amp;lt;Foo&amp;gt;walterlv is a 逗比&amp;lt;/Foo&amp;gt;&amp;lt;PropertyGroup&amp;gt; 那么，就会生成一个 Foo 属性，值为字符串 walterlv is a 逗比。至于这个属性有什么用，那就不归这里管了。这些属性的含义完全是由外部来决定的，例如在旧的 csproj 格式中，编译过程中会使用 TargetFrameworkVersion 属性，以确定编译应该使用的 .NET Framework 目标框架的版本（是 v4.5 还是 v4.7）。在新的 csproj 格式中，编译过程会使用 TargetFrameworks 属性来决定编译应该使用的目标框架（是 net47 还是 netstandard2.0）。具体是编译过程中的哪个环节哪个组件使用了此属性，我们后面会说。从这个角度来说，如果你没有任何地方用到了你定义的属性，那为什么还要定义它呢？是的——这只是浪费。PropertyGroup 可以定义很多个，里面都可以同等地放属性。至于为什么会定义多个，原因无外乎两个： 为了可读性——将一组相关的属性放在一起，便于阅读和理解意图（旧的 csproj 谈不上什么可读性） 为了加条件——有的属性在 Debug 和 Release 下不一样（例如条件编译符 DefineConstants）额外说一下，Debug 和 Release 这两个值其实是在某处一个名为 Configuration 的属性定义的，它们其实只是普通的字符串而已，没什么特殊的意义，只是有很多的 PropertyGroup 加上了 Debug Release 的判断条件才使得不同的 Configuration 具有不同的其他属性，最终表现为编译后的巨大差异。由于 Configuration 属性可以放任意字符串，所以甚至可以定义一个非 Debug 和 Release 的配置（例如用于性能专项测试）也是可以的。ItemGroupItemGroup 是用来指定集合的地方，这与它的名字非常契合。那么这集合里面放什么项呢？答案是——什么都能放！是不是觉得这句话跟前面的 PropertyGroup 句式一模一样？是的——就是一模一样！csproj 中的两个大头都这样不带语义，几乎可以说明 csproj 文件是不包含语义的，它能够用来做什么事情纯属由其他模块来指定；这为 csproj 文件强大的扩展性提供了格式基础。既然什么都能放，那我们放这些吧： &amp;lt;ItemGroup&amp;gt; &amp;lt;Foo Include=&quot;walterlv is a 逗比&quot; /&amp;gt; &amp;lt;Foo Include=&quot;walterlv is a 天才&quot; /&amp;gt; &amp;lt;Foo Include=&quot;天才向左，逗比向右&quot; /&amp;gt; &amp;lt;Foo Include=&quot;逗比属性额外加成&quot; /&amp;gt;&amp;lt;/ItemGroup&amp;gt; 于是我们就有 4 个类型为 Foo 的项了，至于这 4 个 Foo 项有什么作用，那就不归这里管了。这些项的含义与 PropertyGroup 一样也是由外部来决定。具体是哪个外部，我们稍后会说。但是我们依然有一些常见的项可以先介绍介绍： Reference 引用某个程序集 PackageReference 引用某个 NuGet 包 ProjectReference 引用某个项目 Compile 常规的 C# 编译 None 没啥特别的编译选项，就为了执行一些通用的操作（或者是只是为了在 Visual Studio 列表中能够有一个显示） Folder 一个空的文件夹，也没啥用（不过标了这个文件夹，Visual Studio 中就能有一个文件夹的显式，即便实际上这个文件夹可能不存在）ItemGroup 也可以放很多组，一样是为了提升可读性或者增加条件。Import你应该注意到在前面的思维导图中，无论是 Sdk 风格的 csproj 还是旧 csproj 文件，我都写了两个 Import 节点。其实它们本质上是完全一样的，只不过在含义上有不同。前面我们了解到 csproj 文件致力于脱离语义，所以分开两个地方写几乎只是为了可读性考虑。那么前面那个 Import 和后面的 Import 在含义上有何区别？思维导图的括号中我已说明了含义。前面是为了导入属性（props），后面是为了导入 Targets。属性就是前面 PropertyGroup 中说的那些属性和 ItemGroup 里说的那些项；而 Targets 是新东西，这才是真正用来定义编译流程的关键，由于 Targets 是所有节点里面最复杂的部分，所以我们放到最后再说。那么，被我们 Import 进来的那些文件是什么呢？用两种扩展名，定义属性的那一种是 .props，定义行为的那一种是 .targets。这两种文件除了含义不同以外，内容的格式都是完全一样的——而且——就是 csproj 文件的那种格式！没错，也包含 Project、Import、PropertyGroup、ItemGroup、Targets。只不过，相比于对完整性有要求的 csproj 文件来说，这里可以省略更多的节点。由于有 Import 的存在，所以一层一层地嵌套 props 或者 targets 都是可能的。说了这么多，让我们来看其中两个 .props 文件吧。先看看旧格式 csproj 文件中第一行一定会 Import 的那个 Microsoft.Common.props。 &amp;lt;!-- 文件太长，做了大量删减 --&amp;gt;&amp;lt;Project ToolsVersion=&quot;4.0&quot; xmlns=&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;ImportByWildcardBeforeMicrosoftCommonProps Condition=&quot;&#39;$(ImportByWildcardBeforeMicrosoftCommonProps)&#39; == &#39;&#39;&quot;&amp;gt;true&amp;lt;/ImportByWildcardBeforeMicrosoftCommonProps&amp;gt; &amp;lt;ImportByWildcardAfterMicrosoftCommonProps Condition=&quot;&#39;$(ImportByWildcardAfterMicrosoftCommonProps)&#39; == &#39;&#39;&quot;&amp;gt;true&amp;lt;/ImportByWildcardAfterMicrosoftCommonProps&amp;gt; &amp;lt;ImportUserLocationsByWildcardBeforeMicrosoftCommonProps Condition=&quot;&#39;$(ImportUserLocationsByWildcardBeforeMicrosoftCommonProps)&#39; == &#39;&#39;&quot;&amp;gt;true&amp;lt;/ImportUserLocationsByWildcardBeforeMicrosoftCommonProps&amp;gt; &amp;lt;ImportUserLocationsByWildcardAfterMicrosoftCommonProps Condition=&quot;&#39;$(ImportUserLocationsByWildcardAfterMicrosoftCommonProps)&#39; == &#39;&#39;&quot;&amp;gt;true&amp;lt;/ImportUserLocationsByWildcardAfterMicrosoftCommonProps&amp;gt; &amp;lt;ImportDirectoryBuildProps Condition=&quot;&#39;$(ImportDirectoryBuildProps)&#39; == &#39;&#39;&quot;&amp;gt;true&amp;lt;/ImportDirectoryBuildProps&amp;gt; &amp;lt;/PropertyGroup&amp;gt;&amp;lt;/Project&amp;gt;&amp;lt;!-- 文件太长，做了大量删减 --&amp;gt; 文件太长，做了大量删减，但也可以看到文件格式与 csproj 几乎是一样的。此文件中，根据其他属性的值有条件地定义了另一些属性。再看看另一个 MSTest 单元测试项目中被隐式 Import 进 csproj 文件中的 .props 文件。（所谓隐式地 Import，只不过是被间接地引入，在 csproj 文件中看不到这个文件名而已。至于如何间接引入，因为涉及到 Targets，所以后面一起说明。） &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;Project ToolsVersion=&quot;12.0&quot; xmlns=&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;Content Include=&quot;$(MSBuildThisFileDirectory)..\\_common\\Microsoft.VisualStudio.TestPlatform.MSTest.TestAdapter.dll&quot;&amp;gt; &amp;lt;Link&amp;gt;Microsoft.VisualStudio.TestPlatform.MSTest.TestAdapter.dll&amp;lt;/Link&amp;gt; &amp;lt;CopyToOutputDirectory&amp;gt;PreserveNewest&amp;lt;/CopyToOutputDirectory&amp;gt; &amp;lt;Visible&amp;gt;False&amp;lt;/Visible&amp;gt; &amp;lt;/Content&amp;gt; &amp;lt;Content Include=&quot;$(MSBuildThisFileDirectory)..\\_common\\Microsoft.VisualStudio.TestPlatform.MSTestAdapter.PlatformServices.Interface.dll&quot;&amp;gt; &amp;lt;Link&amp;gt;Microsoft.VisualStudio.TestPlatform.MSTestAdapter.PlatformServices.Interface.dll&amp;lt;/Link&amp;gt; &amp;lt;CopyToOutputDirectory&amp;gt;PreserveNewest&amp;lt;/CopyToOutputDirectory&amp;gt; &amp;lt;Visible&amp;gt;False&amp;lt;/Visible&amp;gt; &amp;lt;/Content&amp;gt; &amp;lt;Content Include=&quot;$(MSBuildThisFileDirectory)..\\_common\\Microsoft.VisualStudio.TestPlatform.MSTestAdapter.PlatformServices.dll&quot;&amp;gt; &amp;lt;Link&amp;gt;Microsoft.VisualStudio.TestPlatform.MSTestAdapter.PlatformServices.dll&amp;lt;/Link&amp;gt; &amp;lt;CopyToOutputDirectory&amp;gt;PreserveNewest&amp;lt;/CopyToOutputDirectory&amp;gt; &amp;lt;Visible&amp;gt;False&amp;lt;/Visible&amp;gt; &amp;lt;/Content&amp;gt; &amp;lt;/ItemGroup&amp;gt;&amp;lt;/Project&amp;gt; 此文件中将三个 dll 文件从 MSTest 的 NuGet 包中以链接的形式包含到项目中，并且此文件在 Visual Studio 的解决方案列表中不可见。可以看出，引入的 props 文件可以实现几乎与 csproj 文件中一样的功能。那么，既然 csproj 文件中可以完全实现这样的功能，为何还要单独用 props 文件来存放呢？原因显而易见了——为了在多个项目中使用，一处更新，到处生效。所以有没有觉得很好玩——如果把版本号单独放到 props 文件中，就能做到一处更新版本号，到处更新版本号啦！Target终于开始说 Target 了。为什么会这么期待呢？因为前面埋下的各种伏笔几乎都要在这一节点得到解释了。一般来说，Target 节点写在 csproj 文件的末尾，但这个并不是强制的。Targets 是一种非常强大的功能扩展方式，支持 msbuild 预定义的一些指令，支持命令行，甚至支持使用 C# 直接编写（当然编译成 dll 会更方便些），还支持这些的排列组合和顺序安排。而我们实质上的编译过程便全部由这些 Targets 来完成。我们甚至可以直接说——编译过程就是靠这些 Target 的组合来完成的。如果你希望全面了解 Targets，推荐直接阅读微软的官方文档 MSBuild Targets，而本文只会对其进行一些简单的概述。当然如果你非常感兴趣，还可以阅读我另外几篇关于 Target 使用相关的文章： 如何编写基于 Microsoft.NET.Sdk 的跨平台的 MSBuild Target - 吕毅 如何创建一个基于命令行工具的跨平台的 NuGet 工具包 - 吕毅 如何创建一个基于 MSBuild Task 的跨平台的 NuGet 工具包 - 吕毅 每次都要重新编译？太慢！让跨平台的 MSBuild/dotnet build 的 Target 支持差量编译 - 吕毅 如何最快速地将旧的 NuGet 包 (2.x, packages.config) 升级成新的 NuGet 包 (4.x, PackageReference) - 吕毅不过，为了简单地理解 Target，我依然需要借用官方文档的例子作为开头。 &amp;lt;Target Name=&quot;Construct&quot;&amp;gt; &amp;lt;Csc Sources=&quot;@(Compile)&quot; /&amp;gt;&amp;lt;/Target&amp;gt; 这份代码定义了一个名为 Construct 的 Target，这是随意取的一个名字，并不重要——但是编译过程中会执行这个 Target。在这个 Target 内部，使用了一个 msbuild 自带的名为 Csc 的 Task。这里我们再次引入了一个新的概念 Task。而 Task 是 Target 内部真正完成逻辑性任务的核心；或者说 Target 其实只是一种容器，本身并不包含编译逻辑，但它的内部可以存放 Task 来实现编译逻辑。一个 Target 内可以放多个 Task，不止如此，还能放 PropertyGroup 和 ItemGroup，不过这是仅在编译期生效的属性和项了。@(Compile) 是 ItemGroup 中所有 Compile 类型节点的集合。还记得我们在 ItemGroup 小节时说到每一种 Item 的含义由外部定义吗？是的，就是在这里定义的！本身并没有什么含义，但它们作为参数传入到了具体的 Task 之后便有了此 Task 指定的含义。于是 &amp;lt;Target Name=&quot;Construct&quot;&amp;gt;&amp;lt;Csc Sources=&quot;@(Compile)&quot; /&amp;gt;&amp;lt;/Target&amp;gt; 的含义便是调用 msbuild 内置的 C# 编译器编译所有 Compile 类型的项。如果后面定义了一个跟此名称一样的 Target，那么后一个 Target 就会覆盖前一个 Target，导致前一个 Target 失效。再次回到传统的 csproj 文件上来，每一个传统格式的 csproj 都有这样一行：&amp;lt;Import Project=&quot;$(MSBuildToolsPath)\\Microsoft.CSharp.targets&quot; /&amp;gt;而引入的这份 .targets 文件便包含了 msbuild 定义的各种核心编译任务。只要引入了这个 .targets 文件，便能使用 msbuild 自带的编译任务完成绝大多数项目的编译。你可以自己去查看此文件中的内容，相信有以上 Target 的简单介绍，应该能大致理解其完成编译的流程。这是我的地址：C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\MSBuild\\15.0\\Bin\\Microsoft.CSharp.targets。Project所有的 csproj 文件都是以 Project 节点为根节点。既然是根节点为何我会在最后才说 Project 呢？因为这可是一个大悬念啊！本文一开始就描述了新旧两款 csproj 文件格式的差异，你也能从我的多篇博客中感受到新格式带来的各种好处；而简洁便是新格式中最大的好处之一。它是怎么做到简洁的呢？就靠 Project 节点了。注意到新格式中 Project 节点有 Sdk 属性吗？因为有此属性的存在，csproj 文件才能如此简洁。因为——所谓 Sdk，其实是一大波 .targets 文件的集合。它帮我们导入了公共的属性、公共的编译任务，还帮我们自动将项目文件夹下所有的 **\\*.cs 文件都作为 ItemGroup 的项引入进来。如果你希望看看 Microsoft.NET.Sdk 都引入了哪些文件，可以去本机安装的 msbuild 或 dotnet 的目录下查看。当我使用 msbuild 编译时，我的地址：C:\\Program Files\\dotnet\\sdk\\2.1.300\\Sdks\\Microsoft.NET.Sdk\\build\\。比如你可以从此文件夹里的 Microsoft.NET.GenerateAssemblyInfo.targets 文件中发现 AssemblyInfo.cs 文件是如何自动生成及生效的。编译器是如何将这些零散的部件组织起来的？这里说的编译器几乎只指 msbuild 和 Roslyn，前者基于 .NET Framework，后者基于 .NET Core。不过，它们在处理我们的项目文件时的行为大多是一致的——至少对于通常项目来说如此。我们前一部分介绍每个部件的时候，已经简单说了其组织方式，这里我们进行一个回顾和总结。当 Visual Studio 打开项目时，它会解析里面所有的 Import 节点，确认应该引入的 .props 和 .targets 文件都引入了。随后根据 PropertyGroup 里面设置的属性正确显示属性面板中的状态，根据 ItemGroup 中的项正确显示解决方案管理器中的引用列表、文件列表。——这只是 Visual Studio 做的事情。在编译时，msbuild 或 Roslyn 还会重新做一遍上面的事情——毕竟这两个才是真正的编译器，可不是 Visual Studio 的一部分啊。随后，执行编译过程。它们会按照 Target 指定的先后顺序来安排不同 Target 的执行，当执行完所有的 Target，便完成了编译过程。新旧 csproj 在编译过程上有什么差异？相信读完前面两个部分之后，你应该已经了解到在格式本身上，新旧格式之间其实并没有什么差异。或者更严格来说，差异只有一条——新格式在 Project 上指定了 Sdk。真正造成新旧格式在行为上的差别来源于默认为我们项目 Import 进来的那些 .props 和 .targets 不同。新格式通过 Microsoft.NET.Sdk 为我们导入了更现代化的 .props 和 .targets，而旧格式需要考虑到兼容性压力，只能引入旧的那些 .targets。新的 Microsoft.NET.Sdk 以不兼容的方式支持了各种新属性，例如新的 TargetFrameworks 代替旧的 TargetFrameworkVersion，使得我们的 C# 项目可以脱离 .NET Framework，引入其他各种各样的目标框架，例如 netstandard2.0、net472、uap10.0 等（可以参考 从以前的项目格式迁移到 VS2017 新项目格式 - 林德熙）了解可以使用那些目标框架。新的 Microsoft.NET.Sdk 以不兼容的方式原生支持了 NuGet 包管理。也就是说我们可以在不修改 csproj 的情况之下通过 NuGet 包来扩展 csproj 的功能。而旧的格式需要在 csproj 文件的末尾添加如下代码才可以获得其中一个 NuGet 包功能的支持：&amp;lt;Import Project=&quot;..\\packages\\Walterlv.Demo.3.0.0-beta.6\\build\\Walterlv.Demo.targets&quot; Condition=&quot;Exists(&#39;..\\packages\\Walterlv.Demo.3.0.0-beta.6\\build\\Walterlv.Demo.targets&#39;)&quot; /&amp;gt;&amp;lt;Target Name=&quot;EnsureNuGetPackageBuildImports&quot; BeforeTargets=&quot;PrepareForBuild&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;ErrorText&amp;gt;This project references NuGet package(s) that are missing on this computer. Use NuGet Package Restore to download them. For more information, see http://go.microsoft.com/fwlink/?LinkID=322105. The missing file is {0}.&amp;lt;/ErrorText&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;Error Condition=&quot;!Exists(&#39;..\\packages\\Walterlv.Demo.3.0.0-beta.6\\build\\Walterlv.Demo.targets&#39;)&quot; Text=&quot;$([System.String]::Format(&#39;$(ErrorText)&#39;, &#39;..\\packages\\Walterlv.Demo.3.0.0-beta.6\\build\\Walterlv.Demo.targets&#39;))&quot; /&amp;gt;&amp;lt;/Target&amp;gt;不过好在 NuGet 4.x 以上版本在安装 NuGet 包时自动为我们在 csproj 中插入了以上代码。更多资料如果你在阅读本文时还有更多问题，可以阅读我和朋友的其他相关博客，也可以随时在下方向我留言。如果没有特别原因，我都是在一天之内进行回复。 项目文件中的已知属性（知道了这些，就不会随便在 csproj 中写死常量了） - 吕毅 让一个 csproj 项目指定多个开发框架 - 吕毅 从以前的项目格式迁移到 VS2017 新项目格式 - 林德熙 将 WPF、UWP 以及其他各种类型的旧 csproj 迁移成 Sdk 风格的 csproj - 吕毅 自动将 NuGet 包的引用方式从 packages.config 升级为 PackageReference - 吕毅" }, { "title": "自动将 NuGet 包的引用方式从 packages.config 升级为 PackageReference", "url": "/post/migrate-packages-config-to-package-reference.html", "categories": "", "tags": "dotnet, visualstudio, nuget, msbuild", "date": "2019-04-12 09:37:05 +0800", "snippet": "在前段时间我写了一篇迁移 csproj 格式的博客 将 WPF、UWP 以及其他各种类型的旧 csproj 迁移成 Sdk 风格的 csproj，不过全过程是手工进行的，而且到最后处理 XAML 问题也非常头疼。现在，我们可以利用工具自动地完成这个过程。当然，工具并不将 csproj 格式进行迁移，而是在不迁移格式的情况下，使用到 PackageReference 方式 NuGet 引用带来的好处。自动升级下载安装 Visual Studio 插件 NuGet PackageReference Upgrader。在安装完成之后，再次启动 Visual Studio，则可以开始迁移。更新：自 Visual Studio 2017 的 15.7 版本开始，迁移工具已经自带到 Visual Studio 中。详情请参见：Migrating from package.config to PackageReference formats - Microsoft Docs。只有一个步骤：在 packages.config 文件上点击右键，选择 Upgrade to PackageReference。在弹出的界面中，选择包的版本，确定即可完成一个项目的迁移。相比于之前写的手工迁移，自动迁移方式没有改变 csproj 的格式，而只是将 NuGet 的引用方式改成了 PackageReference。具体有哪些好处，可以阅读 将 WPF、UWP 以及其他各种类型的旧 csproj 迁移成 Sdk 风格的 csproj。检查升级后的兼容性问题packages.config 的 NuGet 包的管理方式有些功能是 PackageReference 没有的。当然，没有这些功能是因为“不需要”，而不是“还没支持”；所以大部分的迁移都不会发生问题（除非发布包使用的是特别老旧的 nuget.exe，或者发布者利用了一些丧心病狂的黑科技）。在 Visual Studio 2017 的 15.7 版本以上自带的迁移工具中，会自动列出可能的兼容性问题。install.ps1 脚本将失效使用 PackageReference 后，在安装和写在的过程中 install.ps1 脚本将不再执行。如果有一些行为依赖于此脚本，那么这个 NuGet 包的行为可能不正常。但是，不用担心！install.ps1 的存在是因为 packages.config 不支持 PackageReference 中的一些新特性（例如 NuGet 包中新的目录结构，例如包中自带的 msbuild targets）。所以，如果 NuGet 包在发布时满足目录要求，那么即便 install.ps1 不用执行也能保证包的行为正常。使用 content 方式指定的内容资产将失效PackageReference 使用 contentFiles 来管理内容资产，这样可以更好地在多个依赖包之间传递和共享。而此前 content 指定的资产将失效。建议检查所有依赖的 NuGet 包，如果你有权限修改部分依赖包，那么请使用 contentFiles 来替代 content。XDT 变换将失效使用 PackageReference 后，在安装和写在的过程中 XDT 转换将不会执行，并且会忽略 .xdt 文件。在 Web 应用开发中会更留意这个问题。lib 根目录中的程序集将被忽略lib 文件夹内的程序集都应该按照目标框架建立子文件夹，例如 net45、netstandard2.0、netcoreapp2.0。PackageReference 要求只能引用在某个目标框架下的程序集。如果是使用默认的方式创建的 NuGet 包，基本上不会遇到这样的问题。除非你在创建 NuGet 包时有自定义操作在根目录放了程序集。解决升级后的编译错误最可能出现的编译问题是 NuGet 包引用的版本冲突。packages.config 方式的包引用要求在 csproj 文件中显式指定一个依赖的包的版本，于是无论依赖使用了哪个版本，最终都由显式指定的版本来指定。而 PackageReference 的引用方式是自动管理依赖版本的，只要每个包都在允许的版本范围之内，就自动选择版本，并显示在解决方案的引用中。PackageReference 出现依赖冲突的提示通常是这样的：Version conflict detected for NuGet.Versioning. Reference the package directly from the project to resolve this issue.NuGet.Packaging 3.5.0 -&amp;gt; NuGet.Versioning (= 3.5.0)NuGet.Configuration 4.0.0 -&amp;gt; NuGet.Versioning (= 4.0.0)也就是说，引用的两个不同的包要求依赖相同包的不同版本，于是 PackageReference 无法隐式推断依赖包的版本。这时需要将项目的依赖方式改为之前的方式。当然，在制作和发布 NuGet 包时，尽量使用非特定版本的依赖包，能够极大地避免这种问题带来的影响。关于如何指定非特定版本的依赖包，可以阅读 Version ranges and wildcards 版本范围和通配符。参考资料 Migrating from package.config to PackageReference formats - Microsoft Docs packages.config (PC) to PackageReference (PR) Migrator · NuGet/Home Wiki" }, { "title": "语义版本号（Semantic Versioning）", "url": "/post/semantic-version.html", "categories": "", "tags": "visualstudio, nuget, csharp, dotnet", "date": "2019-04-12 09:36:54 +0800", "snippet": "版本号格式不陌生吧，.NET 传统的版本号格式类似这样 1.5.1254.0。本文将推荐一种新的版本号格式——语义版本号，格式类似这样 1.4.6-beta。我推荐语义版本号是因为这样的版本号自包含语义，而且这样的语义能够在版本库中体现出来。传统的版本号如果你只是知道传统版本号由四个部分组成，那么建议去官方文档 Assembly Versioning 了解一下这种版本号的定义。它分为 主版本号.次版本号.构建号.修订号 四个部分，但是后面的一个或多个部分可以省略。例如，1.5.1254.0 表示主版本号是 1，次版本号是 5；在 1.5 的版本下，第 1255 次构建，并且在这次构建之后没有进行修订。如果你是一个库的发布者，那么主版本号的改变意味着 API 出现不兼容的修改；次版本号改变意味着 API 出现兼容的修改（通常是新增）。然而我们如何能够准确地向所有人传递这样的版本规则呢？当我们在向全世界提供一个库（比如 NuGet 包）的时候，我们怎么让团队所有人都知道我们正在为哪个版本开发新功能呢？我们又应该在何时更新程序集或者 NuGet 的版本号呢（在功能开发开始？差不多完成？临近发布？）？传统的版本号记录不了这些信息，于是我们不得不用一些额外的方式来记录，这就增加了维护成本。语义版本号语义版本号由五个部分组成 主版本号、次版本号、补丁号、预发布版本标签 和 构建号。举例看看语义版本号是什么样的吧（摘自 NuGet Package Version Reference）： 1.0.1 1.0.1-rc 1.0.1-beta 1.0.1-alpha2 1.0.1-alpha 1.0.1-aaaNuGet 4.3.0 以上，并且 Visual Studio 2017 的 15.3 以上版本开始支持语义版本号 2.0（Semantic Versioning 2.0.0）。 1.0.0-alpha.1 2.0 版本的语义版本号在预发布标签后面使用 . 来区分预发布的不同版本，这样就能避免 alpha2 在字符串比较上大于 alpha10 的问题。（否则得写成 alpha02 了。） 1.0.0+githash 2.0 版本的语义版本号在最后使用 + 来表示 git 版本库相关的信息，这样为持续集成（CI）时自动生成版本号提供了方便。 1.0.0-beta.5+4 表示这是准备发布 1.0.0 的第 5/6 个 beta 版本之后，又新增了 4 个 git 提交。（是不是意义更加明确？） 如何在项目中使用语义版本号？如果你希望方便，在执行 dotnet build 或 dotnet pack 命令之后能够直接得到使用语义版本号的 NuGet 包，那么你必须拥有一个新格式的 csproj，就是 .NET Core 带来的那种新格式。如果你的格式是旧的，可以阅读我的另一篇文章 将 WPF、UWP 以及其他各种类型的旧 csproj 迁移成 Sdk 风格的 csproj 迁移成新格式。这样，在 csproj 文件中将版本号写为以下方式即可：&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;Version&amp;gt;1.6.2-beta&amp;lt;/Version&amp;gt; &amp;lt;!-- &amp;lt;PackageId&amp;gt;Walterlv.DemoPackage&amp;lt;/PackageId&amp;gt; --&amp;gt; &amp;lt;!-- &amp;lt;TargetFrameworks&amp;gt;netstandard2.0;net471&amp;lt;/TargetFrameworks&amp;gt; --&amp;gt; &amp;lt;/PropertyGroup&amp;gt;&amp;lt;/Project&amp;gt;你还可以考虑在编译的时候进行改变，即执行编译命令的时候传入版本号：# 以下三种都行&amp;gt; dotnet build /p:Version=1.6.2-beta&amp;gt; dotnet msbuild /p:Version=1.6.2-beta&amp;gt; msbuild /p:Version=1.6.2-beta当然，你还可以使用响应文件来简化参数，详情可阅读我的另一篇博客 使用 MSBuild 响应文件 (rsp) 来指定 dotnet build 命令行编译时的大量参数。如果希望自动化地在项目中生成语义版本号，可阅读我的另一篇博客 使用 GitVersion 在编译或持续构建时自动使用语义版本号（Semantic Versioning）。如何用 C#/.NET 支持语义版本号？可参考林德熙的博客：C# 使用转换语义版本号。参考资料 Semantic Versioning 2.0.0 - Semantic Versioning Semantic Versioning &amp;amp; auto-incremented NuGet package versions - Xavier Decoster NuGet Package Version Reference - Microsoft Docs Pre-release versions in NuGet packages - Microsoft Docs Versioning NuGet packages in a continuous delivery world: part 1 – Microsoft DevOps Blog Versioning NuGet packages in a continuous delivery world: part 3 – Microsoft DevOps Blog Supporting Semantic Versioning 2.0.0" }, { "title": "项目文件中的已知属性（知道了这些，就不会随便在 csproj 中写死常量啦）", "url": "/post/known-properties-in-csproj.html", "categories": "", "tags": "visualstudio, nuget, csharp, dotnet, msbuild", "date": "2019-04-12 09:36:45 +0800", "snippet": "知道了 csproj 文件中的一些常用属性，修改文件的时候就不会写很多的垃圾代码。“项目文件中的已知属性系列”分为两个部分： 本文：项目文件中的已知属性（知道了这些，就不会随便在 csproj 中写死常量啦） - 吕毅 项目文件中的已知 NuGet 属性（使用这些属性，创建 NuGet 包就可以不需要 nuspec 文件啦） - 吕毅什么？你的 csproj 文件太长不想看？说明你用了旧格式的 csproj，阅读我的另一篇文章 将 WPF、UWP 以及其他各种类型的旧 csproj 迁移成 Sdk 风格的 csproj 将它转为新格式之后，你就会觉得这么简短精炼的 csproj 文件，真不忍将它写杂。比如通过以下写法，可以将所有的 *.xaml.cs 文件折叠到对应的 *.xaml 文件下，而不需要像旧 csproj 格式那样每个文件都写一份： &amp;lt;Compile Update=&quot;**\\*.xaml.cs&quot;&amp;gt; &amp;lt;DependentUpon&amp;gt;%(Filename)&amp;lt;/DependentUpon&amp;gt;&amp;lt;/Compile&amp;gt; 编译上下文以下属性是基本的输出路径属性，可以在 Microsoft.NET.DefaultOutputPaths.targets 找到。 $(Configuration) 这就是我们传说中决定 Debug 还是 Release 的属性。如果没有指定，默认是 Debug。本身没有什么意义，因为各种其他行为判断了这个属性的值，于是就有了编译差别。 $(Platform) 默认是 AnyCPU，还可以是 x86、x64 或者 ARM。 $(BaseOutputPath) 输出路径的起始位置。如果没有指定，就是 bin\\。修改这个属性可以间接修改 OutputPath。 $(OutputPath) 输出路径，默认有两种可能的值。如果 AnyCPU 编译，就是 $(BaseOutputPath)$(Configuration)\\；否则就是 $(BaseOutputPath)$(PlatformName)\\$(Configuration)\\ $(BaseIntermediateOutputPath) 临时生成路径的起始位置。如果没有指定，就是 obj\\。修改这个属性可以间接修改 IntermediateOutputPath。 $(IntermediateOutputPath) 临时生成路径，默认有两种可能的值。如果 AnyCPU 编译，就是 $(BaseIntermediateOutputPath)$(Configuration)\\；否则就是 $(BaseIntermediateOutputPath)$(PlatformName)\\$(Configuration)\\ 额外的，如果你试图在编译期间使用 dll，你可能需要判断运行时环境： $(MSBuildRuntimeType) 例如你可以使用 Condition=&quot; &#39;$(MSBuildRuntimeType)&#39; == &#39;Core&#39;&quot; 来判断当前编译环境是否是 .NET Core。 关于输出路径的更多说明，可以阅读我的另一篇博客：如何更精准地设置 C# / .NET Core 项目的输出路径？（包括添加和删除各种前后缀）以下属性控制哪些文件应该被默认包含在编译中，可以在 Microsoft.NET.TargetFrameworkInference.targets 找到。 $(EnableDefaultItems) 默认为 true，如果指定为 false，那么就不自动将 .cs 和 .resx 文件引入。 $(DefaultItemExcludes) 默认为输出路径（OutputPath）和临时生成路径（IntermediateOutputPath）下的所有文件。 $(AppendTargetFrameworkToOutputPath) 默认我们生成路径会包含 net47 或者 netcoreapp2.1 这样的一层文件夹，如果指定为 false，这一层文件夹就不会生成了。 下面是 Microsoft.NET.Sdk 中的一部分源码，在 Microsoft.NET.Sdk.DefaultItems.props 文件中，可以发现还有更多与控制自动引入文件相关的属性。&amp;lt;ItemGroup Condition=&quot; &#39;$(EnableDefaultItems)&#39; == &#39;true&#39; &quot;&amp;gt; &amp;lt;Compile Include=&quot;**/*$(DefaultLanguageSourceExtension)&quot; Exclude=&quot;$(DefaultItemExcludes);$(DefaultExcludesInProjectFolder)&quot; Condition=&quot; &#39;$(EnableDefaultCompileItems)&#39; == &#39;true&#39; &quot; /&amp;gt; &amp;lt;EmbeddedResource Include=&quot;**/*.resx&quot; Exclude=&quot;$(DefaultItemExcludes);$(DefaultExcludesInProjectFolder)&quot; Condition=&quot; &#39;$(EnableDefaultEmbeddedResourceItems)&#39; == &#39;true&#39; &quot; /&amp;gt;&amp;lt;/ItemGroup&amp;gt;&amp;lt;ItemGroup Condition=&quot; &#39;$(EnableDefaultItems)&#39; == &#39;true&#39; And &#39;$(EnableDefaultNoneItems)&#39; == &#39;true&#39; &quot;&amp;gt; &amp;lt;None Include=&quot;**/*&quot; Exclude=&quot;$(DefaultItemExcludes);$(DefaultExcludesInProjectFolder)&quot; /&amp;gt; &amp;lt;None Remove=&quot;**/*$(DefaultLanguageSourceExtension)&quot; /&amp;gt; &amp;lt;None Remove=&quot;**/*.resx&quot; /&amp;gt;&amp;lt;/ItemGroup&amp;gt;以下属性是 Microsoft.NET.Sdk 中的各种 Target 使用的配置属性，设置这些属性也影响到生成过程。&amp;lt;Project&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;!-- 此程序集的版本，这是很多其他版本号未设置时的默认值。而此值的默认值是 1.0.0 --&amp;gt; &amp;lt;Version&amp;gt;3.1.2-beta&amp;lt;/Version&amp;gt; &amp;lt;!-- 以下属性是当引用的 dll 出现版本冲突时，用于自动生成绑定重定向的。 详见：https://www.erikheemskerk.nl/transitive-nuget-dependencies-net-core-got-your-back/ --&amp;gt; &amp;lt;AutoGenerateBindingRedirects&amp;gt;true&amp;lt;/AutoGenerateBindingRedirects&amp;gt; &amp;lt;GenerateBindingRedirectsOutputType&amp;gt;true&amp;lt;/GenerateBindingRedirectsOutputType&amp;gt; &amp;lt;/PropertyGroup&amp;gt;&amp;lt;/Project&amp;gt;可以阅读 解读 Microsoft.NET.Sdk 的源码，你能定制各种奇怪而富有创意的编译过程 和 Reading the Source Code of Microsoft.NET.Sdk, Writing the Creative Extension of Compiling 了解更多 Microsoft.NET.Sdk 源码。开关 $(AutoGenerateBindingRedirects) 设置开启或关闭绑定重定向，详情可参考：Enable or disable autogenerated binding redirects - Microsoft Docs。文件路径项路径写在 csproj 文件中 ItemGroup 组中的每一个元素即“项”。对以下这一项进行说明的话： &amp;lt;ItemGroup&amp;gt; &amp;lt;Compile Include=&quot;src\\Program.cs&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; 那么，可用的属性有： %(FullPath) 文件的完全路径，例如: C:\\Users\\walterlv\\GitHub\\Demo\\Walterlv.DemoProject\\src\\Program.cs %(RootDir) 文件所在的根目录，例如: C:\\ %(Filename) 文件名（不含扩展名），例如: Program %(Extension) 文件扩展名，例如: .cs %(RelativeDir) 文件所在的文件夹，例如: src\\ %(Directory) 除了根目录之外的目录，例如: walterlv\\GitHub\\Demo\\Walterlv.DemoProject\\src\\ %(RecursiveDir) 如果项是用通配符写的，那么此值表示匹配到某一项时的目录，例如: walterlv\\GitHub\\Demo\\Walterlv.DemoProject\\src\\ %(Identity) 项的标识符，也就是 Include 里写的东西，例如: src\\Program.cs %(ModifiedTime) 文件的修改时间，例如: 2018-04-12 21:00:43.7851385 %(CreatedTime) 文件的创建时间，例如: 2018-04-12 21:01:50.1417635 %(AccessedTime) 文件最近被访问的时间，例如: 2018-04-12 21:02:15.4132476 全局路径 项目文件 $(MSBuildProjectFullPath) 项目文件的绝对路径，例如: C:\\Users\\walterlv\\GitHub\\Demo\\Walterlv.DemoProject.csproj $(MSBuildProjectDirectory) 项目所在的文件夹，例如: C:\\Users\\walterlv\\GitHub\\Demo $(MSBuildProjectFile) 项目文件的完整名称，例如: Walterlv.DemoProject.csproj $(MSBuildProjectName) 项目文件的名称，不含扩展名，例如 Walterlv.DemoProject $(MSBuildProjectExtension) 项目文件的扩展名，例如: .csproj $(MSBuildProjectDirectoryNoRoot) 项目文件去除驱动器的路径，包含反斜杠 部件（例如 .props 文件或 .targets 文件，当然也包含 .csproj 文件） $(MSBuildThisFileFullPath) 用这个属性的文件所在的绝对路径，例如 C:\\Users\\walterlv\\.nuget\\packages\\walterlv.nuget.demo\\2.13.0\\build\\netstandard2.0\\Walterlv.NuGet.Demo.targets $(MSBuildThisFileDirectory) 此文件所在的文件夹，例如: C:\\Users\\walterlv\\.nuget\\packages\\walterlv.nuget.demo\\2.13.0\\build\\netstandard2.0\\ $(MSBuildThisFile) 此文件的完整名称，例如 Walterlv.NuGet.Demo.targets $(MSBuildThisFileName) 此文件的名称，不含扩展名，例如 Walterlv.NuGet.Demo $(MSBuildThisFileExtension) 此文件的扩展名，例如 .targets $(MSBuildThisFileDirectoryNoRoot) 此文件去除驱动器的路径，包含反斜杠 环境 $(MSBuildStartupDirectory) 启动 MSBuild 时的路径，类似于工作目录（输入 msbuild 命令时所在的那个文件夹） 工具 $(MSBuildToolsPath) MSBuild 工具所在的路径 $(MSBuildToolsVersion) 此次编译锁使用的工具的版本 另外还有一些在新的 SDK 中几乎不会在日常开发中用到的全局属性： $(MSBuildBinPath): MSBuild 程序所在的路径 $(MSBuildExtensionsPath): 自定义 targets 所在的路径 $(MSBuildExtensionsPath32): 自定义 targets 所在的路径 $(MSBuildExtensionsPath64): 自定义 targets 所在的路径 $(MSBuildLastTaskResult): 如果前一个 Task 结束后成功，则为 true；否则为 false $(MSBuildNodeCount): 编译时并发的进程数，与命令行中的 /maxcpucount 时一个意思 $(MSBuildProgramFiles32): 通常是 C:\\Program Files (x86) $(MSBuildProjectDefaultTargets): 在 Project 根节点上设置的默认 Targets，例如: &amp;lt;Project DefaultTargets=&quot;A;B;C&quot; &amp;gt; $(MSBuildBinPath): MSBuild 程序所在的路径 $(MSBuildBinPath): MSBuild 程序所在的路径 $(MSBuildBinPath): MSBuild 程序所在的路径 $(MSBuildBinPath): MSBuild 程序所在的路径如果希望了解在 csproj 中创建 NuGet 包时可用的属性，请参考我的另一篇博客：项目文件中的已知 NuGet 属性（知道了这些，创建 NuGet 包就可以不需要 nuspec 文件啦） - 吕毅。参考资料 MSBuild Well-known Item Metadata" }, { "title": "让一个 csproj 项目指定多个开发框架", "url": "/post/configure-projects-to-target-multiple-platforms.html", "categories": "", "tags": "visualstudio", "date": "2019-04-12 09:36:19 +0800", "snippet": "可移植类库、共享项目、.NET Standard 项目都能够帮我们完成跨多个 .NET SDK 的单一项目开发，但它们的跨 SDK 开发都有些限制。现在，我们又有新的方式能够跨多个 .NET SDK 开发了，这就是使用新的 csproj 文件格式。看看拥有多个开发框架的项目长什么样吧！▲ 多 SDK 项目这个是我和 erdao 在 GitHub 上开源项目 dotnet-campus/MSTestEnhancer 的项目依赖截图。是不是很激动？Sdk 风格的 csproj 文件在 如何组织一个同时面向 UWP/WPF/.Net Core 控制台的 C# 项目解决方案 - walterlv 一文中我讲了 .NET Standard 的方式，这种方式优势非常明显，跟普通的开发方式一样，也是我最推荐的方式。但缺点是要求目标 SDK 支持对应的 .NET Standard 版本。使用共享项目的方式则是直接共享了源码，只要在目标项目中指定了条件编译符，那么源码便能针对各种不同的目标框架进行分别编译。但缺点是对扩展插件的支持较差（可能是因为扩展插件难以判断项目的真实开发框架），而且 Visual Studio 本身对它的支持也有 BUG（例如切换编写文件所属的项目经常会失败）。新的 csproj 文件能够指定多个开发框架。这样，我们便能同时编写适用于 .NET Framework 4.5 的和 .NET Standard 2.0 的代码，同时还能够得到 Visual Studio 和扩展插件较好的支持。.NET Standard 和 .NET Core 项目在创建之时就已经是新的 csproj 格式了，但 .NET Framework 项目、UWP/WPF 项目依然使用旧风格的 csproj 文件。对于 .NET Framework 项目，可以通过 将 WPF、UWP 以及其他各种类型的旧 csproj 迁移成 Sdk 风格的 csproj - walterlv 一文进行迁移。不过对于 WPF/UWP 项目，根本就没有跨多个 SDK 的必要，就不要改了……如果是新开项目——强烈建议先按照 .NET Standard 项目类型建好，再修改成多开发框架。如何指定多个开发框架只要是 Sdk 风格的 csproj 文件，指定多个开发框架真的是相当的简单。&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;TargetFrameworks&amp;gt;net45;netstandard2.0&amp;lt;/TargetFrameworks&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;!-- 这个文件里的其他内容 --&amp;gt;&amp;lt;/Project&amp;gt;请特别注意！！！TargetFramework 从单数形式变为了复数形式 TargetFrameworks！！！这个时候，TargetFramework 是编译时自动指定的。如果是对以上多框架的项目进行单元测试，考虑到编译的目标平台是多个的，单元测试项目也需要指定多个目标框架。&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;TargetFrameworks&amp;gt;net471;netcoreapp2.0&amp;lt;/TargetFrameworks&amp;gt; &amp;lt;IsPackable&amp;gt;false&amp;lt;/IsPackable&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;!-- 这个文件里的其他内容 --&amp;gt;&amp;lt;/Project&amp;gt;多框架项目的坑以及如何避坑微软的官方文档 How to: Configure Projects to Target Multiple Platforms - Microsoft Docs 中只说了如何指定多个目标框架，并没有提及指定了多框架以后的坑。如果多开发框架中包含了低版本的 .NET Framework，例如 4.0/4.5 等，那么这些坑才比较容易凸显——因为这些版本的 .NET Framework 与 .NET Standard 的第三方库差异较大。所以，我们需要有方法来解决其第三方库引用的差异。这时需要在 csproj 文件中指定包含条件。例如：&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;TargetFrameworks&amp;gt;net471;netcoreapp2.0&amp;lt;/TargetFrameworks&amp;gt; &amp;lt;OutputType Condition=&quot;&#39;$(TargetFramework)&#39;!=&#39;netcoreapp2.0&#39;&quot;&amp;gt;Exe&amp;lt;/OutputType&amp;gt; &amp;lt;IsPackable&amp;gt;false&amp;lt;/IsPackable&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;!-- 这里的引用是二者共有的 --&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;PackageReference Include=&quot;MSTest.TestAdapter&quot; Version=&quot;1.2.0&quot; /&amp;gt; &amp;lt;PackageReference Include=&quot;MSTest.TestFramework&quot; Version=&quot;1.2.0&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;!-- 这里的引用用于非 .NET Core 框架 --&amp;gt; &amp;lt;ItemGroup Condition=&quot;&#39;$(TargetFramework)&#39;!=&#39;netcoreapp2.0&#39;&quot;&amp;gt; &amp;lt;PackageReference Include=&quot;Xxx&quot; Version=&quot;1.0.*&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;!-- 这里的引用用于 .NET Core 框架 --&amp;gt; &amp;lt;ItemGroup Condition=&quot;&#39;$(TargetFramework)&#39;==&#39;netcoreapp2.0&#39;&quot;&amp;gt; &amp;lt;PackageReference Include=&quot;Yyy&quot; Version=&quot;1.0.*&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt;&amp;lt;/Project&amp;gt;在 dotnet-campus/MSTestEnhancer 项目中，只有 .NET Framework 4.5 才需要引用 System.ValueTuple，于是加上了 net45 条件判断：&amp;lt;!--EXTERNAL_PROPERTIES: TargetFramework--&amp;gt;&amp;lt;ItemGroup Condition=&quot;&#39;$(TargetFramework)&#39;==&#39;net45&#39;&quot;&amp;gt; &amp;lt;PackageReference Include=&quot;System.ValueTuple&quot; Version=&quot;4.4.0&quot; /&amp;gt;&amp;lt;/ItemGroup&amp;gt;那段注释的作用是告诉代码分析工具 TargetFramework 是外部属性，上下文环境中找不到这个属性是正常的。参考资料 impromptu-interface/ImpromptuInterface.csproj at master · ekonbenefits/impromptu-interface How to: Configure Projects to Target Multiple Platforms - Microsoft Docs" }, { "title": ".NET Core/Framework 创建委托以大幅度提高反射调用的性能", "url": "/post/create-delegate-to-improve-reflection-performance.html", "categories": "", "tags": "dotnet, csharp", "date": "2019-04-04 19:21:42 +0800", "snippet": "都知道反射伤性能，但不得不反射的时候又怎么办呢？当真的被问题逼迫的时候还是能找到解决办法的。为反射得到的方法创建一个委托，此后调用此委托将能够提高近乎直接调用方法本身的性能。（当然 Emit 也能够帮助我们显著提升性能，不过直接得到可以调用的委托不是更加方便吗？）性能对比数据▲ 没有什么能够比数据更有说服力（注意后面两行是有秒数的）可能我还需要解释一下那五行数据的含义： 直接调用（😏应该没有什么比直接调用函数本身更有性能优势的吧） 做一个跟直接调用的方法功能一模一样的委托（😮目的是看看调用委托相比调用方法本身是否有性能损失，从数据上看，损失非常小） 本文重点 将反射出来的方法创建一个委托，然后调用这个委托（🤩看看吧，性能跟直接调差别也不大嘛） 先反射得到方法，然后一直调用这个方法（😥终于可以看出来反射本身还是挺伤性能的了，50 多倍的性能损失啊） 缓存都不用，从头开始反射然后调用得到的方法（😒100 多倍的性能损失了）以下是测试代码，可以更好地理解上图数据的含义：using System;using System.Diagnostics;using System.Reflection;namespace Walterlv.Demo{ public class Program { static void Main(string[] args) { // 调用的目标实例。 var instance = new StubClass(); // 使用反射找到的方法。 var method = typeof(StubClass).GetMethod(nameof(StubClass.Test), new[] { typeof(int) }); // 将反射找到的方法创建一个委托。 var func = InstanceMethodBuilder&amp;lt;int, int&amp;gt;.CreateInstanceMethod(instance, method); // 跟被测方法功能一样的纯委托。 Func&amp;lt;int, int&amp;gt; pureFunc = value =&amp;gt; value; // 测试次数。 var count = 10000000; // 直接调用。 var watch = new Stopwatch(); watch.Start(); for (var i = 0; i &amp;lt; count; i++) { var result = instance.Test(5); } watch.Stop(); Console.WriteLine($&quot;{watch.Elapsed} - {count} 次 - 直接调用&quot;); // 使用同样功能的 Func 调用。 watch.Restart(); for (var i = 0; i &amp;lt; count; i++) { var result = pureFunc(5); } watch.Stop(); Console.WriteLine($&quot;{watch.Elapsed} - {count} 次 - 使用同样功能的 Func 调用&quot;); // 使用反射创建出来的委托调用。 watch.Restart(); for (var i = 0; i &amp;lt; count; i++) { var result = func(5); } watch.Stop(); Console.WriteLine($&quot;{watch.Elapsed} - {count} 次 - 使用反射创建出来的委托调用&quot;); // 使用反射得到的方法缓存调用。 watch.Restart(); for (var i = 0; i &amp;lt; count; i++) { var result = method.Invoke(instance, new object[] { 5 }); } watch.Stop(); Console.WriteLine($&quot;{watch.Elapsed} - {count} 次 - 使用反射得到的方法缓存调用&quot;); // 直接使用反射调用。 watch.Restart(); for (var i = 0; i &amp;lt; count; i++) { var result = typeof(StubClass).GetMethod(nameof(StubClass.Test), new[] { typeof(int) }) ?.Invoke(instance, new object[] { 5 }); } watch.Stop(); Console.WriteLine($&quot;{watch.Elapsed} - {count} 次 - 直接使用反射调用&quot;); } private class StubClass { public int Test(int i) { return i; } } }}上面的代码中，有一个我们还没有实现的 InstanceMethodBuilder 类型，接下来将介绍如何实现它。如何实现实现的关键就在于 MethodInfo.CreateDelegate 方法。这是 .NET Standard 中就有的方法，这意味着 .NET Framework 和 .NET Core 中都可以使用。此方法有两个重载： 要求传入一个类型，而这个类型就是应该转成的委托的类型 要求传入一个类型和一个实例，一样的，类型是应该转成的委托的类型他们的区别在于前者创建出来的委托是直接调用那个实例方法本身，后者则更原始一些，真正调用的时候还需要传入一个实例对象。拿上面的 StubClass 来说明会更直观一些：private class StubClass{ public int Test(int i) { return i; }}前者得到的委托相当于 int Test(int i) 方法，后者得到的委托相当于 int Test(StubClass instance, int i) 方法。（在 IL 里实例的方法其实都是后者，而前者更像 C# 中的代码，容易理解。）单独使用 CreateDelegate 方法可能每次都需要尝试第一个参数到底应该传入些什么，于是我将其封装成了泛型版本，增加易用性。using System;using System.Linq;using System.Reflection;using System.Diagnostics.Contracts;namespace Walterlv.Demo{ public static class InstanceMethodBuilder&amp;lt;T, TReturnValue&amp;gt; { /// &amp;lt;summary&amp;gt; /// 调用时就像 var result = func(t)。 /// &amp;lt;/summary&amp;gt; [Pure] public static Func&amp;lt;T, TReturnValue&amp;gt; CreateInstanceMethod&amp;lt;TInstanceType&amp;gt;(TInstanceType instance, MethodInfo method) { if (instance == null) throw new ArgumentNullException(nameof(instance)); if (method == null) throw new ArgumentNullException(nameof(method)); return (Func&amp;lt;T, TReturnValue&amp;gt;) method.CreateDelegate(typeof(Func&amp;lt;T, TReturnValue&amp;gt;), instance); } /// &amp;lt;summary&amp;gt; /// 调用时就像 var result = func(this, t)。 /// &amp;lt;/summary&amp;gt; [Pure] public static Func&amp;lt;TInstanceType, T, TReturnValue&amp;gt; CreateMethod&amp;lt;TInstanceType&amp;gt;(MethodInfo method) { if (method == null) throw new ArgumentNullException(nameof(method)); return (Func&amp;lt;TInstanceType, T, TReturnValue&amp;gt;) method.CreateDelegate(typeof(Func&amp;lt;TInstanceType, T, TReturnValue&amp;gt;)); } }}泛型的多参数版本可以使用泛型类型生成器生成，我在 生成代码，从 &amp;lt;T&amp;gt; 到 &amp;lt;T1, T2, Tn&amp;gt; —— 自动生成多个类型的泛型 - 吕毅 一文中写了一个泛型生成器，可以稍加修改以便适应这种泛型类。" }, { "title": "将 C++/WinRT 中的线程切换体验带到 C# 中来（WPF 版本）", "url": "/post/bring-thread-switching-tasks-to-csharp-for-wpf.html", "categories": "", "tags": "dotnet, csharp, wpf", "date": "2019-03-30 09:13:12 +0800", "snippet": "如果你要在 WPF 程序中使用线程池完成一个特殊的任务，那么使用 .NET 的 API Task.Run 并传入一个 Lambda 表达式可以完成。不过，使用 Lambda 表达式会带来变量捕获的一些问题，比如说你需要区分一个变量作用于是在 Lambda 表达式中，还是当前上下文全局（被 Lambda 表达式捕获到的变量）。然后，在静态分析的时候，也难以知道此 Lambda 表达式在整个方法中的执行先后顺序，不利于分析潜在的 Bug。在使用 async/await 关键字编写异步代码的时候，虽然说实质上也是捕获变量，但这时没有显式写一个 Lambda 表达式，所有的变量都是被隐式捕获的变量，写起来就像在一个同步方法一样，便于理解。C++/WinRT以下 C++/WinRT 的代码来自 Raymond Chen 的示例代码。Raymond Chen 写了一个 UWP 的版本用于模仿 C++/WinRT 的线程切换效果。在看他编写的 UWP 版本之前我也思考了可以如何实现一个 .NET / WPF 的版本，然后成功做出了这样的效果。Raymond Chen 的版本可以参见：C++/WinRT envy: Bringing thread switching tasks to C# (UWP edition) - The Old New Thing。winrt::fire_and_forget MyPage::Button_Click(){ // We start on a UI thread. auto lifetime = get_strong(); // Get the control&#39;s value from the UI thread. auto v = SomeControl().Value(); // Move to a background thread. co_await winrt::resume_background(); // Do the computation on a background thread. auto result1 = Compute1(v); auto other = co_await ContactWebServiceAsync(); auto result2 = Compute2(result1, other); // Return to the UI thread to provide an interim update. co_await winrt::resume_foreground(Dispatcher()); // Back on the UI thread: We can update UI elements. TextBlock1().Text(result1); TextBlock2().Text(result2); // Back to the background thread to do more computations. co_await winrt::resume_background(); auto extra = co_await GetExtraDataAsync(); auto result3 = Compute3(result1, result2, extra); // Return to the UI thread to provide a final update. co_await winrt::resume_foreground(Dispatcher()); // Update the UI one last time. TextBlock3().Text(result3);}可以看到，使用 co_await winrt::resume_background(); 可以将线程切换至线程池，使用 co_await winrt::resume_foreground(Dispatcher()); 可以将线程切换至 UI。也许你会觉得这样没什么好处，因为 C#/.NET 的版本里面 Lambda 表达式一样可以这么做：await Task.Run(() =&amp;gt;{ // 这里的代码会在线程池执行。});// 这里的代码会回到 UI 线程执行。但是，现在我们给出这样的写法：// 仅在某些特定的情况下才使用线程池执行，而其他情况依然在主线程执行 DoSomething()。if (condition) { co_await winrt::resume_background();}DoSomething();你就会发现 Lambda 的版本变得很不好理解了。C# / .NET / WPF 版本我们现在编写一个自己的 Awaiter 来实现这样的线程上下文切换。关于如何编写一个 Awaiter，可以阅读我的其他博客： 定义一组抽象的 Awaiter 的实现接口，你下次写自己的 await 可等待对象时将更加方便 - 吕毅 .NET 中什么样的类是可使用 await 异步等待的？ - 吕毅 .NET 除了用 Task 之外，如何自己写一个可以 await 的对象？ - 吕毅这里，我直接贴出我编写的 DispatcherSwitcher 类的全部源码。using System;using System.Runtime.CompilerServices;using System.Threading.Tasks;using System.Windows.Threading;namespace Walterlv.ThreadSwitchingTasks{ public static class DispatcherSwitcher { public static ThreadPoolAwaiter ResumeBackground() =&amp;gt; new ThreadPoolAwaiter(); public static ThreadPoolAwaiter ResumeBackground(this Dispatcher dispatcher) =&amp;gt; new ThreadPoolAwaiter(); public static DispatcherAwaiter ResumeForeground(this Dispatcher dispatcher) =&amp;gt; new DispatcherAwaiter(dispatcher); public class ThreadPoolAwaiter : INotifyCompletion { public void OnCompleted(Action continuation) { Task.Run(() =&amp;gt; { IsCompleted = true; continuation(); }); } public bool IsCompleted { get; private set; } public void GetResult() { } public ThreadPoolAwaiter GetAwaiter() =&amp;gt; this; } public class DispatcherAwaiter : INotifyCompletion { private readonly Dispatcher _dispatcher; public DispatcherAwaiter(Dispatcher dispatcher) =&amp;gt; _dispatcher = dispatcher; public void OnCompleted(Action continuation) { _dispatcher.InvokeAsync(() =&amp;gt; { IsCompleted = true; continuation(); }); } public bool IsCompleted { get; private set; } public void GetResult() { } public DispatcherAwaiter GetAwaiter() =&amp;gt; this; } }}Raymond Chen 取的类名是 ThreadSwitcher，不过我认为可能 Dispatcher 在 WPF 中更能体现其线程切换的含义。于是，我们来做一个试验。以下代码在 MainWindow.xaml.cs 里面，如果你使用 Visual Studio 创建一个 WPF 的空项目的话是可以找到的。随便放一个 Button 添加事件处理函数。private async void DemoButton_Click(object sender, RoutedEventArgs e){ var id0 = Thread.CurrentThread.ManagedThreadId; await Dispatcher.ResumeBackground(); var id1 = Thread.CurrentThread.ManagedThreadId; await Dispatcher.ResumeForeground(); var id2 = Thread.CurrentThread.ManagedThreadId;}id0 和 id2 在主线程上，id1 是线程池中的一个线程。这样，我们便可以在一个上下文中进行线程切换了，而不需要使用 Task.Run 通过一个 Lambda 表达式来完成这样的任务。现在，这种按照某些特定条件才切换到后台线程执行的代码就很容易写出来了。// 仅在某些特定的情况下才使用线程池执行，而其他情况依然在主线程执行 DoSomething()。if (condition){ await Dispatcher.ResumeBackground();}DoSomething();Raymond Chen 的版本Raymond Chen 后来在另一篇博客中也编写了一份 WPF / Windows Forms 的线程切换版本。请点击下方的链接跳转至原文阅读： C++/WinRT envy: Bringing thread switching tasks to C# (WPF and WinForms edition) - The Old New Thing我在为他的代码添加了所有的注释后，贴在了下面：using System;using System.Runtime.CompilerServices;using System.Threading;using System.Windows.Forms;using System.Windows.Threading;namespace Walterlv.Windows.Threading{ /// &amp;lt;summary&amp;gt; /// 提供类似于 WinRT 中的线程切换体验。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;remarks&amp;gt; /// https://devblogs.microsoft.com/oldnewthing/20190329-00/?p=102373 /// https://blog.walterlv.com/post/bring-thread-switching-tasks-to-csharp-for-wpf.html /// &amp;lt;/remarks&amp;gt; public class ThreadSwitcher { /// &amp;lt;summary&amp;gt; /// 将当前的异步等待上下文切换到 WPF 的 UI 线程中继续执行。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;dispatcher&quot;&amp;gt;WPF 一个 UI 线程的调度器。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;一个可等待对象，使用 await 等待此对象可以使后续任务切换到 UI 线程执行。&amp;lt;/returns&amp;gt; public static DispatcherThreadSwitcher ResumeForegroundAsync(Dispatcher dispatcher) =&amp;gt; new DispatcherThreadSwitcher(dispatcher); /// &amp;lt;summary&amp;gt; /// 将当前的异步等待上下文切换到 Windows Forms 的 UI 线程中继续执行。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;control&quot;&amp;gt;Windows Forms 的一个控件。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;一个可等待对象，使用 await 等待此对象可以使后续任务切换到 UI 线程执行。&amp;lt;/returns&amp;gt; public static ControlThreadSwitcher ResumeForegroundAsync(Control control) =&amp;gt; new ControlThreadSwitcher(control); /// &amp;lt;summary&amp;gt; /// 将当前的异步等待上下文切换到线程池中继续执行。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;一个可等待对象，使用 await 等待此对象可以使后续的任务切换到线程池执行。&amp;lt;/returns&amp;gt; public static ThreadPoolThreadSwitcher ResumeBackgroundAsync() =&amp;gt; new ThreadPoolThreadSwitcher(); } /// &amp;lt;summary&amp;gt; /// 提供一个可切换到 WPF 的 UI 线程执行上下文的可等待对象。 /// &amp;lt;/summary&amp;gt; public struct DispatcherThreadSwitcher : INotifyCompletion { internal DispatcherThreadSwitcher(Dispatcher dispatcher) =&amp;gt; _dispatcher = dispatcher; /// &amp;lt;summary&amp;gt; /// 当使用 await 关键字异步等待此对象时，将调用此方法返回一个可等待对象。 /// &amp;lt;/summary&amp;gt; public DispatcherThreadSwitcher GetAwaiter() =&amp;gt; this; /// &amp;lt;summary&amp;gt; /// 获取一个值，该值指示是否已完成线程池到 WPF UI 线程的切换。 /// &amp;lt;/summary&amp;gt; public bool IsCompleted =&amp;gt; _dispatcher.CheckAccess(); /// &amp;lt;summary&amp;gt; /// 由于进行线程的上下文切换必须使用 await 关键字，所以不支持调用同步的 &amp;lt;see cref=&quot;GetResult&quot;/&amp;gt; 方法。 /// &amp;lt;/summary&amp;gt; public void GetResult() { } /// &amp;lt;summary&amp;gt; /// 当异步状态机中的前一个任务结束后，将调用此方法继续下一个任务。在此可等待对象中，指的是切换到 WPF 的 UI 线程。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;continuation&quot;&amp;gt;将异步状态机推进到下一个异步状态。&amp;lt;/param&amp;gt; public void OnCompleted(Action continuation) =&amp;gt; _dispatcher.BeginInvoke(continuation); private readonly Dispatcher _dispatcher; } /// &amp;lt;summary&amp;gt; /// 提供一个可切换到 Windows Forms 的 UI 线程执行上下文的可等待对象。 /// &amp;lt;/summary&amp;gt; public struct ControlThreadSwitcher : INotifyCompletion { internal ControlThreadSwitcher(Control control) =&amp;gt; _control = control; /// &amp;lt;summary&amp;gt; /// 当使用 await 关键字异步等待此对象时，将调用此方法返回一个可等待对象。 /// &amp;lt;/summary&amp;gt; public ControlThreadSwitcher GetAwaiter() =&amp;gt; this; /// &amp;lt;summary&amp;gt; /// 获取一个值，该值指示是否已完成线程池到 Windows Forms UI 线程的切换。 /// &amp;lt;/summary&amp;gt; public bool IsCompleted =&amp;gt; !_control.InvokeRequired; /// &amp;lt;summary&amp;gt; /// 由于进行线程的上下文切换必须使用 await 关键字，所以不支持调用同步的 &amp;lt;see cref=&quot;GetResult&quot;/&amp;gt; 方法。 /// &amp;lt;/summary&amp;gt; public void GetResult() { } /// &amp;lt;summary&amp;gt; /// 当异步状态机中的前一个任务结束后，将调用此方法继续下一个任务。在此可等待对象中，指的是切换到 Windows Forms 的 UI 线程。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;continuation&quot;&amp;gt;将异步状态机推进到下一个异步状态。&amp;lt;/param&amp;gt; public void OnCompleted(Action continuation) =&amp;gt; _control.BeginInvoke(continuation); private readonly Control _control; } /// &amp;lt;summary&amp;gt; /// 提供一个可切换到线程池执行上下文的可等待对象。 /// &amp;lt;/summary&amp;gt; public struct ThreadPoolThreadSwitcher : INotifyCompletion { /// &amp;lt;summary&amp;gt; /// 当使用 await 关键字异步等待此对象时，将调用此方法返回一个可等待对象。 /// &amp;lt;/summary&amp;gt; public ThreadPoolThreadSwitcher GetAwaiter() =&amp;gt; this; /// &amp;lt;summary&amp;gt; /// 获取一个值，该值指示是否已完成 UI 线程到线程池的切换。 /// &amp;lt;/summary&amp;gt; public bool IsCompleted =&amp;gt; SynchronizationContext.Current == null; /// &amp;lt;summary&amp;gt; /// 由于进行线程的上下文切换必须使用 await 关键字，所以不支持调用同步的 &amp;lt;see cref=&quot;GetResult&quot;/&amp;gt; 方法。 /// &amp;lt;/summary&amp;gt; public void GetResult() { } /// &amp;lt;summary&amp;gt; /// 当异步状态机中的前一个任务结束后，将调用此方法继续下一个任务。在此可等待对象中，指的是切换到线程池中。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;continuation&quot;&amp;gt;将异步状态机推进到下一个异步状态。&amp;lt;/param&amp;gt; public void OnCompleted(Action continuation) =&amp;gt; ThreadPool.QueueUserWorkItem(_ =&amp;gt; continuation()); }}参考资料 C++/WinRT envy: Bringing thread switching tasks to C# (UWP edition) - The Old New Thing C++/WinRT envy: Bringing thread switching tasks to C# (WPF and WinForms edition) - The Old New Thing" }, { "title": "解决 Git 重命名时遇到的大小写不敏感的问题", "url": "/post/case-insensitive-in-git-rename.html", "categories": "", "tags": "windows, git", "date": "2019-03-29 17:19:06 +0800", "snippet": "Windows/Mac OS 操作系统文件的大小写是不敏感的，不管文件路径是何种奇怪的大小写，我们始终可以以另一种大小写的方式访问到这个路径种的文件或者文件夹。Linux 操作系统文件的大小写却是敏感的，不同大小写意味着不同的路径。于是，Windows 下的 A 文件在 Docs 文件夹下，B 文件在 docs 文件夹下，最终效果是 A B 都在 docs 文件夹下；而同样的情况放到 Linux 中，A B 就在两个不同的文件夹。Git 是大小写不敏感的，导致跨操作系统共享的 Git 仓库就会遇到上面的情况。如果重命名的文件或文件夹只有大小写不同，那么对 Git 来说甚至都没有变化。阅读本文将解决 Git 大小写不敏感导致的重命名无效的问题。更新：Windows 10 1803 更新已经可以支持区分大小写的文件夹了，于是此问题迎刃而解，后面会详细说明。解决方法（推荐） 更新 Windows 10 1803 并安装 Windows 的 Linux 子系统； 开启文件夹的大小写敏感特性，请参见： 使用以下命令改名，可以仅大小写不同，你可能需要加上 -f，这样即使目标文件名存在，也可以完成改名。$ git mv -f ./Docs ./docs$ git commit -m &quot;改名&quot;在 git 中使用 mv 命令的时候，会自动 add 所以是不用额外在敲 git add . 的，而后面的 commit 之后就形成了一个提交，之后你该怎么处理你的 git 仓库就怎么处理你的 git 仓库。注意，即便你已经开启了文件夹大小写敏感，但你依然需要使用 git mv -f 命令来重命名，如果使用 Windows 资源管理器来进行重命名，那么 git 也是无法识别到这种仅有大小写名称改变的重命名的。我是分割线如果你不了解到底是怎样的 git 重命名问题，那么可以阅读本博客的原始版本，还是踩了不少坑的。让人困扰的大小写问题让我对此问题产生困扰的是下面这张图，Docs 和 docs 两个文件夹分开了：▲ 分离的两个文件夹Docs 改名为 docs，于是只有新增的文件才在 docs 文件夹下，旧文件依然在 Docs 中。README.md 中的链接可就遭殃了，还要注意大小写！▲ 稍不注意，就 404 了走的弯路这种问题怎么看都不像是我一个人会遇到的问题，堆栈网上讨论肯定很多。至少截至本文发表时，How do I commit case-sensitive only filename changes in Git? 中问题已经得到了 600+ 个赞，回答累计得到 1400+ 个赞了……里面探讨的方法归结起来两个： git mv -f OldFileNameCase newfilenamecase git config core.ignorecase false尝试方法二：core.ignorecase false第二种方法看起来更简单，于是我第一时间在我的全局 git 配置文件（C:\\Users\\lvyi\\.gitconfig）中添加了一项：[core] ignorecase = false这时，git status 就能发现我的 git 仓库中 Docs 文件夹下的所有文件已经标记为修改了，都变成了 docs，于是愉快的提交推送：$ git add .$ git commit -m &quot;Docs 文件夹改名为 docs 文件夹&quot;$ git push然而去其他系统上看——居然有 Docs 和 docs 两份文件夹！！！而且比之前更严重，这一次可是里面的文件都完全重复了一份啊！！！这时注意到 git add . 时，其实文件都是“新增”的，并不是“重命名”：看来需要使用第一种方法了。尝试方法一：mv我写下命令：$ git mv -f ./Docs ./docs执行……推送后最终效果居然和第一种方法一样！依然是有 Docs 和 docs 两份文件夹。尝试出的可行的方法这是堆栈网那位只有 70+ 赞的方法的改进版本。先将文件夹重命名为临时文件夹，然后再从临时文件夹恢复成正常文件夹。但是（划重点）中间需要先 commit 一次，否则和前面的方法效果一样，会存在两份文件夹！$ git mv ./Docs ./docs.bak$ git add .$ git commit -m &quot;改名（第 1/2 步）&quot;$ git mv ./docs.bak/ ./docs$ git add .$ git commit -m &quot;改名（第 2/2 步）&quot;$ git push中间的 git add . 其实是可以不需要的，因为 mv 命令会自动将修改加入暂存区。至此，文件夹才真的做了仅大小写的改名。使用 Windows 10 四月更新的特性（推荐）我在 Windows 10 四月更新，文件夹名称也能区分大小写？ 一文中提到可以使用 fsutil.exe file SetCaseSensitiveInfo 使某个特定的文件夹支持区分大小写。经过尝试，使用此方法后，git 能够支持一次提交完美解决仅大小写的文件夹改名问题，完全不用管 git 的某种配置或其他任何因素。首先，使用管理员权限在当前文件夹启动 PowerShell：然后允许一下命令，以便开启此文件夹的大小写敏感功能。&amp;gt; fsutil.exe file SetCaseSensitiveInfo . enable随后，你可以像一般重命名一样去修改文件夹名称，然后像普通提交一样去 git commit。直接能生成一个仅修改文件夹名称大小写的新提交。如果你在执行以上命令时出现了问题，请移步至 Windows 10 四月更新，文件夹名称也能区分大小写？ 统一寻找解决方法。参考资料 How do I commit case-sensitive only filename changes in Git? - Stack Overflow In a Git repository, how to properly rename a directory? - Stack Overflow" }, { "title": "WPF 的命令的自动刷新时机——当你 CanExecute 会返回 true 但命令依旧不可用时可能是这些原因", "url": "/post/when-wpf-commands-update-their-states.html", "categories": "", "tags": "wpf, dotnet, csharp", "date": "2019-03-29 16:43:27 +0800", "snippet": "在 WPF 中，你可以使用 Command=&quot;{Binding WalterlvCommand}&quot; 的方式来让 XAML 中的一个按钮或其他控件绑定一个命令。这样，按钮的可用性会自动根据 WalterlvCommand 当前 CanExecute 的状态来改变。这本是一个非常智能的特性，直到你可能发现你按钮的可用性状态不正确……本文介绍默认情况下，WPF 在 UI 上的这些命令会在什么时机进行刷新；以及没有及时刷新时，可以如何强制让这些命令的可用性状态进行刷新。了解了这些，你可能能够解决你在 WPF 程序中命令绑定的一些坑。This post is written in multiple languages. Please select yours: 中文 English 一个最简单的例子&amp;lt;Button x:Name=&quot;TestCommand&quot; Command=&quot;{Binding WalterlvCommand}&quot; /&amp;gt;public class Walterlv{ // 省略了此命令的初始化。 public WalterlvCommand WalterlvCommand { get; }}public class WalterlvCommand : ICommand{ public bool SomeFlag { get; set; } bool ICommand.CanExecute(object parameter) { // 判断命令的可用性。 return SomeFlag; } void ICommand.Execute(object parameter) { // 省略了执行命令的代码。 }}假如 SomeFlag 一开始是 false，5 秒种后变为 true，那么你会注意到这时的按钮状态并不会刷新。var walterlv = new Walterlv();TestCommand.DataContext = walterlv;await Task.Delay(5000);walterlv.WalterlvCommand.SomeFlag = true;当然，以上所有代码会更像伪代码，如果你不熟悉 WPF，是一定编译不过的。我只是在表达这个意思。如何手动刷新命令调用以下代码，即可让 WPF 中的命令刷新其可用性：CommandManager.InvalidateRequerySuggested();WPF 的命令在何时刷新？默认情况下，WPF 的命令只会在以下时机刷新可用性： KeyUp MouseUp GotKeyboardFocus LostKeyboardFocus使用通俗的话来说，就是： 键盘按下的按键抬起的时候 在鼠标的左键或者右键松开的时候 在任何一个控件获得键盘焦点或者失去键盘焦点的时候这部分的代码可以在这里查看： CommandDevice.PostProcessInput最关键的代码贴在这里：// 省略前面。if (e.StagingItem.Input.RoutedEvent == Keyboard.KeyUpEvent || e.StagingItem.Input.RoutedEvent == Mouse.MouseUpEvent || e.StagingItem.Input.RoutedEvent == Keyboard.GotKeyboardFocusEvent || e.StagingItem.Input.RoutedEvent == Keyboard.LostKeyboardFocusEvent){ CommandManager.InvalidateRequerySuggested();}然而，并不是只在这些时机进行刷新，还有其他的时机，比如这些： 在 Menu 菜单的子菜单项打开的时候（参见 MenuItem.OnIsSubmenuOpenChanged） 在长按滚动条中的按钮以连续滚动的过程中（参见 Tracker.DecreaseRepeatButton） 在 DataGridCell 的只读属性改变的时候（参见 DataGridCell.OnNotifyIsReadOnlyChanged） 在 DataGrid 中的各种各样的操作中（参见 DataGrid） 在 JournalNavigationScope 向后导航的时候（参见 JournalNavigationScope.OnBackForwardStateChange） 还有其他，你可以在此链接双击 InvalidateRequerySuggested 查看：InvalidateRequerySuggested" }, { "title": "When WPF Commands update their CanExecute states?", "url": "/post/when-wpf-commands-update-their-states-en.html", "categories": "", "tags": "wpf, dotnet, csharp", "date": "2019-03-29 16:43:19 +0800", "snippet": "When writing Command=&quot;{Binding WalterlvCommand}&quot; into your XAML code and your button or other controls can automatically execute command and updating the command states, such as enabling or disabling the button.We’ll talk about when the UI commands will refresh their can-execute states and how to force updating the states.This post is written in multiple languages. Please select yours: 中文 English This post is written for my Stack Overflow answer: Why C# WPF button binding command won’t change view after using simple injector? - Stack OverflowA simple sample&amp;lt;Button x:Name=&quot;TestCommand&quot; Command=&quot;{Binding WalterlvCommand}&quot; /&amp;gt;public class Walterlv{ // Assume that I&#39;ve initialized this command. public WalterlvCommand WalterlvCommand { get; }}public class WalterlvCommand : ICommand{ public bool SomeFlag { get; set; } bool ICommand.CanExecute(object parameter) { // Return the real can execution state. return SomeFlag; } void ICommand.Execute(object parameter) { // The actual executing procedure. }}See this code below. After 5 seconds, the button will still be disabled even that we set the SomeFlat to true.var walterlv = new Walterlv();TestCommand.DataContext = walterlv;await Task.Delay(5000);walterlv.WalterlvCommand.SomeFlag = true;How to update manually?Call this method after you want to update your command states if it won’t update:CommandManager.InvalidateRequerySuggested();When do the commands update their states?Commands only update when these general events happen: KeyUp MouseUp GotKeyboardFocus LostKeyboardFocusYou can see the code here: CommandDevice.PostProcessInputAnd the key code is here:if (e.StagingItem.Input.RoutedEvent == Keyboard.KeyUpEvent || e.StagingItem.Input.RoutedEvent == Mouse.MouseUpEvent || e.StagingItem.Input.RoutedEvent == Keyboard.GotKeyboardFocusEvent || e.StagingItem.Input.RoutedEvent == Keyboard.LostKeyboardFocusEvent){ CommandManager.InvalidateRequerySuggested();}Actually, not only those events above but also these methods below refresh the command states: When opening a submenu of a MenuItem. See MenuItem.OnIsSubmenuOpenChanged When pressing and holding a RepeatButton in a Tracker. Tracker.DecreaseRepeatButton When change the readonly property of DataGridCell. DataGridCell.OnNotifyIsReadOnlyChanged When doing many operations in a DataGrid. DataGrid When navigating back in a JournalNavigationScope. JournalNavigationScope.OnBackForwardStateChange And others, you can find references of InvalidateRequerySuggested: InvalidateRequerySuggested" }, { "title": "程序员与英语：即时聊天中的英语缩写 lol / lmao / idk", "url": "/post/programmers-english-abbr-in-chat.html", "categories": "", "tags": "miscellaneous", "date": "2019-03-27 16:56:05 +0800", "snippet": "经常混迹各大英文开发者社区的你，是否会遇到一些奇怪的英文缩写呢？本文整理一些即时聊天中常用的缩写。英语部分lol Laughing out Loud Laugh out Loud Lots of Laughs Laugh Online缩写可以说来源于上面那些，似乎意思是“好好笑啊”。然而事实可能并不是这样……不知是否用“呵呵”，“Interesting” 来回复对方的句子呢？嗯嗯，差不多就是这个感觉啦。其实就只是回复一下而已，不要当真。或者，这种感觉可能和 233 很像。lmao Laughing my ass off笑到屁屁都掉了。似乎这是一个比 lol 笑得更厉害的笑法儿。idk I don’t know，我不知道thx / tks Thanksbbs / brb Be back soon，马上回来 Be right back，马上回来btw By the way，顺便说一下FYI For your information，给你信息，你参考一下 邮件中会经常见到这个，通常在转发的时候带上ttyl Talk to you later，回头再聊 这个注意可能说出来之后会有结束当前会话的意味，也许没有回头了歪楼：中文部分要歪个楼，因为发现中文中也有一些英文中可以对应的说法。3q / 3Q Thanks，谢了1 如果是一则消息，表示已读；如果是一个问题，表示“是”“同意”等 就一个数字，按下即可回车，很快0 如果是一则消息，表示反对；如果是一个问题，表示“否”“不同意”等 就一个数字，按下即可回车，很快233 愿意是“大笑”，但其实含义已经改变，现在意思几乎跟“呵呵”一样 “你继续说，我就看着不说话”666 溜溜溜，指对方做的某件事情很抢眼，很厉害回聊 回头再聊 Talk to you later，回头再聊 这个注意可能说出来之后会有结束当前会话的意味，也许没有回头了参考资料 聊天中经常用的「lol」是什么意思？ - 知乎 LMAO 不是老毛，是笑出猪叫 【英文缩写专题课】" }, { "title": "C#/.NET 如何获取一个异常（Exception）的关键特征，用来判断两个异常是否表示同一个异常", "url": "/post/get-the-key-descriptor-of-an-exception.html", "categories": "", "tags": "dotnet, csharp", "date": "2019-03-26 14:35:51 +0800", "snippet": "在 .NET / C# 程序中出现异常是很常见的事情，程序出现异常后记录日志或者收集到统一的地方可以便于分析程序中各种各样此前未知的问题。但是，有些异常表示的是同一个异常，只是因为参数不同、状态不同、用户的语言环境不同就分开成多个异常的话，分析起来会有些麻烦。本文将提供一个方法，将异常的关键信息提取出来，这样可以比较多次抛出的不同的异常实例是否表示的是同一个异常。Exception.ToString()以下是捕获到的一个异常实例，调用 ToString() 方法后拿到的结果：System.NotSupportedException: BitmapMetadata 在 BitmapImage 上可用。 在 System.Windows.Media.Imaging.BitmapImage.get_Metadata() 在 System.Windows.Media.Imaging.BitmapFrame.Create(BitmapSource source) 在 Walterlv.Demo.Exceptions.Foo.Take(string fileName)在英文的系统上，拿到的结果可能是这样的：System.NotSupportedException: BitmapMetadata is not available on BitmapImage. at System.Windows.Media.Imaging.BitmapImage.get_Metadata() at System.Windows.Media.Imaging.BitmapFrame.Create(BitmapSource source) at Walterlv.Demo.Exceptions.Foo.Take(string fileName)这样，我们就不能使用 ToString() 来判断两个异常是否表示同一个异常了。另外，在 ToString() 方法中，如果包含 PDB，那么异常堆栈中还会包含源代码文件的路径以及行号信息。关于 ToString() 中输出的信息，可以阅读 StackTrace.ToString() 方法的源码来了解： StackTrace.cs哪些信息是异常的关键信息从默认的 ToString() 中我们可以得知，它包含三个部分： 异常类型的全名 Type.FullName 异常信息 Exception.Message 异常堆栈 Exception.StackTrace考虑到 Message 部分受多语言影响非常严重，很难作为关键异常特征，所以我们在提取关键异常特征的时候，需要将这一部分去掉，只能作为此次异常的附加信息，而不能作为关键特征。所以我们的关键特征就是： 异常类型的全名 Type.FullName 异常堆栈中所有帧的方法签名（这能保证语言无关）比如本文一开始列举出来的异常堆栈，我们应该提取成：System.NotSupportedException System.Windows.Media.Imaging.BitmapImage.get_Metadata() System.Windows.Media.Imaging.BitmapFrame.Create(BitmapSource source) Walterlv.Demo.Exceptions.Foo.Take(string fileName)提取特征的 C# 代码为了提取出以上的关键特征，我需要写一段 C# 代码来做这样的事情：public (string typeName, IReadonlyList&amp;lt;string&amp;gt; frameSignature) GetDescriptor(Exception exception){ var type = exception.GetType().FullName; var stackFrames = new StackTrace(exception).GetFrames() ?? new StackFrame[0]; var frames = stackFrames.Select(x =&amp;gt; x.GetMethod()).Select(m =&amp;gt; $&quot;{m.DeclaringType?.FullName ?? &quot;null&quot;}.{m.Name}({string.Join(&quot;, &quot;, m.GetParameters().Select(p =&amp;gt; $&quot;{p.ParameterType.Name} {p.Name}&quot;))})&quot;); return (type, frames.ToList());}一个是拿到 Exception 实例的类型名称，通过 exception.GetType().FullName。另一个拿到方法签名。由于 Exception.StackTrace 属性得到的是一个字符串，而且此字符串还真的有可能根本不是异常信息呢，所以我们这里通过创建一个 StackTrace 的实例来从异常中获取真实的堆栈，当然如果拿不到我们这里使用空数组来表示。随后，遍历异常堆栈中的所有帧，将方法名和方法的所有参数进行拼接，形成 ClassFullName.MethodName(ParameterType parameterName) 这样的形式，于是就拼接成类似 Exception.ToString() 中的格式了。由于确定一个类型中是否是同一个方法时与返回值无关，所以我们甚至不需要将返回值加上就能唯一确定一个方法了。一个完整的 ExceptionDescriptor为了方便，我写了一个完整的 ExceptionDescriptor 类型来完成异常特征提取的事情。这个类同时重写了相等方法，这样可以直接使用相等方法来判断两个异常的关键信息是否表示的是同一个异常。源码可以在这里找到：https://gist.github.com/walterlv/0ce95369aa78c5f0f38a527bef5779c2using System;using System.Collections.Generic;using System.Diagnostics;using System.Linq;namespace Walterlv{ /// &amp;lt;summary&amp;gt; /// 包含一个 &amp;lt;see cref=&quot;Exception&quot;/&amp;gt; 对象的关键特征，可使用此对象的实例判断两个不同的异常实例是否极有可能表示同一个异常。 /// &amp;lt;/summary&amp;gt; [DebuggerDisplay(&quot;{TypeName,nq}: {FrameSignature[0],nq}&quot;)] public class ExceptionDescriptor : IEquatable&amp;lt;ExceptionDescriptor&amp;gt; { /// &amp;lt;summary&amp;gt; /// 获取此异常的类型名称。 /// &amp;lt;/summary&amp;gt; public string TypeName { get; } /// &amp;lt;summary&amp;gt; /// 获取此异常堆栈中的所有帧的方法签名，指的是在一个类型中不会冲突的最小部分，所以不含返回值和可访问性。 /// 比如 private void Foo(Bar b); 方法，在这里会写成 Foo(Bar b)。 /// &amp;lt;/summary&amp;gt; public IReadOnlyList&amp;lt;string&amp;gt; FrameSignature { get; } /// &amp;lt;summary&amp;gt; /// 从一个异常中提取出关键的异常特征，并创建 &amp;lt;see cref=&quot;ExceptionDescriptor&quot;/&amp;gt; 的新实例。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;exception&quot;&amp;gt;要提取特征的异常。&amp;lt;/param&amp;gt; public ExceptionDescriptor(Exception exception) { var type = exception.GetType().FullName; var stackFrames = new StackTrace(exception).GetFrames() ?? new StackFrame[0]; var frames = stackFrames.Select(x =&amp;gt; x.GetMethod()).Select(m =&amp;gt; $&quot;{m.DeclaringType?.FullName ?? &quot;null&quot;}.{m.Name}({string.Join(&quot;, &quot;, m.GetParameters().Select(p =&amp;gt; $&quot;{p.ParameterType.Name} {p.Name}&quot;))})&quot;); TypeName = type; FrameSignature = frames.ToList(); } /// &amp;lt;summary&amp;gt; /// 根据异常的信息本身创建异常的关键特征。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;typeName&quot;&amp;gt;异常类型的完整名称。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&quot;frameSignature&quot;&amp;gt; /// 异常堆栈中的所有帧的方法签名，指的是在一个类型中不会冲突的最小部分，所以不含返回值和可访问性。 /// 比如 private void Foo(Bar b); 方法，在这里会写成 Foo(Bar b)。 /// &amp;lt;/param&amp;gt; public ExceptionDescriptor(string typeName, IReadOnlyList&amp;lt;string&amp;gt; frameSignature) { TypeName = typeName; FrameSignature = frameSignature; } /// &amp;lt;summary&amp;gt; /// 判断此异常特征对象是否与另一个对象实例相等。 /// 如果参数指定的对象是 &amp;lt;see cref=&quot;ExceptionDescriptor&quot;/&amp;gt;，则判断特征是否相等。 /// &amp;lt;/summary&amp;gt; public override bool Equals(object obj) { if (ReferenceEquals(null, obj)) { return false; } if (ReferenceEquals(this, obj)) { return true; } if (obj.GetType() != this.GetType()) { return false; } return Equals((ExceptionDescriptor) obj); } /// &amp;lt;summary&amp;gt; /// 判断此异常特征与另一个异常特征是否是表示同一个异常。 /// &amp;lt;/summary&amp;gt; public bool Equals(ExceptionDescriptor other) { if (ReferenceEquals(null, other)) { return false; } if (ReferenceEquals(this, other)) { return true; } return string.Equals(TypeName, other.TypeName) &amp;amp;&amp;amp; FrameSignature.SequenceEqual(other.FrameSignature); } /// &amp;lt;inheritdoc /&amp;gt; public override int GetHashCode() { unchecked { return ((TypeName != null ? StringComparer.InvariantCulture.GetHashCode(TypeName) : 0) * 397) ^ (FrameSignature != null ? FrameSignature.GetHashCode() : 0); } } /// &amp;lt;summary&amp;gt; /// 判断两个异常特征是否是表示同一个异常。 /// &amp;lt;/summary&amp;gt; public static bool operator ==(ExceptionDescriptor left, ExceptionDescriptor right) { return Equals(left, right); } /// &amp;lt;summary&amp;gt; /// 判断两个异常特征是否表示的不是同一个异常。 /// &amp;lt;/summary&amp;gt; public static bool operator !=(ExceptionDescriptor left, ExceptionDescriptor right) { return !Equals(left, right); } }}参考资料 StackTrace.cs" }, { "title": "在 CVTE 和广州 .NET 微软技术俱乐部共同举办的 12月8日 广州微软技术沙龙活动", "url": "/post/december-event-microsoft-technology-salon.html", "categories": "", "tags": "dotnet", "date": "2019-03-24 14:25:49 +0800", "snippet": "2018 年 12 月 8 日，在 CVTE·视源股份，在广州黄埔区云埔四路 6 号，我们举办了广州微软技术沙龙。现场参与人数 136 人（不含工作人员），线上参与人员 400+ 人。活动完全免费。这是 CVTE·视源股份 和 广州 .NET 微软技术俱乐部 共同举办的一次技术沙龙，我（吕毅）和林德熙，作为微软 MVP，同时是 CVTE 的一员，同时还是广州 .NET 微软技术俱乐部的一员，组织起这次活动，然后在活动中分享了我们的课程 —— 《预编译框架，开发高性能 .NET 应用》。虽然本文的创建日期是 12 月 9 号，但实际上内容直到今天才慢慢填完。活动的起源活动的发起者是“叶伟民”，叶伟民在 2018 年 8 月计划重新复活沉寂了数年的广州 .NET 微软技术俱乐部，我（吕毅）和林德熙成为了这次复活活动中最早期的一批成员。在叶伟民在“广州 .NET 微软技术俱乐部”微信群中表达了希望举办一场活动来正式复活广州 .NET 微软技术俱乐部，我看到消息的第一时间就回应了叶伟民。因为我和林德熙也在计划在广州范围内举办一次线下活动，再加上广州真的也非常需要有这样一个庞大的 .NET 组织来推广微软技术。于是立刻回应我可以在活动中准备一次演讲或者课程，帮助推广微软 .NET 技术。叶洪，跟我和林德熙一样，是 CVTE·视源股份 的软件工程师，在收到叶伟民的复活广州 .NET 微软技术俱乐部的提议后，也非常积极响应，准备调动 CVTE·视源股份 的资源，为这次活动提供堪称豪华的场地和服务。因为我是做 Windows 应用开发的，和 .NET 技术之间是有很多共通点的，或者说其实也是在大量应用 .NET 技术，所以我只需要稍作调整，即可让我原本在 Windows 应用中适用的技术同样适用于更广泛的 .NET 技术上。活动的计划和准备在活动之前，叶伟民组织我们十位小伙伴一起在星巴克进行一些活动举办上的讨论，确定下了讲师，活动的组织形式，确定中间可以来一些闪电演讲，确定活动完全免费，而且将活动场地定在了 CVTE·视源股份。因为场地选在了 CVTE·视源股份，所以叶洪在这次活动的举办中付出了许许多多的努力，他一直都在加紧与 广州 .NET 微软技术俱乐部 的组织者一起沟通，很多个晚上都在抓紧时间准备活动所需的各种资源和素材，他与公司的各个部分和管理人员取得联系，试图为这次活动争取到足够的场地、时间以及服务。而我在准备中向微软中国 MVP 项目组申请了 100 份用于发放给参与者的礼品，为活动制作了几乎全部的视觉设计，和叶洪一起细化活动过程中的各种细节，为活动的各种意外情况准备救场方式。在场地现场调试 21:9 比例的 LED 显示屏，在活动现场部署我们需要的各种环境等等。当然，还有跟我在同一个团队的各位小伙伴，也在努力的为活动的每一个细节提供最好的服务。张强、邓蘅、牛彦杰、余冬、丁琛、程遥、李嫚、娄娜……印象中我列举的人数和实际比起来还差非常多……他们为活动现场提供了班车接送、公司参观、公司介绍、茶水准备、零食准备、水果准备、桌椅布置、现场摄影等等各种各样的细节。叶伟民为了活动上提高效率，写了一篇给俱乐部成员的博客： 广州.NET微软技术俱乐部提技术问题的正确方式 - 叶伟民 - 博客园我竟然是一位视觉设计师实际上，广州 .NET 微软技术俱乐部在当时还是非常寒碜的，作为一个覆盖整个广州市范围的组织，甚至还没有设计一个 Logo。因为我自己是一位热爱设计的程序员，所以非常乐意在此为 广州 .NET 微软技术俱乐部 设计第一版 Logo。不止如此，我们有三位原生讲师，分别是叶伟民、我（吕毅）和林德熙，但是却连活动专用的 PPT 母版也没有，所以我还为这次活动设计了专门的母版。最开始我准备的母版是 16:9 的，但是后来发现场地实际上是 21:9 的大 LED 屏，于是后来把我的整份课件重新制作成了 21:9 的，以便让现场参与的学员能够获得更好的观看体验。活动还需要暖场视频、座位表、海报、还有各种各样显示或者打印的图片素材，这些也都缺设计师，所以我也挑起了这些设计任务。以下是我设计的报名页，设计得比较素，不过这是我的设计风格。当然，二维码现在已经失效啦！在把这份报名海报发出去的 24 个小时里面，内心真的是非常激动又焦虑，怕人数少了活动组织得尴尬，又怕人数多了我们在现场又安排不过来，造成非常差的体验。活动当天这是活动的重要组织者——叶洪（左），和本次活动主持人，广州 .NET 微软技术俱乐部重要成员——戚亚柱（右）。活动一开始是 Jordan Dong 的演讲 —— 《离你最近的 Windows 10》，这是一个介绍 Windows 10 各项新功能的演讲。随后是叶伟民的 ABP 框架分享。看下图！活动当天过来参加的小伙伴们正在认真地聆听我（吕毅）和林德熙的课程 —— 《预编译框架，开发高性能 .NET 应用》。现场的小伙伴们也都积极地参与提问和其他各种互动。下图是我和林德熙在解答现场小伙伴的提问。活动反馈在活动结束之后，朋友圈、微信群里到处都有参与的小伙伴对本次活动的评价。有表扬 CVTE·视源股份 的，有赞扬 广州 .NET 微软技术俱乐部 的，有表扬课程内容的，也有探讨课程技术细节的。影响与未来在这次活动之后，苏州、西安、重庆、北京、上海等各地的 .NET 俱乐部也开始一一复活，全国的 .NET 开发者们又重新聚集到了一起。附叶伟民没有写完的总结： 2018年12月8日广州.NET微软技术俱乐部活动总结 - 叶伟民 - 博客园" }, { "title": "C#/.NET 如何在第一次机会异常 FirstChanceException 中获取比较完整的异常堆栈", "url": "/post/how-to-get-the-full-stacktrace-of-an-first-chance-exception.html", "categories": "", "tags": "dotnet, csharp", "date": "2019-03-24 12:09:37 +0800", "snippet": "在 FirstChangeException 事件中，我们通常只能拿到异常堆栈的第一帧，这对于我们捕捉到异常是好的，但对分析第一次机会异常可能并不利。本文介绍如何在 FirstChangeException 事件中拿到比较完整的异常堆栈，而不只是第一帧。第一次机会异常.NET 程序代码中的任何一段代码，在刚刚抛出异常，还没有被任何处理的那一时刻，AppDomain 的实例会引发一个 FirstChanceException 事件，用于通知此时刚刚开始发生了一个异常。这时，这个异常还没有寻找任何一个可以处理它的 catch 块，在此事件中，你几乎是第一时间拿到了这个异常的信息。监听第一次机会异常的代码是这个样子的：private void WalterlvDemo(){ AppDomain.CurrentDomain.FirstChanceException += OnFirstChanceException;}private void OnFirstChanceException(object sender, FirstChanceExceptionEventArgs e){ // 在这里，可以通过 e.Exception 来获取到这个异常。 Console.WriteLine(e.Exception.ToString());}只不过，在这里我们拿到的异常堆栈只有第一帧，因为这个时候，还没有任何 catch 块捕捉到这个异常。比如，我们只能拿到这个：System.NotSupportedException: BitmapMetadata 在 BitmapImage 上可用。 在 System.Windows.Media.Imaging.BitmapImage.get_Metadata()一点知识：Exception 实例的异常堆栈，是从第一次抛出异常的地方开始，到第一个 catch 它的地方结束，除非这个 catch 块中继续只用 throw; 抛出才继续向外延伸到下一个 catch。另外，你也可以用 ExceptionDispatchInfo 让内部异常的堆栈也连接起来，详见我的另一篇博客： 使用 ExceptionDispatchInfo 捕捉并重新抛出异常 - 吕毅获取较完整的第一次机会异常堆栈我们需要等到 FirstChanceException 事件中的异常被 catch 到，就能获取到第一次抛出的地方到 catch 处之间的所有帧。所以，我们只需要稍作延迟，即可拿到较完整的异常堆栈：private void WalterlvDemo(){ AppDomain.CurrentDomain.FirstChanceException += OnFirstChanceException;}private async void OnFirstChanceException(object sender, FirstChanceExceptionEventArgs e){ // 刚刚进入第一次机会异常事件的时候，异常堆栈只有一行，因为此时还没有任何地方 catch。 // 现在等待一点点时间，使得异常的堆栈能够延伸到 catch。等待多长不重要，关键是为了让异常得以找到第一个 catch。 await Task.Delay(10); // 在这里，可以通过 e.Exception 来获取到这个异常。 Console.WriteLine(e.Exception.ToString());}这样，我们可以得到：System.NotSupportedException: BitmapMetadata 在 BitmapImage 上可用。 在 System.Windows.Media.Imaging.BitmapImage.get_Metadata() 在 System.Windows.Media.Imaging.BitmapFrame.Create(BitmapSource source) 在 Walterlv.Demo.Exceptions.Foo.Take(string fileName)这里，等待多长时间是不重要的，只要不是 0 就好。因为我们只需要当前调用堆栈中的异常处理执行完成即可。关于等待时间，可以阅读我的另一篇博客： C#/.NET 中 Thread.Sleep(0), Task.Delay(0), Thread.Yield(), Task.Yield() 不同的执行效果和用法建议 - 吕毅如果需要对此异常进行后续的分析，可以参考我的另一篇博客： C#/.NET 如何获取一个异常（Exception）的关键特征，用来判断两个异常是否表示同一个异常 - 吕毅" }, { "title": "流畅设计 Fluent Design System 中的光照效果 RevealBrush，WPF 也能模拟实现啦！", "url": "/post/fluent-design-reveal-brush-in-wpf.html", "categories": "", "tags": "wpf, xaml, uwp", "date": "2019-03-23 11:09:45 +0800", "snippet": "UWP 才能使用的流畅设计效果好惊艳，写新的 UWP 程序可以做出更漂亮的 UI 啦！然而古老的 WPF 项目也想解解馋怎么办？于是我动手实现了一个！迫不及待看效果▲ 是不是很像 UWP 中的 RevealBorderBrush？不止是效果像，连 XAML 写法也像：&amp;lt;Border BorderThickness=&quot;1&quot; Margin=&quot;50,34,526,348&quot;&amp;gt; &amp;lt;Border.BorderBrush&amp;gt; &amp;lt;demo:RevealBorderBrush /&amp;gt; &amp;lt;/Border.BorderBrush&amp;gt;&amp;lt;/Border&amp;gt;&amp;lt;Border BorderThickness=&quot;1&quot; Margin=&quot;50,76,526,306&quot;&amp;gt; &amp;lt;Border.BorderBrush&amp;gt; &amp;lt;demo:RevealBorderBrush Color=&quot;White&quot; FallbackColor=&quot;Gray&quot; /&amp;gt; &amp;lt;/Border.BorderBrush&amp;gt;&amp;lt;/Border&amp;gt;▲ 模拟得很像的 RevealBorderBrush 的 XAML 写法当然，窗口背景那张图是直接用的高斯模糊效果，并不是亚克力 Acrylic 效果。鉴于那张被模糊得看不清的图是我自己画的，所以我一定要单独放出来给大家看🤓！我自己画的图，不忍直视，只好模糊掉作为背景了。请点击查看：图片以下是我后来使用此模拟的效果制作的应用。这些应用虽然看起来整个儿都很像 UWP 应用，但都是 100% 纯 WPF；因为我模拟了 UWP 的风格： WPF 使用 WindowChrome，在自定义窗口标题栏的同时最大程度保留原生窗口样式（类似 UWP/Chrome） - walterlv WPF 应用完全模拟 UWP 的标题栏按钮 - walterlv2019 年 1 月更新：▲ 源码在这个仓库：Walterlv.CloudKeyboard2019 年 3 月更新：话不多说看源码UWP 里的 CompositionBrush 是用一个 ShaderEffect 做出所有控件的所有效果的。正如 叛逆者 在 如何评价微软在 Build 2017 上提出的 Fluent Design System？ - 知乎 一文中说的，只需要极少的计算量就能完成。不过 Win32 窗口并没有得到眷恋，所以我只好自己实现。但限于只能使用 WPF 内建机制，故性能上当然不能比了。但在小型项目的局部用用还是非常不错的——尤其是个人项目！不过话说现在个人项目谁还用 WPF 呢 (逃思路是画一个径向渐变，即 RadialGradientBrush，然后当鼠标在窗口内移动时，改变径向渐变的渐变中心为鼠标所在点。以下是全部源码。不要在意基类啦！WPF 不让我们实现自己的 Brush，所以只好用 MarkupExtension 绕道实现了。2019 年 3 月更新：以下源码中现在使用了全局光照，也就是说，就算你的控件不在一个固定的窗口中，也会使用到光照效果了。using System;using System.Collections.Generic;using System.ComponentModel;using System.Windows;using System.Windows.Input;using System.Windows.Markup;using System.Windows.Media;// ReSharper disable CheckNamespacenamespace Walterlv.Effects{ /// &amp;lt;summary&amp;gt; /// Paints a control border with a reveal effect using composition brush and light effects. /// &amp;lt;/summary&amp;gt; public class RevealBorderBrushExtension : MarkupExtension { [ThreadStatic] private static Dictionary&amp;lt;RadialGradientBrush, WeakReference&amp;lt;FrameworkElement&amp;gt;&amp;gt; _globalRevealingElements; /// &amp;lt;summary&amp;gt; /// The color to use for rendering in case the &amp;lt;see cref=&quot;MarkupExtension&quot;/&amp;gt; can&#39;t work correctly. /// &amp;lt;/summary&amp;gt; public Color FallbackColor { get; set; } = Colors.White; /// &amp;lt;summary&amp;gt; /// Gets or sets a value that specifies the base background color for the brush. /// &amp;lt;/summary&amp;gt; public Color Color { get; set; } = Colors.White; public Transform Transform { get; set; } = Transform.Identity; public Transform RelativeTransform { get; set; } = Transform.Identity; public double Opacity { get; set; } = 1.0; public double Radius { get; set; } = 100.0; public override object ProvideValue(IServiceProvider serviceProvider) { // 如果没有服务，则直接返回。 if (!(serviceProvider.GetService(typeof(IProvideValueTarget)) is IProvideValueTarget service)) return null; // MarkupExtension 在样式模板中，返回 this 以延迟提供值。 if (service.TargetObject.GetType().Name.EndsWith(&quot;SharedDp&quot;)) return this; if (!(service.TargetObject is FrameworkElement element)) return this; if (DesignerProperties.GetIsInDesignMode(element)) return new SolidColorBrush(FallbackColor); var brush = CreateGlobalBrush(element); return brush; } private Brush CreateBrush(UIElement rootVisual, FrameworkElement element) { var brush = CreateRadialGradientBrush(); rootVisual.MouseMove += OnMouseMove; return brush; void OnMouseMove(object sender, MouseEventArgs e) { UpdateBrush(brush, e.GetPosition(element)); } } private Brush CreateGlobalBrush(FrameworkElement element) { var brush = CreateRadialGradientBrush(); if (_globalRevealingElements is null) { CompositionTarget.Rendering -= OnRendering; CompositionTarget.Rendering += OnRendering; _globalRevealingElements = new Dictionary&amp;lt;RadialGradientBrush, WeakReference&amp;lt;FrameworkElement&amp;gt;&amp;gt;(); } _globalRevealingElements.Add(brush, new WeakReference&amp;lt;FrameworkElement&amp;gt;(element)); return brush; } private void OnRendering(object sender, EventArgs e) { if (_globalRevealingElements is null) { return; } var toCollect = new List&amp;lt;RadialGradientBrush&amp;gt;(); foreach (var pair in _globalRevealingElements) { var brush = pair.Key; var weak = pair.Value; if (weak.TryGetTarget(out var element)) { Reveal(brush, element); } else { toCollect.Add(brush); } } foreach (var brush in toCollect) { _globalRevealingElements.Remove(brush); } void Reveal(RadialGradientBrush brush, IInputElement element) { UpdateBrush(brush, Mouse.GetPosition(element)); } } private void UpdateBrush(RadialGradientBrush brush, Point origin) { IInputElement element; if (IsUsingMouseOrStylus()) { brush.GradientOrigin = origin; brush.Center = origin; } else { brush.Center = new Point(double.NegativeInfinity, double.NegativeInfinity); } } private RadialGradientBrush CreateRadialGradientBrush() { var brush = new RadialGradientBrush(Color, Colors.Transparent) { MappingMode = BrushMappingMode.Absolute, RadiusX = Radius, RadiusY = Radius, Opacity = Opacity, Transform = Transform, RelativeTransform = RelativeTransform, Center = new Point(double.NegativeInfinity, double.NegativeInfinity), }; return brush; } private bool IsUsingMouseOrStylus() { var device = Stylus.CurrentStylusDevice; if (device is null) { return true; } if (device.TabletDevice.Type == TabletDeviceType.Stylus) { return true; } return false; } }}参考资料 突出显示 - UWP app developer - Microsoft Docs" }, { "title": "使用 Microsoft.Net.Compilers 在旧版本的 Visual Studio 2013/2015/2017 中开启新的 C# 7.x 和 C# 8 语法", "url": "/post/add-lastest-csharp-support-for-old-visual-studio.html", "categories": "", "tags": "visualstudio, csharp", "date": "2019-03-23 10:30:03 +0800", "snippet": "新版本的 C# 特性需要新版本的 Visual Studio 的支持。不过，如果你不介意修改项目的话，你也能在低版本的 Visual Studio 中获得高版本的 C# 语言支持了。而使用 Microsoft.Net.Compilers 这款 NuGet 包就可以做到。不同 Visual Studio 原生支持的 C# 版本Visual Studio 每一次的重大发布都带来新的 C# 版本（至少在 Visual Studio 2017 之前是这样），于是通常情况下如果你使用了旧版本的 Visual Studio，还打不开编写了新 C# 语法的项目呢！你可以阅读另一篇文章了解不同 Visual Studio 版本原生带来的 C# 版本。各个 C# 版本的主要特性、发布日期和发布方式（C# 1.0 - 7.3） - 吕毅引入 Microsoft.Net.Compilers不过，伴随着 .NET Core 生态的崛起和 NuGet 的逐渐广泛的使用，微软发布了 Microsoft.Net.Compilers 来解决跨 Visual Studio 版本的 C# 语言版本兼容问题了。Microsoft.Net.Compilers 首次发布于 2015 年 7 月。官方对齐的描述是： .NET Compilers package.Referencing this package will cause the project to be built using the specific version of the C# and Visual Basic compilers contained in the package, as opposed to any system installed version.这是一个 .NET 的编译器包，无论你系统中安装的是什么版本的 C# 编译器，使用此包都可以强制项目使用某个特定版本的 C# 编译器。使用 Microsoft.Net.Compilers第一步：安装 .NET Framework 4.6 或以上Microsoft.Net.Compilers 对项目本身没有什么要求，但需要编译项目的计算机上安装有完整功能的 .NET Framework 4.6 及以上版本。 This package can be used to compile code targeting any platform, but can only be run using the desktop .NET 4.6+ Full Framework.这是开发者计算机上的事情，不影响产品的 .NET Framework 版本需求。如果你连系统也比较旧，那么安装下最新版本的 .NET Framework 即可。第二步：安装 NuGet 包 Microsoft.Net.Compilers在你需要编写最新版本 C# 的项目中安装 NuGet 包 Microsoft.Net.Compilers。第三步：编辑项目使用最新版本的 C# 语言就像普通的项目启用最新版 C# 语言一样，在你的项目的 csproj 的 PropertyGroup 中添加以下属性：&amp;lt;LangVersion&amp;gt;Latest&amp;lt;/LangVersion&amp;gt;如果不知道如何添加，可以阅读 VisualStudio 使用三个方法启动最新 C# 功能 - 林德熙。开始使用最新版本的 C# 特性你已经可以使用最新版本的 C# 了，而不用关心你本机安装的是哪个版本 —— 即便你是 Visual Studio 2013/2015。class Program{ static async Task Main(string[] args) { Console.WriteLine(&quot;Thanks Walterlv!&quot;); await Task.Delay(5000); Console.WriteLine(&quot;I got the latest C# version.&quot;); }}参考资料 C# : Enabling C# 7.1 on Visual Studio 2015 / 2013 – programmium NuGet Gallery - Microsoft.Net.Compilers c# - What is the Purpose of Microsoft.Net.Compilers? - Stack Overflow Remove dependency of Microsoft.Net.Compilers NuGet Package · Issue #271 · opserver/Opserver" }, { "title": "制作一个极简的 .NET 客户端应用自安装或自更新程序", "url": "/post/simple-windows-app-self-installer.html", "categories": "", "tags": "windows, dotnet, csharp", "date": "2019-03-22 00:44:03 +0800", "snippet": "本文主要说的是 .NET 客户端应用，可以是只能在 Windows 端运行的基于 .NET Framework 或基于 .NET Core 的 WPF / Windows Forms 应用，也可以是其他基于 .NET Core 的跨平台应用。但是不是那些更新权限受到严格控制的 UWP / iOS / Android 应用。本文将编写一个简单的程序，这个程序初次运行的时候会安装自己，如果已安装旧版本会更新自己，如果已安装最新则直接运行。自安装或自更新的思路简单的安装过程实际上是 解压 + 复制 + 配置 + 外部命令。这里，我只做 复制 + 配置 + 外部命令，并且把 配置 + 外部命令 合为一个步骤。于是： 启动后，检查安装路径下是否有已经安装的程序； 如果没有，则直接复制自己过去； 如果有，则比较版本号，更新则复制过去。本文用到的知识 在 Windows 系统上降低 UAC 权限运行程序（从管理员权限降权到普通用户权限） - walterlv Windows 上的应用程序在运行期间可以给自己改名（可以做 OTA 自我更新） - walterlv 仅反射加载（ReflectionOnlyLoadFrom）的 .NET 程序集，如何反射获取它的 Attribute 元数据呢？ - walterlv使用于是我写了一个简单的类型用来做自安装。创建完 SelfInstaller 的实例后，根据安装完的结果做不同的行为： 显示安装成功的窗口 显示正常的窗口 关闭自己using System.IO;using System.Windows;using Walterlv.Installing;namespace Walterlv.ENPlugins.Presentation{ public partial class App : Application { protected override void OnStartup(StartupEventArgs e) { base.OnStartup(e); var installer = new SelfInstaller(@&quot;C:\\Users\\lvyi\\AppData\\Local\\Walterlv&quot;); var state = installer.TryInstall(); switch (state) { case InstalledState.Installed: case InstalledState.Updated: case InstalledState.UpdatedInUse: new InstallTipWindow().Show(); break; case InstalledState.Same: case InstalledState.Ran: new MainWindow().Show(); break; case InstalledState.ShouldRerun: Shutdown(); break; } } }}附全部源码本文代码在 https://gist.github.com/walterlv/33bdd62e2411c69c2699038e2bc97488。using System;using System.Collections.Generic;using System.Diagnostics;using System.IO;using System.Linq;using System.Reflection;namespace Walterlv.EasiPlugins.Installing{ /// &amp;lt;summary&amp;gt; /// 自安装或字更新的安装器。 /// &amp;lt;/summary&amp;gt; public class SelfInstaller { /// &amp;lt;summary&amp;gt; /// 初始化 &amp;lt;see cref=&quot;SelfInstaller&quot;/&amp;gt; 的新实例。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;targetFilePath&quot;&amp;gt;要安装的主程序的目标路径。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&quot;installingProcedure&quot;&amp;gt;如果需要在安装后执行额外的安装步骤，则指定自定义的安装步骤。&amp;lt;/param&amp;gt; public SelfInstaller(string targetFilePath, IInstallingProcedure installingProcedure = null) { var assembly = Assembly.GetCallingAssembly(); var extensionName = assembly.GetCustomAttribute&amp;lt;AssemblyTitleAttribute&amp;gt;().Title; TargetFileInfo = new FileInfo(Path.Combine( targetFilePath ?? throw new ArgumentNullException(nameof(targetFilePath)), extensionName, extensionName + Path.GetExtension(assembly.Location))); InstallingProcedure = installingProcedure; } /// &amp;lt;summary&amp;gt; /// 获取要安装的主程序的目标路径。 /// &amp;lt;/summary&amp;gt; private FileInfo TargetFileInfo { get; } /// &amp;lt;summary&amp;gt; /// 获取或设置当应用重新启动自己的时候应该使用的参数。 /// &amp;lt;/summary&amp;gt; public string RunSelfArguments { get; set; } = &quot;--rerun-reason {reason}&quot;; /// &amp;lt;summary&amp;gt; /// 获取此自安装器安装中需要执行的自定义安装步骤。 /// &amp;lt;/summary&amp;gt; public IInstallingProcedure InstallingProcedure { get; } /// &amp;lt;summary&amp;gt; /// 尝试安装，并返回安装结果。调用者可能需要对安装结果进行必要的操作。 /// &amp;lt;/summary&amp;gt; public InstalledState TryInstall() { var state0 = InstallOrUpdate(); switch (state0) { // 已安装或更新，由已安装的程序处理安装后操作。 case InstalledState.Installed: case InstalledState.Updated: case InstalledState.UpdatedInUse: case InstalledState.Same: break; case InstalledState.ShouldRerun: Process.Start(TargetFileInfo.FullName, BuildRerunArguments(state0.ToString(), false)); return state0; } var state1 = InstallingProcedure?.AfterInstall(TargetFileInfo.FullName) ?? InstalledState.Ran; if (state0 is InstalledState.UpdatedInUse || state1 is InstalledState.UpdatedInUse) { return InstalledState.UpdatedInUse; } if (state0 is InstalledState.Updated || state1 is InstalledState.Updated) { return InstalledState.Updated; } if (state0 is InstalledState.Installed || state1 is InstalledState.Installed) { return InstalledState.Installed; } return state1; } /// &amp;lt;summary&amp;gt; /// 进行安装或更新。执行后将返回安装状态以及安装后的目标程序路径。 /// &amp;lt;/summary&amp;gt; private InstalledState InstallOrUpdate() { var extensionFilePath = TargetFileInfo.FullName; var selfFilePath = Assembly.GetExecutingAssembly().Location; // 判断当前是否已经运行在插件目录下。如果已经在那里运行，那么不需要安装。 if (string.Equals(extensionFilePath, selfFilePath, StringComparison.CurrentCultureIgnoreCase)) { // 继续运行自己即可。 return InstalledState.Ran; } // 判断插件目录下的软件版本是否比较新，如果插件目录已经比较新，那么不需要安装。 var isOldOneExists = File.Exists(extensionFilePath); if (isOldOneExists) { var isNewer = CheckIfNewer(); if (!isNewer) { // 运行已安装目录下的自己。 return InstalledState.Same; } } // 将自己复制到插件目录进行安装。 var succeedOnce = CopySelfToInstall(); if (!succeedOnce) { // 如果不是一次就成功，说明目标被占用。 return InstalledState.UpdatedInUse; } return isOldOneExists ? InstalledState.Updated : InstalledState.Installed; bool CheckIfNewer() { Version installedVersion; try { var installed = Assembly.ReflectionOnlyLoadFrom(extensionFilePath); var installedVersionString = installed.GetCustomAttributesData() .FirstOrDefault(x =&amp;gt; x.AttributeType.FullName == typeof(AssemblyFileVersionAttribute).FullName) ?.ConstructorArguments[0].Value as string ?? &quot;0.0&quot;; installedVersion = new Version(installedVersionString); } catch (FileLoadException) { installedVersion = new Version(0, 0); } catch (BadImageFormatException) { installedVersion = new Version(0, 0); } var current = Assembly.GetExecutingAssembly(); var currentVersionString = current.GetCustomAttribute&amp;lt;AssemblyFileVersionAttribute&amp;gt;()?.Version ?? &quot;0.0&quot;; var currentVersion = new Version(currentVersionString); return currentVersion &amp;gt; installedVersion; } } /// &amp;lt;summary&amp;gt; /// 将自己复制到目标安装路径。 /// &amp;lt;/summary&amp;gt; private bool CopySelfToInstall() { var extensionFolder = TargetFileInfo.Directory.FullName; var extensionFilePath = TargetFileInfo.FullName; var selfFilePath = Assembly.GetExecutingAssembly().Location; if (!Directory.Exists(extensionFolder)) { Directory.CreateDirectory(extensionFolder); } var isInUse = false; for (var i = 0; i &amp;lt; int.MaxValue; i++) { try { if (i &amp;gt; 0) { File.Move(extensionFilePath, extensionFilePath + $&quot;.{i}.bak&quot;); } File.Copy(selfFilePath, extensionFilePath, true); return !isInUse; } catch (IOException) { // 不退出循环，于是会重试。 isInUse = true; } } return !isInUse; } /// &amp;lt;summary&amp;gt; /// 生成用于重启自身的启动参数。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;rerunReason&quot;&amp;gt;表示重启原因的一个单词（不能包含空格）。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&quot;includeExecutablePath&quot;&amp;gt;&amp;lt;/param&amp;gt; /// &amp;lt;param name=&quot;executablePath&quot;&amp;gt;&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; private string BuildRerunArguments(string rerunReason, bool includeExecutablePath, string executablePath = null) { if (rerunReason == null) { throw new ArgumentNullException(nameof(rerunReason)); } if (rerunReason.Contains(&quot; &quot;)) { throw new ArgumentException(&quot;重启原因不能包含空格&quot;, nameof(rerunReason)); } var args = new List&amp;lt;string&amp;gt;(); if (includeExecutablePath) { args.Add(string.IsNullOrWhiteSpace(executablePath) ? Assembly.GetEntryAssembly().Location : executablePath); } if (!string.IsNullOrWhiteSpace(RunSelfArguments)) { args.Add(RunSelfArguments.Replace(&quot;{reason}&quot;, rerunReason)); } return string.Join(&quot; &quot;, args); } } /// &amp;lt;summary&amp;gt; /// 表示安装完后的状态。 /// &amp;lt;/summary&amp;gt; public enum InstalledState { /// &amp;lt;summary&amp;gt; /// 已安装。 /// &amp;lt;/summary&amp;gt; Installed, /// &amp;lt;summary&amp;gt; /// 已更新。说明运行此程序时，已经存在一个旧版本的应用。 /// &amp;lt;/summary&amp;gt; Updated, /// &amp;lt;summary&amp;gt; /// 已更新。但是原始文件被占用，可能需要重启才可使用。 /// &amp;lt;/summary&amp;gt; UpdatedInUse, /// &amp;lt;summary&amp;gt; /// 已代理启动新的程序，所以此程序需要退出。 /// &amp;lt;/summary&amp;gt; ShouldRerun, /// &amp;lt;summary&amp;gt; /// 两个程序都是一样的，跑谁都一样。 /// &amp;lt;/summary&amp;gt; Same, /// &amp;lt;summary&amp;gt; /// 没有执行安装、更新或代理，表示此程序现在是正常启动。 /// &amp;lt;/summary&amp;gt; Ran, }}" }, { "title": "WPF 同一窗口内的多线程/多进程 UI（使用 SetParent 嵌入另一个窗口）", "url": "/post/embed-win32-window-using-csharp.html", "categories": "", "tags": "wpf, dotnet, csharp, windows", "date": "2019-03-21 10:13:01 +0800", "snippet": "WPF 的 UI 逻辑只在同一个线程中，这是学习 WPF 开发中大家几乎都会学习到的经验。如果希望做不同线程的 UI，大家也会想到使用另一个窗口来实现，让每个窗口拥有自己的 UI 线程。然而，就不能让同一个窗口内部使用多个 UI 线程吗？阅读本文将收获一份 Win32 函数 SetParent 及相关函数的使用方法。WPF 同一个窗口中跨线程访问 UI 有多种方法： 使用 VisualTarget (本文) 使用 SetParent 嵌入另一个窗口前者使用的是 WPF 原生方式，做出来的跨线程 UI 可以和原来的 UI 相互重叠遮挡。后者使用的是 Win32 的方式，实际效果非常类似 WindowsFormsHost，新线程中的 UI 在原来的所有 WPF 控件上面遮挡。另外，后者不止可以是跨线程，还可以跨进程。准备必要的 Win32 函数完成基本功能所需的 Win32 函数是非常少的，只有 SetParent 和 MoveWindow。[DllImport(&quot;user32.dll&quot;)]public static extern bool SetParent(IntPtr hWnd, IntPtr hWndNewParent);[DllImport(&quot;user32.dll&quot;, SetLastError = true)]public static extern bool MoveWindow(IntPtr hWnd, int X, int Y, int nWidth, int nHeight, bool bRepaint);SetParent 用于指定传统的窗口父子关系。有多传统呢？呃……就是 Windows 自诞生以来的那种传统。在传统的 Win32 应用程序中，每一个控件都有自己的窗口句柄，它们之间通过 SetParent 进行连接；可以说一个 Button 就是一个窗口。而我们现在使用 SetParent 其实就是在使用传统 Win32 程序中的控件的机制。MoveWindow 用于指定窗口相对于其父级的位置，我们使用这个函数来决定新嵌入的窗口在原来界面中的位置。启动后台 UI 线程启动一个后台的 WPF UI 线程网上有不少线程的方法，但大体思路是一样的。我之前在 如何实现一个可以用 await 异步等待的 Awaiter 一文中写了一个利用 async/await 做的更高级的版本。为了继续本文，我将上文中的核心文件抽出来做成了 GitHubGist，访问 Custom awaiter with background UI thread 下载那三个文件并放入到自己的项目中。 AwaiterInterfaces.cs 为实现 async/await 机制准备的一些接口，虽然事实上可以不需要，不过加上可以防逗比。 DispatcherAsyncOperation.cs 这是我自己实现的自定义 awaiter，可以利用 awaiter 的回调函数机制规避线程同步锁的使用。 UIDispatcher.cs 用于创建后台 UI 线程的类型，这个文件包含本文需要使用的核心类，使用到了上面两个文件。在使用了上面的三个文件的情况下，创建一个后台 UI 线程并获得用于执行代码的 Dispatcher 只需要一句话：// 传入的参数是线程的名称，也可以不用传。var dispatcher = await UIDispatcher.RunNewAsync(&quot;Background UI&quot;);在得到了后台 UI 线程 Dispatcher 的情况下，无论做什么后台线程的 UI 操作，只需要调用 dispatcher.InvokeAsync 即可。我们使用下面的句子创建一个后台线程的窗口并显示出来：var backgroundWindow = await dispatcher.InvokeAsync(() =&amp;gt;{ var window = new Window(); window.SourceInitialized += OnSourceInitialized; window.Show(); return window;});在代码中，我们监听了 SourceInitialized 事件。这是 WPF 窗口刚刚获得 Windows 窗口句柄的时机，在此事件中，我们可以最早地拿到窗口句柄以便进行 Win32 函数调用。private void OnSourceInitialized(object sender, EventArgs e){ // 在这里可以获取到窗口句柄。}嵌入窗口为了比较容易写出嵌入窗口的代码，我将核心部分代码贴出来：class ParentWindow : Window{ public ParentWindow() { InitializeComponent(); Loaded += OnLoaded; } private async void OnLoaded(object sender, RoutedEventArgs e) { // 获取父窗口的窗口句柄。 var hwnd = (HwndSource) PresentationSource.FromVisual(this); _parentHwnd = hwnd; // 在后台线程创建子窗口。 var dispatcher = await UIDispatcher.RunNewAsync(&quot;Background UI&quot;); await dispatcher.InvokeAsync(() =&amp;gt; { var window = new Window(); window.SourceInitialized += OnSourceInitialized; window.Show(); }); } private void OnSourceInitialized(object sender, EventArgs e) { var childHandle = new WindowInteropHelper((Window) sender).Handle; SetParent(childHandle, _parentHwnd.Handle); MoveWindow(childHandle, 0, 0, 300, 300, true); } private HwndSource _parentHwnd; [DllImport(&quot;user32.dll&quot;)] public static extern bool SetParent(IntPtr hWnd, IntPtr hWndNewParent); [DllImport(&quot;user32.dll&quot;, SetLastError = true)] public static extern bool MoveWindow(IntPtr hWnd, int X, int Y, int nWidth, int nHeight, bool bRepaint);}具体执行嵌入窗口的是这一段：private void OnSourceInitialized(object sender, EventArgs e){ var childHandle = new WindowInteropHelper((Window) sender).Handle; SetParent(childHandle, _parentHwnd.Handle); MoveWindow(childHandle, 0, 0, 300, 300, true);}最终显示时会将后台线程的子窗口显示到父窗口的 (0, 0, 300, 300) 的位置和大小。可以试试在主线程写一个 Thread.Sleep(5000)，在卡顿的事件内，你依然可以拖动子窗口的标题栏进行拖拽。当然，如果你认为外面那一圈窗口的非客户区太丑了，使用普通设置窗口属性的方法去掉即可：await dispatcher.InvokeAsync(() =&amp;gt;{ var window = new Window { BorderBrush = Brushes.DodgerBlue, BorderThickness = new Thickness(8), Background = Brushes.Teal, WindowStyle = WindowStyle.None, ResizeMode = ResizeMode.NoResize, Content = new TextBlock { Text = &quot;walterlv.github.io&quot;, HorizontalAlignment = HorizontalAlignment.Center, VerticalAlignment = VerticalAlignment.Center, Foreground = Brushes.White, FontSize = 24, } }; window.SourceInitialized += OnSourceInitialized; window.Show();});源码以上代码中使用到了我之前的一些源码，这几个文件可分别从以下链接找到并下载到你的项目中： Annotations.cs AwaiterInterfaces.cs DispatcherAsyncOperation.cs UIDispatcher.cs VisualTargetPresentationSource.cs" }, { "title": "应用程序清单 Manifest 中各种 UAC 权限级别的含义和效果", "url": "/post/requested-execution-level-of-application-manifest.html", "categories": "", "tags": "windows, dotnet, csharp, wpf", "date": "2019-03-20 21:39:33 +0800", "snippet": "如果你的程序对 Windows 运行权限有要求，那么需要设置应用程序清单。本文介绍如何添加应用程序清单，并解释其中各项 UAC 权限设置的实际效果。阅读本文之前，你可能需要了解如何创建应用程序清单文件。阅读我的另一篇博客可以了解： 如何创建应用程序清单文件 App.Manifest，如何创建不带清单的应用程序 - 吕毅各种不同的 UAC 清单选项从默认生成的应用程序清单中，我们可以很容易的知道有四种不同的设置： asInvoker requireAdministrator highestAvailable 删除 requestedExecutionLevel 元素 （不要忘了还可以删除）当然这里我们是没有考虑 uiAccess 的。你可以阅读我的另一篇博客了解 uiAccess 的一项应用： 让 Windows 桌面程序运行在 Windows 应用上面 - 吕毅asInvoker父进程是什么权限级别，那么此应用程序作为子进程运行时就是什么权限级别。默认情况下用户启动应用程序都是使用 Windows 资源管理器（explorer.exe）运行的；在开启了 UAC 的情况下，资源管理器是以标准用户权限运行的。于是对于用户点击打开的应用程序，默认就是以标准用户权限运行的。如果已经以管理员权限启动了一个程序，那么这个程序启动的子进程也会是管理员权限。典型的情况是一个应用程序安装包安装的时候使用管理员权限运行，于是这个安装程序在安装完成后启动的这个应用程序进程实例就是管理员权限的。有时候这种设定会出现问题，你可以阅读 在 Windows 系统上降低 UAC 权限运行程序（从管理员权限降权到普通用户权限）。requireAdministrator此程序需要以管理员权限运行。在资源管理器中可以看到这样的程序图标的右下角会有一个盾牌图标。用户在资源管理器中双击启动此程序，或者在程序中使用 Process.Start 启动此程序，会弹出 UAC 提示框。点击“是”会提权，点击“否”则操作取消。highestAvailable此程序将以当前用户能获取的最高权限来运行。这个概念可能会跟前面说的 requireAdministrator 弄混淆。要更好的理解这两个概念的区别，你可能需要对 UAC 用户账户控制有一个初步的了解，可以阅读我的另一篇博客： Windows 中的 UAC 用户账户控制接下来的内容，都假设你已经了解了上文所述的 UAC 用户账户控制。如果你指定为 highestAvailable： 当你在管理员账户下运行此程序，就会要求权限提升。资源管理器上会出现盾牌图标，双击或使用 Process.Start 启动此程序会弹出 UAC 提示框。在用户同意后，你的程序将获得完全访问令牌（Full Access Token）。 当你在标准账户下运行此程序，此账户的最高权限就是标准账户。受限访问令牌（Limited Access Token）就是当前账户下的最高令牌了，于是 highestAvailable 已经达到了要求。资源管理器上不会出现盾牌图标，双击或使用 Process.Start 启动此程序也不会出现 UAC 提示框，此程序将以受限权限执行。下图是一个例子。lvyi 是我安装系统时创建的管理员账号，但是我使用的是 walterlv 标准账号。正常是在 walterlv 账号下启动程序，但以管理员权限运行时，会要求输入 lvyi 账号的密码来提权，于是就会以 lvyi 的身份运行这个程序。这种情况下，那个管理员权限运行的程序会以为当前运行在 lvyi 这个账户下，程序员需要小心这里的坑，因为拿到的用户路径以及注册表不是你所期望的 walterlv 这个账号下的。删除 requestedExecutionLevel 元素删除 requestedExecutionLevel 元素指的是将下面标注的这一行删掉： &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt; &amp;lt;assembly manifestVersion=&quot;1.0&quot; xmlns=&quot;urn:schemas-microsoft-com:asm.v1&quot;&amp;gt; &amp;lt;trustInfo xmlns=&quot;urn:schemas-microsoft-com:asm.v2&quot;&amp;gt; &amp;lt;security&amp;gt; &amp;lt;requestedPrivileges xmlns=&quot;urn:schemas-microsoft-com:asm.v3&quot;&amp;gt;-- &amp;lt;requestedExecutionLevel level=&quot;asInvoker&quot; uiAccess=&quot;false&quot; /&amp;gt; &amp;lt;/requestedPrivileges&amp;gt; &amp;lt;/security&amp;gt; &amp;lt;/trustInfo&amp;gt;注释中说删除 requestedExecutionLevel 元素将开启 UAC 虚拟化。我将这个节点删除后，运行我的 Demo 程序后 UAC 虚拟化将启用。默认这里是“已禁用”的。不过在以下任意一种情况下，UAC 虚拟化即便删了 requestedExecutionLevel 也是不会开启的： 64 位进程 不可交互的进程（例如服务） 进程模拟用户的操作（如果一个进程像用户一样执行了某项操作，那么这个操作不会被虚拟化） 驱动等内核模式进程这部分的列表你可以在这里查询到：Registry Virtualization - Windows applications - Microsoft Docs。这些值都用于什么场景？ asInvoker 是默认情况下的首选。如果你的程序没有什么特殊的需求，就使用 asInvoker；就算你的程序需要管理员程序做一些特殊的任务，那最好也写成 asInvoker，仅在必要的时候才进行管理员权限提升。 requireAdministrator，只有当你的程序大量进行需要管理员权限的操作的时候才建议使用 requireAdministrator 值，例如你正在做安装程序。 highestAvailable，当你的程序需要管理员权限，但又要求仅对当前用户修改时设置为此值。因为标准用户申请 UAC 提权之后会以其他用户的身份运行进程，这就不是对当前用户的操作了；使用 highestAvailable 来确保以当前用户运行。为什么 UWP 程序不能指定 UAC 清单选项？在我的另一篇博客 Windows 中的 UAC 用户账户控制 中说到了访问令牌。UWP 程序只能获得受限访问令牌，没得选，所以也就不需要指定 UAC 清单选项了。这也是为什么当你关闭 UAC 之后，UWP 程序将全部闪退的重要原因。参考资料 Registry Virtualization - Windows applications - Microsoft Docs How User Account Control (UAC) Affects Your Application - Microsoft Docs" }, { "title": "Windows 系统上使用任务管理器查看进程的各项属性（命令行、DPI、管理员权限等）", "url": "/post/view-process-info-using-task-manager.html", "categories": "", "tags": "windows", "date": "2019-03-19 19:52:39 +0800", "snippet": "Windows 系统上的任务管理器进化到 Windows 10 的 1809 版本后，又新增了几项可以查看的进程属性。本文介绍可以使用任务管理器查看的各种进程属性。如何查看进程的各种属性在任务栏上右键，选择“任务管理器”；或者按下 Ctrl + Shift + Esc 可以打开任务管理器。如果你的电脑死掉了，也可以按 Ctrl + Alt + Del 再选择任务管理器打开。在顶部列表标题上右键，可以选择列，在这里可以打开和关闭各种各样可以查看的进程属性。名称、PID、状态名称不用多说，就是启动这个进程时的程序文件的名称。值得注意的是，名称自进程启动时就确定了，即便你在运行期间改了名字，进程名也不会变。关于运行期间改名，可以参见： Windows 上的应用程序在运行期间可以给自己改名（可以做 OTA 自我更新） - 吕毅。PID 可以唯一确定当前系统运行期间的一个进程，所以用 PID 来找到进程是最靠谱的（前提是你拿得到）。这里有一个有意思的事情，可以阅读这些文章： Windows 的 PID为什么是 4 的倍数 - 开源中国社区 WINDOWS 进程或线程号为什么是 4 的倍数 - GUO Xingwang - 博客园进程的状态可以阅读： 进程的挂起状态详细分析 - FreeeLinux’s blog - CSDN博客路径名称、命令行路径名称可以帮助我们了解这个进程是由计算机上的哪个程序启动产生的。不过我更喜欢的是“命令行”。因为除了可以看进程的路径之外，还可以了解到它是如何启动的。比如下面这篇博客中，我就是在任务管理器了解到这些工具的启动参数的。 使用 Visual Studio 自定义外部命令 (External Tools) 快速打开 git bash 等各种工具 - 吕毅关于命令行中的路径，可以参见我的其他博客： .NET 命令行参数包含应用程序路径吗？ - 吕毅 .NET/C# 获取一个正在运行的进程的命令行参数 - 吕毅用户名、特权、UAC 虚拟化我把这三项放在一起说，是因为这三项是与 UAC 相关的项。用户名指的是启动此进程的那个用户的用户名，这在调试一些提权程序的时候可能会有用。因为对于管理员账户而言，提权前后是同一个用户；而对于标准账户，提权后进程将是管理员账户的进程，于是两个进程运行在不同的用户空间下，可能协作上会出现一些问题。关于用户账户以及提权相关的问题，可以阅读 Windows 中的 UAC 用户账户控制 - 吕毅。特权（Privilege）指的是此进程是否运行在管理员权限下。值为“是”则运行在管理员权限下，值为“否”则运行在标准账户权限下。关于特权级别相关的问题，可以阅读 Windows 中的 UAC 用户账户控制 - 吕毅。UAC 虚拟化相关的问题可以阅读 应用程序清单 Manifest 中各种 UAC 权限级别的含义和效果 - 吕毅。DPI 感知可以查看进程的 DPI 感知级别。进程的 DPI 感知级别有以下这些，名字来源于 Windows 系统任务管理器上的显示名称。 不知道 (Unaware) 系统 (System DPI Awareness) 每个显示器 (Per-Monitor DPI Awareness) 每个显示器(v2) (Per-Monitor V2 DPI Awareness)关于 DPI 感知级别的更多内容，可以阅读我的其他博客： Windows 下的高 DPI 应用开发（UWP / WPF / Windows Forms / Win32） - 吕毅 支持 Windows 10 最新 PerMonitorV2 特性的 WPF 多屏高 DPI 应用开发 - 吕毅" }, { "title": "如何创建一个基于 .NET Core 3 的 WPF 项目", "url": "/post/create-new-wpf-on-dotnet-core-project.html", "categories": "", "tags": "dotnet, wpf", "date": "2019-03-19 18:30:07 +0800", "snippet": "在 Connect(); 2018 大会上，微软发布了 .NET Core 3 Preview，以及基于 .NET Core 3 的 WPF；同时还发布了 Visual Studio 2019 预览版。不过 Visual Studio 2019 的预览版中并没有携带 WPF on .NET Core 3 的模板，于是新建项目的时候并不能快速创建一个基于 .NET Core 3 的 WPF 项目。本文将指导大家如何创建一个基于 .NET Core 3 的 WPF 项目。安装 .NET Core 3.0 Preview SDK前往官网下载：.NET Core 3.0 downloads for Linux, macOS, and Windows。然后安装。如果你没有安装 Visual Studio 2019 Preview，请前往下载：Visual Studio 2019。使用 Visual Studio 2019 创建 启动 Visual Studio 2019，选择“创建新项目” 选择 WPF App (.NET Core)，下一步 输入项目名称、位置和解决方案名称，创建使用命令行创建刚刚发布 .NET Core 3.0 和 Visual Studio 2019 第一个预览版的时候，Visual Studio 还不能创建 .NET Core 3.0 的 WPF 程序，所以会有这一小节用命令行来创建。当然，有时我也会用 Visual Studio Code 来写简单的程序，这个时候也用得到命令行： 让你的 VSCode 具备调试 C# 语言 .NET Core 程序的能力 - 吕毅运行新建命令在桌面或其他你要新建项目的文件夹中打开 PowerShell，然后输入命令：dotnet new wpf -o WalterlvWpfApp其中，后面的 WalterlvWPfApp 是 WPF 项目的名称。这时，你会在你刚刚准备的文件夹中发现刚刚新建的 WPF 项目。▲ 刚刚新建的 WPF 项目打开这个 csproj 文件在 Visual Studio 中打开这个 csproj 文件即可在 Visual Studio 2019 Preview 中基于这个新的 WPF on .NET Core 3 的项目进行开发。▲ 新的 WPF 项目。更多如果你希望将现有基于 .NET Framework 的 WPF 项目迁移到 .NET Core 3，那么请阅读我的另一篇博客：将基于 .NET Framework 的 WPF 项目迁移到基于 .NET Core 3。可以持续关注官方 WPF on .NET Core 的例子：samples/wpf/WPF-WinRT at master · dotnet/samples。" }, { "title": "Windows 的 UAC 设置中的通知等级实际上只有两个档而已", "url": "/post/there-are-only-two-settings-for-the-uac-slider.html", "categories": "", "tags": "windows", "date": "2019-03-19 17:43:47 +0800", "snippet": "Windows 系统中的 UAC 设置界面有四种不同的选项可以选，但实际上真正有意义的只有两个选项。本文将介绍 UAC 这四个档设置的区别，帮助你合理的设置你的电脑。UAC 设置界面在 Windows 10 任务栏的搜索框中输入 uac 可以直接打开 UAC 设置界面。下图是“用户账户控制设置”界面，想必小伙伴们应该已经很熟悉了。它有四个档： 始终通知 当应用试图安装软件或更改计算机设置时通知，使用安全桌面 当应用试图安装软件或更改计算机设置时通知，不使用安全桌面 从不通知实际上只有两个档然而在微软的 Raymond Chen（陈瑞孟）在 There are really only two effectively distinct settings for the UAC slider 一文中说实际上只有两个档： 始终通知 辣鸡Windows 系统是通过让一些 UAC 提权动作变成静默提权的方式来避免通知过多的问题，主要是让那些“看起来没什么危害的”系统设置不用通知。但是，这相当于开了一个后门，程序可以很容易注入到 explorer.exe 中然后获得提权，或者通过白名单方式把自己加入到静默提权中。有了这个后门，大家就可以找到各种绕过 UAC 弹窗的方法，比如 NSudo、UACME、QuickAdmin。你根本阻止不完这些绕过 UAC 弹窗的方法！微软说：“绕过 UAC 弹窗不是漏洞，所以我们不会修补。” (也许将来绕过 UAC 弹窗的恶意软件泛滥的时候，微软就会做点什么了)微软已经提供了全部弹窗这个选项，明明可以阻止各类程序绕过 UAC，但为什么默认设置是这个可以绕过的选项呢？—— 因为用户希望如此。Windows Vista 中，确实只有始终通知和关闭 UAC 两个选项，而且始终通知是默认选项；实际上 UAC 也确实只有这两个有实际意义的选项。但是始终通知会使得系统日常使用过程中真的有非常多的 UAC 弹窗，只要你试图修改一些可能影响其他用户的设置或者可能与 Windows 系统安全有关的操作，都会弹出 UAC 弹窗。大多数用户都会觉得这么多的 UAC 弹窗是很烦的。所以 Windows 7 开始不得不引入两个额外的中间状态，让一些已知的提权操作变成静默的，不弹 UAC 窗口。默认值是中间状态，因为大多数用户希望是这样的提醒级别。中间档的差别进程在试图提权的时候，会弹出 UAC 提示。对于 Windows 管理员账户来说，在控制面板里面的大量操作可能都是在影响所有用户，如果全部通知，那么在控制面板里面点击的很多功能都会弹出 UAC 提示（例如修改时间，这是个影响所有用户的操作，而且有些安全软件可能会因为系统时间改变而失效）。那两个中间档就是指： 在控制面板里的管理操作不用弹出提示 在 Windows 资源管理器内部操作的时候不用弹出提示（启动子进程依然需要） 打开任务管理器的时候不用弹出提示 更改防火墙设置的时候不用弹出提示 打开 UAC 设置界面的时候不用弹出提示我的建议现在 Windows 10 都发布了很多个版本了，离 UAC 最初引入到 Windows 系统中时已经过去了十多年时间，这么长的时间，足够很多应用兼容 Medium 的权限级别了。如果你不了解 Medium 权限级别，可以阅读我的另一篇博客：Windows 中的 UAC 用户账户控制 - 吕毅。即便我们现在选择“始终通知”，也不会比当初 Windows 7 刚刚发布时的通知多了，更不会比当初 Windows Vista 刚刚引入时多。因为应用的 UAC 弹窗少了，而对 Windows 的管理操作也不是经常进行。我现在日常使用的是“管理员账户 + 始终通知”，在某些情况下可能会使用“标准账户 + 始终通知”。并不会觉得多出了很多 UAC 弹窗。目前感觉最明显的多出来的弹窗是： 打开任务管理器的时候会弹窗 添加防火墙信任的时候会弹窗 在资源管理器中修改系统目录的时候会弹窗 在 Windows 设置应用中的一些设置会弹窗更多关于 UAC 的博客 Windows 中的 UAC 用户账户控制 - 吕毅 应用程序清单 Manifest 中各种 UAC 权限级别的含义和效果 - 吕毅 在 Windows 系统上降低 UAC 权限运行程序（从管理员权限降权到普通用户权限） - 吕毅 Windows 下使用 runas 命令以指定的权限启动一个进程（非管理员、管理员） - 吕毅参考资料 The Old New Thing - There are really only two effectively distinct settings for the UAC slider" }, { "title": "Windows 中的 UAC 用户账户控制", "url": "/post/windows-user-account-control.html", "categories": "", "tags": "windows", "date": "2019-03-19 17:42:26 +0800", "snippet": "阅读本文，你可以初步了解 Windows 上的 UAC 用户账户控制机制。本文不会涉及到 UAC 的底层实现原理和安全边界问题。用户账户在 Windows 中有多种不同的账户： SYSTEM Administrators 用户组 Administrator 管理员账户 Users 用户组 标准账户 我们需要将这些账户列举出来是因为在解释 UAC 账户控制的时候，会与此相关。SYSTEM 在系统中拥有最高权限。默认我们安装 Windows 时会创建一个管理员账户，这也是 Windows 系统推荐我们使用的管理员账户，其权限等级比 SYSTEM 低。Administrator 的权限级别和我们用户创建的管理员账户的权限级别是一样的，但是访问令牌（Access Token）的管理方式不一样，所以这里我们需要分开说。标准账户是我推荐大家使用的首选账户种类，因为在普通使用场景下，这个是最安全的。Administrator 账户目前的主要作用就是准备 OOBE 开箱体验，不适合日常使用，因为很不安全。关于 OOBE 开箱体验与审核模式，可以阅读我的另一篇博客： 启用 Windows 审核模式（Audit Mode），以 Administrator 账户来设置电脑的开箱体验 - 吕毅UAC 通知等级Windows Vista 开始引入了 UAC，不过在 Windows Vista 上只有两种 UAC 设置——开启和关闭。如果开启，那么应用试图安装软件或更改计算机、或者更改了 Windows 设置时将弹出 UAC 提示框；如果关闭，那么 UAC 就此关闭。Windows Vista 的 UAC 一直饱受诟病就是因为这种情况下的 UAC 提示是非常频繁的（而且以前的程序迁移到不需要管理员权限需要时间）。在 Windows 7 上，在开启和关闭中间新引入了两个 UAC 级别，都是在更改 Windows 设置时不通知（实际上就是加了一些 UAC 提权的白名单）。只是一个会进入“黑屏”状态，另一个不会进入此状态。从表现上看这两个只是黑屏与不黑屏，但从安全性上讲黑屏的安全性会高很多。UAC 通知时进入的黑屏状态在 Windows 中称之为“安全桌面”，这时整个桌面进入了 SYSTEM 账户，原用户账户下的所有程序都无法得知此时 UAC 弹窗的情况，也无法通过模拟用户操作来跳过这个 UAC 框。而不黑屏时，不会切换到新的桌面环境，原有程序依然可以获得此 UAC 弹窗的一些信息，这很不安全。但是！无论是 Windows Vista 还是 Windows 7，一旦你将 UAC 设置拖到最底，那么此时 UAC 将彻底关闭。如果你是管理员账户，那么运行的程序都将以管理员权限运行。从 Windows 8 开始到现在的 Windows 10，虽然依然是上面四个设置，但拖到最底的“从不通知”时，UAC 依然是开启的状态。也就是说，用户正常启动的进程依然是标准权限，要获得管理员权限提升依然需要重启整个进程。这个安全性限制是很重要的。特别说明！实际上 UAC 拖到最顶部，也就是所有 UAC 通知都显示 UAC 提示窗口才是真的在利用 UAC 保护你的电脑。因为 Windows 7 开始新增的两个中间级别都是在部分情况下静默提权，而这两种级别因为可以静默提权，所以也可以很容易被程序绕过。微软认为绕过 UAC 弹窗不是漏洞，因为这是用户自己的选择——如果用户选择全部通知是不会绕过的，用户选择了默认值，于是才可以绕过。所以这里推荐大家使用 UAC 的最高档，也就是全部提权都通知，这可以让大多数绕过 UAC 的方法失效。虽然说通知等级给了用户四个设置项，但实际上真正有用的只有两个而已，参见我的另一篇博客：Windows 的 UAC 设置中的通知等级实际上只有两个档而已 - 吕毅。完整性级别（Integrity Level）从 Windows Vista 开始，进程在创建的时候，可以得到一个访问令牌（Access Token），这个令牌有四个完整性级别： System（系统） High（高） Medium（中） Low（低）System 令牌是对系统完全操作的令牌，对应 SYSTEM 用户拥有的最高权限，可以对 Windows 操作系统做任何事。通常一个服务进程会以 SYSTEM 用户启动，拿到 System 令牌。High 对应 Administrators 组拥有的最高权限，也就是前面所说的 Administrator 用户和用户自己创建的管理员账户的权限级别。此权限级别用来管理计算机，可以修改其他用户，可以修改系统的设置，这些设置可能会造成安全问题（比如更改系统时间可能导致杀毒软件失效）。Medium 对应 Users 组拥有的最高权限，也就是前面所说的用户自己创建的标准用户。此权限级别用来日常使用。Medium 权限在 Windows Vista（实际上是其内核 NT6）中相比于之前版本的 Windows 有一些权限的提升，不危及系统安全性的操作在 Medium 下即可以完成，不需要切换到 High 级别。Users 组的用户是没有 High 和 System 令牌的，程序在此用户账户下，无论如何也无法拿到 High 和 System 令牌的，因为这个用户没有这样的令牌；如果要权限提升，需要输入管理员账号密码，而这时拿到的是这个管理员账号的 High 和 System 令牌。Low 并不对应者一个用户组，这是为了一些需要特殊保护的应用程序准备的。有些应用容易受到攻击，那么使用 Low 令牌启动这些应用程序，可以最大程度减少利用这些应用对系统造成攻击。比如 IE 浏览器的页面进程使用 Low 令牌运行，其对系统很难做出什么改动，甚至也影响不了当前用户的文件；当需要需系统计算机进行交互的时候，会与 IE 的 UI 进程（Medium 令牌）进行通信，请求协助完成。当 UAC 是开启状态，无论是管理员账户还是标准账户，Windows 资源管理器进程（explorer.exe）都是以 Medium 令牌启动进程。由于子进程通常能够继承父进程的令牌完整性级别，所以这样的设定可以防止用户双击打开的程序得到过高的令牌，从而在用户不知情的情况下危及系统安全。当程序需要以管理员权限运行（对应 High 级别的令牌）时，可以自己在 Manifest 里面声明，也可以自己使用 runas 谓词重启自己。而这个时候是会弹出 UAC 提示的，用户知情。前面我们说过在 Administrators 组中，Administrator 账户和普通管理员账户要分开说。差别就在令牌的管理上。普通管理员账户下，正常启动进程使用的是继承自 explorer.exe 的 Medium 访问令牌，当进程需要提升权限时，会弹出 UAC 提示框来启动一个子进程以获得 High 令牌。而 Administrator 账户下，正常启动的进程也都获得了 High 令牌。关于如何通过 Manifest 设置管理员权限运行，可以参考我的另一篇博客： 应用程序清单 Manifest 中各种 UAC 权限级别的含义和效果权限提升在 Windows 系统中，不同权限的进程是隔离的（虽然不是完全隔离）。如果你希望你的程序在执行某个操作的时候提升权限来执行，实际上你不能在你原来的进程上直接提升权限。你有很多种方法来提权，甚至绕过 UAC 来提权，但无论哪一种，你的进程实际上都是重启了，你是在新的提升的进程中执行了这个需要权限的操作。对于管理员账户，如果启动一个普通进程，那么此进程在管理员账户下运行，获得的是 Medium 访问令牌。当此进程提升权限，将弹出 UAC 提示框，用户同意后继续使用此同一个管理员账户运行，但子进程将获得 High 访问令牌。对于标准账户，如果启动一个普通进程，那么此进程在标准账户下运行，获得的是 Medium 访问令牌。当此进程提升权限，将弹出 UAC 提示框，用户输入管理员账号密码后，子进程将在输入的管理员账户下运行，获得此管理员的 High 访问令牌。标准账户没有 High 访问令牌，如果说绕过 UAC 来提权是为了获取 High 访问令牌，那么在标准账户下根本没有 High 访问令牌，所以你绕不过。管理员账户的 UAC 弹窗是这样的，要求用户选“是”或者“否”：而标准账户的 UAC 弹窗是这样的，要求输入管理员账号和密码：以上两个弹窗都是蓝色的，代表发起此 UAC 请求的子进程其程序的证书是经过认证的。如果没有证书那么提示框是黄色的，如果证书过期，那么提示框是红色的。这可以帮助用户区分 UAC 弹窗做出决策（虽然实际上没什么用）。以上在标准账户下用管理员账户打开子进程的例子可以看下图：lvyi 是我安装系统时创建的管理员账号，但是我使用的是 walterlv 标准账号。正常是在 walterlv 账号下启动程序，但以管理员权限运行时，会要求输入 lvyi 账号的密码来提权，于是就会以 lvyi 的身份运行这个程序。这种情况下，那个管理员权限运行的程序会以为当前运行在 lvyi 这个账户下，程序员需要小心这里的坑，因为拿到的用户路径以及注册表不是你所期望的 walterlv 这个账号下的。在上图中，你会发现当前账户下的任务管理器连管理员账户运行的程序图标都拿不到。" }, { "title": "Windows 下使用 runas 命令以指定的权限启动一个进程（非管理员、管理员）", "url": "/post/start-process-in-a-specific-trust-level.html", "categories": "", "tags": "windows, csharp, dotnet", "date": "2019-03-19 09:37:16 +0800", "snippet": "在默认情况下，Windows 系统中启动一个进程会继承父进程的令牌。如果父进程是管理员权限，那么子进程就是管理员权限；如果父进程是标准用户权限，那么子进程也是标准用户权限。我们也知道，可以使用一些方法为自己的应用程序提权。但是有没有方法可以任意指定一个权限然后运行呢？本文将介绍 Windows 下指定权限运行的做法。runas 命令runas 是 Windows 系统上自带的一个命令，通过此命令可以以指定权限级别间接启动我们的程序，而不止是继承父进程的权限。打开 cmd 或者 PowerShell，输入 runas 命令可以看到其用法。&amp;gt; runasRUNAS 用法:RUNAS [ [/noprofile | /profile] [/env] [/savecred | /netonly] ] /user:&amp;lt;UserName&amp;gt; programRUNAS [ [/noprofile | /profile] [/env] [/savecred] ] /smartcard [/user:&amp;lt;UserName&amp;gt;] programRUNAS /trustlevel:&amp;lt;TrustLevel&amp;gt; program /noprofile 指定不应该加载用户的配置文件。 这会加速应用程序加载，但 可能会造成一些应用程序运行不正常。 /profile 指定应该加载用户的配置文件。 这是默认值。 /env 要使用当前环境，而不是用户的环境。 /netonly 只在指定的凭据限于远程访问的情况下才使用。 /savecred 用用户以前保存的凭据。 /smartcard 如果凭据是智能卡提供的，则使用这个选项。 /user &amp;lt;UserName&amp;gt; 应使用 USER@DOMAIN 或 DOMAIN\\USER 形式 /showtrustlevels 显示可以用作 /trustlevel 的参数的 信任级别。 /trustlevel &amp;lt;Level&amp;gt; 应该是在 /showtrustlevels 中枚举 的一个级别。 program EXE 的命令行。请参阅下面的例子示例:&amp;gt; runas /noprofile /user:mymachine\\administrator cmd&amp;gt; runas /profile /env /user:mydomain\\admin &quot;mmc %windir%\\system32\\dsa.msc&quot;&amp;gt; runas /env /user:user@domain.microsoft.com &quot;notepad \\&quot;my file.txt\\&quot;&quot;注意: 只在得到提示时才输入用户的密码。注意: /profile 跟 /netonly 不兼容。注意: /savecred 跟 /smartcard 不兼容。提权运行或者降权运行为了演示提权或者降权，我们需要有一个能够验证当前是否是管理员权限运行的程序。关于如何在程序中判断当前是否以管理员权限运行，可以阅读我和林德熙的博客： dotnet 判断程序当前使用管理员运行降低权使用普通权限运行 - 林德熙 在 Windows 系统上降低 UAC 权限运行程序（从管理员权限降权到普通用户权限） - 吕毅本质上是这段代码：var identity = WindowsIdentity.GetCurrent();var principal = new WindowsPrincipal(identity);if (principal.IsInRole(WindowsBuiltInRole.Administrator)){ // 检测到当前进程是以管理员权限运行的。}此代码如果在 .NET Core 中编写，以上代码需要额外安装 Windows 兼容包：Microsoft.Windows.Compatibility。提权运行或者降权运行我以标准用户权限和管理员权限分别启动了一个 PowerShell Core，然后准备在这两个窗口里面分别启动我的检测管理员权限的程序。0x20000 是标准用户权限，现在运行命令：&amp;gt; runas /trustlevel:0x20000 .\\Walterlv.Demo.exe运行发现，两个进程现在都是标准用户权限。即使是管理员的 PowerShell 中运行的也都是非管理员权限。0x40000 是管理员权限，现在运行命令：&amp;gt; runas /trustlevel:0x40000 .\\Walterlv.Demo.exe运行发现，非管理员的 PowerShell 启动的是非管理员权限的进程；而管理员的 PowerShell 启动的是管理员权限的进程。使用 C# 代码来降权运行使用 C# 代码，就是要将下面这一句翻译成 C#。&amp;gt; runas /trustlevel:0x20000 .\\Walterlv.Demo.exe所以其实非常简单，就是 Process.Start 传入参数即可。Process.Start(&quot;runas.exe&quot;, $&quot;/trustlevel:0x20000 Walterlv.Demo.exe&quot;);关于更多降权运行的方法，可以参考我的另一篇博客： 在 Windows 系统上降低 UAC 权限运行程序（从管理员权限降权到普通用户权限） - 吕毅参考资料 windows - How to run a process as non-admin from an elevated PowerShell console? - Stack Overflow" }, { "title": "启用 Windows 审核模式（Audit Mode），以 Administrator 账户来设置电脑的开箱体验", "url": "/post/windows-audit-mode.html", "categories": "", "tags": "windows", "date": "2019-03-17 20:02:05 +0800", "snippet": "在你刚刚安装完 Windows，在 Windows 开箱体验输入以创建你的用户账户之前，你可以按下 Ctrl + Shift + F3 来进入审核模式。本文将介绍审核模式。OOBEOOBE，Out-of-Box Experience，开箱体验。对于 Windows 系统来说，就是当你买下电脑回来，兴奋地打开电脑开机后第一个看到的界面。具体来说，就是设置你的账号以及各种个性化设置的地方。本文即将要说的审核模式就是在这里开启的。当然你设置完账号也一样能开启，但开箱就是要来个干净整洁嘛，所以就是应该在还没有账号的时候进入审核模式。进入审核模式在 OOBE 界面中，按下 Ctrl + Shift + F3 两次即会进入审核模式。实际上此时进入的账号是 Administrator 账号。我在 Windows 中的 UAC 用户账户控制 一文中说到，Administrator 账号下启动进程获取到的访问令牌都是完全访问令牌。所以在这里 UWP 程序是无法运行的（逃当你进入审核模式之后，会看到自动启动了一个 sysprep 的程序，它位于 C:\\Windows\\System32\\Sysprep 目录下。在审核模式下，重启也会继续进入审核模式。如果要关闭审核模式，则需要在 sysprep 程序中把下一次的启动选项改为开箱体验。关于清理选项中的“通用”：如果你只为这台电脑或这个型号的电脑设置开箱体验，那么就关闭“通用”；如果把这个开箱体验做好之后会拷贝副本到其他型号的电脑上，那么就勾选“通用”。区别就是是否清理掉设备的特定的驱动文件。当然，你现在就可以去 C:\\Windows\\System32\\Sysprep 目录中启动 sysprep.exe，然后给你的电脑再带来一次开箱体验。审核模式有什么作用？从进入审核模式时打开的 sysprep.exe 程序可以看出来，这个模式主要就是为了准备开箱体验的。你可以在这里以 Administrator 权限来为此计算机安装驱动，为将来此计算机的所有用户安装应用、存放一些你认为他们需要的文件。而这一切操作都不需要特地创建一个账号。可以说 Administrator 账户内置到系统里，主要的目的就是这个了，临时使用。而目前就是在审核模式中制作开箱体验。参考资料 Boot Windows to Audit Mode or OOBE - Microsoft Docs" }, { "title": "如何创建应用程序清单文件 App.Manifest，如何创建不带清单的应用程序", "url": "/post/create-manifest-file-for-application.html", "categories": "", "tags": "windows, dotnet, csharp, wpf", "date": "2019-03-17 17:34:18 +0800", "snippet": "如果你的程序对 Windows 运行权限有要求，那么需要设置应用程序清单。本文介绍如何添加应用程序清单，并解释其中各项权限设置的实际效果。嵌入带默认设置的清单对于 WPF 和 Windows Forms 程序，如果你什么都不做，那么就已经嵌入了一个带有默认设置的清单。下图可以在 Visual Studio 中的项目上右键属性插件。新建一个自定义的清单文件在项目上右键，添加，新建项。可以在新建模板中找到“应用程序清单文件”。确认后即添加了一个新的清单文件。这时，项目属性页中的清单也会自动设置为刚刚添加的清单文件。默认的清单中，包含 UAC 清单选项、系统兼容性选项、DPI 感知级别选项和 Windows 公共控件和对话框的主题选项。 关于 UAC 清单选项，你可以阅读 应用程序清单 Manifest 中各种 UAC 权限级别的含义和效果 了解更多。 关于 DPI 感知级别选项，你可以阅读 Windows 下的高 DPI 应用开发（UWP / WPF / Windows Forms / Win32） - walterlv 和 支持 Windows 10 最新 PerMonitorV2 特性的 WPF 多屏高 DPI 应用开发 - walterlv 了解更多。&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;assembly manifestVersion=&quot;1.0&quot; xmlns=&quot;urn:schemas-microsoft-com:asm.v1&quot;&amp;gt; &amp;lt;assemblyIdentity version=&quot;1.0.0.0&quot; name=&quot;MyApplication.app&quot;/&amp;gt; &amp;lt;trustInfo xmlns=&quot;urn:schemas-microsoft-com:asm.v2&quot;&amp;gt; &amp;lt;security&amp;gt; &amp;lt;requestedPrivileges xmlns=&quot;urn:schemas-microsoft-com:asm.v3&quot;&amp;gt; &amp;lt;!-- UAC 清单选项 如果想要更改 Windows 用户帐户控制级别，请使用 以下节点之一替换 requestedExecutionLevel 节点。n &amp;lt;requestedExecutionLevel level=&quot;asInvoker&quot; uiAccess=&quot;false&quot; /&amp;gt; &amp;lt;requestedExecutionLevel level=&quot;requireAdministrator&quot; uiAccess=&quot;false&quot; /&amp;gt; &amp;lt;requestedExecutionLevel level=&quot;highestAvailable&quot; uiAccess=&quot;false&quot; /&amp;gt; 指定 requestedExecutionLevel 元素将禁用文件和注册表虚拟化。 如果你的应用程序需要此虚拟化来实现向后兼容性，则删除此 元素。 --&amp;gt; &amp;lt;requestedExecutionLevel level=&quot;asInvoker&quot; uiAccess=&quot;false&quot; /&amp;gt; &amp;lt;/requestedPrivileges&amp;gt; &amp;lt;/security&amp;gt; &amp;lt;/trustInfo&amp;gt; &amp;lt;compatibility xmlns=&quot;urn:schemas-microsoft-com:compatibility.v1&quot;&amp;gt; &amp;lt;application&amp;gt; &amp;lt;!-- 设计此应用程序与其一起工作且已针对此应用程序进行测试的 Windows 版本的列表。取消评论适当的元素， Windows 将自动选择最兼容的环境。 --&amp;gt; &amp;lt;!-- Windows Vista --&amp;gt; &amp;lt;!--&amp;lt;supportedOS Id=&quot;{e2011457-1546-43c5-a5fe-008deee3d3f0}&quot; /&amp;gt;--&amp;gt; &amp;lt;!-- Windows 7 --&amp;gt; &amp;lt;!--&amp;lt;supportedOS Id=&quot;{35138b9a-5d96-4fbd-8e2d-a2440225f93a}&quot; /&amp;gt;--&amp;gt; &amp;lt;!-- Windows 8 --&amp;gt; &amp;lt;!--&amp;lt;supportedOS Id=&quot;{4a2f28e3-53b9-4441-ba9c-d69d4a4a6e38}&quot; /&amp;gt;--&amp;gt; &amp;lt;!-- Windows 8.1 --&amp;gt; &amp;lt;!--&amp;lt;supportedOS Id=&quot;{1f676c76-80e1-4239-95bb-83d0f6d0da78}&quot; /&amp;gt;--&amp;gt; &amp;lt;!-- Windows 10 --&amp;gt; &amp;lt;!--&amp;lt;supportedOS Id=&quot;{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}&quot; /&amp;gt;--&amp;gt; &amp;lt;/application&amp;gt; &amp;lt;/compatibility&amp;gt; &amp;lt;!-- 指示该应用程序可以感知 DPI 且 Windows 在 DPI 较高时将不会对其进行 自动缩放。Windows Presentation Foundation (WPF)应用程序自动感知 DPI，无需 选择加入。选择加入此设置的 Windows 窗体应用程序(目标设定为 .NET Framework 4.6 )还应 在其 app.config 中将 &quot;EnableWindowsFormsHighDpiAutoResizing&quot; 设置设置为 &quot;true&quot;。--&amp;gt; &amp;lt;!-- &amp;lt;application xmlns=&quot;urn:schemas-microsoft-com:asm.v3&quot;&amp;gt; &amp;lt;windowsSettings&amp;gt; &amp;lt;dpiAware xmlns=&quot;http://schemas.microsoft.com/SMI/2005/WindowsSettings&quot;&amp;gt;true&amp;lt;/dpiAware&amp;gt; &amp;lt;/windowsSettings&amp;gt; &amp;lt;/application&amp;gt; --&amp;gt; &amp;lt;!-- 启用 Windows 公共控件和对话框的主题(Windows XP 和更高版本) --&amp;gt; &amp;lt;!-- &amp;lt;dependency&amp;gt; &amp;lt;dependentAssembly&amp;gt; &amp;lt;assemblyIdentity type=&quot;win32&quot; name=&quot;Microsoft.Windows.Common-Controls&quot; version=&quot;6.0.0.0&quot; processorArchitecture=&quot;*&quot; publicKeyToken=&quot;6595b64144ccf1df&quot; language=&quot;*&quot; /&amp;gt; &amp;lt;/dependentAssembly&amp;gt; &amp;lt;/dependency&amp;gt; --&amp;gt;&amp;lt;/assembly&amp;gt;创建不带清单的应用程序你也可以创建一个不带应用程序清单的应用程序。方法是在属性页中将清单设置为“创建不带清单的应用程序”。" }, { "title": "在有 UI 线程参与的同步锁（如 AutoResetEvent）内部使用 await 可能导致死锁", "url": "/post/deadlock-if-await-in-ui-lock-context.html", "categories": "", "tags": "dotnet, wpf", "date": "2019-03-15 15:54:00 +0800", "snippet": "AutoResetEvent、ManualResetEvent、Monitor、lock 等等这些用来做同步的类，如果在异步上下文（await）中使用，需要非常谨慎。本文将说一个在同步上下文中非常常见的一种用法，换成异步上下文中会产生死锁的问题。一段正常的同步上下文的代码先看看一段非常简单的代码：private void OnLoaded(object sender, RoutedEventArgs e){ ThreadPool.SetMinThreads(100, 100); // 全部在后台线程，不会死锁。 for (var i = 0; i &amp;lt; 100; i++) { Task.Run(() =&amp;gt; Do()); } // 主线程执行与后台线程并发竞争，也不会死锁。 for (var i = 0; i &amp;lt; 100; i++) { Do(); }}private void Do(){ _resetEvent.WaitOne(); try { // 这个 ++ 在安全的线程上下文中，所以不需要使用 Interlocked.Increment(ref _count); _count++; DoCore(); } finally { _resetEvent.Set(); }}private void DoCore(){ Console.WriteLine($&quot;[{_count.ToString().PadLeft(3, &#39; &#39;)}] walterlv is a 逗比&quot;);}以上代码运行会输出 200 个 “walterlv is a 逗比”：[ 1] walterlv is a 逗比[ 2] walterlv is a 逗比[ 3] walterlv is a 逗比[ 4] walterlv is a 逗比[ 5] walterlv is a 逗比[ 6] walterlv is a 逗比[ 7] walterlv is a 逗比[ 8] walterlv is a 逗比[ 9] walterlv is a 逗比[ 10] walterlv is a 逗比// 有 200 个，但是不需要再在这里占用行数了。[197] walterlv is a 逗比[200] walterlv is a 逗比以上代码最关键的使用锁进行同步的地方是 Do 函数，采用了非常典型的防止方法重入的措施：// 获得锁try{ // 执行某个需要线程安全的操作。}finally{ // 释放锁}我们设置了线程池最小线程数为 100，这样在使用 Task.Run 进行并发的时候，一次能够开启 100 个线程来执行 Do 方法。同时 UI 线程也执行 100 次，与后台线程竞争输出。一个微调即会死锁现在我们微调一下刚刚的代码：private void OnLoaded(object sender, RoutedEventArgs e){ ThreadPool.SetMinThreads(100, 100); // 全部在后台线程，不会死锁。 for (var i = 0; i &amp;lt; 100; i++) { Task.Run(() =&amp;gt; DoAsync()); } // 主线程执行与后台线程并发竞争，也不会死锁。 for (var i = 0; i &amp;lt; 100; i++) { DoAsync(); }}private async Task DoAsync(){ _resetEvent.WaitOne(); try { _count++; await DoCoreAsync(); } finally { _resetEvent.Set(); }}private async Task DoCoreAsync(){ await Task.Run(async () =&amp;gt; { Console.WriteLine($&quot;[{_count.ToString().PadLeft(3, &#39; &#39;)}] walterlv is a 逗比&quot;); });}为了直观看出差别，我只贴出不同之处： {-- Task.Run(() =&amp;gt; Do());++ Task.Run(() =&amp;gt; DoAsync()); } ... {-- Do();++ DoAsync(); }-- private void Do()++ private async Task DoAsync() { ... _count++;-- await DoCore();++ await DoCoreAsync(); } ... }-- private void DoCore()++ private async Task DoCoreAsync() {-- Console.WriteLine($&quot;[{_count.ToString().PadLeft(3, &#39; &#39;)}] walterlv is a 逗比&quot;);++ await Task.Run(async () =&amp;gt;++ {++ Console.WriteLine($&quot;[{_count.ToString().PadLeft(3, &#39; &#39;)}] walterlv is a 逗比&quot;);++ }); }现在再运行代码，只输出几次程序就停下来了：[ 0] walterlv is a 逗比[ 1] walterlv is a 逗比[ 2] walterlv is a 逗比[ 3] walterlv is a 逗比[ 4] walterlv is a 逗比[ 5] walterlv is a 逗比每次运行时，停下来的次数都不相同，这也正符合多线程坑的特点。此死锁的触发条件实际上，以上这段代码如果没有 WPF / UWP 的 UI 线程的参与，是 不会出现死锁 的。但是，如果有 UI 线程参与，即便只有 UI 线程调用，也会直接死锁。例如：DoAsync();DoAsync();只是这样的调用，你会看到值输出一次 —— 这就已经死锁了！此死锁的原因WPF / UWP 等 UI 线程会使用 DispatcherSynchronizationContext 作为线程同步上下文，我在 出让执行权：Task.Yield, Dispatcher.Yield - walterlv 一问中有说到它的原理。在 await 等待完成之后，会调用 BeginInvoke 回到 UI 线程。然而，此时 UI 线程正卡死在 _resetEvent.WaitOne();，于是根本没有办法执行 BeginInvoke 中的操作，也就是 await 之后的代码。然而释放锁的代码 _resetEvent.Set(); 就在 await 之后，所以不会执行，于是死锁。更多死锁问题死锁问题： 使用 Task.Wait()？立刻死锁（deadlock） - walterlv 不要使用 Dispatcher.Invoke，因为它可能在你的延迟初始化 Lazy&amp;lt;T&amp;gt; 中导致死锁 - walterlv 在有 UI 线程参与的同步锁（如 AutoResetEvent）内部使用 await 可能导致死锁 .NET 中小心嵌套等待的 Task，它可能会耗尽你线程池的现有资源，出现类似死锁的情况 - walterlv解决方法： 在编写异步方法时，使用 ConfigureAwait(false) 避免使用者死锁 - walterlv 将 async/await 异步代码转换为安全的不会死锁的同步代码（使用 PushFrame） - walterlv" }, { "title": ".NET 中小心嵌套等待的 Task，它可能会耗尽你线程池的现有资源，出现类似死锁的情况", "url": "/post/task-wait-may-cause-long-time-waiting.html", "categories": "", "tags": "dotnet", "date": "2019-03-15 15:54:00 +0800", "snippet": "一个简单的 Task 不会消耗多少时间，但如果你不合适地将 Task 转为同步等待，那么也可能很快耗尽线程池的所有资源，出现类似死锁的情况。本文将以一个最简单的例子说明如何出现以及避免这样的问题。耗时的 Task.Run谁都不会认为 Task.Run(() =&amp;gt; 1) 这个异步任务执行会消耗多少时间。但实际上，如果你的代码写得不清真，它真的能消耗大量的时间，这种时间消耗有点像死锁。下图分别是 7 个这样的任务、8 个这样的任务和 16 个这样的任务的耗时：可以发现，8 个任务和 16 个任务的耗时很不正常。在实际的测试当中，1~7 个任务的耗时几乎相同，而到后面每增加一个任务会增加大量时间。 任务个数 耗时 (ms) 1 39 2 54 3 58 4 50 5 49 6 45 7 54 8 1027 9 2030 10 3027 11 4027 12 5032 13 6027 14 7029 15 8025 16 9025 任务计时采用的是 Stopwatch，关于为什么要使用这种计时方式，可以阅读 .NET/C# 在代码中测量代码执行耗时的建议（比较系统性能计数器和系统时间）从图中，我们可以很直观地观察到，每多一个任务，就会多花 1 秒的事件。这可以认为默认情况下线程池在增加线程的时候，发现如果线程不够，会等待 1 秒之后才会创建新的线程。最简复现代码class Program{ static async Task Main(string[] args) { Console.Title = &quot;walterlv task demo&quot;; var stopwatch = Stopwatch.StartNew(); var task = Enumerable.Range(0, 8).Select(i =&amp;gt; Task.Run(() =&amp;gt; DoAsync(i).Result)).ToList(); await Task.WhenAll(task); Console.WriteLine($&quot;耗时: {stopwatch.Elapsed}&quot;); Console.Read(); } private static async Task&amp;lt;int&amp;gt; DoAsync(int index) { return await Task.Run(() =&amp;gt; 1); }}原因你可以阅读 .NET 默认的 TaskScheduler 和线程池（ThreadPool）设置 了解线程池创建新工作线程的规则。这里其实真的是类似于死锁的一个例子。 一开始，我们创建了 n 个 Task，然后分别安排在线程池中执行，并在每个 Task 中等待任务执行完毕； 随后这 n 个 Task 分别再创建了 n 个子 Task，并继续安排在线程池中执行； 这时问题来了，由于前面 n 个 Task 在等待中，所以占用了线程池的线程资源： 如果 n &amp;lt; 线程池最小线程数，那么当前线程池中还有剩余工作线程帮助完成子 Task； 但如果 n &amp;gt;= 线程池最小线程数，那么当前线程池中便没有新的工作线程来完成子 Task；于是一开始的等待也不会完成；必须等线程池开启新的工作线程后，任务才可以继续。 带线程池开启新的线程之前，以上那些线程就是处于死锁的状态！由于线程池开启新的工作线程需要等待一段时间（例如每秒最多开启一个新的线程），所以每增加一个这样的任务，那么消耗的时间便会持续增加。解决去掉这里本来多余的 Task.Run 问题便可以解决。或者一直 async/await 中间不要转换为同步代码，那么问题也能解决。我会遇到以上代码，是因为在库中写了类似 DoAsync 那样的方法。同时为了方便使用，封装了一个同步等待的属性。在业务使用方，觉得获取此属性可能比较耗时，于是用了 Task.Run 在后台线程调用。同时由于这是一个可能大量并发的操作，于是造成了以上悲剧。更多死锁问题死锁问题： 使用 Task.Wait()？立刻死锁（deadlock） - walterlv 不要使用 Dispatcher.Invoke，因为它可能在你的延迟初始化 Lazy&amp;lt;T&amp;gt; 中导致死锁 - walterlv 在有 UI 线程参与的同步锁（如 AutoResetEvent）内部使用 await 可能导致死锁 .NET 中小心嵌套等待的 Task，它可能会耗尽你线程池的现有资源，出现类似死锁的情况 - walterlv解决方法： 在编写异步方法时，使用 ConfigureAwait(false) 避免使用者死锁 - walterlv 将 async/await 异步代码转换为安全的不会死锁的同步代码（使用 PushFrame） - walterlv" }, { "title": "在编写异步方法时，使用 ConfigureAwait(false) 避免使用者死锁", "url": "/post/using-configure-await-to-avoid-deadlocks.html", "categories": "", "tags": "dotnet", "date": "2019-03-15 15:54:00 +0800", "snippet": "我在 使用 Task.Wait()？立刻死锁（deadlock） 一文中站在类库使用者的角度看 async/await 代码的死锁问题；而本文将站在类库设计者的角度来看死锁问题。阅读本文，我们将知道如何编写类库代码，来尽可能避免类库使用者出现那篇博客中描述的死锁问题。可能死锁的代码现在，我们是类库设计者的身份，我们试图编写一个 RunAsync 方法用以异步执行某些操作。private async Task RunAsync(){ // 某些异步操作。}类库的使用者可能多种多样，一个比较有素养的使用者会考虑这样使用类库： await foo.RunAsync(); 放心，这样的类库使用者是不会出什么岔子的。然而，这世间既然有让人省心的类库使用者，当然也存在非常让人不省心的类库使用者。当你的类库遍布全球，你真的会遇到这样的使用者： foo.RunAsync().Wait(); 或者高级一些，使用 AutoResetEvent 和 try/finally 块的使用者： // 这段代码如果在 foo.RunAsync() 第一次调用返回之前再调用一次，则可能死锁。_autoResetEvent.WaitOne();try{ await foo.RunAsync();}finally{ _autoResetEvent.Set();} 如果这段代码在 UI 线程执行，那么极有可能出现死锁，就是我在 使用 Task.Wait()？立刻死锁（deadlock） 一文中说的那种死锁，详情可进去看原因。那么现在做一个调查，你认为下面三种 RunAsync 的实现中，哪些会在碰到这种不省心的类库使用者时发生死锁呢？答案是——第 2 种！只有第 2 种会发生死锁，第 1 和第 3 种都不会。原因对于第 2 种情况，下方“await 之后的代码”试图回到 UI 线程执行，但 UI 此时处于调用者 foo.RunAsync().Wait(); 这段神奇代码的等待状态——所以死锁了。回到 UI 线程靠的是 DispatcherSynchronizationContext，我在 使用 Task.Wait()？立刻死锁（deadlock） 一文中已有解释，建议前往了解更深层次的原因。 private async Task RunAsync1(){ await Task.Run(() =&amp;gt; { // 某些异步操作。 }); // await 之后的代码（即使没写任何代码，也是需要执行的）。} 那为什么第 1 种和第 3 种不会死锁呢？对第 1 种情况，由于并没有写 async/await，所以异步状态机 AsyncMethodStateMachine 此时并不执行。直接返回了 Task，这相当于此时创建的 Task 对象直接被调用者的 foo.RunAsync().Wait(); 神奇代码等待了。也就是说，等待的 Task 是真正执行异步任务的 Task。Task 的 Wait() 方法内部通过自旋锁来实现等待，可以阅读 .NET 中的轻量级线程安全 - walterlv 了解自旋锁，也可以前往 .NET Framework 源码 Task.SpinWait 了解 Task.SpinWait() 方法的具体实现。 //spin only once if we are running on a single CPUint spinCount = PlatformHelper.IsSingleProcessor ? 1 : System.Threading.SpinWait.YIELD_THRESHOLD;for (int i = 0; i &amp;lt; spinCount; i++){ if (IsCompleted) { return true; } if (i == spinCount / 2) { Thread.Yield(); } else { Thread.SpinWait(PlatformHelper.ProcessorCount * (4 &amp;lt;&amp;lt; i)); }} 当 Run 中的异步任务结束后，自旋锁即发现任务结束 Task.IsCompleted 为 True，于是等待结束，不会发生死锁。对第 3 种情况，由于指定了 ConfigureAwait(false)，这意味着通知异步状态机 AsyncMethodStateMachine 并不需要使用设置好的 SynchronizationContext（对于 UI 线程，是 DispatcherSynchronizationContext）执行线程同步，而是使用默认的 SynchronizationContext，而默认行为是随便找个线程执行后面的代码。于是，await Task.Run 后面的代码便不需要返回原线程，也就不会发生第 2 种情况里的死锁问题。预防建议安装 NuGet 包 Microsoft.CodeAnalysis.FxCopAnalyzers。这样，当你在代码中写出 await 时，分析器会提示你 CA2007 警告，你必须显式设置 ConfigureAwait(false) 或 ConfigureAwait(true) 来提醒你是否需要使用默认的 SynchronizationContext。如果你是类库的编写者，注意此问题能够一定程度上防止逗比使用者出现死锁问题后喷你的类库写得不好。更多死锁问题死锁问题： 使用 Task.Wait()？立刻死锁（deadlock） - walterlv 不要使用 Dispatcher.Invoke，因为它可能在你的延迟初始化 Lazy&amp;lt;T&amp;gt; 中导致死锁 - walterlv 在有 UI 线程参与的同步锁（如 AutoResetEvent）内部使用 await 可能导致死锁 .NET 中小心嵌套等待的 Task，它可能会耗尽你线程池的现有资源，出现类似死锁的情况 - walterlv解决方法： 在编写异步方法时，使用 ConfigureAwait(false) 避免使用者死锁 - walterlv 将 async/await 异步代码转换为安全的不会死锁的同步代码（使用 PushFrame） - walterlv" }, { "title": "将 async/await 异步代码转换为安全的不会死锁的同步代码（使用 PushFrame）", "url": "/post/convert-async-to-sync-by-push-frame.html", "categories": "", "tags": "dotnet, csharp", "date": "2019-03-15 15:54:00 +0800", "snippet": "在 async/await 异步模型（即 TAP Task-based Asynchronous Pattern）出现以前，有大量的同步代码存在于代码库中，以至于这些代码全部迁移到 async/await 可能有些困难。这里就免不了将一部分异步代码修改为同步代码。然而传统的迁移方式存在或多或少的问题。本文将总结这些传统方法的坑，并推出一款异步转同步的新方法，解决传统方法的这些坑。背景问题和传统方法 为什么有些方法不容易迁移到 async/await？ 参见微软的博客 async/await 最佳实践 Async/Await - Best Practices in Asynchronous Programming。如果某个方法从同步方法修改为异步方法（例如从 var content = file.Read() 修改为 var content = await file.ReadAsync()），那么调用此方法的整个调用链全部都要改成 async/await 才能让返回值在调用链中成功传递。 传统的异步转同步的方法有哪些？有什么坑？ 参见我的好朋友林德熙的博客 win10 uwp 异步转同步。文章里使用 Task.Wait() 或者 Task.Result 来获取异步方法的返回值。 这种方法会阻塞调用线程。如果调用线程是 UI 线程，那么 UI 将会无响应；更严重地，如果 UI 线程使用 DispatcherSynchronizationContext（参见我的另一篇文章 DispatcherSynchronizationContext - walterlv）进行线程上下文的同步，那么极有可能会造成死锁（参见我的另一篇文章 使用 Task.Wait()？立刻死锁（deadlock） - walterlv）。 安全的方法传统方法的坑在于 UI 线程无响应和死锁问题。既要解决无响应问题，又要阻塞调用方，可选的方法就是 Windows 消息循环了。在使用消息循环时还要避免使用 async/await 的同步上下文（SynchronizationContext），这样才能避免 UI 线程的死锁问题。所以，我考虑使用 PushFrame 来阻塞当前线程并创建一个新的消息循环。使用 Task.ContinueWith 来恢复阻塞，而不使用 Task 中默认同步所采用的同步上下文。关于 PushFrame，可以阅读 深入了解 WPF Dispatcher 的工作原理（PushFrame 部分） 了解更多。代码如下：/// &amp;lt;summary&amp;gt;/// 通过 PushFrame（进入一个新的消息循环）的方式来同步等待一个必须使用 await 才能等待的异步操作。/// 由于使用了消息循环，所以并不会阻塞 UI 线程。&amp;lt;para/&amp;gt;/// 此方法适用于将一个 async/await 模式的异步代码转换为同步代码。&amp;lt;para/&amp;gt;/// &amp;lt;/summary&amp;gt;/// &amp;lt;remarks&amp;gt;/// 此方法适用于任何线程，包括 UI 线程、非 UI 线程、STA 线程、MTA 线程。/// &amp;lt;/remarks&amp;gt;/// &amp;lt;typeparam name=&quot;TResult&quot;&amp;gt;/// 异步方法返回值的类型。/// 我们认为只有包含返回值的方法才会出现无法从异步转为同步的问题，所以必须要求异步方法返回一个值。/// &amp;lt;/typeparam&amp;gt;/// &amp;lt;param name=&quot;task&quot;&amp;gt;异步的带有返回值的任务。&amp;lt;/param&amp;gt;/// &amp;lt;returns&amp;gt;异步方法在同步返回过程中的返回值。&amp;lt;/returns&amp;gt;public static TResult AwaitByPushFrame&amp;lt;TResult&amp;gt;(Task&amp;lt;TResult&amp;gt; task){ if (task == null) throw new ArgumentNullException(nameof(task)); Contract.EndContractBlock(); var frame = new DispatcherFrame(); task.ContinueWith(t =&amp;gt; { frame.Continue = false; }); Dispatcher.PushFrame(frame); return task.Result;}▲ 这就是全部代码了，仅适用于 Windows 平台（如果使用 .NET Core，需要其他能够创建消息循环这种线程模型的方案。不过这通常是平台相关的，需要多种实现。例如 Avalonia 在 Win32 平台上使用 GetMessage 实现等待；在 iOS 和 Android 平台上使用外部的全局循环；Mac 使用 MonoMac.AppKit 创建；Linux 下使用 GtkMainIteration 实现等待。）新方法的适用范围和优劣事实上，虽然我们使用了消息循环，但其实也适用于控制台程序，适用于各种各样奇奇怪怪的线程 —— 无论是 UI 线程还是非 UI 线程，无论是 STA 还是 MTA。例如，我们现在在一个 MTA 线程模型的控制台程序中试用一下：namespace Walterlv.Demo{ class Program { static void Main(string[] args) { Console.Title = &quot;walterlv&#39;s demo&quot;; var foo = Foo(); var result = AwaitByPushFrame(foo); Console.WriteLine($&quot;输入的字符串为：{result}&quot;); Console.ReadKey(); } private static async Task&amp;lt;string&amp;gt; Foo() { Console.WriteLine(&quot;请稍后……&quot;); await Task.Delay(1000); Console.Write(&quot;请输入：&quot;); var line = Console.ReadLine(); Console.WriteLine(&quot;正在处理……&quot;); await Task.Run(() =&amp;gt; { // 模拟耗时的操作。 Thread.Sleep(1000); }); return line; } }}启动控制台程序，我们发现程序真的停下来等待我们输入了。这说明一开始的 await Task.Delay(1000) 已经生效，Main 函数也没有退出。▲ 开始运行现在我们输入一段文字：▲ 输入文字依然正常。现在我们按下回车看看后台线程的执行是否也正常：▲ 后台线程正在处理后台线程也在处理，而且现在才停到 Main 函数的 ReadKey 中。说明转同步过程成功。不过我们也要认识到，由于使用了消息循环，这意味着此方法不像 Task.Wait() 或 Task.Result 方法那样在全平台通用。不过，消息循环方法的出现便主要是用来解决 UI 的无响应和死锁问题。总结我们使用消息循环的方式完成了异步方法转同步方法，这样的方式不止能解决传统 Task.Wait()/Task.Result 导致 UI 线程无响应或死锁问题之外，也适用于非 UI 线程，不止能在 STA 线程使用，也能在 MTA 线程使用。更多死锁问题死锁问题： 使用 Task.Wait()？立刻死锁（deadlock） - walterlv 不要使用 Dispatcher.Invoke，因为它可能在你的延迟初始化 Lazy&amp;lt;T&amp;gt; 中导致死锁 - walterlv 在有 UI 线程参与的同步锁（如 AutoResetEvent）内部使用 await 可能导致死锁 .NET 中小心嵌套等待的 Task，它可能会耗尽你线程池的现有资源，出现类似死锁的情况 - walterlv解决方法： 在编写异步方法时，使用 ConfigureAwait(false) 避免使用者死锁 - walterlv 将 async/await 异步代码转换为安全的不会死锁的同步代码（使用 PushFrame） - walterlv" }, { "title": "使用 Task.Wait()？立刻死锁（deadlock）", "url": "/post/deadlock-in-task-wait.html", "categories": "", "tags": "dotnet, csharp", "date": "2019-03-15 15:54:00 +0800", "snippet": "最近读到一篇异步转同步的文章，发现其中没有考虑到异步转同步过程中发生的死锁问题，所以特地在本文说说异步转同步过程中的死锁问题。文章作者 林德熙 已经修复了描述： win10 uwp 异步转同步什么情况下会产生死锁？调用 Task.Wait() 或者 Task.Result 立刻产生死锁的充分条件： 调用 Wait() 或 Result 的代码位于 UI 线程； Task 的实际执行在其他线程，且需要返回 UI 线程。死锁的原因：UWP、WPF、Windows Forms 程序的 UI 线程都是单线程的。为了让使用了 async/await 的代码像使用同步代码一样简单，WPF 程序的 Application 类在构造的时候会将主 UI 线程 Task 的同步上下文设置为 DispatcherSynchronizationContext 的实例，这在我的另一篇文章 Task.Yield 中也有过说明。当 Task 的任务结束时，会从 AsyncMethodStateMachine 中调用 Awaiter 的 OnComplete() 方法，而 await 后续方法的执行靠的就是 OnComplete() 方法中一层层调用到 DispatcherSynchronizationContext 里的 Post 方法：/// &amp;lt;summary&amp;gt;/// Asynchronously invoke the callback in the SynchronizationContext./// &amp;lt;/summary&amp;gt;public override void Post(SendOrPostCallback d, Object state){ // Call BeginInvoke with the cached priority. Note that BeginInvoke // preserves the behavior of passing exceptions to // Dispatcher.UnhandledException unlike InvokeAsync. This is // desireable because there is no way to await the call to Post, so // exceptions are hard to observe. _dispatcher.BeginInvoke(_priority, d, state);}这里就是问题的关键！！！如果 _dispatcher.BeginInvoke(_priority, d, state); 这句代码在后台线程，那么此时 UI 线程处于 Wait()/Result 调用中的阻塞状态，BeginInvoke 中的任务是无论如何也无法执行到的！于是无论如何都无法完成这个 Post 任务，即无论如何也无法退出此异步任务的执行，于是 Wait() 便无法完成等待……死锁……这里给出最简复现的例子代码：DoAsync().Wait();async Task DoAsync(){ await Task.Run(() =&amp;gt; { });}无论是 WPF 还是 UWP，只要在 UI 线程上调用上述代码，必然死锁！什么情况下不会产生死锁？阅读了本文一开始说的那篇文章 win10 uwp 异步转同步 后，你一定好奇为什么此文的情况不会产生死锁。那是因为，它不满足本文提到的充分条件——StorageFolder.GetFolderFromPathAsync(&quot;&quot;) 和 StorageFolder.GetFolderFromPathAsync(&quot;&quot;) 这两个方法并不会在后台线程执行！逗我？？？不在后台线程执行怎么做到的异步等待！！！是的，读写文件，访问网络，这些 IO 阻塞的操作执行时，里面根本就没有线程，详情请阅读：There Is No Thread。还有另一些操作，也没有后台线程的参与，于是也不存在从后台线程回到主线程导致死锁的情况。如 Task.Yield，还有 InvokeAsync，它们也不会造成死锁。另外，如果是控制台程序，或者一个普通的非 UI 线程，其 SynchronizationContext 为 null，那么异步任务执行完后不需要回到原有线程，也不会造成死锁。总结不会造成死锁的充分条件： 异步操作执行完后不需要回到原有线程（例如非 UI 线程和控制台线程）； 异步操作不需要单独的线程执行任务。如何避免死锁？明确了会造成死锁的条件和不会造成死锁的条件后，我们只需要做到以下几点即可避免死锁了： 在 UI 线程，如果使用了 async/await，就尽量不要再使用 Task.Wait()/Task.Result 了，就一直异步一条路走到黑好了（微软称其为 Async All the Way）。 如果可能，尽量在异步任务后添加 .ConfigureAwait(false)；这样，异步任务后面继续执行的代码就不会回到原 UI 线程了，而是直接从线程池中再取出一个线程执行；这样，即便 UI 线程后续可能有别的原因造成阻塞，也不会产生死锁了。把原来的代码改成这样，就不会死锁了：await DoAsync();async Task DoAsync(){ await Task.Run(() =&amp;gt; { });}没错！只能是一路 async/await。微软将其描述为：async/await 会像病毒一样在你的代码中传播。 Others have also noticed the spreading behavior of asynchronous programming and have called it “contagious” or compared it to a zombie virus.这句话的原文参见：Async/Await - Best Practices in Asynchronous Programming为了防止真的有代码的调用者使用 Wait()，我们也得写出防 SB 的代码来：async Task DoAsync(){ await Task.Run(() =&amp;gt; { }).ConfigureAwait(false);}这一句的目的是防止执行上下文切换回 UI 线程。这样，即便真的使用 DoAsync().Wait() 也不会发生死锁。注意，整个方法调用链都需要使用 .ConfigureAwait(false) 才能够防止线程切换时，在调用方的 Wait() 方法中发生死锁。详见我的另一篇博客 在编写异步方法时，使用 ConfigureAwait(false) 避免使用者死锁。）更多死锁问题死锁问题： 使用 Task.Wait()？立刻死锁（deadlock） - walterlv 不要使用 Dispatcher.Invoke，因为它可能在你的延迟初始化 Lazy&amp;lt;T&amp;gt; 中导致死锁 - walterlv 在有 UI 线程参与的同步锁（如 AutoResetEvent）内部使用 await 可能导致死锁 .NET 中小心嵌套等待的 Task，它可能会耗尽你线程池的现有资源，出现类似死锁的情况 - walterlv解决方法： 在编写异步方法时，使用 ConfigureAwait(false) 避免使用者死锁 - walterlv 将 async/await 异步代码转换为安全的不会死锁的同步代码（使用 PushFrame） - walterlv参考资料 There Is No Thread Async/Await - Best Practices in Asynchronous Programming" }, { "title": "不要使用 Dispatcher.Invoke，因为它可能在你的延迟初始化 Lazy 中导致死锁", "url": "/post/deadlock-of-invoke-in-lazy.html", "categories": "", "tags": "dotnet, wpf", "date": "2019-03-15 15:52:24 +0800", "snippet": "WPF 中为了 UI 的跨线程访问，提供了 Dispatcher 线程模型。其 Invoke 方法，无论在哪个线程调用，都可以让传入的方法回到 UI 线程。然而，如果你在 Lazy 上下文中使用了 `Invoke`，那么当这个 `Lazy` 跨线程并发时，极有可能导致死锁。本文将具体说说这个例子。一段死锁的代码请先看一段非常简单的 WPF 代码：private Lazy&amp;lt;Walterlv&amp;gt; _walterlvLazy = new Lazy&amp;lt;Walterlv&amp;gt;(() =&amp;gt; new Walterlv());private void OnLoaded(object sender, RoutedEventArgs e){ Task.Run(() =&amp;gt; { // 在后台线程通过 Lazy 获取。 var backgroundWalterlv = _walterlvLazy.Value; }); // 等待一个时间，这样可以确保后台线程先访问到 Lazy，并且在完成之前，UI 线程也能访问到 Lazy。 Thread.Sleep(50); // 在主线程通过 Lazy 获取。 var walterlv = _walterlvLazy.Value;}而其中的 Walterlv 类的定义也是非常简单的：class Walterlv{ public Walterlv() { // 等待一段时间，是为了给我么的测试程序一个准确的时机。 Thread.Sleep(100); // Invoke 到主线程执行，里面什么都不做是为了证明绝不是里面代码带来的影响。 Application.Current.Dispatcher.Invoke(() =&amp;gt; { }); }}这里的 Application.Current.Dispatcher 并不一定必须是 Application.Current，只要是两个不同线程拿到的 Dispatcher 的实例是同一个，就会死锁。此死锁的触发条件 Lazy&amp;lt;T&amp;gt; 的线程安全参数设置为默认的，也就是 LazyThreadSafetyMode.ExecutionAndPublication； 后台线程和主 UI 线程并发访问这个 Lazy&amp;lt;T&amp;gt;，且后台线程先于主 UI 线程访问这个 Lazy&amp;lt;T&amp;gt;； Lazy&amp;lt;T&amp;gt; 内部的代码包含主线程的 Invoke。此死锁的原因 后台线程访问到 Lazy，于是 Lazy 内部获得同步锁； 主 UI 线程访问到 Lazy，于是主 UI 线程等待同步锁完成，并进入阻塞状态（以至于不能处理消息循环）； 后台线程的初始化调用到 Invoke 需要到 UI 线程完成指定的任务后才会返回，但 UI 线程此时阻塞不能处理消息循环，以至于无法完成 Invoke 内的任务；于是，后台线程在等待 UI 线程处理消息以便让 Invoke 完成，而主 UI 线程由于进入 Lazy 的等待，于是不能完成 Invoke 中的任务；于是发生死锁。此死锁的解决方法Invoke 改为 InvokeAsync 便能解锁。这么做能解决的原因是：后台线程能够及时返回，这样 UI 线程便能够继续执行，包括执行 InvokeAsync 中传入的任务。实际上，以上可能是最好的解决办法了。因为： 我们使用 Lazy 并且设置线程安全，一定是因为这个初始化过程会被多个线程访问； 我们会在 Lazy 的初始化代码中使用回到主线程的 Invoke，也是因为我们预料到这份初始化代码可能在后台线程执行。所以，这段初始化代码既然不可避免地会并发，那么就应该阻止并发造成的死锁问题。也就是不要使用 Invoke 而是改用 InvokeAsync。如果需要使用 Invoke 的返回值，那么改为 InvokeAsync 之后，可以使用 await 异步等待返回值。更多死锁问题死锁问题： 使用 Task.Wait()？立刻死锁（deadlock） - walterlv 不要使用 Dispatcher.Invoke，因为它可能在你的延迟初始化 Lazy&amp;lt;T&amp;gt; 中导致死锁 - walterlv 在有 UI 线程参与的同步锁（如 AutoResetEvent）内部使用 await 可能导致死锁 .NET 中小心嵌套等待的 Task，它可能会耗尽你线程池的现有资源，出现类似死锁的情况 - walterlv解决方法： 在编写异步方法时，使用 ConfigureAwait(false) 避免使用者死锁 - walterlv 将 async/await 异步代码转换为安全的不会死锁的同步代码（使用 PushFrame） - walterlv" }, { "title": "C#/.NET 如何结束掉一个进程", "url": "/post/how-to-kill-a-process.html", "categories": "", "tags": "dotnet, csharp", "date": "2019-03-14 22:57:27 +0800", "snippet": "本文介绍如何结束掉一个进程。结束掉特定名字的进程ProcessInfo 中有 Kill 实例方法可以调用，也就是说如果我们能够拿到一个进程的信息，并且对这个进程拥有访问权限，那么我们就能够结束掉它。使用 Process.GetProcessesByName(processName) 可以按照名字拿到进程信息。于是我们可以使用这个方法杀掉具有特定名称的进程。private void KillProcess(string processName){ foreach (var process in Process.GetProcessesByName(processName)) { try { // 杀掉这个进程。 process.Kill(); // 等待进程被杀掉。你也可以在这里加上一个超时时间（毫秒整数）。 process.WaitForExit(); } catch (Win32Exception ex) { // 无法结束进程，可能有很多原因。 // 建议记录这个异常，如果你的程序能够处理这里的某种特定异常了，那么就需要在这里补充处理。 // Log.Error(ex); } catch (InvalidOperationException) { // 进程已经退出，无法继续退出。既然已经退了，那这里也算是退出成功了。 // 于是这里其实什么代码也不需要执行。 } }}结束掉自己可以是参见林德熙的博客，使用 Environment.FailFast，在结束掉自己的时候记录自己的错误日志。 dotnet 使用 Environment.FailFast 结束程序 - 林德熙" }, { "title": "让你的 VSCode 具备调试 C# 语言 .NET Core 程序的能力", "url": "/post/equip-vscode-for-dotnet-core-app-debugging.html", "categories": "", "tags": "dotnet, csharp, vscode, msbuild, visualstudio", "date": "2019-03-14 22:31:16 +0800", "snippet": "如果你是开发个人项目，那就直接用 Visual Studio Community 版本吧，对个人免费，对小团体免费，不需要这么折腾。如果你是 Mac / Linux 用户，不想用 Visual Studio for Mac 版；或者不想用 Visual Studio for Windows 版那么重磅的 IDE 来开发简单的 .NET Core 程序；或者你就是想像我这么折腾，那我们就开始吧！安装 .NET Core Sdk、Visual Studio Code 和 C# for Visual Studio Code 点击这里下载正式或者预览版的 .NET Core 然后安装 点击这里下载 Visual Studio Code 然后安装 在 Visual Studio Code 里安装 C# for Visual Studio Code 插件（步骤如下图所示）搜索的时候，推荐使用 OmniSharp 关键字，因为这可以得到唯一的结果，你不会弄混淆。如果你使用 C# 作为关键字，那需要小心，你得找到名字只有 C#，点开之后是 C# for Visual Studio Code 的那款插件。因为可能装错，所以我不推荐这么做。对于新版的 Visual Studio Code，装完会自动启用，所以你不用担心。我们可以后续步骤了。使用 VSCode 创建 .NET Core 项目本文不会讲解如何使用 VSCode 创建 .NET Core 项目，因为这不是本文的重点。也许你可以参考我还没有写的另一篇博客。打开一个现有的 .NET Core 项目现在假设你已经有一个现成的能用 Visual Studio 跑起来的 .NET Core 控制台项目了（可能是刚克隆下来的，也可能就是用我另一篇博客中的教程创建的），于是我们就在这个项目上进行开发。本文以我的自动化测试程序 Walterlv.InfinityStartupTest 为例进行说明。如果你找不到合适的例子，可以使用这篇博客创建一个。在这个文件夹的根目录下右键，然后 使用 Code 打开。配置编译和调试环境正常情况下，当你用 Visual Studio Code 打开一个包含 .NET Core 项目的文件夹时，C# 插件会在右下角弹出通知提示，问你要不要为这个项目创建编译和调试文件，当然选择“Yes”。这个提示一段时间不点会消失的，但是右下角会有一个小铃铛（上面的图片也可以看得到的），点开可以看到刚刚消失的提示，然后继续操作。这时，你的项目文件夹中会多出两个文件，都在 .vscode 文件夹中。tasks.json 是编译文件，指导如何进行编译；launch.json 是调试文件，指导如何进行调试。开始调试现在，你只需要按下 F5（就是平时 Visual Studio 调试按烂的那个），你就能使用熟悉的调试方式在 Visual Studio Code 中来调试 .NET Core 程序了。下图是调试进行中各个界面的功能分区。如果你没看到这个界面，请点击左侧那只被圈在圆圈里面的小虫子。当你按照本文操作，在按下 F5 后有各种报错，那么原因只有一个——你的这个项目本身就是编译不过的，你自己用命令行也会编译不过。你需要解决编译问题，而本文只是入门教程，不会说如何解决编译问题。手工设置 tasks.json 和 launch.json 文件如果自动创建的这两个文件有问题，或者你根本就找不到自动创建的入口，可以考虑手工创建这两个文件。请参见博客： 手工编辑 tasks.json 和 launch.json，让你的 VSCode 具备调试 .NET Core 程序的能力还补充一句，本文说编译文件和调试文件是不对的，因为在 Visual Studio Code 中没有编译这个概念，编译只是任务中的一种而已。" }, { "title": "手工编辑 tasks.json 和 launch.json，让你的 VSCode 具备调试 .NET Core 程序的能力", "url": "/post/equip-vscode-manually-for-dotnet-core-app-debugging.html", "categories": "", "tags": "dotnet, csharp, vscode, msbuild, visualstudio", "date": "2019-03-14 22:31:12 +0800", "snippet": "如果 C# for Visual Studio Code 没有办法自动为你生成正确的 tasks.json 和 launch.json 文件，那么可以考虑阅读本文手工创建他们。前期准备你需要安装 .NET Core Sdk、Visual Studio Code 和 C# for Visual Studio Code，然后打开一个 .NET Core 的项目。如果你没有准备，请先阅读： 让你的 VSCode 具备调试 C# 语言 .NET Core 程序的能力本文主要处理自动生成的配置文件无法满足要求，手工生成。半自动创建 tasks.json 和 launch.json这依然是个偷懒的好方案，我喜欢。 按下 F5； 在弹出的列表中，选择 .NET Core；你不需要再做什么其他的工作了，这时再按下 F5 你已经可以开始调试了。全手工创建 tasks.json 和 launch.jsontasks.json 定义一组任务。其中我们需要的是编译任务，通常编译一个项目使用的动词是 build。比如 dotnet build 命令就是这样的动词。于是定义一个名字为 build 的任务，对应 label 标签。command 和 args 对应我们在命令行中编译一个项目时使用的命令行和参数。type 为 process 表示此任务是启动一个进程。{ &quot;version&quot;: &quot;2.0.0&quot;, &quot;tasks&quot;: [ { &quot;label&quot;: &quot;build&quot;, &quot;command&quot;: &quot;dotnet&quot;, &quot;type&quot;: &quot;process&quot;, &quot;args&quot;: [ &quot;build&quot;, &quot;${workspaceFolder}/Walterlv.InfinityStartupTest/Walterlv.InfinityStartupTest.csproj&quot; ], &quot;problemMatcher&quot;: &quot;$msCompile&quot; } ]}在 launch.json 中通常配置两个启动配置，一个是启动调试，一个是附加调试。type 是在安装了 C# for Visual Studio Code (powered by OmniSharp) 插件之后才会有的调试类型。preLaunchTask 表示在此启动开始之前需要执行的任务，这里指定的 build 跟前面的 build 任务就关联起来了。program 是调试的程序路径，console 指定调试控制台使用内部控制台。{ &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ { &quot;name&quot;: &quot;调试 Walterlv 的自动化测试程序&quot;, &quot;type&quot;: &quot;coreclr&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;preLaunchTask&quot;: &quot;build&quot;, &quot;program&quot;: &quot;${workspaceFolder}/Walterlv.InfinityStartupTest/bin/Debug/netcoreapp3.0/Walterlv.InfinityStartupTest.dll&quot;, &quot;args&quot;: [], &quot;cwd&quot;: &quot;${workspaceFolder}/Walterlv.InfinityStartupTest&quot;, &quot;console&quot;: &quot;internalConsole&quot;, &quot;stopAtEntry&quot;: false, &quot;internalConsoleOptions&quot;: &quot;openOnSessionStart&quot; }, { &quot;name&quot;: &quot;附加进程&quot;, &quot;type&quot;: &quot;coreclr&quot;, &quot;request&quot;: &quot;attach&quot;, &quot;processId&quot;: &quot;${command:pickProcess}&quot; } ]}这样自己手写的方式更灵活但是也更难。" }, { "title": "自然码的形码", "url": "/post/sound-shape-of-natural-code.html", "categories": "", "tags": "ime", "date": "2019-03-14 13:01:47 +0800", "snippet": "使用拼音/双拼输入法，如果你的打字速度还需要继续提升，那么就不应该再不断地看着候选框打字了。使用双拼形码可以规避相当多字词的选字。本文整理自然码的形码，然后附带一张我自己制作的自然码形码的键盘图。输入法的选择目前各种双拼输入法中，辅码最接近自然码形码的，是手心输入法。所以我选用了手心输入法并重新训练了词库。这款输入法与 360 有点关系，不过很不 360。这让我有点犹豫，不过中文输入法里面也没有几个让人省心得了。小狼毫实在是没法儿折腾到好用呀。自然码的形码自然码的形码主要是部首的声母。 A 一 丨 亅 レ 乛 フ ㄥ B 八 丷 卜 冖 宀 匕 比 白 贝 疒 鼻 C 艹 卄 廾  廿 屮 卝 寸 D 丶 冫 氵 刀 刂 リ ㄍ ⺈ 丁 歹 癶 E 二 儿 阝 耳 卩  F 扌 丰 反 方 风 父 缶 巿 G 乚  ㄅ ㄋ 勹 弓 工 广 艮 戈 瓜 谷 革 骨 鬼 夬 罓 H 灬 火 禾 户 虍 黑 乊 厷 I 厂 川 巛 亍 车 虫 臣 辰 赤 齿 髟 豖 J 几 九 己 巾 斤 钅 金 见 臼  角 K コ 凵 匚 冂 口 囗 丂 L 力 六 立 龙 耒 卤 鹿 M 木 门 毛 马 米 矛 母 皿 尨 麻 丏 N 女 牛 牜 ⺧ 鸟 O 日 曰 月 目 P ノ 彡 片 皮 疋 ⺪ 攴 Q 七 犭 犬 丌 欠 气 且 R 亻 人 入 肉 S 三 罒 巳 纟 糹 糸 厶  T 土 田 U 水 手  食 飠 饣 示 礻 山 石 尸 十 士 矢 殳 舌 身 豕 鼠 V 隹 ⺮ 爫 爪 豸 止 至 舟 W 文 亠 攵 夂 夊 ㄨ 王 韦 瓦 X 彳 小  心 忄  血 彐 夕 习 西 辛 Y 乙 又 已 讠 言 幺 尤 尢 冘 衣 衤 羊 牙 业 由 用 页 酉 鱼 雨 羽 聿 乑 乂 Z 辶 廴 子 自 走 足 ⻊ 卆键盘图将以上的形码整理成一个键盘图，有助于你在练习形码的初期记忆这些形码。图中所用的背景源自微软流畅设计 Fluent Design System 的新版本，Microsoft Office 新图标设计的视频片段。我自己进行了一些高斯模糊处理。参考链接 【双拼输入法】自然码辅助码入门教程（辅助码表） – 柳婼 の blog 如何评价手心输入法？ - 知乎" }, { "title": "在 Visual Studio Code 中添加自定义的代码片段", "url": "/post/add-custom-code-snippet-for-vscode.html", "categories": "", "tags": "vscode", "date": "2019-03-14 13:01:30 +0800", "snippet": "无论是那个编辑器，如果能够添加一些自定义代码片段，能够大大提升代码的输入效率。本文介绍如何在 Visual Studio Code 中添加自定义代码片段。Visual Studio Code 的代码片段设置你可以在 Visual Studio Code 的菜单中找到代码片段的设置入口，在 File -&amp;gt; Preferences -&amp;gt; User Snippets 中。▲ 打开用户代码片段设置点开后，会让你选择做什么： 新建全局代码片段 新建适用于当前工作区的代码片段 新建特定于语言的全局代码片段根据你的需要选择一个范围： 比如你需要在任何文件中都能够使用的代码片段，那么选择全局代码片段。 比如你需要仅在当前工作区生效的代码片段（例如我写博客是才会用到的博客片段），那么选择工作区代码片段。 如果是特定于语言的，那么选择自己需要的语言。在新建全局代码片段和当前工作区的代码片段的时候，是需要自己指定名称的。▲ 指定代码片段的名称编写代码片段无论你使用哪种方式新建代码片段，Visual Studio Code 都会帮你打开这个代码片段文件。整个文件一开始是被注释的状态，就像下面这样：{ // Place your global snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and // description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope // is left empty or omitted, the snippet gets applied to all languages. The prefix is what is // used to trigger the snippet and the body will be expanded and inserted. Possible variables are: // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. // Placeholders with the same ids are connected. // Example: // &quot;Print to console&quot;: { // &quot;scope&quot;: &quot;javascript,typescript&quot;, // &quot;prefix&quot;: &quot;log&quot;, // &quot;body&quot;: [ // &quot;console.log(&#39;$1&#39;);&quot;, // &quot;$2&quot; // ], // &quot;description&quot;: &quot;Log output to console&quot; // }}上面的注释，翻译一下是这样的：可以将你的全局代码片段放到这里。每一个代码片段都由一个名称来定义，其值包含此代码片段的作用域(scope)、前缀(prefix)、代码片段的内容(body)与其描述信息(description)组成。 scope 字段中填写以逗号分隔的作用域 Id，如果 scope 字段为空或根本没有设置，那么将适用于所有语言。 prefix 是用于触发代码片段的一段文字，当你输入这个文字的时候，你将可以展开这个代码片段的内容并将其插入。 body 你可以使用 $1 $2 来作为按下 Tab 时将切换的键盘焦点区域，$0 是插入完成后最终光标所在的位置。你也可以使用 ${1:label} 或 ${2:another} 这样的方式来增加占位符，同样 Id 的占位符将会自动关联起来。例如，我通过以下代码片段来为我插入博客的目录：{ &quot;Add toc to post&quot;: { &quot;scope&quot;: &quot;markdown&quot;, &quot;prefix&quot;: &quot;toc&quot;, &quot;body&quot;: [ &quot;@[TOC](${1:walterlv 的目录})&quot;, &quot;$0&quot; ], &quot;description&quot;: &quot;添加 walterlv 的博客的目录&quot; }}插入代码片段那么现在按下 F1 打开快捷命令输入框进入 Insert Snippet 命令，输入 toc 可以看到我们刚刚加入的代码片段：或者，在带有智能感知提示的文件中，可以直接通过智能感知提示插入：在插入的代码片段中，${1:walterlv 的目录} 会成为我们的第一个占位符，而且默认文字就是 walterlv 的目录。需要注意的是，Visual Studio Code 中 Markdown 默认是没有打开智能感知提示的。你需要在你的工作区或者全局打开它。默认是这样的：{ // Configure editor settings to be overridden for [markdown] language. &quot;[markdown]&quot;: { &quot;editor.wordWrap&quot;: &quot;on&quot;, &quot;editor.quickSuggestions&quot;: false }}你需要把 editor.quickSuggestions 设置为 true。{ &quot;[markdown]&quot;: { &quot;editor.quickSuggestions&quot;: true }}一个更复杂的例子现在，我们来做一个更复杂的例子，以便了解 Visual Studio Code 中代码片段定义的更多内容。输入 post 以便插入 blog.walterlv.com 专用的博客模板：在模板中，我们的的第一个焦点文字是标题，于是我们可以立刻输入博客标题：▲ 博客标题占位符当写完后按下 Tab 换到下一个占位符时，可以选择一些常用的选项：▲ 选择博客分类而最后，焦点会落到博客摘要处：▲ 最后的焦点在博客摘要顺便的，你可能没有注意到还有博客时间。就是那个 date 字段为空或根本没有设置，那么将适用于所有语言。是的 代码片段中可以插入时间 和其他各种变量。而这样的一个模板，配置文件是这样的：{ &quot;Insert a post for blog.walterlv.com&quot;: { &quot;scope&quot;: &quot;markdown&quot;, &quot;prefix&quot;: &quot;post&quot;, &quot;body&quot;: [ &quot;---&quot;, &quot;title: \\&quot;${1:在此处添加标题}\\&quot;&quot;, &quot;date: ${CURRENT_YEAR}-${CURRENT_MONTH}-${CURRENT_DATE} ${CURRENT_HOUR}:${CURRENT_MINUTE}:${CURRENT_SECOND} +0800&quot;, &quot;tags: ${2|dotnet,csharp,uwp|}&quot;, &quot;---&quot;, &quot;&quot;, &quot;${0:在此处编辑 blog.walterlv.com 的博客摘要}&quot;, &quot;&quot;, &quot;---&quot;, &quot;&quot;, &quot;@[TOC](本文内容)&quot;, &quot;&quot;, &quot;## 标题&quot;, &quot;&quot;, &quot;---&quot;, &quot;&quot;, &quot;**参考资料**&quot; ], &quot;description&quot;: &quot;使用 blog.walterlv.com 专用的博客模板&quot; }}接下来我们就来说说这是怎么做出来的。关于代码片段编写的更多细节关于文件名称在阅读前面的博客内容时，你可能注意到了：添加全局代码片段的时候，文件扩展名为 .code-snippets，例如 blog.code-snippets；添加语言特定的代码片段的时候，扩展名为 .json，如 markdown.json。这个规则无论在全局还是在工作区，都是一样适用的。光标停留点（Tabstop）使用 $1 $2 这些可以作为按下 Tab 键时的光标停留位置，而 $0 无论出现在代码片段的哪个地方，都会是最后一个光标位置。占位符${1:占位符 Id} 可以表示一个占位符。当你插入此代码片段的时候，会出现 占位符 Id 字样，然后光标会选中这几个字以便你进行修改。占位符可以嵌套，例如 ${1:walterlv 的 ${2:嵌套占位符}}。这时，光标会首先选中所有的文字，随后按下 Tab 之后选中后面那一部分。在前面那个比较复杂的博客代码片段中，${1:在此处添加标题} 就是一个占位符，而 ${0:在此处编辑 blog.walterlv.com 的博客摘要} 就是光标的最终停留点。下拉选项使用 ${1|选项 1,选项 2,选项 3|} 可以创建三个选项的下拉框。在前面的博客代码片段中，${2|dotnet,csharp,uwp|} 就是一个下拉选框，帮助我选择常用的一些博客类别。变量使用 $变量名 或者 ${变量名:变量的默认值} 可以创建变量。在 Visual Studio Code 中，你有这些变量可以使用：-TM_SELECTED_TEXT - 在插入代码片段的时刻选中的文本-TM_CURRENT_LINE - 在插入代码片段的时刻光标所在的行-TM_CURRENT_WORD - 在插入代码片段的时刻光标所在的词-TM_LINE_INDEX - 在插入代码片段的时刻的行号（0 为首行）-TM_LINE_NUMBER - 当前文档的总行数-TM_FILENAME - 当前文档的文件名称-TM_FILENAME_BASE - 当前文档不含扩展名的名称-TM_DIRECTORY - 当前文档所在的文件夹-TM_FILEPATH - 当前文档的完全路径-CLIPBOARD - 剪贴板中的内容-CURRENT_YEAR - 年-CURRENT_YEAR_SHORT - 两位数字显示的年-CURRENT_MONTH - 月，如 02-CURRENT_MONTH_NAME - 月的英文名称，如 July-CURRENT_MONTH_NAME_SHORT - 月的英文缩写，如 Jul-CURRENT_DATE - 日-CURRENT_DAY_NAME - 星期的英文名称，如 Monday-CURRENT_DAY_NAME_SHORT - 星期的英文缩写，如 Mon-CURRENT_HOUR - 24 小时制的时-CURRENT_MINUTE - 分-CURRENT_SECOND - 秒所以在上面比较复杂的博客模板中，我们可以直接插入当前的时间 ${CURRENT_YEAR}-${CURRENT_MONTH}-${CURRENT_DATE} ${CURRENT_HOUR}:${CURRENT_MINUTE}:${CURRENT_SECOND} +0800。这个时间我之前也在输入法中调过：常用输入法快速输入自定义格式的时间和日期（搜狗/QQ/微软拼音）。参考资料 Creating your own snippets in Visual Studio Code" }, { "title": "解决 mklink 使用中的各种坑（硬链接，软链接/符号链接，目录链接）", "url": "/post/problems-of-mklink.html", "categories": "", "tags": "windows", "date": "2019-03-14 13:01:14 +0800", "snippet": "通过 mklink 命令可以创建文件或文件夹的链接，而这种链接跟快捷方式是不一样的。然而我们还可能会遇到其使用过程中的一些坑，本文将整理这些坑并提供解决方法。0x00 背景介绍：mklinkmklink 可以像创建快捷方式一样建立文件或文件夹的链接，但不同于快捷方式的是，mklink 创建的链接绝大多数程序都不会认为那是一个链接，而是一个实实在在的文件或文件夹。例如，为 D:\\OneDrive\\Foo 文件夹创建链接到 D:\\Foo，那么 D:\\OneDrive\\Foo 中有一个 .git 文件时，绝大多数程序都会以为 D:\\Foo 中也存在 .git 文件，而且文件内容一模一样。mklink 可以创建符号链接、硬链接和目录链接。在 cmd 中输入 mklink 即可看到以下这样的帮助信息。C:\\Users\\lvyi&amp;gt;mklink创建符号链接。MKLINK [[/D] | [/H] | [/J]] Link Target /D 创建目录符号链接。默认为文件 符号链接。 /H 创建硬链接而非符号链接。 /J 创建目录联接。 Link 指定新的符号链接名称。 Target 指定新链接引用的路径 (相对或绝对)。具体的使用不是本文的重点，可以阅读本文末尾的参考资料了解，这里只给出他们之间的大体区别。 使用方式 适用于 快捷方式小箭头 不带参数 文件 有 /D 文件夹 有 /J 文件夹 有 /H 文件 无 上面的表格顺序，从上到下的行为从越来越像快捷方式到越来越像两个独立的文件夹。0x01 坑：PowerShell 中没有 mklink 命令是的，PowerShell 中就是中没有 mklink 命令。如果要在 powershell 中使用 mklink，那么得先敲 cmd 进入 cmd 之后再使用 mklink 命令。如果你是一个重度强迫症患者，那么可以编写一个 powershell 的扩展函数来实现：Creating a Symbolic Link using PowerShell - Learn Powershell - Achieve More。0x02 坑：权限默认我们的用户账户是 Administrators 组的，会继承它的权限设定。正常情况下，我们使用 mklink 是可以成功执行的。但如果文件系统的设置比较奇怪或者重装过系统，那么可能出现没有权限的错误。C:\\Users\\lvyi&amp;gt;mklink /D D:\\Foo D:\\OneDrive\\Foo你没有足够的权限执行此操作。这时，使用管理员权限启动 cmd 是最简单的做法。不过也可以考虑在 本地安全策略（secpol.msc）\\本地策略\\用户权利分配 中添加当前用户。参考链接 活用 MKLINK 命令保护、节省你的硬盘 - SinoSky 关于mklink的/D /J 区别 - CSDN博客 Creating a Symbolic Link using PowerShell - Learn Powershell - Achieve More win10 无法运行mklink命令同步onedrive和电脑数据 - Microsoft Community Win10下执行mklink提示你没有足够权限执行此操作 - CSDN博客" }, { "title": ".NET 中的轻量级线程安全", "url": "/post/lightweight-thread-safe-since-dotnet-4.html", "categories": "", "tags": "dotnet", "date": "2019-03-14 13:01:05 +0800", "snippet": "对线程安全有要求的代码中，通常会使用锁（lock）。自 .NET 诞生以来就有锁，然而从 .NET Framework 4.0 开始，又诞生了 6 个轻量级的线程安全方案：SpinLock, SpinWait, CountdownEvent, SemaphoreSlim, ManualResetEventSlim, Barrier。类型SpinLock, SpinWaitSpinLock 被称之为“自旋锁”，SpinWait 称为“自旋等待”，适合在非常轻量的计算中使用。它与普通 lock 的区别在于普通 lock 使用 Win32 内核态对象来实现等待，Overview of Synchronization Primitives 中描述为： you can use synchronization primitives that provide fast performance by avoiding expensive reliance on Win32 kernel objects such as wait handles whenever possible.在这个过程中，调用线程会挂起，并造成线程的上下文切换，而这是一部分不算小的开销。自旋等待则是继续让 CPU 执行此线程，直到锁释放。在这个过程中，此线程会持续占用 CPU 资源，但避免了线程上下文切换。所以，对于短时间的计算采用 SpinLock 实现线程安全会更加高效；而长时间的任务执行会导致占用 CPU 资源从而导致其他任务执行所需的资源减少。CountdownEvent并行执行一些任务之后，通常还会继续执行一些代码。初始化时设置信号量次数，随后在每一个子任务结束之后设置一个信号量（调用其 Signal 方法）可以使计数减 1.这样，在调用 Wait 等待的地方就会等计数为 0 后继续执行。SemaphoreSlim, ManualResetEventSlimSemaphoreSlim、ManualResetEventSlim 是此前 Semaphore 和 ManualResetEvent 的轻量级版本，从其名字“slim”便能看出来。如何轻量这些轻量级线程同步方案因为没有使用到 Win32 内核对象，而是在 .NET 内部完成，所以只能进行线程之间的同步，不能进行跨进程同步。如果要完成跨进程的同步，需要使用 Monitor、Mutex 这样的方案。参考资料 Overview of Synchronization Primitives - Microsoft Docs Thread-Safe Collections - Microsoft Docs .net 4.0新特性-自旋锁(SpinLock) - CSDN博客 .net 4.0新特性-CountDownEvent - CSDN博客 Atomicity, volatility and immutability are different, part three – Fabulous Adventures In Coding How to: Enable Thread-Tracking Mode in SpinLock - Microsoft Docs C# SpinWait 实现 - 程序园 C#并行编程 (Barrier,CountdownEvent,ManualResetEventSlim,SemaphoreSlim,SpinLock,SpinWait )–Thread,Ant,ICP,index,ConsoleWriteLine,CookTasks,cook,particpants" }, { "title": "UI 设计中的视觉无障碍设计（色盲眼中的世界以及 UI 使用体验）", "url": "/post/ui-design-for-color-blindness.html", "categories": "", "tags": "ux, ui", "date": "2019-03-14 13:00:53 +0800", "snippet": "我给博客改了主题色，从 这样的 改成了 这样的；然而我问小伙伴看看效果他却并没有发现改变。红绿色盲在亚洲人中占比，男性约 5%，女性则小得多。也就是说，就算仅考虑为国内用户开发应用，这也是很大的一部分用户了。本文将通过更加了解色盲（Color Blindness）来指导我们为更多用户提供更好的 UI 设计。没有色盲模拟器大多数想理解色盲眼中世界的人可能会考虑“色盲模拟器”。在网上搜索“色盲模拟器”，或者英文的“color blindness simulator”可以得到很多的模拟工具，大体思路是将红色、绿色或蓝色分量模拟成另一种颜色分量。比如下面这款（Coblis — Color Blindness Simulator）：读者可以试试自己选择一张照片，比如我选择了我拍摄的家门口的照片：看完就一个感觉——然而为什么模拟器会模拟成这种图片？因为不可能找到真正能模拟色盲的模拟方法。是的——没有真正的色盲模拟器，这只是正常三色视觉者臆想出来的照片！那么，他们眼中的世界到底是怎样？只能想象！理解和想象色盲眼中的世界光和颜色小学科学课本上说“光照在物体上，红色的光射到了眼睛中，于是我们看到的物体是红色”；然而这种说法有些勉强。人类可见光波长范围从约 312.30nm 到 745.40nm 之间，从物理学上光从来都没有颜色的说法，从来无法仅在物理上定义哪一段属于红色、绿色或者青色。那么颜色是怎么来的？——单纯只是人类的感觉。▲ 可见光而这种感觉从哪里来？从视锥细胞接收到的刺激到大脑皮层的处理这些都是形成感觉的重要部分。对于视锥细胞，维基百科上有说明： 一般人眼中有三种不同的视锥细胞：第一种主要感受黄绿色，它的最敏感点在565纳米左右；第二种主要感受绿色，它的最敏感点在535纳米左右；第三种主要感受蓝紫色，其最敏感点在420纳米左右。 ▲ 来自于维基百科 颜色于是，人类对于可见光部分的所有波长的光，会有各种不同的颜色感觉，比如红色、黄色、绿色、蓝色。我们没有办法证明每个人对颜色的感知完全一致，不过这里列举的这四种颜色，在全世界所有文化中理解是一致的。这说明遗传带给我们的三种视锥细胞在颜色的感知和理解上占了主导地位。当然，这里说的颜色其实是一段波长范围，在这一段波长范围内，所有文化都会认为它是红色或者黄色或者绿色；虽然有些许不一样，但大体可以说是这种颜色。虽然在中华文化中，青色也会被说成是蓝色的一部分，不过这并不影响人类对这些颜色边界的模糊划分。所以，在这一段中，我们将达成一个认知——三种不同的视锥细胞决定了我们对于颜色的感知和识别。我们将人类这种通过三种颜色感知细胞对颜色的识别称为三色视觉。双色视觉，三色视觉和四色视觉 有些动物有更多的感受光线的细胞种类，比如鸟。▲ 来自于维基百科 颜色事实上，有更多的感受光线的细胞才是“正常”的、“传统”的。鸟类四种不同的视锥细胞，其主要感受黄、青、蓝和紫外，感受峰值分别是 565nm、508nm、440nm、370nm。而这四种不同的视锥细胞从爬行动物进化而来，事实上即便是现在，大多数脊椎动物依然都是这四种视锥细胞。但是，哺乳动物在进化的过程中丢掉了两种——青和紫外，只剩下黄和蓝部分了。也就是说，大多数哺乳动物都是“色盲”，只有双色视觉。而灵长类在进化的过程中因为基因突变，“黄”的部分变成了两种不同的视锥细胞，于是成了三色视觉，主要感受黄色、绿色和蓝色。也就是说，相比于哺乳动物，灵长目的双色视觉（我们所说的色盲）才是“传统”，而三色视觉其实是基因突变的产物。注意鸟类和人类峰值波长的数字，鸟类的四种峰值波长分布比较平均，而人类的三种峰值波长中黄和绿相隔非常近。这也间接说明了这种基因突变的影响。▲ 人类黄绿色和绿色感知峰值很近，而鸟类的四种感知峰值都很平均于是，其实红色和绿色之间的差异本没有那么大，只是因为人类在黄绿色和绿色波长部分出现了两种视锥细胞，于是就把颜色的感知拉得那么大了。即本来差别并不明显的颜色，被大多数人类夸张到红色和绿色这样巨大的差异。从进化的角度来想象色盲眼中的世界所以，人类现在的三色视觉其实是从爬行类的四色视觉“进化”至哺乳类的双色视觉，随后基因突变再次形成灵长类的三色视觉的，其中黄绿色和绿色的感知是同一个基因突变产生，波长感知差异很小的两个部分。于是，红绿色盲者和大部分祖先——哺乳类观察绿色和棕色（橙色调暗一点就是棕色）是很接近的两种颜色。这种接近很像我们观察绿色和波长稍微长一点的绿色一样。于是——哺乳类的毛发颜色其实是保护色：▲ 这只是模拟，不代表 TA 们眼中真实的世界然后，那个偶然的基因突变让我们硬生生地把波长稍微长一点点的绿色看成了另一种截然不同的颜色。于是，我们一眼便看出了躲藏在万绿丛中的一点棕色。那是多么刺眼的颜色！以至于散落的薰衣草的颜色与周围杂草的颜色对比开始显得暗淡。甚至如果不经过上面的保护色而是直接看到下图你都不一定注意得到薰衣草的存在。▲ 三色视觉的人类发现了草丛中使用了保护色的哺乳动物以上图片来源于网络搜索，模拟由工具生成。如有侵权，请与我联系。从四色视觉的角度来想象色盲眼中的世界现在，我们再来脑洞一次。我们硬生生插入一种新的视锥细胞，并为这种人命名为“异人”。▲ 硬生生插入一种视锥细胞于是他会发现上面的蕨类植物和下面的狗尾草的颜色差异巨大，他们一眼便能将狗尾草从草丛中分离出来，而我们人类需要一点点通过叶子的形状慢慢区分。假如异人觉得蕨类植物比较好吃，狗尾草吃着恶心，那么他们便能通过颜色一眼从草丛堆种识别出这两种草来。然后异人有一天突发奇想希望研究我们三色视觉的人类眼中的世界是怎样的，那么他们把他们新增的那种感知颜色模拟成哪种颜色呢？模拟成蕨类植物色？——那他们眼中的草丛都是好吃的甜蜜的颜色，甚至恶心的狗尾草他们居然都能够舒舒服服地看着！模拟成狗尾草色？——那他们眼中的草丛居然都是那么恶心的颜色，他们整天怎么受得了！模拟成中间色？——那看起来就一点也没有草丛的感觉，丑死了！丑死了！一脸嫌弃！UI 设计中的视觉无障碍设计作为三色视觉的程序员和设计师，刚刚我们想象了一把双色视觉的色盲世界，又被四色视觉的异人逼着看叶子的形状找草体验了一把当色盲的感觉。于是，我们便知道可以如何照顾他们的感受，考虑那 5% 的用户做出更好的 UI 设计。安全色在有多种颜色方案可选的时候，我们可以挑选出那些对色盲友好的颜色方案。当然我们并不指望能够照顾到所有的色盲人群，因为那样就没有任何必要去使用颜色了，超过 99% 的用户将无颜色可用，但这样的性价比实在太低。但是我们可以尽量照顾到红绿色盲人群，因为这在色盲人种的比例是最高的，剩余的人群占比非常低，我们将考虑用非颜色元素来实现无障碍设计。那么，如何挑选呢？红色部分可以不变，绿色部分可以考虑像蓝色部分偏移，就像现在的红绿灯设计那样。色盲者接触到的颜色信息会少一些，这使得能分辨出的颜色差异会更加明显。在团队的 UI 设计中，建议制作一些产品标准色之后通过色盲模拟器检验。此后使用这些标准色。非颜色辅助元素如果某些 UI 元素仅用颜色来区分，那么对色盲来说这样的 UI 将非常难用。比如下面这个验证数学公式的方式：▲ 红色代表错误，绿色代表编辑中如果用模拟器模拟，将得到这样的图像：▲ 色盲模拟器模拟的输入框验证 1▲ 色盲模拟器模拟的输入框验证 2也就是说，找到错误的公式会像我们前面从草丛种分辨出狗尾草一样困难。但如果我们增加一点符号显示，或者在公式旁边放上文字提示（其中一种就够了），这样的问题就能立刻解决。比如这样：这时再模拟，也能清楚地找到错误的公式：▲ 色盲模拟器模拟的输入框验证 1▲ 色盲模拟器模拟的输入框验证 2另外，前面我标注人类、鸟类和异人的波长点用的是符号而不是颜色。在制作图表的时候，通常也应该考虑使用符号代替颜色。推荐一些工具用来手工检查界面是否做到了无障碍设计本文开头我们说到色盲模拟器并不能模拟色盲眼中的世界，但是我们却可以用这些模拟器来评估我们的 UI 设计是否能让色盲者无障碍地使用。 Toptal Color Blind Filter Coblis — Color Blindness Simulator - Colblindor参考与引用 颜色 - 维基百科，自由的百科全书 色盲 - 维基百科，自由的百科全书 为什么没有绿色毛发的哺乳动物？ - 小城的回答 - 知乎 在红绿色盲眼里看到的世界是怎样的？ - 知乎 无障碍设计：为色盲用户多走一步" }, { "title": "C#/.NET 中的契约式编程，以及 ReSharper 为我们提供的契约特性", "url": "/post/contracts-in-csharp.html", "categories": "", "tags": "csharp, dotnet", "date": "2019-03-14 12:57:32 +0800", "snippet": " 将文档放到代码里面，文档才会及时地更新！微软从 .NET Framework 4.0 开始，增加了 System.Diagnostics.Contracts 命名空间，用来把契约文档融入代码。然而后面一直不冷不热，Visual Studio 都没天然支持。ReSharper 也提供了 ReSharper Annotations，在 ReSharper 插件工作的情况下能够进行静态契约的验证。C#8.0 的可空引用类型是 Roslyn 对 null 的验证，这个可能更加强大，既可以是编译警告，也可以是编译错误。契约式编程当你调用某个类库里面的方法时，你如何能够知道传入的参数是否符合规范？如何能够知道方法调用结束之后是否要对结果进行判断？T DoSomething&amp;lt;T&amp;gt;(T parent) where T : class;▲ 对于上面的方法，你知道 null 传入参数是合理的吗？返回的参数需要判空吗？代码的编写者可能是这么写的：public T DoSomething&amp;lt;T&amp;gt;(T parent) where T : class{ if (parent == null) { throw new ArgumentNullException(nameof(parent)); } // 后续逻辑。}有些静态代码检查工具也许可以根据这里的参数判断代码块来认定为此处的参数不能为 null，但这种判断代码无处不在，静态检查工具如何能够有效地捕获每一处的检查呢？难道我们真的要去翻阅文档吗？然而除非是专门提供 SDK 的团队，否则文档通常都会滞后于代码，那么对于这些契约的修改可能就不太准确。于是，契约式编程就应运而生。它将前置条件（Precondition）、后置条件（Postcondition）、不变量（Invariant）等代码分离出来，按照特定的格式编写以便能够被静态检查工具分析出来。有了静态分析工具以及契约代码的帮助，Visual Studio 的智能感知提示将能够直接告诉我们代码编写的潜在问题，而不必等到运行时再抛出异常，那时将降低开发效率，将增加生产环境运行的风险。几种不同的契约方法ReSharper AnnotationsReSharper 并没有将其称之为“契约”，因为它真的只是“文档级别”的约束，只会在写代码的时候具备一定程度的静态分析能力以便给出提示，并不提供运行时的检查。不过，ReSharper 会为我们生成运行时检查的代码。只要是装了 ReSharper 插件并用它写过代码的，应该都见过 ReSharper Annotations 了，因为它会在我们试图添加契约代码时自动添加契约标记（Attribute）。▲ 生成 ReSharper Annotations如果错过了首次提示，可以在 ReSharper 的设置界面中生成 Annotations 的代码。（复制一份代码然后新建一个文件粘贴。）▲ 手动生成 ReSharper AnnotationsReSharper 中常用的契约 Attribute CanBeNull 表示参数或返回值可能为 null。 CannotApplyEqualityOperator 表示某个类型的相等比较不应该用 == 或 !=，而应该用 Equals。 ItemCanBeNull 表示集合参数或集合返回值里某一项可能为 null。 或者表示 Task&amp;lt;T&amp;gt; 返回值中的 T 可能为 null。 ItemNotNull 表示集合参数或集合返回值里每一项都不为 null。 或者表示 Task&amp;lt;T&amp;gt; 返回值中的 T 不为 null。 LinqTunnel 表示某个方法就像 linq 方法一样。 LocalizationRequired 表示参数字符串需要被本地化。 NotNull 表示参数或返回值不可能为 null。 PathReference 表示参数字符串是一个路径。 Pure 表示方法不会修改任何状态（这意味着如果连返回值都不用，那调用了也相当于什么都没做）。 RegexPattern 表示参数字符串是一个正则表达式（会被 ReSharper 代码着色）。 还有 100+ 个…… ContractAnnotation 详见 Contract Annotations - Help - ReSharper，可以使用约定的语法写出更复杂的契约。 我的朋友林德熙在 使用 Resharper 特性 一文中有这些契约对编写代码的更详细的效果描述和截图。System.Diagnostics.Contracts此命名空间下的 Contract 类型定义了几个方法，覆盖了我们编写一个方法所要遵循的契约模式。private T DoSomething&amp;lt;T&amp;gt;(T parent) where T : class{ // * 要开始此任务必须先满足某些条件（Requires，RequiresAlways，EndContractBlock） // 做一些操作。 // * 此时认定一定满足某个条件（Assume） // 继续执行一些操作。 // * 操作执行完后一定满足某组条件（Ensures，EnsuresOnThrows）}以上代码中，星号（*）表示契约代码，其他表示方法内的普通代码。一个典型的例子如以下代码所示：private T DoSomething&amp;lt;T&amp;gt;(T parent) where T : class{ // * 要开始此任务必须先满足某些条件（Requires，EndContractBlock） Contract.Requires&amp;lt;ArgumentNullException&amp;gt;(parent != null); // 做一些操作。 // * 此时认定一定满足某个条件（Assume） Contract.Assume(parent != null); // 继续执行一些操作。 // * 操作执行完后一定满足某组条件（Ensures，EnsuresOnThrows） Contract.EnsuresOnThrow&amp;lt;InvalidOperationException&amp;gt;(Value != null);}在这里，Requires 是真的会抛出异常的，但 Assume 和 EnsuresOnThrow 是需要写条件编译符为 CONTRACTS_FULL 的。或者，这样用普通的抛异常的方式。如果使用普通方式抛出异常，需要遵循 if-then-throw 的模式，即有问题立刻就抛出异常。例如下面对 null 的判断就符合这样的模式。private T DoSomething&amp;lt;T&amp;gt;(T parent) where T : class{ // * 要开始此任务必须先满足某些条件（Requires，EndContractBlock） if (parent == null) throw new ArgumentNullException(nameof(parent)); Contract.EndContractBlock(); // 做一些操作。 // * 此时认定一定满足某个条件（Assume） Contract.Assume(parent != null); // 继续执行一些操作。 // * 操作执行完后一定满足某组条件（Ensures，EnsuresOnThrows） Contract.EnsuresOnThrow&amp;lt;InvalidOperationException&amp;gt;(Value != null);}当然也可以不止是这样简单的判断，也可以调用其他方法，但要求方法必须是 [Pure] 方法，即方法执行完之后，除了返回一个值之外，不改变应用程序的任何状态。对此契约的静态分析微软有提供工具：Microsoft/CodeContracts: Source code for the CodeContracts tools for .NET，ReSharper 对此也有一丁点儿的支持。RoslynRoslyn 相比于任何第三方契约的优势在于它甚至能在语法层面形成契约（比如 C#8.0 中的可空引用类型）。实际应用事实上在 GitHub 中，使用各种契约的都有，不过以 ReSharper Annotations 和 System.Diagnostics.Contracts 的居多；C#8.0 的可空引用类型等到 8.0 发布以后再看吧。在实际应用中，并没有严格的说哪一个更好哪一个一般，两者都可以用，只要我们有分析和提示此契约的工具，就可以在项目中推行开来。但是，基于契约编写代码的模式却能帮助我们写出更加健壮的代码来。也就是说，用哪个并不重要，重要的是——用起来！参考资料 Code Contracts - Microsoft Docs .NET 4.0 中的契约式编程 - Angel Lucifer - 博客园 C# 中参数验证方式的演变 -.net-火龙果软件工程 Contract Annotations - Help - ReSharper" }, { "title": "我收集的各种公有 NuGet 源", "url": "/post/public-nuget-sources.html", "categories": "", "tags": "dotnet, nuget", "date": "2019-03-12 12:41:49 +0800", "snippet": "本文收集我发现的各种公共 NuGet 源。如何添加本文介绍的 NuGet 源？请参见： 全局或为单独的项目添加自定义的 NuGet 源官方 NuGet 源 官方源 https://api.nuget.org/v3/index.json 官方离线本地源 C:\\Program Files (x86)\\Microsoft SDKs\\NuGetPackages\\ 官方网站：https://www.nuget.org/ dotnet feed 包含 .NET Foundation 中各种项目的日构建包 https://dotnetfeed.blob.core.windows.net/dotnet-core/index.json NuGet 镜像 华为云 huaweicloud https://mirrors.huaweicloud.com/ https://repo.huaweicloud.com/repository/nuget/v3/index.json Telerik NuGet https://nuget.telerik.com/nuget 其他 NuGet 源 MyGet 这是一个很激进的 NuGet 源，包含各种日构建包（其中包括 .NET Standard 或者 .NET Core 等库的日构建版本），所以如果你希望尝试最新的 API 最新的功能，最好设置此 NuGet 源。 https://dotnet.myget.org/F/dotnet-core/api/v3/index.json 私有 NuGet 源 Installing private NuGet packages · Gemfury Dev Center 这是私有 NuGet 源，你可以在上面取得独立的 NuGet 链接，上面只有自己私有的 NuGet 包 NuGet 网站呃……这部分只是 NuGet 网站而已，你可以在这里浏览 NuGet 包的各种信息，但是它不提供源。 FuGet Gallery - https://www.fuget.org/ 此项目开源：praeclarum/FuGetGallery: An alternative web UI for browsing nuget packages " }, { "title": "在 csproj 文件中使用系统环境变量的值（示例将 dll 生成到 AppData 目录下）", "url": "/post/environment-variables-in-csproj.html", "categories": "", "tags": "dotnet, csharp, visualstudio, msbuild", "date": "2019-03-12 11:53:06 +0800", "snippet": "Windows 系统以及很多应用程序会考虑使用系统的环境变量来传递一些公共的参数或者配置。Windows 资源管理器使用 %var% 来使用环境变量，那么我们能否在 Visual Studio 的项目文件中使用环境变量呢？本文介绍如何在 csproj 文件中使用环境变量。遇到的问题在 Windows 资源管理器中，我们可以使用 %AppData% 进入到用户的漫游路径。我正在为 希沃白板5 为互动教学而生 - 课件制作神器 编写插件，于是需要将插件放到指定目录：%AppData%\\Seewo\\EasiNote5\\Walterlv.Presentation在 Windows 资源管理器中可以直接输入以上文字进入对应的目录（当然需要确保存在）。更多关于路径的信息可以参考：UWP 中的各种文件路径（用户、缓存、漫游、安装……） - walterlv然而，为了调试方便，我最好在 Visual Studio 中编写的时候就能直接输出到插件目录。于是，我需要将 Visual Studio 的调试目录设置为以上目录，但是以上目录中包含环境变量 %AppData%在 Visual Studio 中修改输出路径如果直接在 csproj 中使用 %AppData%，那么 Visual Studio 会原封不动地创建一个这样的文件夹。实际上，Visual Studio 是天然支持环境变量的。直接使用 MSBuild 获取属性的语法即可获取环境变量的值。也就是说，使用 $(AppData) 即可获取到其值。在我的电脑上是 C:\\Users\\lvyi\\AppData\\Roaming。于是，在 csproj 中设置 OutputPath 即可正确输出我的插件到目标路径。&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;TargetFrameworks&amp;gt;net472&amp;lt;/TargetFrameworks&amp;gt; &amp;lt;OutputPath&amp;gt;$(AppData)\\Seewo\\EasiNote5\\Extensions\\Walterlv.Presentation&amp;lt;/OutputPath&amp;gt; &amp;lt;AppendTargetFrameworkToOutputPath&amp;gt;False&amp;lt;/AppendTargetFrameworkToOutputPath&amp;gt; &amp;lt;/PropertyGroup&amp;gt;&amp;lt;/Project&amp;gt;这里，我额外设置了 AppendTargetFrameworkToOutputPath 属性，这是避免 net472 出现在了目标输出路径中。你可以阅读我的另一篇博客了解更多关于输出路径的问题： 如何更精准地设置 C# / .NET Core 项目的输出路径？（包括添加和删除各种前后缀） - walterlv" }, { "title": "为 WPF 程序添加 Windows 跳转列表的支持", "url": "/post/wpf-application-with-jumplist.html", "categories": "", "tags": "windows, wpf, dotnet, csharp", "date": "2019-03-10 21:30:54 +0800", "snippet": "Windows 跳转列表是自 Windows 7 时代就带来的功能，这一功能是跟随 Windows 7 的任务栏而发布的。当时应用程序要想用上这样的功能需要调用 shell 提供的一些 API。然而在 WPF 程序中使用 Windows 跳转列表功能非常简单，在 XAML 里面就能完成。本文将介绍如何让你的 WPF 应用支持 Windows 跳转列表功能。一个简单的跳转列表程序新建一个 WPF 程序，然后直接在 App.xaml 中添加跳转列表的代码。这里为了更快上手，我直接贴出整个 App.xaml 的代码。&amp;lt;Application x:Class=&quot;Walterlv.Demo.WindowsTasks.App&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:local=&quot;clr-namespace:Walterlv.Demo.WindowsTasks&quot; StartupUri=&quot;MainWindow.xaml&quot;&amp;gt; &amp;lt;JumpList.JumpList&amp;gt; &amp;lt;JumpList ShowRecentCategory=&quot;True&quot; ShowFrequentCategory=&quot;True&quot;&amp;gt; &amp;lt;JumpTask Title=&quot;启动新窗口&quot; Description=&quot;启动一个新的空窗口&quot; /&amp;gt; &amp;lt;JumpTask Title=&quot;修改 walterlv 的个性化设置&quot; Description=&quot;打开个性化设置页面并定位到 walterlv 的设置&quot; IconResourcePath=&quot;C:\\Windows\\System32\\wmploc.dll&quot; IconResourceIndex=&quot;17&quot; Arguments=&quot;--account&quot; /&amp;gt; &amp;lt;/JumpList&amp;gt; &amp;lt;/JumpList.JumpList&amp;gt;&amp;lt;/Application&amp;gt;顺便的，我加了一个简单的图标，这样不至于显示一个默认的应用图标。运行此程序后就可以在任务栏上右击的时候看到跳转列表：在这段程序中，我们添加了两个“任务”，在跳转列表中有一个“任务”分类。因为我的系统是英文，所以显示的是“Task”。在任务分类中，有两个“任务”，启动新窗口 以及 修改 walterlv 的个性化设置。第一个任务只设了标题和鼠标移上去的提示信息，于是显示的图标就是应用本身的图标，点击之后也是启动任务自己。第二个任务设置了 Arguments 参数，于是点击之后会带里面设置的参数启动自己；同时设置了 IconResourcePath 和 IconResourceIndex 用于指定图标。这种图标的指定方式是 Windows 系统中非常常用的方式。你可以在我的另一篇博客中找到各种各样系统自带的图标；至于序号，则是自己去数。 Windows 10 自带那么多图标，去哪里找呢？定制跳转列表的功能JumpList 有两个属性 ShowRecentCategory 和 ShowFrequentCategory，如果指定为 true 则表示操作系统会自动为我们保存此程序最近使用的文件的最频繁使用的文件。Windows 的跳转列表有两种不同的列表项，一种是“任务”，另一种是文件。至于这两种不同的列表项如何在跳转列表中安排，则是操作系统的事情。这两种不同的列表项对应的类型分别是： JumpTask JumpPathJumpTask 可以理解为这就是一个应用程序的快捷方式，可以指定应用程序的路径（ApplicationPath）、工作目录（WorkingDirectory）、启动参数（Arguments）和图标（IconResourcePath、IconResourceIndex）。如果不指定路径，那么就默认为当前程序。也可以指定显示的名称（Title）和鼠标移上去可以看的描述（Description）。JumpPath 则是一个路径，可以是文件或者文件夹的路径。通常用来作为最近使用文件的展示。特别说明：你必须关联某种文件类型这种类型的文件才会显示到 JumpPath 中。另外，JumpTask 和 JumpPath 都有一个 CustomCategory 属性可以指定类别。对于 JumpTask，如果不指定类别，那么就会在默认的“任务”（Task）类别中。对于 JumpPath，如果不指定类别，就在最近的文件中。JumpTask 如果不指定 Title 和 CustomCategory 属性，那么他会成为一个分隔符。参考资料 JumpList Class (System.Windows.Shell) - Microsoft Docs Taskbar Extensions - Windows applications - Microsoft Docs" }, { "title": "Windows 上的应用程序在运行期间可以给自己改名（可以做 OTA 自我更新）", "url": "/post/rename-executable-self-when-running.html", "categories": "", "tags": "windows, dotnet, csharp", "date": "2019-03-10 21:30:52 +0800", "snippet": "程序如何自己更新自己呢？你可能会想到启动一个新的程序或者脚本来更新自己。然而 Windows 操作系统允许一个应用程序在运行期间修改自己的名称甚至移动自己到另一个文件夹中。利用这一点，我们可以很简单直接地做程序的 OTA 自动更新。本文将介绍示例程序运行期间改名并解释其原理。在程序运行期间手工改名我们写一个简单的程序。将它运行起来，然后删除。我们会发现无法删除它。但是，我们却可以很轻松地在资源管理器中对它进行改名，甚至将它从一个文件夹中移动到另一个文件夹中。值得注意的是，你不能跨驱动器移动此文件。不止是 exe 文件，dll 文件也是可以改名的实际上，不止是 exe 文件，在 exe 程序运行期间，即使用到了某些 dll 文件，这些 dll 文件也是可以改名的。当然，一个 exe 的运行不一定在启动期间就加载好了所有的 dll，所以如果你在 exe 启动之后，某个 dll 加载之前改了那个 dll 的名称，那么会出现找不到 dll 的情况，可能导致程序崩溃。为什么 Windows 上的可执行程序可以在运行期间改名？Windows 的文件系统由两个主要的表示结构：一个是目录信息，它保存有关文件的元数据（如文件名、大小、属性和时间戳）；第二个是文件的数据链。当运行程序加载一个程序集的时候，会为此程序集创建一个内存映射文件。为了优化性能，往往只有实际用到的部分才会被加入到内存映射文件中；当需要用到程序集文件中的某块数据时，Windows 操作系统就会将需要的部分加载到内存中。但是，内存映射文件只会锁定文件的数据部分，以保证文件文件的数据不会被其他的进程修改。这里就是关键，内存映射文件只会锁定文件的数据部分，而不会锁住文件元数据信息。这意味着你可以随意修改这些元数据信息而不会影响程序的正常运行。这就包括你可以修改文件名，或者把程序从一个文件夹下移动到另一个文件夹去。但是跨驱动器移动文件，就意味着需要在原来的驱动器下删除文件，而这个操作会影响到文件的数据部分，所以此操作不被允许。编写一个程序在运行期间自动改名一般来说，需要 OTA 更新的程序是客户端程序，所以实际上真正需要此代码的是客户端应用。以下代码中我使用 .NET Core 3.0 来编写一个给自己改名的 WPF 程序。using System.Diagnostics;using System.IO;using System.Windows;namespace Walterlv.Windows.Updater{ public partial class App : Application { protected override void OnStartup(StartupEventArgs e) { base.OnStartup(e); var fileName = Process.GetCurrentProcess().MainModule.FileName; var newFileName = Path.Combine(Path.GetDirectoryName(fileName), &quot;OldUpdater.exe&quot;); File.Move(fileName, newFileName); // 省略的代码：将新下载下载的程序改名成 fileName。 } }}于是，程序自己在运行后会改名。顺便的，以上代码仅适用于 .NET Framework 的桌面应用程序或者 .NET Core 3.0 的桌面应用程序。如果是 .NET Core 2.x，那么以上代码在获取到进程名称的时候可能是 dotnet.exe（已发布的 .NET Core 程序除外）。参考资料 c# - Why does rename a loaded .net assembly work? - Stack Overflow windows 7 - Why can I rename a running executable, but not delete it? - Super User deployment - How can we overwrite EXE files while users are running them? - Stack Overflow" }, { "title": ".NET 使用 JustAssembly 比较两个不同版本程序集的 API 变化", "url": "/post/compare-api-between-two-assemblies-using-just-assembly.html", "categories": "", "tags": "dotnet, csharp", "date": "2019-03-10 21:30:49 +0800", "snippet": "最近我大幅度重构了我一个库的项目结构，使之使用最新的项目文件格式（基于 Microsoft.NET.Sdk）并使用 SourceYard 源码包来打包其中的一些公共代码。不过，最终生成了一个新的 dll 之后却心有余悸，不知道我是否删除或者修改了某些 API，是否可能导致我原有库的使用者出现意料之外的兼容性问题。另外，准备为一个产品级项目更新某个依赖库，但不知道更新此库对我们的影响有多大，希望知道目前版本和希望更新的版本之间的 API 差异。索性发现了 JustAssembly 可以帮助我们分析程序集 API 的变化。本文将介绍如何使用 JustAssembly 来分析不同版本程序集 API 的变化。下载和安装 JustAssemblyJustAssembly 是 Telerik 开源的一款程序集分析工具。你可以去它的官网下载并安装：Assembly Diff Tool for .NET - JustAssembly。开始比较启动 JustAssembly，在一开始丑陋（逃）的界面中选择旧的和新的 dll 文件，然后点击 Load。然后，你就能看到新版本的 API 相比于旧版本的差异了。关于比较结果的说明在差异界面中，差异有以下几种显示： 没有差异 以白色底显示 新增 以绿色底辅以 + 符号显示 删除 以醒目的红色底辅以 - 符号显示 有部分差异 以蓝紫色底辅以 ~ 符号显示 这里可能需要说明一下“部分差异”：由于差异是以树状结构显示的，所以如果子节点有新增，那么父节点因为既有新增又存在未修改的节点，所以会以“有部分差异”的方式显示。对于每一个差异，双击可以去看差异的代码详情。上图我的 SourceFusion 项目在版本更新的时候只有新增的 API，没有修改和删除的 API，所以还是一个比较健康的 API 更新。参考资料 telerik/JustAssembly: Assembly Diff and Analysis Tool Assembly Diff Tool for .NET - JustAssembly" }, { "title": "详解 .NET 反射中的 BindingFlags 以及常用的 BindingFlags 使用方式", "url": "/post/binding-flags-of-reflection.html", "categories": "", "tags": "dotnet, csharp", "date": "2019-03-10 19:05:11 +0800", "snippet": "使用 .NET 的反射 API 时，通常会要求我们传入一个 BindingFlags 参数用于指定反射查找的范围。不过如果对反射不熟的话，第一次写反射很容易写错导致找不到需要的类型成员。本文介绍 BindingFlags 中的各个枚举标记的含义、用途，以及常用的组合使用方式。所有的 BindingFlags默认值// 默认值Default查找这些标记用于反射的时候查找类型成员：// 表示查找的时候，需要忽略大小写。IgnoreCase// 仅查找此特定类型中声明的成员，而不会包括这个类继承得到的成员。DeclaredOnly// 仅查找类型中的实例成员。Instance// 仅查找类型中的静态成员。Static// 仅查找类型中的公共成员。Public// 仅查找类型中的非公共成员（internal protected private）NonPublic// 会查找此特定类型继承树上得到的静态成员。但仅继承公共（public）静态成员和受保护（protected）静态成员；不包含私有静态成员，也不包含嵌套类型。FlattenHierarchy调用这些标记用于为 InvokeMember 方法提供参数，告知应该如何反射调用一个方法：// 调用方法。InvokeMethod// 创建实例。CreateInstance// 获取字段的值。GetField// 设置字段的值。SetField// 获取属性的值。GetProperty// 设置属性的值。SetProperty其他接下来下面的部分就不是那么常用的了。这些标记用于为 InvokeMember 方法提供参数，但是仅在调用一个 COM 组件的时候才应该使用：PutDispPropertyPutRefDispPropertyExactBindingSuppressChangeTypeOptionalParamBinding下面是一些杂项……// 忽略返回值（在 COM 组件的互操作中使用）IgnoreReturn// 反射调用方法时如果出现了异常，通常反射会用 TargetInvocationException 包装这个异常。// 此标记用于禁止把异常包装到 TargetInvocationException 中。DoNotWrapExceptions你可能会有的疑问 如果 A 程序集对 B 程序集内部可见（InternalsVisibleTo(&quot;B&quot;)），那么 B 在反射查找 A 的时候，internal 成员的查找应该使用 Public 还是 NonPublic 标记呢？ 依然是 NonPublic 标记。 因为反射的是程序集的元数据，这是静态的数据，跟运行时状态是无关的。 常用的组合从上面的解释中可以发现，这个类型的设计其实是有问题的，不符合单一职责原则。所以我们会在不同的使用场景下使用不同区域的组合。查找，也就是获取一个类型中的字段、属性、方法等的时候使用的。拿到所有成员：BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance实际上 RuntimeReflectionExtensions.Everything 属性就是这么写的。拿到公有的实例成员：BindingFlags.Public | BindingFlags.Instance附 BindingFlags 的源码[Flags]public enum BindingFlags{ // NOTES: We have lookup masks defined in RuntimeType and Activator. If we // change the lookup values then these masks may need to change also. // a place holder for no flag specifed Default = 0x00, // These flags indicate what to search for when binding IgnoreCase = 0x01, // Ignore the case of Names while searching DeclaredOnly = 0x02, // Only look at the members declared on the Type Instance = 0x04, // Include Instance members in search Static = 0x08, // Include Static members in search Public = 0x10, // Include Public members in search NonPublic = 0x20, // Include Non-Public members in search FlattenHierarchy = 0x40, // Rollup the statics into the class. // These flags are used by InvokeMember to determine // what type of member we are trying to Invoke. // BindingAccess = 0xFF00; InvokeMethod = 0x0100, CreateInstance = 0x0200, GetField = 0x0400, SetField = 0x0800, GetProperty = 0x1000, SetProperty = 0x2000, // These flags are also used by InvokeMember but they should only // be used when calling InvokeMember on a COM object. PutDispProperty = 0x4000, PutRefDispProperty = 0x8000, ExactBinding = 0x010000, // Bind with Exact Type matching, No Change type SuppressChangeType = 0x020000, // DefaultValueBinding will return the set of methods having ArgCount or // more parameters. This is used for default values, etc. OptionalParamBinding = 0x040000, // These are a couple of misc attributes used IgnoreReturn = 0x01000000, // This is used in COM Interop DoNotWrapExceptions = 0x02000000, // Disables wrapping exceptions in TargetInvocationException}参考资料 BindingFlags.cs RuntimeReflectionExtensions.cs" }, { "title": "如何使用 MyGet 这个激进的 NuGet 源体验日构建版本的 .NET Standard / .NET Core", "url": "/post/develop-with-very-early-framework-version-using-myget.html", "categories": "", "tags": "dotnet, csharp, visualstudio, msbuild, nuget", "date": "2019-03-10 16:57:26 +0800", "snippet": "很多库都会在 nuget.org 上发布预览版本，不过一般来说这个预览版本也是大多可用的。然而想要体验日构建版本，这个就没有了，毕竟要照顾绝大多数开发者嘛……本文介绍如何使用 MyGet 这个激进的 NuGet 源，介绍如何使用框架级别的库的预览版本如 .NET Standard 的预览版本。加入 MyGet 这个 NuGet 源添加 NuGet 源的方法在我和林德熙的博客中都有说明： 全局或为单独的项目添加自定义的 NuGet 源 - 吕毅 VisualStudio 给项目添加特殊的 Nuget 的链接 - 林德熙简单点，就是在 Visual Studio 中打开 工具 -&amp;gt; 选项 -&amp;gt; NuGet 包管理器 -&amp;gt; 包源：然后把 MyGet 的源添加进去： https://dotnet.myget.org/F/dotnet-core/api/v3/index.json如果你想添加其他的 NuGet 源，可以参见我的另一篇博客：我收集的各种公有 NuGet 源 - 吕毅。使用 .NET Standard 的预览版本因为我们在使用 .NET Standard 库的时候，是直接作为目标框架来选择的，就像下面的项目文件内容一样：&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;TargetFramework&amp;gt;netstandard2.0&amp;lt;/TargetFramework&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;/Project&amp;gt;然而，如果你直接把 TargetFramework 中的值改为预览版本，是无法使用的。因为 TargetFramework 的匹配是按照字符串来匹配的，并不会解析成库和版本号。关于这一点可以如何得知的，可以参考我的另一篇博客（中英双语）： 解读 Microsoft.NET.Sdk 的源码，你能定制各种奇怪而富有创意的编译过程 - 吕毅 Reading the Source Code of Microsoft.NET.Sdk, Writing the Creative Extension of Compiling - walterlv然而实际上的使用方法很简单，就是直接用正常的方法安装对应的 NuGet 包：PM&amp;gt; Install-Package NETStandard.Library -Version 2.1.0-preview1-27119-01或者直接去 csproj 中添加 PackageReference。&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;TargetFramework&amp;gt;netstandard2.0&amp;lt;/TargetFramework&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;PackageReference Include=&quot;NETStandard.Library&quot; Version=&quot;2.1.0-preview1-27119-01&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;/Project&amp;gt;至于版本号如何确定，请直接前往 MyGet 网站查看：dotnet-core - NETStandard.Library - MyGet。这个时候，.NET Standard 的预览版标准库会使用以替换 .NET Standard 2.0 的正式版本库。" }, { "title": "常用输入法快速输入自定义格式的时间和日期（搜狗/QQ/手心/微软拼音）", "url": "/post/ime-date-time-format.html", "categories": "", "tags": "ime, windows", "date": "2019-03-09 15:30:38 +0800", "snippet": "几个主流的输入法输入 rq 或者 sj 都可以得到预定义格式的日期或者时间。然而他们都是预定义的格式；当我们需要一些其他格式的时候该怎么做呢？本文将介绍几个常用输入法自定义时间和日期格式的方法。主流输入法的日期格式一般是这样的：▲ 微软拼音▲ 搜狗拼音▲ QQ 拼音如果自定义，可以是这样：▲ UTC 自定义输出效果像这样：2018-08-26 15:58:05微软拼音输入法微软拼音输入法自定义短语的方法请前往：用微软拼音快速输入自定义格式的时间和日期。具体的自定义字符串是：%yyyy%-%MM%-%dd% %HH%:%mm%:%ss%更多自定义请参阅：自定义日期和时间格式字符串 - Microsoft Docs搜狗拼音输入法搜狗输入法的自定义短语入口在这里：▲ 搜狗输入法自定义短语具体的自定义字符串是：#$year-$month_mm-$day_dd $fullhour:$minute:$second▲ 注意前面的 # 是必须保留的，否则输入法不会将字符串进行转义字符串中的 $month 和 $day 后面跟着 mm 和 dd，这跟微软拼音的思路是类似的，代表具体的格式。 $year 2018 $year_yy 18 $year_cn 二零一八 $year_yy_cn 一八 $month 8 $month_mm 08 $month_cn 八 $day 6 $day_dd 06 $day_cn 六, 二十六 $weekday 0, 1 $weekday_cn 日, 一 $fullhour 15 (24 小时制) $halfhour 3 (12 小时制) $fullhour_cn 十五 $halfhour_cn 三 $ampm AM, PM $ampm_cn 上午, 下午 $minute 44 $minute_cn 四十四 $second 40 $second_cn 四十QQ 拼音输入法QQ 拼音输入法的自定义短语入口在这里：▲ QQ 输入法自定义短语具体的自定义字符串是：$(Year)-$(month)-$(date) $(hour):$(minute):$(second)手心输入法▲ 手心输入法自定义短语手心输入法的自定义字符串是：#$(year)-$(month_mm)-$(day_dd) $(fullhour):$(minute):$(second) +0800注意，前面必须有一个 #，这表示后面的字符串中包含函数，需要计算函数值。如果没有前面的 #，那么输入的所有内容将被视为普通字符串。实际上，你如果将手心输入法默认的自定义短语导出，你就能看到它们对自定义短语的说明还是非常齐全的：;手心输入法自定义短语说明;1、自定义短语可用来快速输入日期、时间、手机号、邮箱、账号、小短文等，可由用户自行添加和修改;2、通过设置添加的自定义短语最多支持1000条，如果有需求，其他的自定义短语可以通过导入个性短语来实现，导入个性短语支持最大50MB和最多一百万条个性短语的文本文件，当文本大小超过50MB不进行导入，当文本中词条数超过一百万条时，只录入前一百万条数据。;3、导入的自定义短语可支持的格式有如下几种：; 1）输入串+英文逗号+数字（指定排序位置）=短语内容; 2）输入串=短语内容（位置默认为第1位）; 3）输入串=数字（指定排序位置）+英文逗号+短语内容; 4）输入串,数字（指定排序位置）=回车; 多行语句1; 多行语句2; 多行语句3;4、支持集合，可用来支持多个字符：; 格式为：输入串=#[]，括号内为想支持的字符集合，如：; dxlm=#[ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫ] 可从第一位开始显示从1到12的罗马数字;5、支持的时间函数：; 格式为：输入串=#+函数或者文字，如：; now=3,#$(YYYY)年$(MM)月$(DD)日 $(hh):$(mm):$(ss); 函数(区分大小写) 说明 例子; $(year) 4位数的年份 2006、2015; $(year_yy) 2位数的年份 06、15; $(month_mm) 2位数的月份 01、09、12; $(month) 不补零的月份 1、9、12; $(day_dd) 2位数的日 01、07、24; $(day) 不补零的日 1、7、24; $(fullhour) 2位数的小时(24小时) 02、09、14; $(halfhour) 2位数的小时(12小时) 02、09; $(ampm) 按当前时间显示AM或者PM AM、PM; $(minute) 2位数的分钟 08、37; $(second) 2位数的秒 01、59; $(year_cn) 4位中文年份 二〇一五、二〇〇八; $(year_yy_cn) 2位中文年份 一五、〇八; $(month_cn) 中文月份 一、九、十一; $(day_cn) 中文日 八、二十四; $(week_cn) 中文星期 星期一、星期三、星期天; $(year_ln) 农历年份 乙未年、甲午年; $(month_ln) 农历月份 正月、五月、腊月、冬月; $(day_ln) 农历日 初一、初七、十三、廿四" }, { "title": "使用一句 git 命令将仓库的改动推送到所有的远端", "url": "/post/git-push-to-all-remotes.html", "categories": "", "tags": "git", "date": "2019-03-09 09:12:32 +0800", "snippet": "git 支持一个本地仓库包含多个远端（remote），这对于开源社区来说是一个很重要的功能，可以实时获取到最新的开源代码且能推送到自己的仓库中提交 pull request。有时候多个远端都是自己的，典型的就是 GitHub Pages 服务了，推送总是希望这几个远端能够始终和本地仓库保持一致。本文将介绍一个命令推送到所有远端的方法。我的博客同时发布在 GitHub 仓库 https://github.com/walterlv/walterlv.github.io 和 Gitee 仓库 http://gitee.com/walterlv/walterlv。由于这两个远端的 Pages 服务没有打通，所以我总是需要同时将博客推送到两个不同的远端中。第一步：设置多个远端（remote）使用你平常使用的方法添加多个 git 远端。例如：git remote add github https://github.com/walterlv/walterlv.github.io.git --no-tags需要注意，对于不是 origin 的远端，建议不要拉取 tags，所以我加了 --no-tags 选项。我添加了两个新的远端（github 和 gitee）之后，打开你仓库 .git 文件夹中的 config 文件，应该可以看到如下的内容：[remote &quot;origin&quot;] url = https://github.com/walterlv/walterlv.github.io.git fetch = +refs/heads/*:refs/remotes/origin/*[branch &quot;master&quot;] remote = origin merge = refs/heads/master[remote &quot;github&quot;] url = https://github.com/walterlv/walterlv.github.io.git fetch = +refs/heads/*:refs/remotes/github/* tagopt = --no-tags[remote &quot;gitee&quot;] url = https://gitee.com/walterlv/walterlv.git fetch = +refs/heads/*:refs/remotes/gitee/* tagopt = --no-tags第二步：添加一个名为 all 的新远端现在，我们要添加一个名为 all 的新远端，并且在里面添加两个 url。由于这个步骤没有 git 命令行的帮助，所以你需要手工修改 config 文件中的内容。[remote &quot;all&quot;] url = https://github.com/walterlv/walterlv.github.io.git url = https://gitee.com/walterlv/walterlv.git tagopt = --no-tags如果你有更多需要同步的远端，那么就在里面添加更多的 url。开始使用一个命令同步所有的仓库现在，你可以使用一句命令将本地的修改推送到所有的远端了。git push all我现在自己的博客仓库就是这样的推送方式。于是你可以在以下多个地址打开阅读我的博客： https://walterlv.com/ https://blog.walterlv.com/ https://walterlv.github.io/ https://walterlv.gitee.io/ https://walterlv.oschina.io/" }, { "title": ".NET/C# 获取一个正在运行的进程的命令行参数", "url": "/post/get-command-line-for-a-running-process.html", "categories": "", "tags": "dotnet, csharp, windows", "date": "2019-03-09 09:12:11 +0800", "snippet": "在自己的进程内部，我们可以通过 Main 函数传入的参数，也可以通过 Environment.GetCommandLineArgs 来获取命令行参数。但是，可以通过什么方式来获取另一个运行着的程序的命令行参数呢？进程内部获取传入参数的方法，可以参见我的另一篇博客：.NET 命令行参数包含应用程序路径吗？。.NET Framework / .NET Core 框架内部是不包含获取其他进程命令行参数的方法的，但是我们可以在任务管理器中看到，说明肯定存在这样的方法。实际上方法是有的，不过这个方法是 Windows 上的专属方法。对于 .NET Framework，需要引用程序集 System.Management；对于 .NET Core 需要引用 Microsoft.Windows.Compatibility 这个针对 Windows 系统准备的兼容包（不过这个兼容包目前还是预览版本）。&amp;lt;ItemGroup Condition=&quot;$(TargetFramework) == &#39;netcoreapp2.1&#39;&quot;&amp;gt; &amp;lt;PackageReference Include=&quot;Microsoft.Windows.Compatibility&quot; Version=&quot;2.1.0-preview.19073.11&quot; /&amp;gt;&amp;lt;/ItemGroup&amp;gt;&amp;lt;ItemGroup Condition=&quot;$(TargetFramework) == &#39;net472&#39;&quot;&amp;gt; &amp;lt;Reference Include=&quot;System.Management&quot; /&amp;gt;&amp;lt;/ItemGroup&amp;gt;然后，我们使用 ManagementObjectSearcher 和 ManagementBaseObject 来获取命令行参数。为了简便，我将其封装成一个扩展方法，其中包括对于一些异常的简单处理。using System;using System.Diagnostics;using System.Linq;using System.Management;namespace Walterlv{ /// &amp;lt;summary&amp;gt; /// 为 &amp;lt;see cref=&quot;Process&quot;/&amp;gt; 类型提供扩展方法。 /// &amp;lt;/summary&amp;gt; public static class ProcessExtensions { /// &amp;lt;summary&amp;gt; /// 获取一个正在运行的进程的命令行参数。 /// 与 &amp;lt;see cref=&quot;Environment.GetCommandLineArgs&quot;/&amp;gt; 一样，使用此方法获取的参数是包含应用程序路径的。 /// 关于 &amp;lt;see cref=&quot;Environment.GetCommandLineArgs&quot;/&amp;gt; 可参见： /// .NET 命令行参数包含应用程序路径吗？https://blog.walterlv.com/post/when-will-the-command-line-args-contain-the-executable-path.html /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;process&quot;&amp;gt;一个正在运行的进程。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;表示应用程序运行命令行参数的字符串。&amp;lt;/returns&amp;gt; public static string GetCommandLineArgs(this Process process) { if (process is null) throw new ArgumentNullException(nameof(process)); try { return GetCommandLineArgsCore(); } catch (Win32Exception ex) when ((uint) ex.ErrorCode == 0x80004005) { // 没有对该进程的安全访问权限。 return string.Empty; } catch (InvalidOperationException) { // 进程已退出。 return string.Empty; } string GetCommandLineArgsCore() { using (var searcher = new ManagementObjectSearcher( &quot;SELECT CommandLine FROM Win32_Process WHERE ProcessId = &quot; + process.Id)) using (var objects = searcher.Get()) { var @object = objects.Cast&amp;lt;ManagementBaseObject&amp;gt;().SingleOrDefault(); return @object?[&quot;CommandLine&quot;]?.ToString() ?? &quot;&quot;; } } } }}使用此方法得到的命令行参数是一个字符串，而不是我们通常使用字符串时的字符串数组。如果你需要将其转换为字符串数组，可以使用我在另一篇博客中使用的方法： .NET/C# 将一个命令行参数字符串转换为命令行参数数组 args参考资料 Can I get command line arguments of other processes from .NET/C#? - Stack Overflow How to get Command Line info for a process in PowerShell or C# - Stack Overflow" }, { "title": "WPF 让普通 CLR 属性支持 XAML 绑定（非依赖属性），这样 MarkupExtension 中定义的属性也能使用绑定了", "url": "/post/add-wpf-xaml-binding-support-for-clr-property.html", "categories": "", "tags": "wpf, dotnet, csharp, xaml", "date": "2019-03-09 09:12:06 +0800", "snippet": "如果你写了一个 MarkupExtension 在 XAML 当中使用，你会发现你在 MarkupExtension 中定时的属性是无法使用 XAML 绑定的，因为 MarkupExtension 不是一个 DependencyObject。本文将给出解决方案，让你能够在任意的类型中写出支持 XAML 绑定的属性；而不一定要依赖对象（DependencyObject）和依赖属性（DependencyProperty）。问题下面是一个很简单的 MarkupExtension，用户设置了什么值，就返回什么值。拿这么简单的类型只是为了避免额外引入复杂的理解难度。public class WalterlvExtension : MarkupExtension{ private object _value; public object Value { get =&amp;gt; _value; set =&amp;gt; _value = value; } public override object ProvideValue(IServiceProvider serviceProvider) { return Value; }}可以在 XAML 中直接赋值：&amp;lt;Button Content=&quot;{local:Walterlv Value=blog.walterlv.com&quot; /&amp;gt;但不能绑定：&amp;lt;TextBox x:Name=&quot;SourceTextBox&quot; Text=&quot;blog.walterlv.com&quot; /&amp;gt;&amp;lt;Button Content=&quot;{local:Walterlv Value={Binding Text, Source={x:Reference SourceTextBox}}}&quot; /&amp;gt;因为运行时会报错，提示绑定必须被设置到依赖对象的依赖属性中。在设计器中也可以看到提示不能绑定。解决实际上这个问题是能够解决的（不过也花了我一些时间思考解决方案）。既然绑定需要一个依赖属性，那么我们就定义一个依赖属性。非依赖对象中不能定义依赖属性，于是我们定义附加属性。// 注意：这一段代码实际上是无效的。public static readonly DependencyProperty ValueProperty = DependencyProperty.RegisterAttached( &quot;Value&quot;, typeof(object), typeof(WalterlvExtension), new PropertyMetadata(default(object)));public object Value{ get =&amp;gt; ???.GetValue(ValueProperty); set =&amp;gt; ???.SetValue(ValueProperty, value);}这里问题来了，获取和设置附加属性是需要一个依赖对象的，那么我们哪里去找依赖对象呢？直接定义一个新的就好了。于是我们定义一个新的依赖对象：// 注意：这一段代码实际上是无效的。public static readonly DependencyProperty ValueProperty = DependencyProperty.RegisterAttached( &quot;Value&quot;, typeof(object), typeof(WalterlvExtension), new PropertyMetadata(default(object)));public object Value{ get =&amp;gt; _dependencyObject.GetValue(ValueProperty); set =&amp;gt; _dependencyObject.SetValue(ValueProperty, value);}private readonly DependencyObject _dependencyObject = new DependencyObject();现在虽然可以编译通过，但是我们会遇到两个问题： ValueProperty 的变更通知的回调函数中，我们只能找到 _dependencyObject 的实例，而无法找到外面的类型 WalterlvExtension 的实例；这几乎使得 Value 的变更通知完全失效。 在 Value 的 set 方法中得到的 value 值是一个 Binding 对象，而不是正常依赖属性中得到的绑定的结果；这意味着我们无法直接使用 Value 的值。为了解决这两个问题，我必须自己写一个代理的依赖对象，用于帮助做属性的变更通知，以及处理绑定产生的 Binding 对象。在正常的依赖对象和依赖属性中，这些本来都不需要我们自己来处理。方案于是我写了一个代理的依赖对象，我把它命名为 ClrBindingExchanger，意思是将 CLR 属性和依赖属性的绑定进行交换。代码如下：public class ClrBindingExchanger : DependencyObject{ private readonly object _owner; private readonly DependencyProperty _attachedProperty; private readonly Action&amp;lt;object, object&amp;gt; _valueChangeCallback; public ClrBindingExchanger(object owner, DependencyProperty attachedProperty, Action&amp;lt;object, object&amp;gt; valueChangeCallback = null) { _owner = owner; _attachedProperty = attachedProperty; _valueChangeCallback = valueChangeCallback; } public object GetValue() { return GetValue(_attachedProperty); } public void SetValue(object value) { if (value is Binding binding) { BindingOperations.SetBinding(this, _attachedProperty, binding); } else { SetValue(_attachedProperty, value); } } public static void ValueChangeCallback(DependencyObject d, DependencyPropertyChangedEventArgs e) { ((ClrBindingExchanger) d)._valueChangeCallback?.Invoke(e.OldValue, e.NewValue); }}这段代码的意思是这样的： 构造函数中的 owner 参数完全没有用，我只是拿来备用，你可以删掉。 构造函数中的 attachedProperty 参数是需要定义的附加属性。 因为前面我们说过，有一个附加属性才可以编译通过，所以附加属性是一定要定义的 既然一定要定义附加属性，那么就可以用起来，接下来会用 构造函数中的 valueChangeCallback 参数是为了指定变更通知的，因为前面我们说变更通知不好做，于是就这样代理做变更通知。 GetValue 和 SetValue 这两个方法是用来代替 DependencyObject 自带的 GetValue 和 SetValue 的，目的是执行我们希望特别执行的方法。 SetValue 中我们需要自己考虑绑定对象，如果发现是绑定，那么就真的进行一次绑定。 ValueChangeCallback 是给附加属性用的，因为用我的这种方法定义附加属性时，只能写出相同的代码，所以干脆就提取出来。而用法是这样的：public class WalterlvExtension : MarkupExtension{ public WalterlvExtension() { _valueExchanger = new ClrBindingExchanger(this, ValueProperty, OnValueChanged); } private readonly ClrBindingExchanger _valueExchanger; public static readonly DependencyProperty ValueProperty = DependencyProperty.RegisterAttached( &quot;Value&quot;, typeof(object), typeof(WalterlvExtension), new PropertyMetadata(null, ClrBindingExchanger.ValueChangeCallback)); public object Value { get =&amp;gt; _valueExchanger.GetValue(); set =&amp;gt; _valueExchanger.SetValue(value); } private void OnValueChanged(object oldValue, object newValue) { // 在这里可以处理 Value 属性值改变的变更通知。 } public override object ProvideValue(IServiceProvider serviceProvider) { return Value; }}对于一个属性来说，代码确实多了些，这实在是让人难受。可是，这可以达成目的呀！解释一下： 定义一个 _valueExchanger，就是在使用我们刚刚写的那个新类。 在构造函数中对 _valueExchanger 进行初始化，因为要传入 this 和一个实例方法 OnValueChanged，所以只能在构造函数中初始化。 定义一个附加属性（前面我们说了，一定要有依赖属性才可以编译通过哦）。 注意属性的变更通知方法，需要固定写成 ClrBindingExchanger.ValueChangeCallback 定义普通的 CLR 属性 Value GetValue 方法要换成我们自定义的 GetValue 哦 SetValue 方法也要换成我们自定义的 SetValue 哦，这样绑定才可以生效 OnValueChanged 就是我们实际的变更通知，这里得到的 oldValue 和 newValue 就是你期望的值，而不是我面前面奇怪的绑定实例。于是，绑定就这么在一个普通的类型和一个普通的 CLR 属性中生效了，而且还获得了变更通知。参考资料本文没有任何参考资料，所有方法都是我（walterlv）的原创方法，因为真的找不到资料呀！不过在找资料的过程中发现了一些没解决的文档或帖子： How to use CLR property as binding target? CLR Object Binding In WPF wpf - MarkupExtension with binding parameters - Stack Overflow c# - Binding to dependency and regular properties in WPF - Stack Overflow c# - XAML bind to DependencyProperty instance held in a CLR property - Stack Overflow Tore Senneseth’s blog » Custom Markup Extension with bindable properties Markup Extensions for XAML Overview - Microsoft Docs Service Contexts Available to Type Converters and Markup Extensions - Microsoft Docs" }, { "title": "在 Snoop 中使用 PowerShell 脚本进行更高级的 UI 调试", "url": "/post/powershell-of-snoop.html", "categories": "", "tags": "wpf, dotnet, powershell", "date": "2019-03-09 09:11:47 +0800", "snippet": "在 WPF 开发时，有 Snoop 的帮助，UI 的调试将变得非常轻松。使用 Snoop，能轻松地查看 WPF 中控件的可视化树以及每一个 Visual 节点的各种属性，或者查看数据上下文，或者监听查看事件的引发。不过，更强大的是支持使用 PowerShell 脚本。这使得它即便 UI 没有给你提供一些入口，你也能通过各种方式查看或者修改 UI。Snoop PowerShell 入口常规 Snoop 的使用方法，将狮子瞄准镜拖出来对准要调试 UI 的 WPF 窗口松开。这里我拿 Visual Studio 2019 的窗口做试验。在打开的新的 Snoop 窗口中我们打开 PowerShell 标签。本文的内容将从这里开始。自带的 PowerShell 变量在 Snoop 的 PowerShell 提示窗口中，我们可以得知有两个变量可以使用：$root 和 $selected。包含这两个，还有其他的可以使用： $root 拿到当前 Snoop 窗口顶层元素类型的实例 $selected 拿到当前 Snoop 用鼠标或键盘选中的元素的实例 $parent 拿到当前 Snoop 选中元素的可视化树父级 $null 就是 .NET 中的 null当然，你也可以定义和使用其他的变量，后面会说。基本的 PowerShell 命令属性# 获取属性$selected.Visual.Content# 将属性设置为 null$selected.Visual.Content = $null直接像 C# 语法那样一直在后面使用 . 可以访问实例中的属性。不需要关心实例是什么类型的，只要拥有那个属性，就可以访问到。比如下面，上面的例子我们选中的是 MainWindow，于是我们使用 $selected.Visual.Content 访问到 MainWindow 的 Content 属性，而后面 $selected.Visual.Content = $null 则是将 Window 的内容清空了。创建对象# 创建对象$button = New-Object System.Windows.Controls.Button -property @{ Content = &quot;欢迎访问 blog.walterlv.com&quot; }调用方法$selected.Visual.Children.Add($button)顶部的那个按钮就是通过上面的命令添加上去的。调用静态方法用的是 [类名]::方法名(参数)$button.Content = [System.Environment]::Version.ToString() + &quot; running for blog.walterlv.com&quot;参考资料 Snooping WPF: Tips and PowerShell tricks" }, { "title": "四种方法获取可执行程序的文件路径（.NET Core / .NET Framework）", "url": "/post/get-current-executable-file-path.html", "categories": "", "tags": "dotnet, csharp", "date": "2019-03-09 09:10:45 +0800", "snippet": "本文介绍四种不同的获取可执行程序文件路径的方法。适用于 .NET Core 以及 .NET Framework。使用程序集信息获取var executablePath = Assembly.GetEntryAssembly().Location;这种方式的思路是获取入口程序集所在的路径。不过 Assembly.GetEntryAssembly() 能获取到的程序集是入口托管程序集；使用此方法会返回第一个托管程序集。只有 .NET Framework 程序的入口才是托管程序（exe）。而对于 .NET Core 程序，如果直接发布成带环境依赖声明的 dll，那么实际运行的进程是 dotnet.exe；而如果发布成自包含的 exe 程序，其主 exe 也是一个非托管的 CLR 启动器而已，并不是托管程序集。所以此方法适用条件： 必须是 .NET Framework 程序（.NET Core 程序不适用）使用应用程序域信息获取var executablePath = AppDomain.CurrentDomain.SetupInformation.ApplicationBase;这种方式的思路是获取当前 AppDomain 所在的文件夹。不过此方法也只是获取到文件夹而已，不包含文件名。所以此方法适用条件： 你不需要知道文件名，只是要一个程序所在的文件夹而已。当然，此方法因为不涉及到托管和非托管程序集，所以与编译结果无关，适用于 .NET Core 和 .NET Framework 程序。使用进程信息获取var executablePath = Process.GetCurrentProcess().MainModule.FileName;这种方式的思路是获取当前进程可执行程序的完全路径。对于 .NET Framework 程序，其 exe 就是这个路径。对于 .NET Core 程序来说： 如果发布成带环境依赖声明的 dll，那么此方法获取到的可执行程序名将是 dotnet.exe，这显然不会是我们预期的行为； 如果发布成自包含的 exe，那么此方法获取到的可执行程序名就是程序自己的名称，这是期望的结果。所以此方法适用条件： 适用于 .NET Framework 程序； 适用于发布成自包含的 .NET Core 程序。使用命令行参数获取我在另一篇博客中提到命令行参数中包含应用程序路径： .NET 命令行参数包含应用程序路径吗？ - 吕毅于是我们也可以通过命令行参数来获取到可执行程序的路径。var executablePath = Environment.GetCommandLineArgs()[0];这种方法的效果和前面使用进程信息获取的效果是相同的，会获取到相同的可执行程序路径。总结靠谱的方法通过以上方法的说明，我们可以知道目前没有 100% 可靠的获取当前可执行程序文件路径的方法，不过可以组合多种方法达到 100% 可靠的目的。 如果我们只需要获取程序所在的文件夹 那么请直接使用 AppDomain.CurrentDomain.SetupInformation.ApplicationBase 如果我们需要获取到可执行程序的完整路径 先通过进程或者命令行参数的方式获取 Process.GetCurrentProcess().MainModule.FileName Environment.GetCommandLineArgs()[0] 如果得到的进程是 dotnet.exe，那么再通过程序集信息获取 Assembly.GetEntryAssembly().Location 另外，关于以上方法的性能对比，你可以参阅林德熙的博客：dotnet 获取路径各种方法的性能对比。" }, { "title": "UWP 在 WebView 中执行 JavaScript 代码（用于模拟用户输入等）", "url": "/post/invoke-web-script-in-webview.html", "categories": "", "tags": "uwp, javascript", "date": "2019-03-09 09:10:11 +0800", "snippet": "UWP 中使用 WebView 时可以在网页中额外执行一些代码。于是你几乎可以在网页上做任何事情，那些你可以在浏览器控制台中做的事情。本文将介绍做法。准备环境在页面（XAML）中放一个 WebView，然后取个名字，比如就叫做 WebView。监听 NavigationCompleted 事件，然后导航到需要操作的页面。WebView.NavigationCompleted += OnNavigationCompleted;WebView.Navigate(new Uri(&quot;https://blog.walterlv.com&quot;));private async void OnNavigationCompleted(WebView sender, WebViewNavigationCompletedEventArgs e){ // 我们接下来的代码都将在这里编写。}要执行 JavaScript 代码，必须要导航完成才行，所以我们接下来的代码都是写在 NavigationCompleted 事件处理函数中的。执行 JavaScript 代码模拟用户输入下面这一句的代码是填充用户 Id 一栏：await WebView.InvokeScriptAsync(&quot;eval&quot;, new[]{ &quot;document.getElementById(&#39;userId&#39;).value = &#39;walterlv&#39;;&quot;});登录页面截图来自于 码友网。JavaScript eval(string) 函数在上面的代码中，eval 是指执行 JavaScript 的 eval 函数，并且将后面的字符串数组作为它的参数传入。在 JavaScript 中，eval(string) 函数可计算某个字符串，并执行其中的的 JavaScript 代码。在计算结束后，会返回一个字符串，就是参数中那个字符串执行完之后的返回值（如果有的话）。于是意味着你可以通过这种方式拿到输入框中的值：var userId = await WebView.InvokeScriptAsync(&quot;eval&quot;, new[]{ &quot;document.getElementById(&#39;userId&#39;).value;&quot;});执行完后，可以得到 userId 的值是 walterlv 字符串；也就是我们上一步填充的那个值。模拟用户登录完整的输入用户名、密码，并点击登录按钮的代码则是这样的：await LoginWebView.InvokeScriptAsync(&quot;eval&quot;, new[]{ &quot;document.getElementById(&#39;userId&#39;).value = &#39;walterlv&#39;;&quot;});await LoginWebView.InvokeScriptAsync(&quot;eval&quot;, new[]{ &quot;document.getElementById(&#39;password&#39;).value = &#39;不想让你看见的密码&#39;;&quot;});await Task.Delay(1000);await LoginWebView.InvokeScriptAsync(&quot;eval&quot;, new[]{ &quot;document.getElementById(&#39;submit&#39;).click();&quot;});参考资料 JavaScript eval() 函数 win10 uwp 模拟网页输入" }, { "title": "在 Visual Studio Code 中为代码片段（Code Snippets）添加快捷键", "url": "/post/key-binding-to-snippets-for-vscode.html", "categories": "", "tags": "vscode", "date": "2019-03-09 09:10:05 +0800", "snippet": "Visual Studio Code 默认是关闭了 Markdown 的智能感知提示的（因为真的是不好用，尤其是其没有中文分词的情况下）。那么在没有智能感知提示的情况下如何快速插入代码片段呢？可以使用快捷键！本文介绍如何为代码片段绑定快捷键。代码片段本没有快捷键相关的字段可供设置的，不过在快捷键设置中可以添加代码片段相关的设置。首先，在 Visual Studio Code 中打开快捷键设置：选择手工编辑快捷键配置文件：在配置文件中添加这些代码即可关联一个代码片段：[ { &quot;key&quot;: &quot;alt+p&quot;, &quot;command&quot;: &quot;editor.action.insertSnippet&quot;, &quot;when&quot;: &quot;editorTextFocus&quot;, &quot;args&quot;: { &quot;langId&quot;: &quot;markdown&quot;, &quot;name&quot;: &quot;Insert a post for blog.walterlv.com&quot; } }]在这个配置中，alt+p 是我指定的快捷键，editor.action.insertSnippet 表示执行命令插入代码片段，生效条件为 editorTextFocus 及文本编辑器获得焦点的期间。args 字段指定了两个值，作为对一个现有代码片段的引用。langId 是生效的语言 Id，name 是代码片段的名称。这个名称是我在 在 Visual Studio Code 中添加自定义的代码片段 中做的代码片段的名称。保存，现在按下 alt+p 后就会插入指定的代码片段了。事实上，args 也可以不是引用，而直接是代码片段的内容：[ { &quot;key&quot;: &quot;alt+p&quot;, &quot;command&quot;: &quot;editor.action.insertSnippet&quot;, &quot;when&quot;: &quot;editorTextFocus&quot;, &quot;args&quot;: { &quot;snippet&quot;: &quot;@[TOC](walterlv 的博客目录)&quot; } }]这样，也不需要事先定义代码片段了。额外提及以下，Visual Studio Code 快捷键只能设置全局的而不能设置仅工作区生效，详情请看 load keybindings.json from .vscode dir if there is any ? · Issue #10708 · Microsoft/vscode。参考资料 Creating your own snippets in Visual Studio Code load keybindings.json from .vscode dir if there is any ? · Issue #10708 · Microsoft/vscode" }, { "title": "WindowsXamlHost：在 WPF 中使用 UWP 控件库中的控件", "url": "/post/use-uwp-control-library-in-wpf.html", "categories": "", "tags": "uwp, wpf, dotnet", "date": "2019-03-09 09:09:25 +0800", "snippet": "在 WindowsXamlHost：在 WPF 中使用 UWP 的控件（Windows Community Toolkit） 一文中，我们说到了在 WPF 中引入简单的 UWP 控件以及相关的注意事项。不过，通常更有实际价值的是更复杂的 UWP 控件的引入，通常是一整个 Page。本文将介绍如何在 WPF 项目中引用 UWP 的控件库。创建一个 UWP 控件库建议专门为你复杂的 UWP 控件创建一个 UWP 控件库。在这个控件库中的开发就像普通 UWP 应用一样。这样比较容易创建出更复杂的 UWP 控件出来，而不会与 WPF 项目产生太多的影响。▲ 创建一个 UWP 控件库▲ 选择 SDK 版本对 WPF 项目的准备工作你依然需要阅读 WindowsXamlHost：在 WPF 中使用 UWP 的控件（Windows Community Toolkit） 一文，以便将你的 WPF 项目改造成可以访问 UWP 类型的项目。不方便的引入方式你如果直接让 WPF 项目添加 UWP 项目的引用，将会得到一个错误提示：也就是说并不能直接完成这样的引用。也许将来 WPF 项目格式更新或者 Visual Studio 的更新能为我们带来这样更直接此引用方式。不过现在来看，还不能如此方便地使用。编辑 UWP 项目文件是的，你需要手工编写 UWP 的项目文件。如果你阅读过 (1/2) 为了理解 UWP 的启动流程，我从零开始创建了一个 UWP 程序 这篇文章，或者已经 理解了 C# 项目 csproj 文件格式的本质和编译流程，那么对这里 csproj 文件的编辑应该不会感觉到陌生或者害怕。当然，即便你没有编辑过或者不理解 csproj 也不用担心，你只需要按照本文要求进行操作即可。现在，右击卸载项目，再右击编辑项目文件：▲ 编辑项目文件找到 Import targets 的哪一行，你需要在那一行前面的任意位置添加以下特别标注为新增的几行：++ &amp;lt;PropertyGroup&amp;gt;++ &amp;lt;EnableTypeInfoReflection&amp;gt;false&amp;lt;/EnableTypeInfoReflection&amp;gt;++ &amp;lt;EnableXBindDiagnostics&amp;gt;false&amp;lt;/EnableXBindDiagnostics&amp;gt;++ &amp;lt;/PropertyGroup&amp;gt; &amp;lt;Import Project=&quot;$(MSBuildExtensionsPath)\\Microsoft\\WindowsXaml\\v$(VisualStudioVersion)\\Microsoft.Windows.UI.Xaml.CSharp.targets&quot; /&amp;gt;随后，还要在以上 targets 之后再添加以下代码：&amp;lt;PropertyGroup&amp;gt; &amp;lt;!-- 这里需要填写你的 WPF 项目的路径 --&amp;gt; &amp;lt;HostFrameworkProjectFolder&amp;gt;$(ProjectDir)..\\Whitman.Wpf&amp;lt;/HostFrameworkProjectFolder&amp;gt; &amp;lt;ObjPath&amp;gt;obj\\$(Platform)\\$(Configuration)\\&amp;lt;/ObjPath&amp;gt;&amp;lt;/PropertyGroup&amp;gt;&amp;lt;PropertyGroup Condition=&quot; &#39;$(Platform)&#39; == &#39;AnyCPU&#39; &quot;&amp;gt; &amp;lt;ObjPath&amp;gt;obj\\$(Configuration)\\&amp;lt;/ObjPath&amp;gt;&amp;lt;/PropertyGroup&amp;gt;&amp;lt;PropertyGroup&amp;gt; &amp;lt;!-- 把此项目的输出文件都拷贝到 WPF 项目的生成路径下 --&amp;gt; &amp;lt;PostBuildEvent&amp;gt; md $(HostFrameworkProjectFolder)\\$(ProjectName) md $(HostFrameworkProjectFolder)\\bin\\$(Configuration)\\$(ProjectName) copy $(TargetDir)*.xbf $(HostFrameworkProjectFolder)\\bin\\$(Configuration)\\$(ProjectName) copy $(ProjectDir)*.xaml $(HostFrameworkProjectFolder)\\bin\\$(Configuration)\\$(ProjectName) copy $(ProjectDir)*.xaml.cs $(HostFrameworkProjectFolder)\\$(ProjectName) copy $(ProjectDir)$(ObjPath)*.g.* $(HostFrameworkProjectFolder)\\$(ProjectName) &amp;lt;/PostBuildEvent&amp;gt;&amp;lt;/PropertyGroup&amp;gt;需要注意： 一定要在 targets 之后添加这些代码，因为 $(TargetDir)、$(ProjectName) 等属性是在那里的 targets 执行完后才生成的。 你的 UWP 项目中需要有 xaml，比如可以添加一个 MainPage.xaml 和 MainPage.xaml.cs，不然编译的时候可能会出现错误。重新加载项目并编译现在，重新加载那个 UWP 控件库，将其编译，以便将 UWP 项目的生成文件复制到 WPF 目录下。▲ 生成的文件已复制到 WPF 目录下在 WPF 项目中间接引用 UWP 控件库现在，在 WPF 项目中开启所有文件夹的显示，然后将 UWP 项目中生成的文件添加到 WPF 项目中：▲ 在 WPF 的项目中添加 UWP 的控件库为了能够在每次编译 WPF 项目的时候确保 UWP 项目先编译，需要为 WPF 项目设置项目依赖。在依赖对话框中将 UWP 项目设为依赖。▲ 添加项目依赖现在，编译 WPF 项目的时候，会将 UWP 项目编译后的源码也一起编译到 WPF 项目中；相当于间接使用了 UWP 的控件库。特别的，如果你的项目被 git 进行版本管理，你可能需要忽略 UWP 控件库项目中的文件。方法是在 WPF 项目内生成的 UWP 文件夹下添加一个 .gitignore 文件，填写所有内容忽略：*.*但记得需要额外通过 git add ./Whitman.Wpf/Whitman.Uwp/.gitignore 把这个文件添加到版本管理中，不然其他人不会生效。在 WPF 项目中使用 UWP 控件库中的控件这时，在 WindowsXamlHost 中就可以添加 UWP 控件库中的 MainPage 了。&amp;lt;XamlHost:WindowsXamlHost InitialTypeName=&quot;Walterlv.Whitman.Universal.MainPage&quot; /&amp;gt;于是，你可以在局部获得 UWP 完整 Page 的支持。或者你整个界面都是用 UWP 开发都没问题，并且还能获得 .NET Framework 的完全访问支持。（当然，未来一定是 .NET Core。）▲ 运行后的效果可以使用 UWP 的 Page，并且也能弹出 UWP 的 MessageDialog。而 MainPage 就是普通的 UWP MainPage：&amp;lt;Page x:Class=&quot;Walterlv.Whitman.Universal.MainPage&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:local=&quot;using:Walterlv.Whitman.Universal&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; mc:Ignorable=&quot;d&quot; Background=&quot;{ThemeResource ApplicationPageBackgroundThemeBrush}&quot;&amp;gt; &amp;lt;StackPanel Width=&quot;400&quot; VerticalAlignment=&quot;Center&quot;&amp;gt; &amp;lt;TextBlock&amp;gt; &amp;lt;Run Text=&quot;欢迎访问 吕毅的博客&quot; /&amp;gt; &amp;lt;LineBreak /&amp;gt; &amp;lt;Run Text=&quot;https://blog.walterlv.com&quot; /&amp;gt; &amp;lt;/TextBlock&amp;gt; &amp;lt;Button Content=&quot;Click&quot; Click=&quot;DemoButton_Click&quot; /&amp;gt; &amp;lt;/StackPanel&amp;gt;&amp;lt;/Page&amp;gt;using System;using Windows.UI.Popups;using Windows.UI.Xaml;using Windows.UI.Xaml.Controls;namespace Walterlv.Whitman.Universal{ public sealed partial class MainPage : Page { public MainPage() =&amp;gt; InitializeComponent(); private async void DemoButton_Click(object sender, RoutedEventArgs e) { var button = (Button) sender; await new MessageDialog(&quot;UWP 的消息框，在 WPF 的窗口中。&quot;, &quot;walterlv&quot;).ShowAsync(); } }}参考资料 WindowsXAMLHost control - Windows Community Toolkit - Microsoft Docs Enhance your desktop application for Windows 10 - UWP app developer - Microsoft Docs" }, { "title": ".NET 中创建支持集合初始化器的类型", "url": "/post/create-class-that-supports-collection-initializer.html", "categories": "", "tags": "dotnet", "date": "2019-03-09 09:09:21 +0800", "snippet": "对象初始化器和集合初始化器只是语法糖，但是能让你的代码看起来更加清晰。至少能让对象初始化的代码和其他业务执行的代码分开，可读性会好一些。本文将编写一个类型，可以使用集合初始化器构造这个类型。不只是添加元素的集合初始化器，还有带索引的集合初始化器。稍微提一下对象初始化器很普通的类型就可以支持对象初始化器，只需要对象有可以 set 的属性或者可访问的字段即可。public class Walterlv{ public string Site { get; set; }}初始化时可以使用var walterlv = new Walterlv{ Site = &quot;https://blog.walterlv.com&quot;,};基本上大家编写的类或多或少都会支持对象初始化器，所以本文不会对此谈论更多的内容。通常的集合初始化器当你定义一个集合的时候，你会发现你的类型已经天然支持集合初始化器了。比如你定义了下面这个集合：public class WalterlvCollection : ICollection&amp;lt;Walterlv&amp;gt;{ // 省略集合定义的代码。}那么此集合初始化的代码就可以写成下面这样：var collection = new WalterlvCollection{ new Walterlv(), new Walterlv(),}实际上你会发现实现一个 ICollection 是一件非常繁琐的事情。▲ 实现一个 ICollection 需要实现的方法最简单的集合初始化器只是做一个集合初始化器的话并不需要写上面那么多的代码。实际上，你只需要两个步骤： 实现 IEnumerable 接口或任何子接口 有一个 Add 方法就像这样：public class WalterlvCollection : IEnumerable{ private readonly List&amp;lt;Walterlv&amp;gt; _list = new List&amp;lt;Walterlv&amp;gt;(); public IEnumerator GetEnumerator()=&amp;gt;_list.GetEnumerator(); public void Add(string site) =&amp;gt; _list.Add(new Walterlv { Site = site });}于是你就可以像一个一般的集合那样去使用集合初始化器了：var collection = new WalterlvCollection{ &quot;https://blog.walterlv.com/&quot;, &quot;https://walterlv.blog.csdn.net/&quot;,};多个参数的集合初始化器刚刚我们的例子中 Add 方法只有一个参数，实际上也可以是多个参数。public class WalterlvCollection : IEnumerable{ private readonly List&amp;lt;Walterlv&amp;gt; _list = new List&amp;lt;Walterlv&amp;gt;(); public IEnumerator GetEnumerator()=&amp;gt;_list.GetEnumerator(); public void Add(string site, bool includeProtocol) =&amp;gt; _list.Add(new Walterlv { Site = site });}现在初始化的方法就有点像字典了：var collection = new WalterlvCollection{ { &quot;https://blog.walterlv.com/&quot;, true }, { &quot;https://walterlv.blog.csdn.net/&quot;, true },};当然你也可以写更多参数，看起来更加丧心病狂。public class WalterlvCollection : IEnumerable{ private readonly List&amp;lt;Walterlv&amp;gt; _list = new List&amp;lt;Walterlv&amp;gt;(); public IEnumerator GetEnumerator()=&amp;gt;_list.GetEnumerator(); public void Add(string site, bool includeProtocol, string author) =&amp;gt; _list.Add(new Walterlv { Site = site });}var collection = new WalterlvCollection{ { &quot;https://blog.walterlv.com/&quot;, true, &quot;walterlv&quot; }, { &quot;https://walterlv.blog.csdn.net/&quot;, true, &quot;walterlv&quot; },};带索引集合初始化器如果你期望的初始化方法是索引，实际上也不需要 Add 方法。只需要增加一个索引的定义即可：public class WalterlvCollection : IEnumerable{ private readonly List&amp;lt;Walterlv&amp;gt; _list = new List&amp;lt;Walterlv&amp;gt;(); public IEnumerator GetEnumerator()=&amp;gt;_list.GetEnumerator(); public string this[string site] { get =&amp;gt; _list.Find(x =&amp;gt; x.Site == site).Site; // 请忽略这里的 Bug，这只是一个语法糖的示例。 set =&amp;gt; _list.Add(new Walterlv { Site = value }); }}这时，可以使用索引方式的集合初始化器：var collection = new WalterlvCollection{ [&quot;吕毅&quot;] = &quot;https://blog.walterlv.com/&quot;, [&quot;林德熙&quot;] = &quot;https://blog.lindexi.com/&quot;};这是一个可以发挥创造力的语法糖利用单个和多个参数的集合初始化器，以及带索引的集合初始化器，我们甚至可以用集合初始化器去构造一些看起来不像集合的类型。这又是一波语法糖！当然有一点值得注意，使用集合初始化器初始化的时候，Add 和 this[] 的初始化是不能同时使用的。参考资料事实上微软的官方文档中并没有对集合初始化器的最简实现有多少描述，所以以下的参考实际上并没有用。 英文：Object and Collection Initializers (C# Programming Guide) - Microsoft Docs 中文：对象和集合初始值设定项（C# 编程指南） - Microsoft Docs" }, { "title": "WPF 多线程 UI：设计一个异步加载 UI 的容器", "url": "/post/design-an-async-loading-view.html", "categories": "", "tags": "wpf, dotnet, csharp", "date": "2019-03-09 09:09:12 +0800", "snippet": "对于 WPF 程序，如果你有某一个 UI 控件非常复杂，很有可能会卡住主 UI，给用户软件很卡的感受。但如果此时能有一个加载动画，那么就不会感受到那么卡顿了。UI 的卡住不同于 IO 操作或者密集的 CPU 计算，WPF 中的 UI 卡顿时，我们几乎没有可以让 UI 响应的方式，因为 WPF 一个窗口只有一个 UI 线程。No！WPF 一个窗口可以不止一个 UI 线程，本文将设计一个异步加载 UI 的容器，可以在主线程完全卡死的情况下显示一个加载动画。本文是对我另一篇博客 WPF 同一窗口内的多线程 UI（VisualTarget） 的一项应用。阅读本文，你将得到一个 UI 控件 AsyncBox，放入其中的控件即便卡住主线程，也依然会有一个加载动画缓解用户的焦虑情绪。异步加载的效果预览下图的黑屏部分是正在加载一个布局需要花 500ms 的按钮。我们可以看到，即便是主线程被占用了 500ms，依然能有一个加载动画缓解用户的等待焦虑。▲ 异步加载效果预览使用我写的 WPF 异步加载控件 AsyncBox控件的名字为 AsyncBox，意为异步加载显示 UI 的容器。如果要使用它，可以很简单地写出以下代码：&amp;lt;ww:AsyncBox LoadingViewType=&quot;demo:LoadingView&quot;&amp;gt; &amp;lt;demo:LongTimeView /&amp;gt;&amp;lt;/ww:AsyncBox&amp;gt;其中，LoadingView 是在指定用哪一个控件来做加载动画。由于这个控件会在后台线程创建并执行，为了避免意外的线程问题，这里传入类型，而不是实例。LongTimeView 是一个用来模拟耗时 UI 的模拟控件。如果要看整个窗口，则是下面这样：&amp;lt;Window x:Class=&quot;Walterlv.Demo.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:local=&quot;clr-namespace:Walterlv.Demo&quot; xmlns:ww=&quot;clr-namespace:Walterlv.Windows;assembly=Walterlv.Windows&quot; xmlns:demo=&quot;clr-namespace:Walterlv.Demo&quot; Title=&quot;blog.walterlv.com&quot; Height=&quot;450&quot; Width=&quot;800&quot; Background=&quot;Black&quot;&amp;gt; &amp;lt;Grid&amp;gt; &amp;lt;ww:AsyncBox LoadingViewType=&quot;demo:LoadingView&quot;&amp;gt; &amp;lt;demo:LongTimeView /&amp;gt; &amp;lt;/ww:AsyncBox&amp;gt; &amp;lt;/Grid&amp;gt;&amp;lt;/Window&amp;gt;LongTimeView 则是这样：&amp;lt;UserControl x:Class=&quot;Walterlv.Demo.LongTimeView&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:local=&quot;clr-namespace:Walterlv.Demo&quot; mc:Ignorable=&quot;d&quot; d:DesignHeight=&quot;450&quot; d:DesignWidth=&quot;800&quot; FontSize=&quot;48&quot; FontFamily=&quot;Monaco&quot;&amp;gt; &amp;lt;Grid&amp;gt; &amp;lt;Button Content=&quot;blog.walterlv.com&quot; Click=&quot;DelayButton_Click&quot; /&amp;gt; &amp;lt;/Grid&amp;gt;&amp;lt;/UserControl&amp;gt;using System.Threading;using System.Windows;using System.Windows.Controls;namespace Walterlv.Demo{ public partial class LongTimeView : UserControl { public LongTimeView() { InitializeComponent(); } protected override Size MeasureOverride(Size constraint) { Thread.Sleep(500); return base.MeasureOverride(constraint); } private void DelayButton_Click(object sender, RoutedEventArgs e) { Thread.Sleep(3000); } }}而 LoadingView 则很简单，只是一个无限旋转的动画而已。同时它还没有后台代码：▲ LoadingView 的动画效果&amp;lt;UserControl x:Class=&quot;Walterlv.Demo.LoadingView&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:local=&quot;clr-namespace:Walterlv.Demo&quot; mc:Ignorable=&quot;d&quot; d:DesignHeight=&quot;450&quot; d:DesignWidth=&quot;800&quot;&amp;gt; &amp;lt;FrameworkElement.Resources&amp;gt; &amp;lt;Storyboard x:Key=&quot;Storyboard.Loading&quot;&amp;gt; &amp;lt;DoubleAnimation Storyboard.TargetName=&quot;Target&quot; Storyboard.TargetProperty=&quot;(UIElement.RenderTransform).(RotateTransform.Angle)&quot; From=&quot;0&quot; To=&quot;1440&quot; Duration=&quot;0:0:1.5&quot; RepeatBehavior=&quot;Forever&quot;&amp;gt; &amp;lt;/DoubleAnimation&amp;gt; &amp;lt;/Storyboard&amp;gt; &amp;lt;/FrameworkElement.Resources&amp;gt; &amp;lt;Grid&amp;gt; &amp;lt;Ellipse x:Name=&quot;Target&quot; Width=&quot;48&quot; Height=&quot;48&quot; Stroke=&quot;White&quot; StrokeThickness=&quot;8&quot; StrokeDashArray=&quot;10&quot; StrokeDashCap=&quot;Round&quot; RenderTransformOrigin=&quot;0.5 0.5&quot;&amp;gt; &amp;lt;Ellipse.RenderTransform&amp;gt; &amp;lt;RotateTransform /&amp;gt; &amp;lt;/Ellipse.RenderTransform&amp;gt; &amp;lt;Ellipse.Triggers&amp;gt; &amp;lt;EventTrigger RoutedEvent=&quot;FrameworkElement.Loaded&quot;&amp;gt; &amp;lt;BeginStoryboard Storyboard=&quot;{StaticResource Storyboard.Loading}&quot; /&amp;gt; &amp;lt;/EventTrigger&amp;gt; &amp;lt;/Ellipse.Triggers&amp;gt; &amp;lt;/Ellipse&amp;gt; &amp;lt;/Grid&amp;gt;&amp;lt;/UserControl&amp;gt;现在，我们来实现这个异步加载 UI 的容器你需要为你的项目添加以下文件：其中，1、2、3、4、6 这几个文件可分别从以下链接找到并下载到你的项目中： Annotations.cs AwaiterInterfaces.cs DispatcherAsyncOperation.cs UIDispatcher.cs VisualTargetPresentationSource.cs这些文件都是通用的异步类型。第 5 个文件 AsyncBox 就是我们要实现的主要类型。实现思路是建一个 PresentationSource（类似于窗口的根 HwndSource），这可以用来承载一个新的可视化树（Visual Tree）。这样，我们就能在一个窗口中显示两个可视化树了。这两个可视化树通过 HostVisual 跨线程连接起来，于是我们能在一个窗口中得到两个不同线程的可视化树。由于这两棵树不在同一个线程中，于是主线程即便卡死，也不影响后台用来播放加载动画的线程。附 AsyncBox 的源码如果你不能在下面看到 AsyncBox 的源码，那么你的网络应该是被屏蔽了，可以访问 AsyncBox.cs - A UI container for async loading. 查看。" }, { "title": "WindowsXamlHost：在 WPF 中使用 UWP 的控件（Windows Community Toolkit）", "url": "/post/use-uwp-controls-in-wpf.html", "categories": "", "tags": "uwp, wpf, dotnet", "date": "2019-03-09 09:09:02 +0800", "snippet": "Windows Community Toolkit 再次更新到 5.0。以前可以在 WPF 中使用有限的 UWP 控件，而现在有了 WindowsXamlHost，则可以使用更多 UWP 原生控件了。关于 Windows Community Toolkit 早期版本的 Xaml Bridge，可以参见： WPF 使用 Edge 浏览器 - 林德熙安装 NuGet 包你需要做的第一步，是在你的 WPF 项目中安装 Microsoft.Toolkit.Wpf.UI.XamlHost。建议直接在 项目的 NuGet 管理器中搜索并安装。配置 WPF 项目能访问 UWP 的类型因为我们即将开始使用到 UWP 中的控件类型，所以需要配置项目能够访问到 Windows Runtime 的类型。▲ 添加引用你需要在你的 WPF 项目中添加以下 6 个引用才能访问 UWP 的类型： C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework.NETCore\\v4.5 引用 System.Runtime.WindowsRuntime 引用 System.Runtime.WindowsRuntime.UI.Xaml 引用 System.Runtime.InteropServices.WindowsRuntime C:\\Program Files (x86)\\Windows Kits\\10\\UnionMetadata\\Facade 引用 Windows.winmd C:\\Program Files (x86)\\Windows Kits\\10\\References 在此目录下选择你的 SDK 版本（如 16299,17763 等） Windows.Foundation.UniversalApiContract 在此目录下选择你的 API 版本（如 4.0.0.0） 引用 Windows.Foundation.UniversalApiContract.winmd Windows.Foundation.FoundationContract 在此目录下选择你的 API 版本（如 3.0.0.0） 引用 Windows.Foundation.FoundationContract.winmd 在你添加完这些引用之后，还需要选中这些引用，右击属性，把所有的 “复制到本地” 选项设置为 “否”。▲ 添加 Windows Runtime 的 .NET Framework 类型引用▲ 添加 Windows.WinMD 的引用▲ 在添加引用时注意选择 SDK 的版本号▲ 添加 Windows.Foundation.UniversalApiContract.winmd▲ 添加 Windows.Foundation.FoundationContract.winmd开始在 WPF 中使用 UWP 的控件你可以像使用普通 WPF 控件一样将 WindowsXamlHost 添加到你的 WPF 界面中： 拖拽到界面设计器中 拖拽到 XAML 代码行中 直接在 XAML 代码中写▲ 添加 WindowsXamlHost 控件接着，指定 InitialTypeName 属性为 UWP 中的控件的名称（带命名空间）。这样，当 WindowsXamlHost 初始化的时候，也会初始化一个 UWP 的控件。这里为了简单，我初始化一个 UWP 的按钮。但必须得为 UWP 的按钮进行一些初始化，所以我监听了 ChangedChanged 事件：&amp;lt;XamlHost:WindowsXamlHost Grid.Column=&quot;1&quot; InitialTypeName=&quot;Windows.UI.Xaml.Controls.Button&quot; ChildChanged=&quot;WindowsXamlHost_ChildChanged&quot; /&amp;gt;private void WindowsXamlHost_ChildChanged(object sender, EventArgs e){ var host = (WindowsXamlHost) sender; var button = (Windows.UI.Xaml.Controls.Button) host.Child; button.Width = 120; button.Height = 40; button.Content = &quot;blog.walterlv.com&quot;; button.Click += UwpButton_Click;}private void UwpButton_Click(object sender, RoutedEventArgs e){}可以忽略的错误在启动的时候，你可能会遇到一些异常。比如下面这个：因为我们不是原生的 UWP，而是 Host 在 WPF 中的 UWP 控件，所以会没有 Application。这在 UWP 控件初始化内部已经 catch 了，所以你可以忽略。最终效果当将程序跑起来之后，你就能看到 WPF 窗口中的 UWP 控件了。值得注意的地方 目前 WindowsXamlHost 还不够稳定，会出现一些闪退 这点就需要为 WindowsCommunityToolkit 贡献 Issues 或代码了 Host 的 UWP 控件是一个新的 HwndSource，这相当于 UWP 的控件是通过子窗口的形式与 WPF 窗口放在一起的 于是，只能指定一个矩形区域完全属于 UWP，在这个区域 WPF 控件无法与其获得交互或渲染叠加 关于 DPI 适配为了让 UWP 控件能够在 WPF 窗口中获得正确的 Per-Monitor 的 DPI 适配效果，你需要设置为 PerMonitorV2 的 DPI 感知级别。在 PerMonitorV2 的 DPI 感知级别下，UWP 控件能够正常获得 DPI 缩放。在 100% DPI 的屏幕下：在 150% DPI 的屏幕下：而如果只是指定为 PerMonitor，那么切换 DPI 或者切换屏幕的时候，只有 WPF 部分会缩放，而 UWP 部分不会变化。关于 PerMonitorV2 和 PerMonitor 的理解和区别，可以参见： Windows 下的高 DPI 应用开发（UWP / WPF / Windows Forms / Win32） - walterlv关于如何在 WPF 下开启 PerMonitorV2 级别的 DPI 感知可以参见： 支持 Windows 10 最新 PerMonitorV2 特性的 WPF 多屏高 DPI 应用开发 - walterlv更复杂的 UWP 控件嵌入如果希望将更多的 WPF 窗口内的 UI 部分交给 UWP 来做，那么就不能只是仅仅初始化一个 Button 就完了。你需要引入一个 UWP 控件库。阅读以下文章了解更多： WindowsXamlHost：在 WPF 中使用 UWP 控件库中的控件 - walterlv参考资料 WindowsXAMLHost control - Windows Community Toolkit - Microsoft Docs Enhance your desktop application for Windows 10 - UWP app developer - Microsoft Docs" }, { "title": "使用并解析 OPML 格式的订阅列表来转移自己的 RSS 订阅（概念篇）", "url": "/post/using-opml-for-rss-migrating.html", "categories": "", "tags": "dotnet, csharp, uwp", "date": "2019-03-09 09:08:10 +0800", "snippet": "OPML 全称是 Outline Processor Markup Language ，即 大纲处理标记语言。目前流行于收集博客的 RSS 源，便于用户转移自己的订阅项目。本文将介绍这个古老的格式，并提供一个 .NET 上的简易解析器。本文分为两个部分，一个是理解 OPML 格式，一个是解析此格式： 概念篇（本文） 解析篇OPML 格式RSS 订阅你应该并不陌生，你可以在我的博客上方看到 RSS 的订阅源按钮，也可以在各大博客站点发现这样的订阅按钮。▲ RSS 图标图片来源于维基百科，如果你不太了解 RSS，可以直接前往 RSS - 维基百科，自由的百科全书 查看或者自己搜索。OPML 是个古老的格式，第一个版本还是二十世纪六十年代的产物呢（详见 OPML 1.0 Specification）；只不过实际在用的 1.0 版本是 2000 年发布的，2.0 版本是 2007 年发布的。这么古老的格式也不妨碍它依然成为订阅源交换的标准格式。不过我们这篇文章不会去谈历史，我们只谈它的格式以及使用。OPML 官网对其作用的描述为： The purpose of this format is to provide a way to exchange information between outliners and Internet services that can be browsed or controlled through an outliner. OPML is also the file format for an outliner application, which is why OPML files may contain information about the size, position and expansion state of the window the outline is displayed in. OPML has also become popular as a format for exchanging subscription lists between feed readers and aggregators.其中最后一行的描述即交换订阅，尤其是 RSS 订阅。典型的 OPML 文件为了直观地了解 OPML 格式，我直接贴一个我的订阅的极简版文件内容。&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;opml version=&quot;1.0&quot;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;walterlv&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;outline text=&quot;walterlv&quot; title=&quot;walterlv&quot; type=&quot;rss&quot; xmlUrl=&quot;https://blog.walterlv.com/feed.xml&quot; htmlUrl=&quot;https://blog.walterlv.com/&quot; /&amp;gt; &amp;lt;outline title=&quot;Team&quot; text=&quot;Team&quot;&amp;gt; &amp;lt;outline text=&quot;林德熙&quot; title=&quot;林德熙&quot; type=&quot;rss&quot; xmlUrl=&quot;https://blog.lindexi.com/feed.xml&quot; htmlUrl=&quot;https://blog.lindexi.com/&quot; /&amp;gt; &amp;lt;/outline&amp;gt; &amp;lt;outline title=&quot;Microsoft&quot; text=&quot;Microsoft&quot;&amp;gt; &amp;lt;outline text=&quot;Microsoft .NET Blog&quot; title=&quot;Microsoft .NET Blog&quot; type=&quot;rss&quot; xmlUrl=&quot;https://blogs.msdn.microsoft.com/dotnet/feed/&quot;/&amp;gt; &amp;lt;outline text=&quot;Microsoft The Visual Studio Blog&quot; title=&quot;Microsoft The Visual Studio Blog&quot; type=&quot;rss&quot; xmlUrl=&quot;https://blogs.msdn.microsoft.com/visualstudio/feed/&quot;/&amp;gt; &amp;lt;/outline&amp;gt; &amp;lt;/body&amp;gt;&amp;lt;/opml&amp;gt;你可以很容易地看出它的一些特征。比如以 opml 为根，head 中包含 title，body 中包含分组的 outline。每一个 outline 中包含 text, type, xmlUrl 等属性。接下来我们详细描述这个格式。OPML 文件中的节点解释opml 根节点&amp;lt;opml&amp;gt; 是 OPML 格式文件的根节点，其 version 属性是必要的。它的值可能为 1.0 或 2.0；如果是 1.0，则视为符合 OPML 1.0 规范；如果是 2.0，则视为符合 OPML 2.0 规范。额外的，值也可能是 1.1，那么也视为符合 1.0 规范。opml 根节点中包含 head 和 body 节点。head 节点head 节点可包含 0 个或多个元素： title 这就是 OPML 文档标题 dateCreated 文档创建时间 dateModified 文档修改时间 ownerName 文档作者 ownerEmail 文档作者的邮箱 ownerId 文档作者的 url，要求不存在相同 Id 的两个作者 docs 描述此文档的文档的 url 当然，这些都是可选的。额外的，还有 expansionState, vertScrollState, windowTop, windowLeft, windowBottom, windowRight。body 节点body 节点包含一个或多个 outline 元素。outline（普通）outline 元素组成一个树状结构。也就是说，如果我们使用 OPML 储存 RSS 订阅列表，那么可以存为树状结构。在前面的例子中，我把自己的 RSS 订阅独立开来，把朋友和微软的 RSS 订阅分成了单独的组。outline 必须有 text 属性，其他都是可选的。而 text 属性就是 RSS 订阅的显示文字，如果没有这个属性，那么 RSS 的订阅列表中将会是空白一片。于是，我们解析 text 属性便可以得到可以显示出来的 RSS 订阅列表。对于前面的例子对应的 RSS 订阅列表就可以显示成下面这样：- walterlv- Team - 林德熙- Microsoft - Microsoft .NET Blog - Microsoft The Visual Studio Blogoutline 还有其他可选属性： type 指示此 outline 节点应该如何解析 isComment 布尔值，为 true 或 false；如果为 true，那么次 outline 就只是注释而已 isBreakpoint 适用于脚本，执行时可下断点 created 一个时间，表示此节点的创建时间 category 逗号分隔的类别：如果表示分类，则要用 / 分隔子类别；如果表示标签，则不加 / 例如：/Boston/Weather, /Harvard/Berkman,/Politics（例子来源于官方规范） outline（RSS 专属）当 type 是 rss 时，还有一些 RSS 专属属性。这时，必要属性就有三个了： type text xmlUrl其中，xmlUrl 就指的是订阅源的 url 地址了。在官方规范中，规定解析器不应该总认为 text 存在，相比之下，xmlUrl 显得更加重要。还有一些可选属性： description htmlUrl language title versionOPML 的解析在了解了 OPML 的格式组成之后，便可以很容易的地解析此文件了。当然，我也写了一份 OPML 的解析，请参阅本文的第二部分，解析篇。" }, { "title": "使用 Postman 调试 ASP.NET Core 开发的 API", "url": "/post/use-postman-to-debug-asp-net-core-api.html", "categories": "", "tags": "dotnet, csharp, asp", "date": "2019-03-09 09:07:59 +0800", "snippet": "使用 ASP.NET Core 开发简单的后台 API 还是非常容易的。涉及到 GET 请求的调试我们可以用浏览器简单搞定，那么 POST/PUT/DELETE 这样的请求呢？本文将使用 Postman 来调试这些请求。简单的 ASP.NET Core 程序如果你还不清楚如何编写一个 ASP.NET Core 程序，可以阅读 win10 uwp 手把手教你使用 asp dotnet core 做 cs 程序 学习做一个最简单的版本。我们的重点不是写一个 ASP.NET Core 程序，所以我只贴出最简单的路由地址的处理。using Microsoft.AspNetCore.Mvc;using Walterlv.WebApi.Rssman.Models;namespace Walterlv.WebApi.Rssman.Controllers{ [Route(&quot;api/[controller]&quot;)] [ApiController] public class RssController : ControllerBase { private readonly RssFeedContext _context; public RssController(RssFeedContext context) { } // GET: api/Rss [HttpGet] public ActionResult&amp;lt;List&amp;lt;RssFeedItem&amp;gt;&amp;gt; Get() { // 省略实现。 } // GET: api/Rss/5 [HttpGet(&quot;{id}&quot;, Name = &quot;Get&quot;)] public ActionResult&amp;lt;RssFeedItem&amp;gt; Get(long id) { // 省略实现。 } // POST: api/Rss [HttpPost] public IActionResult Post([FromBody] RssFeedItem item) { // 省略实现。 } // PUT: api/Rss/5 [HttpPut(&quot;{id}&quot;)] public IActionResult Put(long id, [FromBody] RssFeedItem item) { // 省略实现。 } // DELETE: api/ApiWithActions/5 [HttpDelete(&quot;{id}&quot;)] public IActionResult Delete(long id) { // 省略实现。 } }}以上代码是省略了所有实现的，完整的实现可以看这里：RssController。相关数据模型类的定义可以看这里： RssFeedItem.cs RssFeedContext.cs以上程序如果在 Visual Studio 里进行调试，可以在本地搭建一个可访问的 Url。比如: https://localhost:44395/ 。模拟 GET 请求我们通过浏览器就可以模拟 GET 请求，比如我们在 Chrome / Microsoft Edge / Firefox 中访问 https://localhost:44395/api/rss 会在浏览器中显示结果的 json 字符串：[ { &quot;id&quot;: 1, &quot;name&quot;: &quot;walterlv&quot;, &quot;feedUrl&quot;: &quot;https://blog.walterlv.com/feed.xml&quot;, &quot;siteUrl&quot;: &quot;https://blog.walterlv.com/&quot; }, { &quot;id&quot;: 2, &quot;name&quot;: &quot;lindexi&quot;, &quot;feedUrl&quot;: &quot;https://blog.lindexi.com/feed.xml&quot;, &quot;siteUrl&quot;: &quot;https://blog.lindexi.com/&quot; }]▲ Chrome 浏览器访问当然，实际上浏览器访问时是没有这些空白字符的，这样可以节省带宽。特别的，Internet Explorer 在访问时会提示保存 rss.json 文件▲ IE 浏览器访问很明显不用去管被时代淘汰的 IE 浏览器。下载安装 PostmanPostman 的下载地址在这里 https://www.getpostman.com/apps，▲ 选择你需要的平台Postman 的安装是极简的，没有任何设置。当启动后，注册或登录你的个人账号，然后填写一些个性化设置即可。如果你是本地 https 的调试，记得在 Postman 里关掉 SSL 证书验证，不然这种自己签署的证书是无法成功完成请求的。▲ 关闭 SSL 证书验证模拟 POST 请求在 Postman 的主界面，创建一个 HTTP POST 请求只需要几个小步骤：▲ 创建一个 POST 请求“Send” 按钮点击后，我们便可以在右侧看到此请求的响应：▲ 请求响应注意，如果你看到的是下面这样的响应界面，记得回到前面的步骤去关闭 SSL 证书验证。▲ 无法获取响应如果你在 Visual Studio 中打了断点，那么现在应该已经进入了断点了：▲ Visual Studio 中进入断点于是你就能调试 POST 请求了。模拟 PUT / PATCH / DELETE / … 请求同样的，你也可以用 Postman 模拟其他种类的 HTTP 请求。▲ 模拟其他请求关于本文调试的 ASP.NET 程序 RssmanRssman 是用来管理 RSS 订阅的 ASP.NET 程序，目前正在开发中。" }, { "title": "项目文件中的已知 NuGet 属性（使用这些属性，创建 NuGet 包就可以不需要 nuspec 文件啦）", "url": "/post/known-nuget-properties-in-csproj.html", "categories": "", "tags": "visualstudio, nuget, csharp, dotnet, msbuild", "date": "2019-03-09 09:07:32 +0800", "snippet": "知道了 csproj 文件中的一些常用 NuGet 属性，创建 NuGet 包时就可以充分发挥新 Sdk 自动生成 NuGet 包的优势，不需要 nuspec 文件啦。（毕竟 nuspec 文件没有 .csproj 和 .targets 文件强大而又有扩展性。）“项目文件中的已知属性系列”分为两个部分： 项目文件中的已知属性（知道了这些，就不会随便在 csproj 中写死常量啦） - 吕毅 本文：项目文件中的已知 NuGet 属性（使用这些属性，创建 NuGet 包就可以不需要 nuspec 文件啦） - 吕毅NuGet 相关的属性也分为全局属性和项属性两类。不过，我更愿意分成三类来说明：nuspec 属性当然，这部分的属性也是在 csproj 中使用的，是为了生成 nuspec 文件。使用方法像这样：&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;PackageId&amp;gt;Walterlv.Demo&amp;lt;/PackageId&amp;gt; &amp;lt;PackageVersion&amp;gt;3.2.0-beta&amp;lt;/PackageVersion&amp;gt; &amp;lt;TargetFramework&amp;gt;net46&amp;lt;/TargetFramework&amp;gt; &amp;lt;/PropertyGroup&amp;gt;&amp;lt;/Project&amp;gt;不过我们通常没有这么直接去设置，因为大多数属性都是有默认值的，如果不设置，将自动使用默认值。甚至什么都不写也能生成正确的 nuspec 文件。 $(PackageId): NuGet 包的唯一 Id，对应 NuGet 的 Id 属性。这个 Id 需要在整个服务器（例如 nuget.org）上唯一，如果没设置，则使用 $(AssemblyName)；例如 Newtonsoft.Json。 $(PackageVersion): NuGet 包的包版本，可以使用语义版本号（参见语义版本号（Semantic Versioning） - 吕毅），如果没设置，则使用 $(Version)；例如 3.2.0-beta。 $(PackageVersionPrefix): 包版本前缀，默认为空。 $(PackageVersionSuffix): 包版本后缀，默认为空。 $(Authors): 包的作者；建议指定成在 nuget.org 上的用户名，这样访客可以点击包作者查看到包作者的信息；多个名字用分号分隔。 $(Title): 包的显示名称，如果没设置，则使用 $(PackageId)。 $(PackageDescription): 包的描述文字，如果填写了，则用户在浏览包的时候可以看到。 $(Copyright): 包的版权声明 $(PackageRequireLicenseAcceptance): 是个布尔值，如果为 true，则在安装包之前要求同意协议。 $(PackageLicenseUrl): 此 NuGet 包协议所在的 url。 $(PackageProjectUrl): 此 NuGet 包的项目 url。 $(PackageIconUrl): 此 NuGet 包的图标 url，无论是 nuget.org 还是 Visual Studio 都将从这个 url 下载包的图标。 $(PackageTags): 标签，用分号分隔；指定多个标签有助于用户在 nuget.org 上搜索到你的 NuGet 包。 $(PackageReleaseNotes): 这个版本的 Release 记录。 $(RepositoryUrl): 仓库 url，例如 https://github.com/dotnet-campus/MSTestEnhancer.git $(RepositoryType): 仓库类型，例如 git、tfs。 $(RepositoryBranch): NuGet 4.7 才开始的新属性！此包对应的仓库分支，例如 master。 $(RepositoryCommit): NuGet 4.7 才开始的新属性！此包对应的提交号，例如 2d3ef96ee704d7896eeb2d88fbc987b2004ff786。 $(PackageType): 我还没有理解到此属性的作用。以上有些信息在每次 NuGet 发布之前都是要改的，例如：$(PackageVersion)、$(PackageReleaseNotes)、$(RepositoryCommit)。所以很明显——这不是用来给开发者设置的属性，是用于辅助我们生成打包工具的。配置属性这些属性会影响生成 NuGet 包的过程。&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;!-- 此程序集不可打包，通常在单元测试项目中设置此属性。 --&amp;gt; &amp;lt;IsPackable&amp;gt;false&amp;lt;/IsPackable&amp;gt; &amp;lt;Description&amp;gt;&amp;lt;/Description&amp;gt; &amp;lt;!-- 这是一个仅开发阶段使用的 NuGet 包，详情请参见 https://blog.walterlv.com/post/prevent-nuget-package-been-depended.html。 --&amp;gt; &amp;lt;DevelopmentDependency&amp;gt;true&amp;lt;/DevelopmentDependency&amp;gt; &amp;lt;!-- 单独指定 NuGet 包应该输出到哪个目录（可以跟项目文件的输出目录不一样）。 --&amp;gt; &amp;lt;PackageOutputPath&amp;gt;&amp;lt;/PackageOutputPath&amp;gt; &amp;lt;!-- 如果指定为 true，那么还会额外生成 PackageId.symbols.nupkg 包， 除了原有包的内容外，还额外包含全部的输出文件，以及源码和项目文件，用于调试。 --&amp;gt; &amp;lt;IncludeSymbols&amp;gt;true&amp;lt;/IncludeSymbols&amp;gt; &amp;lt;!-- 大致与 IncludeSymbols 相同，不过只会额外把 pdb 和 Compile 类型的文件打包到 NuGet 包中。 如果使用 ProjectReference 引用的项目没有指定 TreatAsPackageReference=false，也会一起被打包。 --&amp;gt; &amp;lt;IncludeSource&amp;gt;true&amp;lt;/IncludeSource&amp;gt; &amp;lt;PackageTypes&amp;gt;&amp;lt;/PackageTypes&amp;gt; &amp;lt;!-- 如果指定为 true，那么生成的 dll 将拷贝到 NuGet 包的 tools 目录下。 --&amp;gt; &amp;lt;IsTool&amp;gt;true&amp;lt;/IsTool&amp;gt; &amp;lt;!-- 如果 lib/**/*dll 中没有发现 dll，NuGet 打包过程中会有警告； 将这个属性设为 true 可以禁用警告；这在制作纯工具型 NuGet 包是非常有用。 --&amp;gt; &amp;lt;NoPackageAnalysis&amp;gt;true&amp;lt;/NoPackageAnalysis&amp;gt; &amp;lt;MinClientVersion&amp;gt;&amp;lt;/MinClientVersion&amp;gt; &amp;lt;IncludeContentInPack&amp;gt;&amp;lt;/IncludeContentInPack&amp;gt; &amp;lt;!-- 默认情况下，项目输出的 dll 会被打包到 lib 目录下； 设置了此属性后，就可以打包到其他目录下了。此例打包到 task 目录下 --&amp;gt; &amp;lt;BuildOutputTargetFolder&amp;gt;tasks&amp;lt;/BuildOutputTargetFolder&amp;gt; &amp;lt;ContentTargetFolders&amp;gt;&amp;lt;/ContentTargetFolders&amp;gt; &amp;lt;!-- 以下属性都是为了使用单独的 nuspec 文件而准备的；如果不使用 nuspec 文件，通常无需设置这些属性。 --&amp;gt; &amp;lt;!-- 默认情况下，使用 dotnet pack 打 NuGet 包时，也会顺便编译； 但设置此值为 true 后，就会像 nuget.exe 那样不进行编译了。 --&amp;gt; &amp;lt;NoBuild&amp;gt;true&amp;lt;/NoBuild&amp;gt; &amp;lt;!-- 默认是 true，如果指定为 false，那么项目编译输出的 dll 文件将不会被打包到 NuGet 包中。 --&amp;gt; &amp;lt;IncludeBuildOutput&amp;gt;false&amp;lt;/IncludeBuildOutput&amp;gt; &amp;lt;!-- 如果需要额外手工编写 nuspec 文件，那么使用此属性指定绝对或相对路径。 --&amp;gt; &amp;lt;NuspecFile&amp;gt;Walterlv.Demo.nuspec&amp;lt;/NuspecFile&amp;gt; &amp;lt;!-- 生成的属性可以时 nuspec 文件中的占位符生效， 例如 &amp;lt;file src=&quot;$SampleProperty$&quot; target=&quot;src/&quot; /&amp;gt; --&amp;gt; &amp;lt;NuspecProperties&amp;gt;SampleProperty=Program.cs&amp;lt;/NuspecProperties&amp;gt; &amp;lt;!-- 如果 NuspecFile 使用相对路径，那么就会相对于此路径；通常不需要指定。 --&amp;gt; &amp;lt;NuspecBasePath&amp;gt;&amp;lt;/NuspecBasePath&amp;gt; &amp;lt;/PropertyGroup&amp;gt;&amp;lt;/Project&amp;gt;其中，DevelopmentDependency 的设置可参见：帮助官方 NuGet 解掉 Bug，制作绝对不会传递依赖的 NuGet 包 - walterlv。以上没有设置值和注释的属性，我正在查阅资料。项属性文件为了脱离 nuspec 文件来打包，csproj 中需要对特殊用途的文件设置特别的 NuGet 属性。例如 Pack 属性可以额外指定一或一组通配符文件需要被打包到 NuGet 包中；PackagePath 则指定了打包到 NuGet 包的路径（NuGet 会通过扩展名来自动识别这是文件夹还是文件，所以可以通过这个属性来重新指定名称，但无法重新指定扩展名）。&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;Content Include=&quot;readme.txt&quot;&amp;gt; &amp;lt;Pack&amp;gt;true&amp;lt;/Pack&amp;gt; &amp;lt;PackagePath&amp;gt;\\&amp;lt;/PackagePath&amp;gt; &amp;lt;/Content&amp;gt; &amp;lt;Content Include=&quot;PackageId.targets&quot;&amp;gt; &amp;lt;Pack&amp;gt;true&amp;lt;/Pack&amp;gt; &amp;lt;PackagePath&amp;gt;buildMultiTargeting\\&amp;lt;/PackagePath&amp;gt; &amp;lt;/Content&amp;gt; &amp;lt;/PropertyGroup&amp;gt;&amp;lt;/Project&amp;gt;引用引用中也可以加入一些 NuGet 包的生成属性。无论是 &amp;lt;ProjectReference /&amp;gt; 还是 &amp;lt;PackageReference /&amp;gt;，都可以额外加上 &amp;lt;IncludeAssets&amp;gt; &amp;lt;ExcludeAssets&amp;gt; &amp;lt;PrivateAssets&amp;gt; 属性。使用方法类似这样：&amp;lt;PackageReference Include=&quot;Walterlv.Demo&quot; Version=&quot;3.0.0-beta&quot;&amp;gt; &amp;lt;IncludeAssets&amp;gt;all&amp;lt;/IncludeAssets&amp;gt; &amp;lt;ExcludeAssets&amp;gt;contentFiles&amp;lt;/ExcludeAssets&amp;gt; &amp;lt;PrivateAssets&amp;gt;contentFiles;analyzers&amp;lt;/PrivateAssets&amp;gt;&amp;lt;/PackageReference&amp;gt;或者这样：&amp;lt;PackageReference Include=&quot;Walterlv.Demo&quot; Version=&quot;3.0.0-beta&quot; PrivateAssets=&quot;all&quot; /&amp;gt;不区分大小写。 &amp;lt;IncludeAssets&amp;gt; 引用的项目或包中的指定部分是本项目的依赖项。默认为 all。 &amp;lt;ExcludeAssets&amp;gt; 引用的项目或包中的指定部分不是本项目的依赖项，应该排除。默认为 none。 &amp;lt;PrivateAssets&amp;gt; 引用的项目或包中的指定部分依然是本项目的依赖项，但是在打 NuGet 包时不作为依赖项（不会传递到下一个项目）。默认为 contentfiles;analyzers;build。如果你正试图用 NuGet 编写一个编译时工具，那么，你可能需要在所有引用的最后加上如下行，将所有的包引用都设为 PrivateAssets。&amp;lt;PackageReference Update=&quot;@(PackageReference)&quot; PrivateAssets=&quot;All&quot; /&amp;gt;如果你希望了解 Reference PackageReference 以及上面 @ 的含义，可以阅读我的另一篇文章：理解 C# 项目 csproj 文件格式的本质和编译流程 - walterlv。可能没有开放的内部属性在 Microsoft.NET.Sdk 中，NuGet 包的打包主要靠的是 NuGet.Build.Tasks.Pack.targets 文件中一个名为 PackTask 的任务来完成的，它是一个使用了非常多参数的 Task。&amp;lt;PackTask PackItem=&quot;$(PackProjectInputFile)&quot; PackageFiles=&quot;@(_PackageFiles)&quot; PackageFilesToExclude=&quot;@(_PackageFilesToExclude)&quot; PackageVersion=&quot;$(PackageVersion)&quot; PackageId=&quot;$(PackageId)&quot; Title=&quot;$(Title)&quot; Authors=&quot;$(Authors)&quot; Description=&quot;$(PackageDescription)&quot; Copyright=&quot;$(Copyright)&quot; RequireLicenseAcceptance=&quot;$(PackageRequireLicenseAcceptance)&quot; LicenseUrl=&quot;$(PackageLicenseUrl)&quot; ProjectUrl=&quot;$(PackageProjectUrl)&quot; IconUrl=&quot;$(PackageIconUrl)&quot; ReleaseNotes=&quot;$(PackageReleaseNotes)&quot; Tags=&quot;$(PackageTags)&quot; DevelopmentDependency=&quot;$(DevelopmentDependency)&quot; BuildOutputInPackage=&quot;@(_BuildOutputInPackage)&quot; ProjectReferencesWithVersions=&quot;@(_ProjectReferencesWithVersions)&quot; TargetPathsToSymbols=&quot;@(_TargetPathsToSymbols)&quot; TargetFrameworks=&quot;@(_TargetFrameworks)&quot; AssemblyName=&quot;$(AssemblyName)&quot; PackageOutputPath=&quot;$(PackageOutputAbsolutePath)&quot; IncludeSymbols=&quot;$(IncludeSymbols)&quot; IncludeSource=&quot;$(IncludeSource)&quot; PackageTypes=&quot;$(PackageType)&quot; IsTool=&quot;$(IsTool)&quot; RepositoryUrl=&quot;$(RepositoryUrl)&quot; RepositoryType=&quot;$(RepositoryType)&quot; SourceFiles=&quot;@(_SourceFiles-&amp;gt;Distinct())&quot; NoPackageAnalysis=&quot;$(NoPackageAnalysis)&quot; MinClientVersion=&quot;$(MinClientVersion)&quot; Serviceable=&quot;$(Serviceable)&quot; FrameworkAssemblyReferences=&quot;@(_FrameworkAssemblyReferences)&quot; ContinuePackingAfterGeneratingNuspec=&quot;$(ContinuePackingAfterGeneratingNuspec)&quot; NuspecOutputPath=&quot;$(NuspecOutputAbsolutePath)&quot; IncludeBuildOutput=&quot;$(IncludeBuildOutput)&quot; BuildOutputFolder=&quot;$(BuildOutputTargetFolder)&quot; ContentTargetFolders=&quot;$(ContentTargetFolders)&quot; RestoreOutputPath=&quot;$(RestoreOutputAbsolutePath)&quot; NuspecFile=&quot;$(NuspecFileAbsolutePath)&quot; NuspecBasePath=&quot;$(NuspecBasePath)&quot; NuspecProperties=&quot;$(NuspecProperties)&quot; AllowedOutputExtensionsInPackageBuildOutputFolder=&quot;$(AllowedOutputExtensionsInPackageBuildOutputFolder)&quot; AllowedOutputExtensionsInSymbolsPackageBuildOutputFolder=&quot;$(AllowedOutputExtensionsInSymbolsPackageBuildOutputFolder)&quot;/&amp;gt;&amp;lt;/Target&amp;gt;所以总结起来我们还有这些 NuGet 的属性还可以配置（想必下划线开头的属性或集合是 NuGet 内部不愿意公开的属性了）： $(PackProjectInputFile) @(_PackageFiles) @(_PackageFilesToExclude) $(PackageVersion) $(PackageId) $(Title) $(Authors) $(PackageDescription) $(Copyright) $(PackageRequireLicenseAcceptance) $(PackageLicenseUrl) $(PackageProjectUrl) $(PackageIconUrl) $(PackageReleaseNotes) $(PackageTags) $(DevelopmentDependency) @(_BuildOutputInPackage) @(_ProjectReferencesWithVersions) @(_TargetPathsToSymbols) @(_TargetFrameworks) $(AssemblyName) $(PackageOutputAbsolutePath) $(IncludeSymbols) $(IncludeSource) $(PackageType) $(IsTool) $(RepositoryUrl) $(RepositoryType) @(_SourceFiles-&amp;gt;Distinct()) $(NoPackageAnalysis) $(MinClientVersion) $(Serviceable) @(_FrameworkAssemblyReferences) $(ContinuePackingAfterGeneratingNuspec) $(NuspecOutputAbsolutePath) $(IncludeBuildOutput) $(BuildOutputTargetFolder) $(ContentTargetFolders) $(RestoreOutputAbsolutePath) $(NuspecFileAbsolutePath) $(NuspecBasePath) $(NuspecProperties) $(AllowedOutputExtensionsInPackageBuildOutputFolder) $(AllowedOutputExtensionsInSymbolsPackageBuildOutputFolder)这是 .NET Core 2.1 中自带的 NuGet 的打包属性，比 .NET Core 2.0 中多了个 @(_SourceFiles-&amp;gt;Distinct())。参考资料 NuGet pack and restore as MSBuild targets - Microsoft Docs NuGet PackageReference format (package references in project files) - Microsoft Docs" }, { "title": "为什么 C# 的 string.Empty 是一个静态只读字段，而不是一个常量呢？", "url": "/post/why-string-empty-is-a-readonly-field-but-not-a-constant.html", "categories": "", "tags": "dotnet, csharp", "date": "2019-03-05 23:54:05 +0800", "snippet": "使用 C# 语言编写字符串常量的时候，你可能会发现可以使用 &quot;&quot; 而不能使用 string.Empty。进一步可以发现 string.Empty 实际上是一个静态只读字段，而不是一个常量。为什么这个看起来最适合是常量的 string.Empty，竟然使用静态只读字段呢？string.Empty这个问题，我们需要去看 .NET Core 的源码（当然 .NET Framework 也是一样的）。[Intrinsic]public static readonly string Empty;值得注意的是上面的 Intrinsic 特性。Intrinsic 特性Intrinsic 特性的注释是这样的： Calls to methods or references to fields marked with this attribute may be replaced at some call sites with jit intrinsic expansions.Types marked with this attribute may be specially treated by the runtime/compiler.翻译过来是：对具有此 Intrinsic 特性标记的字段的方法或引用的调用可以在某些具有 JIT 内部扩展的调用点处替换，标记有此属性的类型可能被运行时或编译器特殊处理。也就是说，string.Empty 字段并不是一个普通的字段，对它的调用会被特殊处理。但是是如何特殊处理呢？JIT 编译器对 string.Empty 的注释是这样描述的： The Empty constant holds the empty string value. It is initialized by the EE during startup. It is treated as intrinsic by the JIT as so the static constructor would never run. Leaving it uninitialized would confuse debuggers.We need to call the String constructor so that the compiler doesn’t mark this as a literal. Marking this as a literal would mean that it doesn’t show up as a field which we can access from native.翻译过来是： Empty 常量保存的是空字符串的值，它在启动期间由执行引擎初始化。它被 JIT 视为内在的，因此静态构造函数永远不会运行。将它保持为未初始化的状态将会使得调试器难以解释此行为。于是我们需要调用 String 的构造函数，以便编译器不会将其标记为文字。将其标记为文字将意味着它不会显示为我们可以从本机代码访问的字段。说明一下： 注释里的 EE 是 Execution Engine 的缩写，其实也就是 CLR 运行时。 那个 literal 我翻译成了文字。实际上这里说的是 IL 调用字符串时的一些区别： 在调用 &quot;&quot; 时使用的 IL 是 ldstr &quot;&quot;（Load String Literal） 而在调用 string.Empty 时使用的 IL 是 ldsfld string [mscorlib]System.String::Empty（Load Static Field） 虽然 IL 在调用 &quot;&quot; 和 string.Empty 时生成的 IL 不同，但是在 JIT 编译成本机代码的时候，生成的代码完全一样。 详情请参见：.net - What’s the different between ldsfld and ldstr in IL? - Stack Overflow 我写过一篇文章 .NET/C# 编译期间能确定的相同字符串，在运行期间是相同的实例 - 吕毅。虽然一般情况下取字符串常量实例的时候会去字符串池，但是不用担心取 &quot;&quot; 会造成性能问题，因为实际上 JIT 编译器已经特殊处理了，不会去找池子。 string.Empty 字段在整个 String 类型中你都看不到初始化的代码，String 类的静态构造函数也不会执行。也就是说，String 类中的所有静态成员都不会被托管代码初始化。String 的静态初始化过程都是由 CLR 运行时进行的，而这部分的初始化是本机代码实现的。那本机代码又是如何初始化 String 类型的呢？在 CLR 运行时的 AppDomain::SetupSharedStatics() 方法中实现，可前往 GitHub 阅读这部分的源码： coreclr/appdomain.cpp at ef1e2ab328087c61a6878c1e84f4fc5d710aebce · dotnet/coreclr// This is a convenient place to initialize String.Empty.// It is treated as intrinsic by the JIT as so the static constructor would never run.// Leaving it uninitialized would confuse debuggers.// String should not have any static constructors._ASSERTE(g_pStringClass-&amp;gt;IsClassPreInited());FieldDesc * pEmptyStringFD = MscorlibBinder::GetField(FIELD__STRING__EMPTY);OBJECTREF* pEmptyStringHandle = (OBJECTREF*) ((TADDR)pLocalModule-&amp;gt;GetPrecomputedGCStaticsBasePointer()+pEmptyStringFD-&amp;gt;GetOffset());SetObjectReference( pEmptyStringHandle, StringObject::GetEmptyString(), this );总结：为什么 string.Empty 需要是一个静态只读字段而不是常量？从上文中 string.Empty 的注释描述中可以知道： 编译器会将 C# 语言编译成中间语言 MSIL； 如果这是一个常量，那么编译器在不做特殊处理的情况下，就会生成 ldstr &quot;&quot;，而这种方式不会调用到 String 类的构造函数（注意不是静态构造函数，String 类的静态构造函数是特殊处理不会调用的）； 而如果这是一个静态字段，那么编译器可以在不做特殊处理的情况下，生成 ldsfld string [mscorlib]System.String::Empty，这在首次执行时会触发 String 类的构造函数，并在本机代码（非托管代码）中完成初始化。当然，事实上编译器也可以针对此场景做特殊处理，但为什么不是在编译这一层进行特殊处理，我已经找不到出处了。本文引申的其他问题能否反射修改 string.Empty 的值？不行！实际上，在 .NET Framework 4.0 及以前是可以反射修改其值的，这会造成相当多的基础组件不能正常工作，在 .NET Framework 4.5 和以后的版本，以及 .NET Core 中，CLR 运行时已经不允许你做出这么出格儿的事了。不过，如果你使用不安全代码（unsafe）来修改这个字段的值就当我没说。关于使用不安全代码转换字符串的方法可以参见： C＃ 字符串首字符大写 - 林德熙 .NET/C# 编译期间能确定的相同字符串，在运行期间是相同的实例 - 吕毅&quot;&quot; 和 string.Empty 到底有什么区别？从前文你可以得知，在运行时级别，这两者 没有任何区别。于是，当你需要一个代表 “空字符串” 含义的时候，使用 string.Empty；而当你必须要一个常量时，就使用 &quot;&quot;。参考资料 String.CoreCLR.cs Intrinsic 在C#中 String.Empty和 “” 有什么区别？ - 知乎 .net - What’s the different between ldsfld and ldstr in IL? - Stack Overflow" }, { "title": "C#/.NET 调试的时候显示自定义的调试信息（DebuggerDisplay 和 DebuggerTypeProxy）", "url": "/post/display-instance-info-in-custom-debugger-view.html", "categories": "", "tags": "dotnet, csharp, visualstudio", "date": "2019-03-05 22:53:06 +0800", "snippet": "使用 Visual Studio 调试 .NET 程序的时候，在局部变量窗格或者用鼠标划到变量上就能查看变量的各个字段和属性的值。默认显示的是对象 ToString() 方法调用之后返回的字符串，不过如果 ToString() 已经被占作它用，或者我们只是希望在调试的时候得到我们最希望关心的信息，则需要使用 .NET 中调试器相关的特性。本文介绍使用 DebuggerDisplayAttribute 和 DebuggerTypeProxyAttribute 来自定义调试信息的显示。（同时隐藏我们在背后做的这些见不得人的事儿。）示例代码比如我们有一个名为 CommandLine 的类型，表示从命令行传入的参数；内有一个字典，包含命令行参数的所有信息。public class CommandLine{ private readonly Dictionary&amp;lt;string, IReadOnlyList&amp;lt;string&amp;gt;&amp;gt; _optionArgs; private CommandLine(Dictionary&amp;lt;string, IReadOnlyList&amp;lt;string&amp;gt;&amp;gt; optionArgs) =&amp;gt; _optionArgs = optionArgs ?? throw new ArgumentNullException(nameof(optionArgs));}现在，我们在 Visual Studio 里面调试得到一个 CommandLine 的实例，然后使用调试器查看这个实例的属性、字段和集合。然后，这样的一个字典嵌套列表的类型，竟然需要点开 4 层才能知道命令行参数究竟是什么。这样的调试效率显然是太低了！DebuggerDisplay使用 DebuggerDisplayAttribute 可以帮助我们直接在局部变量窗格或者鼠标划过的时候就看到对象中我们最希望了解的信息。现在，我们在 CommandLine 上加上 DebuggerDisplayAttribute：// 此段代码非最终版本。[DebuggerDisplay(&quot;CommandLine: {DebuggerDisplay}&quot;)]public class CommandLine{ private readonly Dictionary&amp;lt;string, IReadOnlyList&amp;lt;string&amp;gt;&amp;gt; _optionArgs; private CommandLine(Dictionary&amp;lt;string, IReadOnlyList&amp;lt;string&amp;gt;&amp;gt; optionArgs) =&amp;gt; _optionArgs = optionArgs ?? throw new ArgumentNullException(nameof(optionArgs)); private string DebuggerDisplay =&amp;gt; string.Join(&#39; &#39;, _optionArgs .Select(pair =&amp;gt; $&quot;{pair.Key}{(pair.Key == null ? &quot;&quot; : &quot; &quot;)}{string.Join(&#39; &#39;, pair.Value)}&quot;));}效果有了：不过，展开对象查看的时候可以看到一个 DebuggerDisplay 的属性，而这个属性我们只是调试使用，这是个垃圾属性，并不应该影响我们的查看。我们使用 DebuggerBrowsable 特性可以关闭某个属性或者字段在调试器中的显示。于是代码可以改进为：-- [DebuggerDisplay(&quot;CommandLine: {DebuggerDisplay}&quot;)]++ [DebuggerDisplay(&quot;CommandLine: {DebuggerDisplay,nq}&quot;)] public class CommandLine { private readonly Dictionary&amp;lt;string, IReadOnlyList&amp;lt;string&amp;gt;&amp;gt; _optionArgs; private CommandLine(Dictionary&amp;lt;string, IReadOnlyList&amp;lt;string&amp;gt;&amp;gt; optionArgs) =&amp;gt; _optionArgs = optionArgs ?? throw new ArgumentNullException(nameof(optionArgs)); ++ [DebuggerBrowsable(DebuggerBrowsableState.Never)] private string DebuggerDisplay =&amp;gt; string.Join(&#39; &#39;, _optionArgs .Select(pair =&amp;gt; $&quot;{pair.Key}{(pair.Key == null ? &quot;&quot; : &quot; &quot;)}{string.Join(&#39; &#39;, pair.Value)}&quot;)); }添加了从不显示此字段（DebuggerBrowsableState.Never），在调试的时候，展开后的属性列表里面没有垃圾 DebuggerDisplay 属性了。另外，我们在 DebuggerDisplay 特性的中括号中加了 nq 标记（No Quote）来去掉最终显示的引号。DebuggerTypeProxy虽然我们使用了 DebuggerDisplay 使得命令行参数一眼能看出来，但是看不出来我们把命令行解析成什么样了。于是我们需要更精细的视图。然而，上面展开 _optionArgs 字段的时候，依然需要展开 4 层才能看到我们的所有信息，所以我们使用 DebuggerTypeProxyAttribute 来优化调试器实例内部的视图。class CommandLineDebugView{ [DebuggerBrowsable(DebuggerBrowsableState.Never)] private readonly CommandLine _owner; public CommandLineDebugView(CommandLine owner) { _owner = owner; } [DebuggerBrowsable(DebuggerBrowsableState.RootHidden)] private string[] Options =&amp;gt; _owner._optionArgs .Select(pair =&amp;gt; $&quot;{pair.Key}{(pair.Key == null ? &quot;&quot; : &quot; &quot;)}{string.Join(&#39; &#39;, pair.Value)}&quot;) .ToArray();}我面写了一个新的类型 CommandLineDebugView，并在构造函数中允许传入要优化显示的类型的实例。在这里，我们写一个新的 Options 属性把原来字典里面需要四层才能展开的值合并成一个字符串集合。但是，我们在 Options 上标记 DebuggerBrowsableState.RootHidden： 如果这是一个集合，那么这个集合将直接显示到调试视图的上一级视图中； 如果这是一个普通对象，那么这个对象的各个属性字段将合并到上一级视图中显示。别忘了我们还需要禁止 _owner 在调试器中显示，然后把 [DebuggerTypeProxy(typeof(CommandLineDebugView))] 加到 CommandLine 类型上。这样，最终的显示效果是这样的：点击 Raw View 可以看到我们没有使用 DebuggerTypeProxyAttribute 视图时的属性和字段。最终代码using System;using System.Collections.Generic;using System.Diagnostics;using System.Linq;using Walterlv.Framework.StateMachine;namespace Walterlv.Framework{ [DebuggerDisplay(&quot;CommandLine: {DebuggerDisplay,nq}&quot;)] [DebuggerTypeProxy(typeof(CommandLineDebugView))] public class CommandLine { private readonly Dictionary&amp;lt;string, IReadOnlyList&amp;lt;string&amp;gt;&amp;gt; _optionArgs; private CommandLine(Dictionary&amp;lt;string, IReadOnlyList&amp;lt;string&amp;gt;&amp;gt; optionArgs) =&amp;gt; _optionArgs = optionArgs ?? throw new ArgumentNullException(nameof(optionArgs)); [DebuggerBrowsable(DebuggerBrowsableState.Never)] private string DebuggerDisplay =&amp;gt; string.Join(&#39; &#39;, _optionArgs .Select(pair =&amp;gt; $&quot;{pair.Key}{(pair.Key == null ? &quot;&quot; : &quot; &quot;)}{string.Join(&#39; &#39;, pair.Value)}&quot;)); private class CommandLineDebugView { [DebuggerBrowsable(DebuggerBrowsableState.Never)] private readonly CommandLine _owner; public CommandLineDebugView(CommandLine owner) =&amp;gt; _owner = owner; [DebuggerBrowsable(DebuggerBrowsableState.RootHidden)] private string[] Options =&amp;gt; _owner._optionArgs .Select(pair =&amp;gt; $&quot;{pair.Key}{(pair.Key == null ? &quot;&quot; : &quot; &quot;)}{string.Join(&#39; &#39;, pair.Value)}&quot;) .ToArray(); } }}参考资料 DebuggerTypeProxyAttribute Class (System.Diagnostics) - Microsoft Docs DebuggerDisplayAttribute Class (System.Diagnostics) - Microsoft Docs Using DebuggerTypeProxy Attribute - Visual Studio - Microsoft Docs Using the DebuggerDisplay Attribute - Visual Studio - Microsoft Docs" }, { "title": "透明度叠加算法：如何计算半透明像素叠加到另一个像素上的实际可见像素值（附 WPF 和 HLSL 的实现）", "url": "/post/alpha-blending-algorithm.html", "categories": "", "tags": "algorithm, dotnet, wpf, uwp", "date": "2019-03-05 15:01:55 +0800", "snippet": "本文介绍透明度叠加算法（Alpha Blending Algorithm），并用 C#/WPF 的代码，以及像素着色器的代码 HLSL 来实现它。算法对于算法，我只是搬运工，可以随意搜索到。算法详情请查看：Alpha compositing - Wikipedia。对于完全不透明的背景和带有透明度的前景，合并算法为：float r = (foreground.r * alpha) + (background.r * (1.0 - alpha));这是红色。然后绿色 g 和蓝色 b 通道进行一样的计算。最终合成图像的透明通道始终设置为 1。在 C# 代码中实现多数 UI 框架对于颜色值的处理都是用一个 byte 赛表单个通道的一个像素。于是计算会采用 0xff 即 255。for (int i = 0; i + 4 &amp;lt; length; i = i + 4){ var backB = background[i]; var backG = background[i + 1]; var backR = background[i + 2]; var foreB = foreground[i]; var foreG = foreground[i + 1]; var foreR = foreground[i + 2]; double alpha = foreground[i + 3]; blue = 0; output[i] = (foreB * alpha) + (backB * (1.0 - alpha)); output[i + 1] = (foreG * alpha) + (backG * (1.0 - alpha)); output[i + 2] = (foreR * alpha) + (backR * (1.0 - alpha)); output[i + 3] = 1.0;}这段代码当然是跑不起来的，因为是下面两篇博客的魔改代码。你需要阅读以下两篇博客了解如何在 WPF 中按像素修改图像，然后应用上面的透明度叠加代码。 WPF 修改图片颜色 WPF 通过位处理合并图片话说，一般 UI 框架都自带有透明度叠加，为什么还要自己写一份呢？当然是因为某些场景下我们无法使用到 UI 框架的透明度叠加特性的时候。例如使用 HLSL 编写像素着色器的一个实现。下面使用像素着色器的实现是我曾经写过的一个特效的一个小部分，我把透明度叠加的部分单独摘取出来。在像素着色器中实现以下是 HLSL 代码的实现。Background 是从采样寄存器 0 取到的颜色采样，Foreground 是从采样寄存器 1 取到的颜色采样。这里的计算中，背景是不带透明度的，而前景是带有透明度的。/// &amp;lt;description&amp;gt;透明度叠加效果。&amp;lt;/description&amp;gt;sampler2D Background : register(s0);sampler2D Foreground : register(s1);float4 main(float2 uv : TEXCOORD) : COlOR{ float4 background = tex2D(Background, uv); float4 foreground = tex2D(Foreground, uv); float alpha = foreground.a; float r = (foreground.r * alpha) + (background.r * (1.0 - alpha)); float g = (foreground.g * alpha) + (background.g * (1.0 - alpha)); float b = (foreground.b * alpha) + (background.b * (1.0 - alpha)); float a = 1.0; return float4(r, g, b, a);}如果要测试的图片都是不带透明度的，那么可以通过自己设一个透明度来模拟，传入透明度值 Alpha。/// &amp;lt;description&amp;gt;透明度叠加效果。&amp;lt;/description&amp;gt;/// &amp;lt;type&amp;gt;Double&amp;lt;/type&amp;gt;/// &amp;lt;summary&amp;gt;采样 2 的叠加透明度。&amp;lt;/summary&amp;gt;/// &amp;lt;minValue&amp;gt;0.0&amp;lt;/minValue&amp;gt;/// &amp;lt;maxValue&amp;gt;1.0&amp;lt;/maxValue&amp;gt;/// &amp;lt;defaultValue&amp;gt;0.75&amp;lt;/defaultValue&amp;gt;float Alpha : register(C0);sampler2D Background : register(s0);sampler2D Foreground : register(s1);float4 main(float2 uv : TEXCOORD) : COlOR{ float4 background = tex2D(Background, uv); float4 foreground = tex2D(Foreground, uv); float alpha = Alpha; float r = (foreground.r * alpha) + (background.r * (1.0 - alpha)); float g = (foreground.g * alpha) + (background.g * (1.0 - alpha)); float b = (foreground.b * alpha) + (background.b * (1.0 - alpha)); float a = 1.0; return float4(r, g, b, a);}参考资料 Alpha compositing - Wikipedia algorithm - Manually alpha blending an RGBA pixel with an RGB pixel - Stack Overflow" }, { "title": "使用 Xamarin 开发 iOS 键盘扩展（含网络访问）", "url": "/post/develop-ios-keyboard-extension-using-xamarin.html", "categories": "", "tags": "xamarin, dotnet, csharp, xaml, ios", "date": "2019-03-04 22:15:47 +0800", "snippet": "作为一位 .NET 技术的死忠，开发 iOS 应用当然要使用 Xamarin 啦！本文用我的阅读的文档和实践为素材，介绍如何使用 Xamarin 开发一个 iOS 的键盘扩展。你可以在 Walterlv.CloudKeyboard 仓库中获得本文所述的全部源代码。搭建环境本文不会花篇幅来讲如何搭建 Xamarin iOS 开发的环境，不然这篇文章就没有重点。于是，请阅读这一篇来了解如何搭建 Xamarin iOS 的开发环境： 安装调试工具：Mac 部分 Xamarin开发(Mac开发)环境搭建 - 简书 安装调试工具：Windows 部分 vs2017开发IOS（vs2017 xamarin 连接mac） - ManGo.XYZ - CSDN博客 申请开发者账号：https://developer.apple.com/register/，阅读这里了解坑 准备一根 Type-C 到 Lightning 的数据线，用于 Mac 从 Mac 部署到真机进行调试你需要了解的 iOS 键盘扩展的背景知识了解以下背景知识，有助于我们接下来开发的时候少踩一些坑。当然我不会在这里说 iOS 应用开发的所有背景知识，只会说与 iOS 键盘扩展相关的部分。 iOS 键盘扩展是 iOS 扩展的一种，而 iOS 扩展是 iOS 8.0 才开始引入的概念。 iOS 扩展需要有一个 iOS 普通应用作为容器一起打包；所以，你需要创建两个项目来完成 iOS 键盘扩展的开发。 在后文，我们将直接使用 iOS 容器应用来描述这个概念 扩展的包标识符（Bundle Identifier）必须以容器应用的包标识符字符串作为开头 iOS 扩展和 iOS 容器应用会被视为两款完全不同的应用，互相之前不能共享任何数据。 如果真的要共享数据，就需要像其他两款不同应用共享数据一样的处理方式 iOS 键盘扩展默认是不能访问网络的，你需要声明允许访问网络，并获得用户的同意才行。创建 iOS 键盘扩展项目第一步：创建 Xamarin.Forms 项目。这个不用太在意里面的实现，因为它只是我们的“容器项目”（前面有介绍）。实际上在本文我们完全不会碰这个项目里面的代码，只是为了配置我们的 iOS 应用包而已。未来你可以在这个容器应用里面做键盘的个性化设置。然后，选择 iOS 平台。我们只需要 iOS 端。因为对于键盘，不同系统的实现差异很大，之间共享的代码只能是非键盘部分的代码了。第二步：创建 iOS 键盘扩展项目当你创建完之后，你会看到三个不同的项目。你可能发现 Walterlv.KeyboardExtension.Keyboard 项目有些奇怪，里面有 Main 函数和 AppDelegate，按道理这是一个主程序包。然而实际测试中单独有这个项目是跑不起来的（这可能是一个 Bug，如果修复了，请在下面评论或者邮件告知我，谢谢了）。于是，Main 和 AppDelegate 这两个文件是可以删除的。如果你强迫症，就删掉吧。当然不删掉也不影响，不过我删掉了。第三步：引用 iOS 键盘扩展项目在 iOS 容器应用上面添加键盘扩展项目作为引用。如果你感兴趣去查看 Walterlv.KeyboardExtension.iOS 项目中对 Walterlv.KeyboardExtension.Keyboard 项目的引用节点的话，你会发现 Xamarin 已经自动为这个项目标记上了 &amp;lt;IsAppExtension /&amp;gt;。只有加上了 AppExtension 标记，Xamarin 才会把这个项目作为 iOS 扩展项目进行打包。&amp;lt;ProjectReference Include=&quot;..\\..\\Walterlv.KeyboardExtension.Keyboard\\Walterlv.KeyboardExtension.Keyboard.csproj&quot;&amp;gt; &amp;lt;Project&amp;gt;{d6f006e7-3c98-4b97-b2d5-4d2e3bc2f945}&amp;lt;/Project&amp;gt; &amp;lt;Name&amp;gt;Walterlv.KeyboardExtension.Keyboard&amp;lt;/Name&amp;gt; &amp;lt;IsAppExtension&amp;gt;true&amp;lt;/IsAppExtension&amp;gt; &amp;lt;IsWatchApp&amp;gt;false&amp;lt;/IsWatchApp&amp;gt;&amp;lt;/ProjectReference&amp;gt;在以上三个步骤完成之后，理论上你是可以正常编译此项目的。配置包信息iOS 应用的包信息存储在 plist 中。所以在这一节，你需要正确配置两个项目的 plist。没错！是两个项目。还记得前面背景知识里面我们说到容器项目和扩展项目就是两个不同的应用吗？配置 plist 的方法，就是在 Visual Studio 里面双击这个文件。按照下图这样配置：说明： Application Name 对应 plist 中的 CFBundleDisplayName 属性，也就是应用的显示名称。 对于容器应用，就是 iOS 图标下面的名称，对于键盘，就是切换键盘的时候所用的名称。 下图中 iOS 应用图标下面的名称 CloudKeyboard 就是我在 Walterlv.CloudKeyboard 项目中的容器应用的名称。 下图中在 iOS 切换键盘时，Cloud 就是我在 Walterlv.CloudKeyboard 项目中的键盘名称。 扩展项目的 Bundle Identifier 名称必须以容器项目的 Bundle Identifier 名称作为前缀。 如果不满足要求，部署时扩展将不会生效。 至此，你的项目可以直接编译了。如果你有真机部署环境，都可以直接部署到真机上看效果了。真机部署调试本文不会花篇幅来讲如何真机部署调试，不然这篇文章就没有重点。但是你可以阅读：使用 Xamarin 在 iOS 真机上部署应用进行调试当然这是 Mac 版本的（毕竟我在 Windows 上实际也没有成功真机调试过，我是 git 同步到 Mac 上用 Visual Studio for Mac 来真机调试的）。只是你需要注意做这些内容： 你需要同意一份开发者证书（不然打不开应用）： 设置 -&amp;gt; 通用 -&amp;gt; 设备管理 -&amp;gt; [自己的开发者账号] -&amp;gt; 信任 还需要打开这个键盘（不然看不到键盘）： 设置 -&amp;gt; 通用 -&amp;gt; 键盘 -&amp;gt; 添加新键盘… -&amp;gt; [选择我们刚刚开发的键盘] 下面是我部署到真机上之后，在亮暗两种不同的界面下的键盘截图（就是上面的项目，没有改任何代码）：处理键盘的文字输入、退格和确定我们把 Walterlv.CloudKeyboard.iOS.Extension 也就是那个键盘扩展项目删除得只剩下 KeyboardViewController.cs 了，我们也只需要在这个类中写代码而已。要控制文字输入，就是使用 TextDocumentProxy 实例。我们的 KeyboardViewController 继承自 UIInputViewController，于是我们能够在类中直接使用 TextDocumentProxy 实例。在光标处插入文字：TextDocumentProxy.InsertText(&quot;walterlv&quot;);如果要插入换行或者确认输入，则使用：TextDocumentProxy.InsertText(&quot;\\n&quot;);在光标处删除前一个字：TextDocumentProxy.DeleteBackward();如果想要清空文本，则可以循环删除：while (TextDocumentProxy.HasText){ TextDocumentProxy.DeleteBackward();}你没有办法删除后一个字，也不能获取到用户输入的任何内容。关于换行，特别注意：如果文本框被设置为发送或者其他非换行的功能，那么使用 InsertText 单独插入换行时才能正常执行这些功能。如果调用此代码之前还有其他的插入文字，那么最终就只会是换行，而不会执行其他的功能。实际上我在这一点上踩了坑，导致在 QQ 或者其他工具中只能实现换行，而无法发送消息。iOS 的键盘有不同种类的确认，需要键盘针对 TextDocumentProxy.我还没有找到办法直接完成文本的输入，例如执行确认按钮的逻辑。而确认按钮有这么些不同的情况：// 我当然是写 C# 语言版本的枚举，而不是 Object-C 版本的啦。public enum UIReturnKeyType : long{ Default, Go, Google, Join, Next, Route, Search, Send, Yahoo, Done, EmergencyCall, Continue,}添加键盘的网络访问支持允许完全访问（包括网络）纯本地的键盘很难在打字速度上获得优势，各种主流的输入法也通常借助网络来提高自身的输入准确度。用户需要在键盘设置里面开启键盘的“允许完全访问”才能让对应的输入法获得网络访问的权限。如果用户没有给权限，那么网络访问的时候键盘扩展就会出现异常，然后闪退。然而如果你去我们刚刚开发的输入法中看，你会发现我们的输入法没有提供这样的选项可以设置。那么如何能够添加这个设置以便进行网络访问呢？方法是修改键盘扩展项目的 Info.plist 文件。这个时候的修改，我们就不能使用 Visual Studio 中自带的 plist 编辑器了，我们需要使用文本编辑器来编辑 plist 文件。在你的 Info.plist 文件中找到 RequestsOpenAccess 属性，然后将它分值从 false 改为 true： &amp;lt;key&amp;gt;RequestsOpenAccess&amp;lt;/key&amp;gt;-- &amp;lt;false/&amp;gt;++ &amp;lt;true/&amp;gt;这个属性设为 true 之后，再次部署，你将可以在你的键盘设置里面看到“允许完全访问”的设置项。开启之后，你就能在你的键盘里面访问网络了。允许访问 http 不安全网络一般来说你不用阅读这一小节的内容。因为现在基本上各种服务都已经是 https 了，http 基本已经绝迹。但是如果你需要临时部署一个服务，没来得及申请 https 证书的话，那么就需要使用本小结的内容让你的键盘支持 http 的访问。继续打开你的键盘扩展项目的 Info.plist 文件，在根字典的最后添加一个完整的字典属性 NSAppTransportSecurity：&amp;lt;key&amp;gt;NSAppTransportSecurity&amp;lt;/key&amp;gt;&amp;lt;dict&amp;gt; &amp;lt;key&amp;gt;NSAllowsArbitraryLoads&amp;lt;/key&amp;gt; &amp;lt;true/&amp;gt; &amp;lt;key&amp;gt;NSExceptionDomains&amp;lt;/key&amp;gt; &amp;lt;dict&amp;gt; &amp;lt;key&amp;gt;walterlv.com&amp;lt;/key&amp;gt; &amp;lt;dict&amp;gt; &amp;lt;key&amp;gt;NSExceptionAllowsInsecureHTTPLoads&amp;lt;/key&amp;gt; &amp;lt;true/&amp;gt; &amp;lt;key&amp;gt;NSIncludesSubdomains&amp;lt;/key&amp;gt; &amp;lt;true/&amp;gt; &amp;lt;/dict&amp;gt; &amp;lt;/dict&amp;gt;&amp;lt;/dict&amp;gt;特别注意，里面的 walterlv.com 需要换成你自己的域名。是域名，不用包含端口号。这样，你就能在键盘中访问 http://walterlv.com 了。本文总结 本文介绍了使用 Xamarin 开发 iOS 键盘插件的背景知识。 必须了解这些知识才不会在一些不太重要的坑上耗费太长时间。 本文教大家如何开发 iOS 键盘插件，主要是项目组织以及写代码。 至少，使用文本编写出来的代码，能够在不作任何修改的情况下部署到真机。（实际上我们只在 KeyboardViewController.cs 中加了寥寥几行代码。） 本文不涉及到搭建开发环境，不涉及如何连接真机调试。 你可能需要配合这些博客才能完成部署以及调试： Xamarin开发(Mac开发)环境搭建 - 简书 vs2017开发IOS（vs2017 xamarin 连接mac） - ManGo.XYZ - CSDN博客 如果你还遇到了一些其他诡异的问题： 欢迎阅读 使用 Xamarin 开发 iOS 应用中需要注意的若干个问题。 欢迎在评论区评论或者向我发邮件。参考资料 iOS Extensions in Xamarin.iOS - Xamarin - Microsoft Docs [iOS 8 Custom Keyboard Tutorial: How to Create A Third-Party Keyboard Extension iPhone and iOS App UI Design Templates](http://www.appdesignvault.com/ios-8-custom-keyboard-extension/#a_aid=mdev) 如何使用Xamarin开发iOS输入法 - 简书 ios - Make HTTP Request from Custom Keyboard App Extension - Stack Overflow ios - Transport security has blocked a cleartext HTTP - Stack Overflow iOS - 输入框有值时才能点击键盘上的returnkey(enablesReturnKeyA… - 简书 objective c - Handling Return key in iOS 8 keyboard extension - Stack Overflow objective c - Handling Return key in iOS 8 keyboard extension - Stack Overflow iphone - iOS keyboard with “Go” button instead of return - Stack Overflow Custom Keyboards - Extensions - iOS - Human Interface Guidelines - Apple Developer Creating a Custom Keyboard In IOS… – Swift India – Medium" }, { "title": "如何为你的 Windows 应用程序关联一种或多种文件类型", "url": "/post/windows-file-type-association.html", "categories": "", "tags": "dotnet, windows, csharp", "date": "2019-03-04 22:15:30 +0800", "snippet": "对于 Windows 桌面应用来说，让应用关联一种或多种文件类型是通过修改注册表来实现的。本文介绍如何为你的应用关联自定义的文件类型或者关联被广泛使用的文件类型。文件关联Windows 上的文件关联是通过文件的扩展名来实现的。有些文件类型是被广泛使用的公共类型，例如 .txt、.png、.mp4 文件；有些则是你自己的应用程序使用的私有类型，例如我自己定义一个 .lvyi 扩展名的文件类型。我们会关联这些广泛使用的类型可能是因为我们自己写了一个自己的文本编辑器，于是我们会关联 .txt 或者 .md 类型。而我们关联自定义的文件类型是因为我们需要为我们自己的应用生态产生一些文件数据。那么问题来了，我怎么知道我现在准备使用的扩展名是不是已经被广泛使用的公共类型呢？请进入此网站查看：Media Types。注册一个文件类型要在 Windows 系统上注册一个文件类型，你需要做三个步骤： 取一个应用程序标识符（ProgID） 在注册表中添加文件关联（用于告知 Windows 这个文件已经被关联） 为关联的程序添加谓词（用于打开这个文件）取一个应用程序标识符没错，我说的就是取名字，而且要求在 Windows 系统上全局唯一；所以这里取名字也是有讲究的。关于应用程序标识符的相关内容，可以阅读微软的官方文档：Programmatic Identifiers - Windows applications - Microsoft Docs。微软建议的 ProgID 的取名方式是这样的：厂商名.应用名.版本号这里的版本号通常是指的大版本号。例如版本号为 1.6.0.97 的应用，通常只取第一位，即 1。一个典型的建议的取名示例是这样的：Walterlv.Foo.1还是看微软自己的命名示例会更权威一点：竟然取一个名字也能写这么多篇幅，看来程序员的命名果然是世界上的一大难题呀！赶紧试用一下我的命名神器吧 —— 点击下载，其原理可阅读 冷算法：自动生成代码标识符（类名、方法名、变量名） - 吕毅。在注册表中添加文件关联你需要在注册表的 HKEY_LOCAL_MACHINE\\Software\\Classes 或者 HKEY_CURRENT_USER\\Software\\Classes 添加一些子键：HKEY_CURRENT_USER\\Software\\Classes .walv (Default) = Walterlv.Foo.1 .lvyi (Default) = Walterlv.Foo.1 Walterlv.Foo.1 (Default) = 吕毅的示例文件 Shell Open Command (Default) = &quot;C:\\Users\\lvyi\\AppData\\Local\\Walterlv.Foo\\walterlv.exe&quot; &quot;%1&quot; 前面的 .walv 和 lvyi 是我自己定义的两种文件类型，我将它们的 (Default) 值设置成 Walterlv.Foo.1；而 Walterlv.Foo.1 就是前面说的应用程序标识符（ProgID）。后面的又新建了一个 Walterlv.Foo.1 的键，其 (Default) 值设置成了我们这个应用关联时使用的名称，也就是资源管理器中显示这个文件的时候使用的名称。只要我们完成了以上的步骤，我们就能在资源管理器中看到我们的文件关联（虽然双击打不开）：关于注册表路径的说明：HKEY_LOCAL_MACHINE 主键是此计算机上的所有用户共享的注册表键值，而 HKEY_CURRENT_USER 是当前用户使用的注册表键值。而我们在注册表的 HKEY_CLASSES_ROOT 中也可以看到跟 HKEY_LOCAL_MACHINE\\Software\\Classes 和 HKEY_CURRENT_USER\\Software\\Classes 中一样的文件关联项，是因为 HKEY_CLASSES_ROOT 是 HKEY_LOCAL_MACHINE\\Software\\Classes 和 HKEY_CURRENT_USER\\Software\\Classes 合并之后的一个视图，其中用户键值会覆盖此计算机上的相同键值。也就是说，如果你试图修改文件关联，那么需要去 HKEY_LOCAL_MACHINE\\Software\\Classes 和 HKEY_CURRENT_USER\\Software\\Classes 中，但如果只是去查看文件关联的情况，则只需要去 HKEY_CLASSES_ROOT 中。写入计算机范围内的注册表项需要管理员权限，而写入用户范围内的注册表项不需要管理员权限；你可以酌情选用。为关联的程序添加谓词我们需要为关联的程序添加谓词才能够使用我们的程序打开这个文件。通常进行文件关联时最常用的谓词是 open，添加路径为 HKEY_CURRENT_USER\\Software\\Classes\\Walterlv.Foo.1\\shell\\Open\\Command。添加后，我们可以在文件资源管理器中通过双击打开这个文件。Walterlv.Foo.1 (Default) = 吕毅的示例文件 shell Open Command (Default) = &quot;C:\\Users\\lvyi\\AppData\\Local\\Walterlv.Foo\\walterlv.exe&quot; -f &quot;%1&quot;其中路径后面的 &quot;%1&quot; 是文件资源管理器传入的参数，其实就是文件的完整路径。我们加上了引号是避免解析命令行的时候把包含空格的路径拆成了多个参数。还可以添加其他谓词，有一些是预定义的谓词，你也可以随便写其他的谓词。另外，还可以定义文件的图标。Walterlv.Foo.1 (Default) = 吕毅的示例文件 DefaultIcon = &quot;C:\\Users\\lvyi\\AppData\\Local\\Walterlv.Foo\\lvyi-icon.ico&quot; shell Open Command (Default) = &quot;C:\\Users\\lvyi\\AppData\\Local\\Walterlv.Foo\\walterlv.exe&quot; open -f &quot;%1&quot; 用逗比的方式打开 Command (Default) = &quot;C:\\Users\\lvyi\\AppData\\Local\\Walterlv.Foo\\walterlv.exe&quot; open -f &quot;%1&quot; --doubi反注册文件类型当你卸载你的程序的时候，需要反注册之前注册过的文件类型；而反注册的过程并不是把以上的过程完全反过来。微软推荐我们只删除 ProgID 的键，而不删除文件扩展名的键；因为其他的程序可能已经关联了我们的文件扩展名。就算我们使用的是私有的格式，也有可能是我们程序的未来版本会关联这个扩展名。总之，你需要做的，只是删除 ProgID 的键，文件扩展名的键不要去动它，Windows 自己会处理好 ProgID 删除之后文件关联的问题的。一个完整的文件关联示例HKEY_CLASSES_ROOT .walv (Default) = Walterlv.Foo.1 .lvyi (Default) = Walterlv.Foo.1 Content Type = text/xml Walterlv.Foo.1 (Default) = Walterlv Foo AlwaysShowExt = 1 DefaultIcon = &quot;C:\\Users\\lvyi\\AppData\\Local\\Walterlv.Foo\\lvyi-icon.ico&quot; FriendlyTypeName = 吕毅的示例文件 shell Open Command (Default) = &quot;C:\\Users\\lvyi\\AppData\\Local\\Walterlv.Foo\\walterlv.exe&quot; open -f &quot;%1&quot; 用逗比的方式打开 Command (Default) = &quot;C:\\Users\\lvyi\\AppData\\Local\\Walterlv.Foo\\walterlv.exe&quot; open -f &quot;%1&quot; --doubi Edit Command (Default) = &quot;C:\\Users\\lvyi\\AppData\\Local\\Walterlv.Foo\\walterlv.exe&quot; edit -f &quot;%1&quot; print command (Default) = &quot;C:\\Users\\lvyi\\AppData\\Local\\Walterlv.Foo\\walterlv.exe&quot; print -f &quot;%1&quot; printto command (Default) = &quot;C:\\Users\\lvyi\\AppData\\Local\\Walterlv.Foo\\walterlv.exe&quot; print -f &quot;%1&quot; -t &quot;%2&quot;参考资料 File Types and File Associations - Windows applications - Microsoft Docs Programmatic Identifiers - Windows applications - Microsoft Docs Media Types" }, { "title": "通过重写预定义的 Target 来扩展 MSBuild / Visual Studio 的编译过程", "url": "/post/extend-the-visual-studio-build-process.html", "categories": "", "tags": "dotnet, msbuild, visualstudio", "date": "2019-03-04 22:15:06 +0800", "snippet": "MSBuild 的编译过程提供了一些可以被重写的 Target，通过重写这些 Target 可以扩展 MSBuild 的编译过程。重写预定义的 Target有这些预定义的 Target 可以重写： BeforeCompile, AfterCompile BeforeBuild, AfterBuild BeforeRebuild, AfterRebuild BeforeClean, AfterClean BeforePublish, AfterPublish BeforeResolveReference, AfterResolveReferences BeforeResGen, AfterResGen你可以在 Microsoft.NET.Sdk 中找到各种富有创意的 Target 用来扩展，以上这些也是 Microsoft.NET.Sdk 的一部分，在那个文件夹的 Microsoft.Common.targets 或者 Microsoft.Common.CurrentVersion.targets 中。而写法是这样的：&amp;lt;Project&amp;gt; ... &amp;lt;Target Name=&quot;BeforeResGen&quot;&amp;gt; &amp;lt;!-- 这里可以写在生成资源之前执行的 Task 或者修改属性和集合。 --&amp;gt; &amp;lt;/Target&amp;gt; &amp;lt;Target Name=&quot;AfterCompile&quot;&amp;gt; &amp;lt;!-- 这里可以写在 C# 文件以及各种资源文件编译之后执行的 Task 或者修改属性和集合。 --&amp;gt; &amp;lt;/Target&amp;gt;&amp;lt;/Project&amp;gt;是的，相比于你全新定义一个 Target 来说，你不需要去写 BeforeTargets 或者 AfterTargets。那么以上那些 Target 都是什么时机呢？BeforeCompile, AfterCompile在 C# 文件以及各种资源文件被编译成 dll 的之前或之后执行。你可以在之前执行以便修改要编译的 C# 文件或者资源文件，你也可以在编译之后做一些其他的操作。由于我们可以在 BeforeCompile 这个时机修改源码，所以我们很多关于代码级别的重新定义都可以在这个时机去完成。BeforeBuild, AfterBuild在整个编译之前或者之后执行。对于普通的编译来说，一般来说不会有比 BeforeBuild 更前以及比 AfterBuild 更后的时机了，不过如果有其他 Import 进来的 Target 或者通过 NuGet 自动引入进来的其他 Target 也使用了类似这样的时机，那么你就不一定比他们更靠前或者靠后。BeforeRebuild, AfterRebuild如果编译时采用了 /t:Rebuild 方案，也就是重新编译，那么 BeforeRebuild 和 AfterRebuild 就会被触发。一旦触发，会比前面更加提前和靠后。执行顺序为：BeforeRebuild -&amp;gt; Clean -&amp;gt; Build -&amp;gt; AfterRebuildBeforeClean, AfterClean在清理开始和结束时执行。如果是重新编译，那么也会有 Clean 的过程。顺序见上面。BeforePublish, AfterPublish在发布之前执行和发布之后执行。对应到 Visual Studio 右键菜单中的发布按钮。BeforeResolveReference, AfterResolveReferences在程序集的引用被解析之前和之后执行。你可以通过重写这两个时机的 Target 来修改程序集的引用关系或者利用引用执行一些其他操作。BeforeResGen, AfterResGen在资源被生成之前和之后执行。通过改写 DependsOn 的值扩展编译有这些预定义的 DependsOn 可以改写： BuildDependsOn CleanDependsOn CompileDependsOn这几个属性的时机跟上面是一样的，你可以直接通过阅读上面一节中对应名字的 Target 的解释来获得这几个属性所对应的时机。而这几个属性影响编译过程的写法是这样的：&amp;lt;PropertyGroup&amp;gt; &amp;lt;BuildDependsOn&amp;gt;WalterlvDemoTarget1;$(BuildDependsOn);WalterlvDemoTarget1&amp;lt;/BuildDependsOn&amp;gt;&amp;lt;/PropertyGroup&amp;gt;&amp;lt;Target Name=&quot;WalterlvDemoTarget1&quot;&amp;gt; &amp;lt;Message Text=&quot;正在运行 WalterlvDemoTarget1……&quot;/&amp;gt; &amp;lt;/Target&amp;gt; &amp;lt;Target Name=&quot;WalterlvDemoTarget1&quot;&amp;gt; &amp;lt;Message Text=&quot;正在运行 WalterlvDemoTarget2……&quot;/&amp;gt; &amp;lt;/Target&amp;gt;更推荐使用 DependsOn 属性的改写而不是像本文第一节那样直接重写 Target，是因为一个 Target 的重写很容易被不同的开发小伙伴覆盖。比如一个小伙伴在一处代码里面写了一个 Target，但另一个小伙伴不知道，在另一个地方也写了相同名字的 Target，那么这两个 Target 也会相互覆盖，导致其中的一个失效。虽然同名的属性跟 Target 一样的会被覆盖，但是我们可以通过在改写属性的值的时候同时获取这个属性之前设置的值，可以把以前的值保留下来。正如上面的例子那样，我们通过写了两个新的 Target 的名字，分别叠加到 $(BuildDependsOn) 这个属性原有值的两边，使得我们可以在编译前后执行两个不同的 Target。如果有其他的小伙伴使用了相同的方式去改写这个属性的值，那么它获取原有值的时候就会把这里已经赋过的值放入到它新的值的中间。也就是说，一个也不会丢。参考资料 Extend the build process - Visual Studio - Microsoft Docs c# - Determine if MSBuild CoreCompile will run and call custom target - Stack Overflow" }, { "title": "在 Target 中获取项目引用的所有依赖（dll/NuGet/Project）的路径", "url": "/post/resolve-project-references-using-target.html", "categories": "", "tags": "msbuild, visualstudio", "date": "2019-03-04 22:15:01 +0800", "snippet": "在项目编译成 dll 之前，如何分析项目的所有依赖呢？可以在在项目的 Target 中去收集项目的依赖。本文将说明如何在 Target 中收集项目依赖的所有 dll 的文件路径。编写 Target&amp;lt;Target Name=&quot;WalterlvDemoTarget&quot; BeforeTargets=&quot;CoreCompile&quot;&amp;gt; &amp;lt;Message Text=&quot;References:&quot; /&amp;gt; &amp;lt;Message Text=&quot;@(Reference)&quot; /&amp;gt; &amp;lt;/Target&amp;gt;这个 Target 的作用是将项目的所有 Reference 节点作为集合输出出来。然而实际上如果真的编译这个项目，会发现我们得到的结果有一些问题： 实际上其值就是写到每一个 Reference 里面的字符串的集合 比如引用了 System.Xaml，那么这里就会是 System.Xaml 如果引用是通过 ProjectReference 进行的项目引用，那么这里就没有目标项目的 dll所以，我们需要一个新的属性来查找引用的 dll。通过 研究 Microsoft.NET.Sdk 的源码，我发现有 ReferencePath 属性可以使用，于是将 Target 改为这样：&amp;lt;Target Name=&quot;WalterlvDemoTarget&quot; BeforeTargets=&quot;CoreCompile;ResolveAssemblyReference&quot;&amp;gt; &amp;lt;Message Text=&quot;ReferencePaths:&quot; /&amp;gt; &amp;lt;Message Text=&quot;@(ReferencePath)&quot; /&amp;gt; &amp;lt;/Target&amp;gt;现在得到的所有依赖字符串则没有以上的问题。注意，我在 BeforeTargets 上增加了一个 ResolveAssemblyReference。以上 Target 的输出引用通常很多，所以我将以上的输出单独放到这里来，避免影响到上面一节知识的阅读。Reference 的输出可以看到，Reference 的输出几乎就是 Reference 中写的字符串本身。CefSharp, Version=57.0.0.0, Culture=neutral, PublicKeyToken=40c4b6fc221f4138, processorArchitecture=x86CefSharp.Core, Version=57.0.0.0, Culture=neutral, PublicKeyToken=40c4b6fc221f4138, processorArchitecture=x86CefSharp.WinForms, Version=57.0.0.0, Culture=neutral, PublicKeyToken=40c4b6fc221f4138, processorArchitecture=x86Microsoft.Expression.Interactions, Version=4.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSILSystem.IO.Compression.FileSystemSystem.Windows.Interactivity, Version=4.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSILWindowsFormsIntegrationC:\\Users\\walterlv\\.nuget\\packages\\walterlv.demopackage\\1.0.0.0\\lib\\net47\\Walterlv.DemoPackageLibrary.dllPresentationCoreSystem.ComponentModel.CompositionSystem.ConfigurationSystem.Windows.FormsWindowsBasePresentationFrameworkSystem.XamlSystem.ServiceModelSystemSystem.DataSystem.Data.DataSetExtensionsSystem.ManagementSystem.Net.HttpSystem.Runtime.SerializationSystem.ServiceProcessSystem.WebSystem.XmlSystem.Xml.LinqSystem.DrawingMicrosoft.CSharpSystem.CoreReferencePath 的输出可以看到，ReferencePath 则是将所有的 dll 的路径也输出了，而且即便是项目引用，项目编译好的 dll 的路径也在。D:\\Walterlv\\Demo\\Walterlv.Demo\\Code\\_Externals\\Refs\\Cef\\x86\\CefSharp.Core.dllD:\\Walterlv\\Demo\\Walterlv.Demo\\Code\\_Externals\\Refs\\Cef\\x86\\CefSharp.dllD:\\Walterlv\\Demo\\Walterlv.Demo\\Code\\_Externals\\Refs\\Cef\\x86\\CefSharp.WinForms.dllC:\\Users\\walterlv\\.nuget\\packages\\walterlv.demopackage\\1.0.0.0\\lib\\net47\\Walterlv.DemoPackageLibrary.dllD:\\Walterlv\\Demo\\Walterlv.Demo\\Walterlv.Library1\\bin\\Debug\\Walterlv.Library1.dllD:\\Walterlv\\Demo\\Walterlv.Demo\\Walterlv.Library2\\bin\\Debug\\Walterlv.Library2.dllD:\\Walterlv\\Demo\\Walterlv.Demo\\Walterlv.Library3\\bin\\Debug\\Walterlv.Library3.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\Microsoft.CSharp.dllD:\\Walterlv\\Demo\\Walterlv.Demo\\Code\\_Externals\\Refs\\Microsoft.Expression.Interactions.dllC:\\Users\\walterlv\\.nuget\\packages\\windowsapicodepackshell\\1.1.0.8\\lib\\NET45\\Microsoft.WindowsAPICodePack.dllC:\\Users\\walterlv\\.nuget\\packages\\windowsapicodepackshell\\1.1.0.8\\lib\\NET45\\Microsoft.WindowsAPICodePack.Shell.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\mscorlib.dllC:\\Users\\walterlv\\.nuget\\packages\\newtonsoft.json\\11.0.2\\lib\\net45\\Newtonsoft.Json.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\PresentationCore.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\PresentationFramework.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\System.ComponentModel.Composition.dllC:\\Users\\walterlv\\.nuget\\packages\\system.composition.attributedmodel\\1.0.31\\lib\\portable-net45+win8+wp8+wpa81\\System.Composition.AttributedModel.dllC:\\Users\\walterlv\\.nuget\\packages\\system.composition.convention\\1.0.31\\lib\\portable-net45+win8+wp8+wpa81\\System.Composition.Convention.dllC:\\Users\\walterlv\\.nuget\\packages\\system.composition.hosting\\1.0.31\\lib\\portable-net45+win8+wp8+wpa81\\System.Composition.Hosting.dllC:\\Users\\walterlv\\.nuget\\packages\\system.composition.runtime\\1.0.31\\lib\\portable-net45+win8+wp8+wpa81\\System.Composition.Runtime.dllC:\\Users\\walterlv\\.nuget\\packages\\system.composition.typedparts\\1.0.31\\lib\\portable-net45+win8+wp8+wpa81\\System.Composition.TypedParts.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\System.Configuration.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\System.Core.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\System.Data.DataSetExtensions.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\System.Data.dllC:\\Users\\walterlv\\.nuget\\packages\\system.data.sqlite.core\\1.0.97\\lib\\net45\\System.Data.SQLite.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\System.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\System.Drawing.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\System.IO.Compression.FileSystem.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\System.Management.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\System.Net.Http.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\System.Runtime.Serialization.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\System.ServiceModel.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\System.ServiceProcess.dllC:\\Users\\walterlv\\.nuget\\packages\\system.valuetuple\\4.5.0\\ref\\portable-net40+sl4+win8+wp8\\System.ValueTuple.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\System.Web.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\System.Windows.Forms.dllD:\\Walterlv\\Demo\\Walterlv.Demo\\Code\\_Externals\\Refs\\System.Windows.Interactivity.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\System.Xaml.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\System.Xml.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\System.Xml.Linq.dllC:\\Users\\walterlv\\.nuget\\packages\\texteditorplus\\1.0.0.903\\lib\\NET45\\TextEditorPlus.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\WindowsBase.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\WindowsFormsIntegration.dllC:\\Users\\walterlv\\.nuget\\packages\\wpfmediakit\\3.0.2.78\\lib\\NET45\\WPFMediaKit.dllobj\\Debug\\Interop.IWshRuntimeLibrary.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\Facades\\System.Collections.Concurrent.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\Facades\\System.Collections.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\Facades\\System.ComponentModel.Annotations.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\Facades\\System.ComponentModel.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\Facades\\System.ComponentModel.EventBasedAsync.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\Facades\\System.Diagnostics.Contracts.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\Facades\\System.Diagnostics.Debug.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\Facades\\System.Diagnostics.Tools.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\Facades\\System.Diagnostics.Tracing.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\Facades\\System.Dynamic.Runtime.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\Facades\\System.Globalization.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\Facades\\System.IO.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\Facades\\System.Linq.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\Facades\\System.Linq.Expressions.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\Facades\\System.Linq.Parallel.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\Facades\\System.Linq.Queryable.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\Facades\\System.Net.NetworkInformation.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\Facades\\System.Net.Primitives.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\Facades\\System.Net.Requests.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\Facades\\System.ObjectModel.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\Facades\\System.Reflection.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\Facades\\System.Reflection.Emit.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\Facades\\System.Reflection.Emit.ILGeneration.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\Facades\\System.Reflection.Emit.Lightweight.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\Facades\\System.Reflection.Extensions.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\Facades\\System.Reflection.Primitives.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\Facades\\System.Resources.ResourceManager.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\Facades\\System.Runtime.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\Facades\\System.Runtime.Extensions.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\Facades\\System.Runtime.InteropServices.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\Facades\\System.Runtime.InteropServices.WindowsRuntime.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\Facades\\System.Runtime.Numerics.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\Facades\\System.Runtime.Serialization.Json.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\Facades\\System.Runtime.Serialization.Primitives.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\Facades\\System.Runtime.Serialization.Xml.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\Facades\\System.Security.Principal.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\Facades\\System.ServiceModel.Duplex.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\Facades\\System.ServiceModel.Http.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\Facades\\System.ServiceModel.NetTcp.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\Facades\\System.ServiceModel.Primitives.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\Facades\\System.ServiceModel.Security.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\Facades\\System.Text.Encoding.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\Facades\\System.Text.Encoding.Extensions.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\Facades\\System.Text.RegularExpressions.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\Facades\\System.Threading.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\Facades\\System.Threading.Tasks.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\Facades\\System.Threading.Tasks.Parallel.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\Facades\\System.Xml.ReaderWriter.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\Facades\\System.Xml.XDocument.dllC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.5\\Facades\\System.Xml.XmlSerializer.dll解读原因解析引用的 dll 的路径的 Task 是 ResolveAssemblyReference，你可以在 Microsoft.NET.Sdk 文件夹 中找到它。如果想知道 Task 是什么意思，可以阅读：理解 C# 项目 csproj 文件格式的本质和编译流程。&amp;lt;ResolveAssemblyReference Assemblies=&quot;@(Reference)&quot; AssemblyFiles=&quot;@(_ResolvedProjectReferencePaths);@(_ExplicitReference)&quot; TargetFrameworkDirectories=&quot;@(_ReferenceInstalledAssemblyDirectory)&quot; InstalledAssemblyTables=&quot;@(InstalledAssemblyTables);@(RedistList)&quot; IgnoreDefaultInstalledAssemblyTables=&quot;$(IgnoreDefaultInstalledAssemblyTables)&quot; IgnoreDefaultInstalledAssemblySubsetTables=&quot;$(IgnoreInstalledAssemblySubsetTables)&quot; CandidateAssemblyFiles=&quot;@(Content);@(None)&quot; SearchPaths=&quot;$(AssemblySearchPaths)&quot; AllowedAssemblyExtensions=&quot;$(AllowedReferenceAssemblyFileExtensions)&quot; AllowedRelatedFileExtensions=&quot;$(AllowedReferenceRelatedFileExtensions)&quot; TargetProcessorArchitecture=&quot;$(ProcessorArchitecture)&quot; AppConfigFile=&quot;@(_ResolveAssemblyReferencesApplicationConfigFileForExes)&quot; AutoUnify=&quot;$(AutoUnifyAssemblyReferences)&quot; SupportsBindingRedirectGeneration=&quot;$(GenerateBindingRedirectsOutputType)&quot; IgnoreVersionForFrameworkReferences=&quot;$(IgnoreVersionForFrameworkReferences)&quot; FindDependencies=&quot;$(_FindDependencies)&quot; FindSatellites=&quot;$(BuildingProject)&quot; FindSerializationAssemblies=&quot;$(BuildingProject)&quot; FindRelatedFiles=&quot;$(BuildingProject)&quot; Silent=&quot;$(ResolveAssemblyReferencesSilent)&quot; TargetFrameworkVersion=&quot;$(TargetFrameworkVersion)&quot; TargetFrameworkMoniker=&quot;$(TargetFrameworkMoniker)&quot; TargetFrameworkMonikerDisplayName=&quot;$(TargetFrameworkMonikerDisplayName)&quot; TargetedRuntimeVersion=&quot;$(TargetedRuntimeVersion)&quot; StateFile=&quot;$(ResolveAssemblyReferencesStateFile)&quot; InstalledAssemblySubsetTables=&quot;@(InstalledAssemblySubsetTables)&quot; TargetFrameworkSubsets=&quot;@(_ReferenceInstalledAssemblySubsets)&quot; FullTargetFrameworkSubsetNames=&quot;$(FullReferenceAssemblyNames)&quot; FullFrameworkFolders=&quot;$(_FullFrameworkReferenceAssemblyPaths)&quot; FullFrameworkAssemblyTables=&quot;@(FullFrameworkAssemblyTables)&quot; ProfileName=&quot;$(TargetFrameworkProfile)&quot; LatestTargetFrameworkDirectories=&quot;@(LatestTargetFrameworkDirectories)&quot; CopyLocalDependenciesWhenParentReferenceInGac=&quot;$(CopyLocalDependenciesWhenParentReferenceInGac)&quot; DoNotCopyLocalIfInGac=&quot;$(DoNotCopyLocalIfInGac)&quot; ResolvedSDKReferences=&quot;@(ResolvedSDKReference)&quot; WarnOrErrorOnTargetArchitectureMismatch=&quot;$(ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch)&quot; IgnoreTargetFrameworkAttributeVersionMismatch =&quot;$(ResolveAssemblyReferenceIgnoreTargetFrameworkAttributeVersionMismatch)&quot; FindDependenciesOfExternallyResolvedReferences=&quot;$(FindDependenciesOfExternallyResolvedReferences)&quot; ContinueOnError=&quot;$(ContinueOnError)&quot; Condition=&quot;&#39;@(Reference)&#39;!=&#39;&#39; or &#39;@(_ResolvedProjectReferencePaths)&#39;!=&#39;&#39; or &#39;@(_ExplicitReference)&#39; != &#39;&#39;&quot; &amp;gt; &amp;lt;Output TaskParameter=&quot;ResolvedFiles&quot; ItemName=&quot;ReferencePath&quot;/&amp;gt; &amp;lt;Output TaskParameter=&quot;ResolvedFiles&quot; ItemName=&quot;_ResolveAssemblyReferenceResolvedFiles&quot;/&amp;gt; &amp;lt;Output TaskParameter=&quot;ResolvedDependencyFiles&quot; ItemName=&quot;ReferenceDependencyPaths&quot;/&amp;gt; &amp;lt;Output TaskParameter=&quot;RelatedFiles&quot; ItemName=&quot;_ReferenceRelatedPaths&quot;/&amp;gt; &amp;lt;Output TaskParameter=&quot;SatelliteFiles&quot; ItemName=&quot;ReferenceSatellitePaths&quot;/&amp;gt; &amp;lt;Output TaskParameter=&quot;SerializationAssemblyFiles&quot; ItemName=&quot;_ReferenceSerializationAssemblyPaths&quot;/&amp;gt; &amp;lt;Output TaskParameter=&quot;ScatterFiles&quot; ItemName=&quot;_ReferenceScatterPaths&quot;/&amp;gt; &amp;lt;Output TaskParameter=&quot;CopyLocalFiles&quot; ItemName=&quot;ReferenceCopyLocalPaths&quot;/&amp;gt; &amp;lt;Output TaskParameter=&quot;SuggestedRedirects&quot; ItemName=&quot;SuggestedBindingRedirects&quot;/&amp;gt; &amp;lt;Output TaskParameter=&quot;FilesWritten&quot; ItemName=&quot;FileWrites&quot;/&amp;gt; &amp;lt;Output TaskParameter=&quot;DependsOnSystemRuntime&quot; PropertyName=&quot;DependsOnSystemRuntime&quot;/&amp;gt; &amp;lt;Output TaskParameter=&quot;DependsOnNETStandard&quot; PropertyName=&quot;_DependsOnNETStandard&quot;/&amp;gt;&amp;lt;/ResolveAssemblyReference&amp;gt;从这个 Task 中可以看出，它还输出了以下这些属性或集合： ReferenceDependencyPaths ReferenceSatellitePaths ReferenceCopyLocalPaths 这是需要拷贝到本地的那些 dll 的路径（不含框架自带的 dll） SuggestedBindingRedirects FileWrites 要写入的一些缓存文件 DependsOnSystemRuntime 以上都是集合，唯独这是一个布尔值，表示是否依赖系统运行时 " }, { "title": "如何在命令行中监听用户输入文本的改变？", "url": "/post/notify-text-changed-when-typing-in-console-application.html", "categories": "", "tags": "dotnet, csharp", "date": "2019-03-04 22:14:42 +0800", "snippet": "这真是一个诡异的需求。为什么我需要在命令行中得知用户输入文字的改变啊！实际上我希望实现的是：在命令行中输入一段文字，然后不断地将这段文字发往其他地方。本文将介绍如何监听用户在命令行中输入文本的改变。在命令行中输入有三种不同的方法： Console.Read() 用户可以一直输入，在用户输入回车之前，此方法都会一直阻塞。而一旦用户输入了回车，你后面的 Console.Read 就不会一直阻塞了，直到把用户在这一行输入的文字全部读完。 Console.ReadKey() 用户输入之前此方法会一直阻塞，用户只要按下任何一个键这个方法都会返回并得到用户按下的按键信息。 Console.ReadLine() 用户可以一直输入，在用户输入回车之前，此方法都会一直阻塞。当用户输入了回车之后，此方法会返回用户在这一行输入的字符串。 从表面上来说，以上这三个方法都不能满足我们的需求，每一个方法都不能直接监听用户的输入文本改变。尤其是 Console.Read() 和 Console.ReadLine() 方法，在用户输入回车之前，我们都得不到任何信息。看起来我们似乎只能通过 Console.ReadKey() 来完成我们的需求了。但是，一旦我们使用了 Console.ReadKey()，我们将不能获得另外两个方法中的输入体验。例如，我们按下退格键（BackSpace）可以删除光标的前一个字符，按下删除键（Delete）可以删除光标的后一个字符，按下左右键可以移动光标到合适的文本上。然而，不幸的是，除了这三个方法，我们还真的没有原生的方法来实现命令行的输入监听了。所以看样子我们需要自己来使用 Console.ReadKey() 实现用户输入文字的监听了。我在 如何让 .NET Core 命令行程序接受密码的输入而不显示密码明文 - walterlv 一问中有说到如何在命令行中输入密码而不会显示明文。我们用到的就是此博客中所述的方法。var builder = new StringBuilder();while (true){ var i = Console.ReadKey(true); if (i.Key == ConsoleKey.Enter) { Console.WriteLine(); // 用户在这里输入了回车，于是我们需要结束输入了。 } if (i.Key == ConsoleKey.Backspace) { if (builder.Length &amp;gt; 0) { Console.Write(&quot;\\b \\b&quot;); builder.Remove(builder.Length - 1, 1); } } else { builder.Append(i.KeyChar); Console.Write(i.KeyChar); }}然而实际上在使用此方法的时候并不符合预期，因为退格的时候我们得到了半个字：额外的，我们还不支持左右键移动光标，而且按住控制键的时候也会输入一个字符；这些都是我还没有处理的。这就意味着我们使用 &quot;\\b \\b&quot; 来删除我们输入的字符的时候，有可能在一些字符的情况下我们需要删除两个字符宽度。然而如何获取一个字的字符宽度呢？还是很复杂的。于是我很暴力地使用 OnChar函数的中文处理问题，退格键时，怎么处理-CSDN论坛 论坛中使用的方法直接通过编码范围判断中文的方式来推测字符宽度。如果你有更正统的方法，非常欢迎指导我。简单起见，我写了一个类来封装输入文本改变。阅读以下代码，或者访问 Walterlv.CloudKeyboard/ConsoleLineReader.cs 阅读此类型的最新版本的代码。using System;using System.Text;namespace Walterlv.Demo{ public sealed class ConsoleLineReader { public event EventHandler&amp;lt;ConsoleTextChangedEventArgs&amp;gt; TextChanged; public string ReadLine() { var builder = new StringBuilder(); while (true) { var i = Console.ReadKey(true); if (i.Key == ConsoleKey.Enter) { var line = builder.ToString(); OnTextChanged(line, i.Key); Console.WriteLine(); return line; } if (i.Key == ConsoleKey.Backspace) { if (builder.Length &amp;gt; 0) { var lastChar = builder[builder.Length - 1]; Console.Write(lastChar &amp;gt; 0xA0 ? &quot;\\b\\b \\b\\b&quot; : &quot;\\b \\b&quot;); builder.Remove(builder.Length - 1, 1); } } else { builder.Append(i.KeyChar); Console.Write(i.KeyChar); } OnTextChanged(builder.ToString(), i.Key); } } private void OnTextChanged(string line, ConsoleKey key) { TextChanged?.Invoke(this, new ConsoleTextChangedEventArgs(line, key)); } } public class ConsoleTextChangedEventArgs : EventArgs { public ConsoleTextChangedEventArgs(string line, ConsoleKey consoleKey) { Line = line; ConsoleKey = consoleKey; } public string Line { get; } public ConsoleKey ConsoleKey { get; } }}那么使用的时候，则会简单很多：var reader = new ConsoleLineReader();reader.TextChanged += (sender, args) =&amp;gt;{ // 这里可以在用户每次输入的文本改变的时候执行。};while (true){ // 我在这里循环执行，于是即便用户按了回车，也会继续输入。 reader.ReadLine();}参考资料 StreamReader.cs windows - How to backspace the characters in the cmd buffer? - Super User Console.KeyAvailable Property (System) - Microsoft Docs OnChar函数的中文处理问题，退格键时，怎么处理-CSDN论坛" }, { "title": "仅反射加载（ReflectionOnlyLoadFrom）的 .NET 程序集，如何反射获取它的 Attribute 元数据呢？", "url": "/post/get-attributes-for-reflection-only-loaded-assembly.html", "categories": "", "tags": "dotnet, csharp", "date": "2019-03-04 22:14:26 +0800", "snippet": "平时我们获取一个程序集或者类型的 Attribute 是非常轻松的，只需要通过 GetCustomAttribute 方法就能拿到实例然后获取其中的值。但是，有时我们仅为反射加载一些程序集的时候，获取这些元数据就不那么简单了，因为我们没有加载目标程序集中的类型。本文介绍如何为仅反射加载的程序集读取 Attribute 元数据信息。仅反射加载一个程序集使用 ReflectionOnlyLoadFrom 可以仅以反射的方式加载一个程序集。var extensionFilePath = @&quot;C:\\Users\\walterlv\\Desktop\\Walterlv.Extension.dll&quot;;var assembly = Assembly.ReflectionOnlyLoadFrom(extensionFilePath);获取程序集的 Attribute（例如获取程序集版本号）Assembly.GetCustomAttributesData() 得到的是一个 CustomAttributeData 的列表，而这个列表中的每一项都与普通反射中拿到的特性集合不同，这里拿到的只是特性的信息（以下循环中的 data 变量）。CustomAttributeData 中有 AttributeType 属性，虽然此属性是 Type 类型的，但是实际上它只会是 RuntimeType 类型，而不会是真实的 Attribute 的类型（因为不能保证宿主程序域中已经加载了那个类型）。var customAttributesData = assembly.GetCustomAttributesData();foreach (CustomAttributeData data in customAttributesData){ // 这里可以针对每一个拿到的慝的信息进行操作。}比如我们要获取这个程序集的版本号，正常我们写 assembly.GetCustomAttribute&amp;lt;AssemblyFileVersionAttribute&amp;gt;().Version，但是这里我们无法生成 AssemblyFileVersionAttribute 的实例，我们只能这么写：var versionString = assembly.GetCustomAttributesData() .FirstOrDefault(x =&amp;gt; x.AttributeType.FullName == typeof(AssemblyFileVersionAttribute).FullName) ?.ConstructorArguments[0].Value as string ?? &quot;0.0&quot;;var version = new Version(versionString);代码解读是这样的： 我们从拿到的所有的 Attribute 元数据中找到第一个名称与 AssemblyFileVersionAttribute 相同的数据； 从数据的构造函数参数中找到传入的参数值，而这个值就是我们定义 AssemblyFileVersionAttribute 时传入的参数的实际值。因为我们知道 AssemblyFileVersionAttribute 的构造函数只有一个，所以我们确信可以从第一个参数中拿到我们想要的值。顺便一提，我们使用 AssemblyFileVersionAttribute 而不是使用 AssemblyVersionAttribute 是因为使用 .NET Core 新格式（基于 Microsoft.NET.Sdk）编译出来的程序集默认是不带 AssemblyVersionAttribute 的。详见：语义版本号（Semantic Versioning） - walterlv。参考资料 CustomAttributeData Class (System.Reflection) - Microsoft Docs c# - How to get custom attributes from an assembly that is not (really) loaded - Stack Overflow c# - Get custom attribute data from assembly file and unlock it afterwise - Stack Overflow" }, { "title": "使用 Visual Studio 自定义外部命令 (External Tools) 快速打开 git bash 等各种工具", "url": "/post/customize-external-tools-for-visual-studio.html", "categories": "", "tags": "visualstudio", "date": "2019-03-04 11:06:33 +0800", "snippet": "Visual Studio 支持自定义的外部命令，于是即便 Visual Studio 原生没有的功能，插件没有提供的功能，你也能仅仅通过配置就实现。比如，我们可以一键打开 Git Bash 输入 git 命令，比如可以一键打开项目或者文件所在的文件夹。本文将教你如何自定义 Visual Studio 的外部命令，并提供一些我自己正在使用的外部命令配置。看，就是一键的按钮！所以，你想不想也在 Visual Studio 的工具栏上增加高效率的功能按钮呢？ 一键打开 Git Bash 一键打开解决方案所在文件夹 一键 Blame 正在打开的文件 (话说 VS17 的 Blame 功能也没好到哪儿去，还是得 TortoiseGit)我们开始吧！第一步：自定义外部命令打开 [工具] -&amp;gt; [外部命令]，然后在新打开的对话框中编辑外部命令。为了方便，我把我自己正在用的几个外部命令分享给大家： 用于一键打开 Git Bash，以便快速输入 git 命令 [Title] 打开 Git Bash [Command] C:\\Program Files\\Git\\git-bash.exe [Arguments] --cd=&quot;$(SolutionDir)\\.&quot; [InitialDirectory] &quot;$(SolutionDir)&quot; 用于快速打开解决方案所在的文件夹（通常这也是 git 仓库的根目录） [Title] 在资源管理器中查看此解决方案 [Command] C:\\Windows\\explorer.exe [Arguments] /select,&quot;$(SolutionDir)$(SolutionFileName)&quot; [InitialDirectory] &quot;$(SolutionDir)&quot; 用于快速打开当前正在编辑的文件所在的文件夹 [Title] 在资源管理器中查看此文件 [Command] C:\\Windows\\explorer.exe [Arguments] /select,&quot;$(ItemPath)&quot; [InitialDirectory] &quot;$(ItemDir)&quot; 使用 VSCode 打开此解决方案（这可以用来快速编辑某些 VS 中不方便编辑的文件） [Title] 使用 VSCode 编辑 [Command] %LocalAppData%\\Programs\\Microsoft VS Code\\Code.exe [Arguments] &quot;$(SolutionDir)&quot; [InitialDirectory] &quot;$(SolutionDir)&quot; 使用 TortoiseGit 来 Blame 此文件（而且还会自动定位到当前行） [Title] 追溯此文件 [Command] C:\\Program Files\\TortoiseGit\\bin\\TortoiseGitBlame.exe [Arguments] &quot;$(ItemPath)&quot; /line:$(CurLine) [InitialDirectory] &quot;$(ItemDir)&quot; 使用 TortoiseGit 来查看此文件的 git 日志 [Title] 查看此文件的历史记录 [Command] C:\\Program Files\\TortoiseGit\\bin\\TortoiseGitProc.exe [Arguments] /command:log /path:&quot;$(ItemPath)&quot; [InitialDirectory] &quot;$(ItemDir)&quot; 第二步：自定义工具条按钮点击工具条最右侧的小箭头，然后添加删除按钮，在长长的下拉框的最后，有一个“自定义”菜单项。打开，我们接下来的操作都在这里面。随后，按照下图操作添加一个外部命令。注意，外部命令的序号从 1 开始，就是我们在上一节外部命令框中那些命令的序号。然后，编辑这个外部命令。在一个个添加完成之后，Visual Studio 的顶部工具栏中就会出现我们刚刚添加的各种外部命令了。点击可以一键使用相应的功能。" }, { "title": "让你的 Windows 应用程序在任意路径也能够直接通过文件名执行", "url": "/post/run-your-application-without-full-executable-path.html", "categories": "", "tags": "windows", "date": "2019-03-02 19:07:48 +0800", "snippet": "我们可以在任何路径下输入 explorer 来启动资源管理器，可以在任何路径中输入 git 来使用 git 相关的命令。我们知道可以通过将一个应用程序加入到环境变量中来获得这个效果，但是还有其他的方式吗？我们将这个过程称之为向 Windows 注册一个应用程序路径。本文介绍向 Windows 注册一个应用程序路径的各种方法。Windows 如何查找程序路径？当我们在任意目录中输入一个命令的时候，Windows 会按照如下顺序寻找这个命令对应的可执行程序： 当前的工作目录 Windows 文件夹（仅此文件夹，不会搜索子文件夹） Windows\\System32 文件夹 环境变量 Path 值中的所有文件夹 注册表 HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths微软 推荐使用 App Paths 即修改此注册表项来添加可执行程序。当然，你也可以使用当前用户键下的注册表项来实现同样的目的，程序使用当前用户路径写注册表是不需要管理员权限的。HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\App Paths。使用 App Paths 添加可执行程序在注册表中打开 HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths 子键，你可以在里面找到当前通过此方法注册的所有可执行程序。比如下图是 PowerShell Core 的 msi 包安装后添加的 pwsh.exe 键。现在我们添加一个我们自己开发的程序 walterlv.exe，于是就直接在 App Paths 子键下添加一个 walterlv.exe 的键，并将其默认值设为 walterlv.exe 的完整路径。参考资料 Application Registration - Windows applications - Microsoft Docs" }, { "title": "编写 MSBuild 内联编译任务（Task）用于获取当前编译环境下的所有编译目标（Target）", "url": "/post/write-a-msbuild-inline-task-for-getting-all-targets.html", "categories": "", "tags": "msbuild, dotnet, visualstudio, csharp", "date": "2019-03-01 15:35:27 +0800", "snippet": "我之前写过一些改变 MSBuild 编译过程的一些博客，包括利用 Microsoft.NET.Sdk 中各种自带的 Task 来执行各种各样的编译任务。更复杂的任务难以直接利用自带的 Task 实现，需要自己写 Task。本文将编写一个内联的编译任务，获取当前编译环境下的所有编译目标（Target）。获取所有的这些 Target 对我们调试一些与 MSBuild 或编译相关的问题时可能带来一些帮助。编写纯 C# 版本编译任务获取所有编译目标（Target）的代码是这样的：using Microsoft.Build.Evaluation;using Microsoft.Build.Execution;using Microsoft.Build.Utilities;using Microsoft.Build.Framework;public class WalterlvGetAllTargets : Task{ public string ProjectFile { get; set; } public ITaskItem[] WalterlvTargets { get; set; } public override bool Execute() { var project = new Project(ProjectFile); var taskItems = new List&amp;lt;ITaskItem&amp;gt;(project.Targets.Count); foreach (KeyValuePair&amp;lt;string, ProjectTargetInstance&amp;gt; pair in project.Targets) { var target = pair.Value; var metadata = new Dictionary&amp;lt;string, string&amp;gt; { { &quot;Condition&quot;, target.Condition }, { &quot;Inputs&quot;, target.Inputs }, { &quot;Outputs&quot;, target.Outputs }, { &quot;DependsOnTargets&quot;, target.DependsOnTargets } }; taskItems.Add(new TaskItem(pair.Key, metadata)); } WalterlvTargets = taskItems.ToArray(); return true; }}那么转换成内联版本下面这样。为了方便验证，我直接把完整的 csproj 文件贴出来了。如果你希望在你的项目中去使用，可以只复制 UsingTask 和 Target 两个部分。&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;OutputType&amp;gt;Exe&amp;lt;/OutputType&amp;gt; &amp;lt;TargetFramework&amp;gt;net472&amp;lt;/TargetFramework&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;UsingTask TaskName=&quot;WalterlvGetAllTargets&quot; TaskFactory=&quot;CodeTaskFactory&quot; AssemblyFile=&quot;$(MSBuildToolsPath)\\Microsoft.Build.Tasks.v4.0.dll&quot; &amp;gt; &amp;lt;ParameterGroup&amp;gt; &amp;lt;!-- 内联 C# 代码的输入参数（Task 的输入属性），相当于 public string ProjectFile { get; set; } --&amp;gt; &amp;lt;ProjectFile ParameterType=&quot;System.String&quot; Required=&quot;true&quot;/&amp;gt; &amp;lt;!-- 内联 C# 代码的输出参数（Task 的输入属性），相当于 public ITaskItem[] WalterlvTargets { get; set; } --&amp;gt; &amp;lt;WalterlvTargets ParameterType=&quot;Microsoft.Build.Framework.ITaskItem[]&quot; Output=&quot;true&quot;/&amp;gt; &amp;lt;/ParameterGroup&amp;gt; &amp;lt;Task&amp;gt; &amp;lt;!-- 引用程序集。 --&amp;gt; &amp;lt;Reference Include=&quot;System.Xml&quot;/&amp;gt; &amp;lt;Reference Include=&quot;Microsoft.Build&quot;/&amp;gt; &amp;lt;Reference Include=&quot;Microsoft.Build.Framework&quot;/&amp;gt; &amp;lt;!-- 编写 C# 代码所用到的 using。 --&amp;gt; &amp;lt;Using Namespace=&quot;Microsoft.Build.Evaluation&quot;/&amp;gt; &amp;lt;Using Namespace=&quot;Microsoft.Build.Execution&quot;/&amp;gt; &amp;lt;Using Namespace=&quot;Microsoft.Build.Utilities&quot;/&amp;gt; &amp;lt;Using Namespace=&quot;Microsoft.Build.Framework&quot;/&amp;gt; &amp;lt;!-- 开始插入 C# 代码。 --&amp;gt; &amp;lt;Code Type=&quot;Fragment&quot; Language=&quot;cs&quot;&amp;gt; &amp;lt;![CDATA[ var project = new Project(ProjectFile); var taskItems = new List&amp;lt;ITaskItem&amp;gt;(project.Targets.Count); foreach (KeyValuePair&amp;lt;string, ProjectTargetInstance&amp;gt; pair in project.Targets) { var target = pair.Value; var metadata = new Dictionary&amp;lt;string, string&amp;gt; { { &quot;Condition&quot;, target.Condition }, { &quot;Inputs&quot;, target.Inputs }, { &quot;Outputs&quot;, target.Outputs }, { &quot;DependsOnTargets&quot;, target.DependsOnTargets } }; taskItems.Add(new TaskItem(pair.Key, metadata)); } WalterlvTargets = taskItems.ToArray(); ]]&amp;gt; &amp;lt;/Code&amp;gt; &amp;lt;/Task&amp;gt; &amp;lt;/UsingTask&amp;gt; &amp;lt;Target Name=&quot;WalterlvOutputAllTargets&quot; AfterTargets=&quot;Build&quot;&amp;gt; &amp;lt;!-- 执行刚刚写的内联 Task，然后获取它的输出参数 WalterlvTargets 并填充到 TargetItems 集合中。 --&amp;gt; &amp;lt;WalterlvGetAllTargets ProjectFile=&quot;$(MSBuildProjectFile)&quot;&amp;gt; &amp;lt;Output ItemName=&quot;TargetItems&quot; TaskParameter=&quot;WalterlvTargets&quot;/&amp;gt; &amp;lt;/WalterlvGetAllTargets&amp;gt; &amp;lt;!-- 用一个 Message 输出刚刚生成的 TargetItems 集合中每一项的 Identity 属性（集合中每一项都会输出。） --&amp;gt; &amp;lt;Message Text=&quot;输出的 Target：%(TargetItems.Identity)&quot;/&amp;gt; &amp;lt;/Target&amp;gt;&amp;lt;Project&amp;gt;现在使用 msbuild 命令进行编译，我们将看到所有 Target 的输出：WalterlvOutputAllTargets: 输出的 Target：OutputAll 输出的 Target：_CheckForUnsupportedTargetFramework 输出的 Target：_CollectTargetFrameworkForTelemetry 输出的 Target：_CheckForUnsupportedNETCoreVersion 输出的 Target：_CheckForUnsupportedNETStandardVersion 输出的 Target：_CheckForUnsupportedAppHostUsage 输出的 Target：_CheckForMismatchingPlatform 输出的 Target：_CheckForNETCoreSdkIsPreview 输出的 Target：AdjustDefaultPlatformTargetForNetFrameworkExeWithNoNativeCopyLocalItems 输出的 Target：CreateManifestResourceNames 输出的 Target：ResolveCodeAnalysisRuleSet 输出的 Target：XamlPreCompile 输出的 Target：ShimReferencePathsWhenCommonTargetsDoesNotUnderstandReferenceAssemblies 输出的 Target：_BeforeVBCSCoreCompile 输出的 Target：InitializeSourceRootMappedPaths 输出的 Target：_InitializeSourceRootMappedPathsFromSourceControl 输出的 Target：_SetPathMapFromSourceRoots 输出的 Target：CoreCompile 输出的 Target：ResolvePackageDependenciesDesignTime 输出的 Target：CollectSDKReferencesDesignTime 输出的 Target：CollectResolvedSDKReferencesDesignTime 输出的 Target：CollectPackageReferences 输出的 Target：_CheckCompileDesignTimePrerequisite 输出的 Target：CollectAnalyzersDesignTime 输出的 Target：CollectResolvedCompilationReferencesDesignTime 输出的 Target：CollectUpToDateCheckInputDesignTime 输出的 Target：CollectUpToDateCheckOutputDesignTime 输出的 Target：CollectUpToDateCheckBuiltDesignTime 输出的 Target：CompileDesignTime 输出的 Target：_FixVCLibs120References 输出的 Target：_AddVCLibs140UniversalCrtDebugReference 输出的 Target：InitializeSourceControlInformation 输出的 Target：_CheckForInvalidConfigurationAndPlatform 输出的 Target：Build 输出的 Target：BeforeBuild 输出的 Target：AfterBuild 输出的 Target：CoreBuild 输出的 Target：Rebuild 输出的 Target：BeforeRebuild 输出的 Target：AfterRebuild 输出的 Target：BuildGenerateSources 输出的 Target：BuildGenerateSourcesTraverse 输出的 Target：BuildCompile 输出的 Target：BuildCompileTraverse 输出的 Target：BuildLink 输出的 Target：BuildLinkTraverse 输出的 Target：CopyRunEnvironmentFiles 输出的 Target：Run 输出的 Target：BuildOnlySettings 输出的 Target：PrepareForBuild 输出的 Target：GetFrameworkPaths 输出的 Target：GetReferenceAssemblyPaths 输出的 Target：GetTargetFrameworkMoniker 输出的 Target：GetTargetFrameworkMonikerDisplayName 输出的 Target：GetTargetFrameworkDirectories 输出的 Target：AssignLinkMetadata 输出的 Target：PreBuildEvent 输出的 Target：UnmanagedUnregistration 输出的 Target：GetTargetFrameworkVersion 输出的 Target：ResolveReferences 输出的 Target：BeforeResolveReferences 输出的 Target：AfterResolveReferences 输出的 Target：AssignProjectConfiguration 输出的 Target：_SplitProjectReferencesByFileExistence 输出的 Target：_GetProjectReferenceTargetFrameworkProperties 输出的 Target：GetTargetFrameworks 输出的 Target：GetTargetFrameworkProperties 输出的 Target：PrepareProjectReferences 输出的 Target：ResolveProjectReferences 输出的 Target：ResolveProjectReferencesDesignTime 输出的 Target：ExpandSDKReferencesDesignTime 输出的 Target：GetTargetPath 输出的 Target：GetTargetPathWithTargetPlatformMoniker 输出的 Target：GetNativeManifest 输出的 Target：ResolveNativeReferences 输出的 Target：ResolveAssemblyReferences 输出的 Target：FindReferenceAssembliesForReferences 输出的 Target：GenerateBindingRedirects 输出的 Target：GenerateBindingRedirectsUpdateAppConfig 输出的 Target：GetInstalledSDKLocations 输出的 Target：ResolveSDKReferences 输出的 Target：ResolveSDKReferencesDesignTime 输出的 Target：FindInvalidProjectReferences 输出的 Target：GetReferenceTargetPlatformMonikers 输出的 Target：ExpandSDKReferences 输出的 Target：ExportWindowsMDFile 输出的 Target：ResolveAssemblyReferencesDesignTime 输出的 Target：DesignTimeResolveAssemblyReferences 输出的 Target：ResolveComReferences 输出的 Target：ResolveComReferencesDesignTime 输出的 Target：PrepareResources 输出的 Target：PrepareResourceNames 输出的 Target：AssignTargetPaths 输出的 Target：GetItemTargetPaths 输出的 Target：SplitResourcesByCulture 输出的 Target：CreateCustomManifestResourceNames 输出的 Target：ResGen 输出的 Target：BeforeResGen 输出的 Target：AfterResGen 输出的 Target：CoreResGen 输出的 Target：CompileLicxFiles 输出的 Target：ResolveKeySource 输出的 Target：Compile 输出的 Target：_GenerateCompileInputs 输出的 Target：GenerateTargetFrameworkMonikerAttribute 输出的 Target：GenerateAdditionalSources 输出的 Target：BeforeCompile 输出的 Target：AfterCompile 输出的 Target：_TimeStampBeforeCompile 输出的 Target：_GenerateCompileDependencyCache 输出的 Target：_TimeStampAfterCompile 输出的 Target：_ComputeNonExistentFileProperty 输出的 Target：GenerateSerializationAssemblies 输出的 Target：CreateSatelliteAssemblies 输出的 Target：_GenerateSatelliteAssemblyInputs 输出的 Target：GenerateSatelliteAssemblies 输出的 Target：ComputeIntermediateSatelliteAssemblies 输出的 Target：SetWin32ManifestProperties 输出的 Target：_SetExternalWin32ManifestProperties 输出的 Target：_SetEmbeddedWin32ManifestProperties 输出的 Target：_GenerateResolvedDeploymentManifestEntryPoint 输出的 Target：GenerateManifests 输出的 Target：GenerateApplicationManifest 输出的 Target：_DeploymentComputeNativeManifestInfo 输出的 Target：_DeploymentComputeClickOnceManifestInfo 输出的 Target：_DeploymentGenerateTrustInfo 输出的 Target：GenerateDeploymentManifest 输出的 Target：PrepareForRun 输出的 Target：CopyFilesToOutputDirectory 输出的 Target：_CopyFilesMarkedCopyLocal 输出的 Target：_CopySourceItemsToOutputDirectory 输出的 Target：GetCopyToOutputDirectoryItems 输出的 Target：GetCopyToPublishDirectoryItems 输出的 Target：_CopyOutOfDateSourceItemsToOutputDirectory 输出的 Target：_CopyOutOfDateSourceItemsToOutputDirectoryAlways 输出的 Target：_CopyAppConfigFile 输出的 Target：_CopyManifestFiles 输出的 Target：_CheckForCompileOutputs 输出的 Target：_SGenCheckForOutputs 输出的 Target：UnmanagedRegistration 输出的 Target：IncrementalClean 输出的 Target：_CleanGetCurrentAndPriorFileWrites 输出的 Target：Clean 输出的 Target：BeforeClean 输出的 Target：AfterClean 输出的 Target：CleanReferencedProjects 输出的 Target：CoreClean 输出的 Target：_CleanRecordFileWrites 输出的 Target：CleanPublishFolder 输出的 Target：PostBuildEvent 输出的 Target：Publish 输出的 Target：_DeploymentUnpublishable 输出的 Target：SetGenerateManifests 输出的 Target：PublishOnly 输出的 Target：BeforePublish 输出的 Target：AfterPublish 输出的 Target：PublishBuild 输出的 Target：_CopyFilesToPublishFolder 输出的 Target：_DeploymentGenerateBootstrapper 输出的 Target：_DeploymentSignClickOnceDeployment 输出的 Target：AllProjectOutputGroups 输出的 Target：BuiltProjectOutputGroup 输出的 Target：DebugSymbolsProjectOutputGroup 输出的 Target：DocumentationProjectOutputGroup 输出的 Target：SatelliteDllsProjectOutputGroup 输出的 Target：SourceFilesProjectOutputGroup 输出的 Target：GetCompile 输出的 Target：ContentFilesProjectOutputGroup 输出的 Target：SGenFilesOutputGroup 输出的 Target：GetResolvedSDKReferences 输出的 Target：CollectReferencedNuGetPackages 输出的 Target：PriFilesOutputGroup 输出的 Target：SDKRedistOutputGroup 输出的 Target：AllProjectOutputGroupsDependencies 输出的 Target：BuiltProjectOutputGroupDependencies 输出的 Target：DebugSymbolsProjectOutputGroupDependencies 输出的 Target：SatelliteDllsProjectOutputGroupDependencies 输出的 Target：DocumentationProjectOutputGroupDependencies 输出的 Target：SGenFilesOutputGroupDependencies 输出的 Target：ReferenceCopyLocalPathsOutputGroup 输出的 Target：SetCABuildNativeEnvironmentVariables 输出的 Target：RunCodeAnalysis 输出的 Target：RunNativeCodeAnalysis 输出的 Target：RunSelectedFileNativeCodeAnalysis 输出的 Target：RunMergeNativeCodeAnalysis 输出的 Target：ImplicitlyExpandDesignTimeFacades 输出的 Target：GetWinFXPath 输出的 Target：DesignTimeMarkupCompilation 输出的 Target：PrepareResourcesForSatelliteAssemblies 输出的 Target：_AfterCompileWinFXInternal 输出的 Target：AfterCompileWinFX 输出的 Target：AfterMarkupCompilePass1 输出的 Target：AfterMarkupCompilePass2 输出的 Target：MarkupCompilePass1 输出的 Target：MarkupCompilePass2 输出的 Target：_CompileTemporaryAssembly 输出的 Target：MarkupCompilePass2ForMainAssembly 输出的 Target：GenerateTemporaryTargetAssembly 输出的 Target：CleanupTemporaryTargetAssembly 输出的 Target：AddIntermediateAssemblyToReferenceList 输出的 Target：SatelliteOnlyMarkupCompilePass2 输出的 Target：HostInBrowserValidation 输出的 Target：SplashScreenValidation 输出的 Target：ResignApplicationManifest 输出的 Target：SignDeploymentManifest 输出的 Target：FileClassification 输出的 Target：MainResourcesGeneration 输出的 Target：SatelliteResourceGeneration 输出的 Target：GenerateResourceWithCultureItem 输出的 Target：CheckUid 输出的 Target：UpdateUid 输出的 Target：RemoveUid 输出的 Target：MergeLocalizationDirectives 输出的 Target：AssignWinFXEmbeddedResource 输出的 Target：EntityDeploy 输出的 Target：EntityDeploySplit 输出的 Target：EntityDeployNonEmbeddedResources 输出的 Target：EntityDeployEmbeddedResources 输出的 Target：EntityClean 输出的 Target：EntityDeploySetLogicalNames 输出的 Target：DesignTimeXamlMarkupCompilation 输出的 Target：InProcessXamlMarkupCompilePass1 输出的 Target：CleanInProcessXamlGeneratedFiles 输出的 Target：XamlMarkupCompileReadGeneratedFileList 输出的 Target：XamlMarkupCompilePass1 输出的 Target：XamlMarkupCompileAddFilesGenerated 输出的 Target：XamlMarkupCompileReadPass2Flag 输出的 Target：XamlTemporaryAssemblyGeneration 输出的 Target：CompileTemporaryAssembly 输出的 Target：XamlMarkupCompilePass2 输出的 Target：XamlMarkupCompileAddExtensionFilesGenerated 输出的 Target：GetCopyToOutputDirectoryXamlAppDefs 输出的 Target：ExpressionBuildExtension 输出的 Target：ValidationExtension 输出的 Target：GenerateCompiledExpressionsTempFile 输出的 Target：AddDeferredValidationErrorsFileToFileWrites 输出的 Target：ReportValidationBuildExtensionErrors 输出的 Target：DeferredValidation 输出的 Target：ResolveTestReferences 输出的 Target：CleanAppxPackage 输出的 Target：GetPackagingOutputs 输出的 Target：Restore 输出的 Target：GenerateRestoreGraphFile 输出的 Target：_LoadRestoreGraphEntryPoints 输出的 Target：_FilterRestoreGraphProjectInputItems 输出的 Target：_GenerateRestoreGraph 输出的 Target：_GenerateRestoreGraphProjectEntry 输出的 Target：_GenerateRestoreSpecs 输出的 Target：_GenerateDotnetCliToolReferenceSpecs 输出的 Target：_GetProjectJsonPath 输出的 Target：_GetRestoreProjectStyle 输出的 Target：EnableIntermediateOutputPathMismatchWarning 输出的 Target：_GetRestoreTargetFrameworksOutput 输出的 Target：_GetRestoreTargetFrameworksAsItems 输出的 Target：_GetRestoreSettings 输出的 Target：_GetRestoreSettingsCurrentProject 输出的 Target：_GetRestoreSettingsAllFrameworks 输出的 Target：_GetRestoreSettingsPerFramework 输出的 Target：_GenerateRestoreProjectSpec 输出的 Target：_GenerateProjectRestoreGraph 输出的 Target：_GenerateRestoreDependencies 输出的 Target：_GenerateProjectRestoreGraphAllFrameworks 输出的 Target：_GenerateProjectRestoreGraphCurrentProject 输出的 Target：_GenerateProjectRestoreGraphPerFramework 输出的 Target：_GenerateRestoreProjectPathItemsCurrentProject 输出的 Target：_GenerateRestoreProjectPathItemsPerFramework 输出的 Target：_GenerateRestoreProjectPathItems 输出的 Target：_GenerateRestoreProjectPathItemsAllFrameworks 输出的 Target：_GenerateRestoreProjectPathWalk 输出的 Target：_GetAllRestoreProjectPathItems 输出的 Target：_GetRestoreSettingsOverrides 输出的 Target：_GetRestorePackagesPathOverride 输出的 Target：_GetRestoreSourcesOverride 输出的 Target：_GetRestoreFallbackFoldersOverride 输出的 Target：_IsProjectRestoreSupported 输出的 Target：DesktopBridgeCopyLocalOutputGroup 输出的 Target：DesktopBridgeComFilesOutputGroup 输出的 Target：GetDeployableContentReferenceOutputs 输出的 Target：DockerResolveAppType 输出的 Target：DockerUpdateComposeVsGeneratedFiles 输出的 Target：DockerResolveTargetFramework 输出的 Target：DockerComposeBuild 输出的 Target：DockerPackageService 输出的 Target：ImplicitlyExpandNETStandardFacades 输出的 Target：_RemoveZipFileSuggestedRedirect 输出的 Target：SetARM64AppxPackageInputsForInboxNetNative 输出的 Target：_CleanMdbFiles 输出的 Target：PreXsdCodeGen 输出的 Target：XsdCodeGen 输出的 Target：XsdResolveReferencePath 输出的 Target：CleanXsdCodeGen 输出的 Target：_SetTargetFrameworkMonikerAttribute 输出的 Target：ResolvePackageDependenciesForBuild 输出的 Target：RunResolvePackageDependencies 输出的 Target：ResolvePackageAssets 输出的 Target：FilterSatelliteResources 输出的 Target：RunProduceContentAssets 输出的 Target：ReportAssetsLogMessages 输出的 Target：ResolveLockFileReferences 输出的 Target：IncludeTransitiveProjectReferences 输出的 Target：ResolveLockFileAnalyzers 输出的 Target：_ComputeLockFileCopyLocal 输出的 Target：ResolveLockFileCopyLocalProjectDeps 输出的 Target：CheckForImplicitPackageReferenceOverrides 输出的 Target：CheckForDuplicateItems 输出的 Target：GenerateBuildDependencyFile 输出的 Target：GenerateBuildRuntimeConfigurationFiles 输出的 Target：AddRuntimeConfigFileToBuiltProjectOutputGroupOutput 输出的 Target：_SdkBeforeClean 输出的 Target：_SdkBeforeRebuild 输出的 Target：_ComputeNETCoreBuildOutputFiles 输出的 Target：_ComputeReferenceAssemblies 输出的 Target：CoreGenerateSatelliteAssemblies 输出的 Target：_GetAssemblyInfoFromTemplateFile 输出的 Target：_DefaultMicrosoftNETPlatformLibrary 输出的 Target：GetAllRuntimeIdentifiers 输出的 Target：GenerateAssemblyInfo 输出的 Target：AddSourceRevisionToInformationalVersion 输出的 Target：GetAssemblyAttributes 输出的 Target：CreateGeneratedAssemblyInfoInputsCacheFile 输出的 Target：CoreGenerateAssemblyInfo 输出的 Target：GetAssemblyVersion 输出的 Target：ComposeStore 输出的 Target：StoreWorkerMain 输出的 Target：StoreWorkerMapper 输出的 Target：StoreResolver 输出的 Target：StoreWorkerPerformWork 输出的 Target：StoreFinalizer 输出的 Target：_CopyResolvedOptimizedFiles 输出的 Target：PrepareForComposeStore 输出的 Target：PrepforRestoreForComposeStore 输出的 Target：RestoreForComposeStore 输出的 Target：ComputeAndCopyFilesToStoreDirectory 输出的 Target：CopyFilesToStoreDirectory 输出的 Target：_CopyResolvedUnOptimizedFiles 输出的 Target：_ComputeResolvedFilesToStoreTypes 输出的 Target：_SplitResolvedFiles 输出的 Target：_GetResolvedFilesToStore 输出的 Target：ComputeFilesToStore 输出的 Target：PrepRestoreForStoreProjects 输出的 Target：PrepOptimizer 输出的 Target：_RunOptimizer 输出的 Target：RunCrossGen 输出的 Target：_InitializeBasicProps 输出的 Target：_GetCrossgenProps 输出的 Target：_SetupStageForCrossgen 输出的 Target：_RestoreCrossgen 输出的 Target：_CheckForObsoleteDotNetCliToolReferences 输出的 Target：_PublishBuildAlternative 输出的 Target：_PublishNoBuildAlternative 输出的 Target：_PreventProjectReferencesFromBuilding 输出的 Target：PrepareForPublish 输出的 Target：ComputeAndCopyFilesToPublishDirectory 输出的 Target：CopyFilesToPublishDirectory 输出的 Target：_CopyResolvedFilesToPublishPreserveNewest 输出的 Target：_CopyResolvedFilesToPublishAlways 输出的 Target：_ComputeResolvedFilesToPublishTypes 输出的 Target：ComputeFilesToPublish 输出的 Target：_ComputeNetPublishAssets 输出的 Target：RunResolvePublishAssemblies 输出的 Target：FilterPublishSatelliteResources 输出的 Target：_ComputeCopyToPublishDirectoryItems 输出的 Target：DefaultCopyToPublishDirectoryMetadata 输出的 Target：GeneratePublishDependencyFile 输出的 Target：_ComputeExcludeFromPublishPackageReferences 输出的 Target：_ParseTargetManifestFiles 输出的 Target：GeneratePublishRuntimeConfigurationFile 输出的 Target：DeployAppHost 输出的 Target：PackTool 输出的 Target：GenerateToolsSettingsFileFromBuildProperty 输出的 Target：ResolveApphostAsset 输出的 Target：ComputeDependencyFileCompilerOptions 输出的 Target：ComputeRefAssembliesToPublish 输出的 Target：_CopyReferenceOnlyAssembliesForBuild 输出的 Target：_HandlePackageFileConflicts 输出的 Target：_HandlePublishFileConflicts 输出的 Target：_GetOutputItemsFromPack 输出的 Target：_GetTargetFrameworksOutput 输出的 Target：_PackAsBuildAfterTarget 输出的 Target：_CleanPackageFiles 输出的 Target：_CalculateInputsOutputsForPack 输出的 Target：Pack 输出的 Target：_IntermediatePack 输出的 Target：GenerateNuspec 输出的 Target：_InitializeNuspecRepositoryInformationProperties 输出的 Target：_LoadPackInputItems 输出的 Target：_GetProjectReferenceVersions 输出的 Target：_GetProjectVersion 输出的 Target：_WalkEachTargetPerFramework 输出的 Target：_GetFrameworksWithSuppressedDependencies 输出的 Target：_GetFrameworkAssemblyReferences 输出的 Target：_GetBuildOutputFilesWithTfm 输出的 Target：_GetTfmSpecificContentForPackage 输出的 Target：_GetDebugSymbolsWithTfm 输出的 Target：_AddPriFileToPackBuildOutput 输出的 Target：_GetPackageFiles参考资料 msbuild - Is there a way to list all the build targets available in a build file? - Stack Overflow" }, { "title": "如何在 csproj 中用 C# 代码写一个内联的编译任务 Task", "url": "/post/write-msbuild-inline-task.html", "categories": "", "tags": "msbuild, dotnet, visualstudio, csharp", "date": "2019-03-01 15:12:04 +0800", "snippet": "我之前写过一些改变 MSBuild 编译过程的一些博客，包括利用 Microsoft.NET.Sdk 中各种自带的 Task 来执行各种各样的编译任务。更复杂的任务难以直接利用自带的 Task 实现，需要自己写 Task。本文介绍非常简单的 Task 的编写方式 —— 在 csproj 文件中写内联的 Task。前置知识在阅读本文之前，你至少需要懂得： csproj 文件的结构以及编译过程 Target 是什么，Task 是什么所以如果你不懂或者理不清，则请先阅读： 理解 C# 项目 csproj 文件格式的本质和编译流程 - 吕毅关于 Task 的理解，我有一些介绍自带 Task 的博客以及如何编写 Task 的教程： 如何编写基于 Microsoft.NET.Sdk 的跨平台的 MSBuild Target（附各种自带的 Task） - 吕毅 如何创建一个基于 MSBuild Task 的跨平台的 NuGet 工具包 - 吕毅编写内联的编译任务（Task）如果你阅读了前面的博客，那么大致知道如何写一个在编译期间执行的 Task。不过，默认你需要编写一个额外的项目来写 Task，然后将这个项目生成 dll 供编译过程通过 UsingTask 来使用。然而如果 Task 足够简单，那么依然需要那么复杂的过程显然开发成本过高。于是现在可以编写内联的 Task： 内联任务的支持需要用到 Microsoft.Build.Tasks.v4.0.dll； 我们用 &amp;lt;![CDATA[ ]]&amp;gt; 来内嵌 C# 代码； 除了用 UsingTask 编写内联的 Task 外，我们需要额外编写一个 Target 来验证我们的内联 Task 能正常工作。下面是一个最简单的内联编译任务：&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;UsingTask TaskName=&quot;WalterlvDemoTask&quot; TaskFactory=&quot;CodeTaskFactory&quot; AssemblyFile=&quot;$(MSBuildToolsPath)\\Microsoft.Build.Tasks.v4.0.dll&quot;&amp;gt; &amp;lt;Task&amp;gt; &amp;lt;Code Type=&quot;Fragment&quot; Language=&quot;cs&quot;&amp;gt; &amp;lt;![CDATA[ Console.WriteLine(&quot;Hello Walterlv!&quot;); ]]&amp;gt; &amp;lt;/Code&amp;gt; &amp;lt;/Task&amp;gt; &amp;lt;/UsingTask&amp;gt;&amp;lt;Project&amp;gt;为了能够测试，我把完整的 csproj 文件贴出来：&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;OutputType&amp;gt;Exe&amp;lt;/OutputType&amp;gt; &amp;lt;TargetFramework&amp;gt;net472&amp;lt;/TargetFramework&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;UsingTask TaskName=&quot;WalterlvDemoTask&quot; TaskFactory=&quot;CodeTaskFactory&quot; AssemblyFile=&quot;$(MSBuildToolsPath)\\Microsoft.Build.Tasks.v4.0.dll&quot;&amp;gt; &amp;lt;Task&amp;gt; &amp;lt;Code Type=&quot;Fragment&quot; Language=&quot;cs&quot;&amp;gt; &amp;lt;![CDATA[ Console.WriteLine(&quot;Hello Walterlv!&quot;); ]]&amp;gt; &amp;lt;/Code&amp;gt; &amp;lt;/Task&amp;gt; &amp;lt;/UsingTask&amp;gt; &amp;lt;Target Name=&quot;WalterlvDemoTarget&quot; AfterTargets=&quot;Build&quot;&amp;gt; &amp;lt;WalterlvDemoTask /&amp;gt; &amp;lt;/Target&amp;gt;&amp;lt;/Project&amp;gt;目前内联编译仅适用于 MSBuild，而 dotnet build 尚不支持。现在在项目目录输入命令进行编译，可以在输出窗口看到我们内联编译中的输出内容：msbuild编写更复杂的内联编译任务阅读我的另一篇博客了解如何编写一个更复杂的内联编译任务： 编写 MSBuild 内联编译任务（Task）用于获取当前编译环境下的所有编译目标（Target） - 吕毅" }, { "title": "在 MSBuild 编译项目时阻止输出所有的警告信息", "url": "/post/suppress-all-warnings-for-msbuild.html", "categories": "", "tags": "msbuild, dotnet, visualstudio", "date": "2019-02-27 17:35:48 +0800", "snippet": "大型旧项目可能存在大量的 Warning，在编译之后 Visual Studio 会给出大量的警告。Visual Studio 中可以直接点掉警告，然而如果是通过命令行 msbuild 编译的，那如何不要让警告输出呢？在使用 msbuild 命令编译项目的时候，如果存在大量的警告，输出量会非常多。如果我们使用 msbuild 命令编译来定位项目的编译错误，那么这些警告将会导致我们准确查找错误的效率明显降低。当然，这种问题的首选解决方案是 —— 真的修复掉这些警告！！！那么可以用什么方式临时关闭 msbuild 命令编译时的警告呢？可以输入如下命令：msbuild /p:WarningLevel=0这样在调试编译问题的时候，因警告而造成的大量输出信息就会少很多。不过需要注意的是，这种方式不会关闭所有的警告，实际上这关闭的是 csc 命令的警告（CS 开头）。关于 csc 命令的警告可以参见：-warn (C# Compiler Options) - Microsoft Docs。于是，如果项目中存在 msbuild 的警告（MSB 开头），此方法依然还会输出，只不过如果是为了调试编译问题，那么依然会方便很多，因为 MSB 开头的警告会少非常多。关于警告等级： 0 关闭所有的警告。 1 仅显示严重警告。 2 显示 1 级的警告以及某些不太严重的警告，例如有关隐藏类成员的警告。 3 显示级别 2 警告以及某些不太严重的警告，例如关于始终评估为 true 或 false 的表达式的警告。 4 默认值 显示所有 3 级警告和普通信息警告。参考资料 command line - How to suppress specific MSBuild warning - Stack Overflow command line - How to suppress all warnings using MSBuild - Stack Overflow visual studio 2013 - How to have MSBuild quiet output but with error/warning summary - Stack Overflow -warn (C# Compiler Options) - Microsoft Docs Suppress MSB4126" }, { "title": "帮助官方 NuGet 解掉 Bug，制作绝对不会传递依赖的 NuGet 包", "url": "/post/prevent-nuget-package-been-depended.html", "categories": "", "tags": "nuget, msbuild", "date": "2019-02-27 16:34:26 +0800", "snippet": "如果你希望做一个 NuGet 工具包，那么这个包一定不能作为依赖传递给下一个包。典型的例子，做一个生成版本号的工具 NuGet 包，或者做一个代码分析器。本文将解决 NuGet 的几个坑，真正做到绝对没有的依赖传递。我们遇到了什么问题如果你使用了 GitVersion 这款 NuGet 包来自动修改你的版本号，那么你可能会遇到这个问题。GitTools/GitVersion: Easy Semantic Versioning (http://semver.org) for projects using Git假想我们希望开发一个 NuGet 包 Walterlv.PackageDemo.A。另一位小伙伴想要使用我 A 包的功能做一个 Walterlv.PackageDemo.B 包。于是其他小伙伴可以安装 B 包去做自己的项目 C。那么，除非我在 B 包安装完之后，明确在 B 的 csproj 文件中写以下代码，否则 B 包发布出去后，安装 B 包的项目 C 就会同时安装上 A 包。&amp;lt;ItemGroup&amp;gt; &amp;lt;PackageReference Include=&quot;Walterlv.PackageDemo.A&quot; Version=&quot;1.0.0&quot; PrivateAssets=&quot;All&quot; /&amp;gt;&amp;lt;/ItemGroup&amp;gt;显然，由于 A 是个工具包，只是为了给安装了 A 的 B 包提供版本号或其他编译期功能的。C 不需要这样的功能！然而我们希望做出来的 A 包具备这样的特点： 小伙伴给 B 安装 A 包的时候，不用额外为 A 包写配置依赖的代码； 小伙伴为 C 安装 B 的时候，不会出现 A 乱入的情况。如果你依然对这样的问题存有疑惑，可以阅读以下文章，这是切实的例子。 如何创建一个基于命令行工具的跨平台的 NuGet 工具包 如何创建一个基于 MSBuild Task 的跨平台的 NuGet 工具包官方提供的解决方案官方在非常早期的 2.7 版本就提供了 developmentDependency 属性，可以在 nuspec 文件中写。但实际上这个属性在后面版本的 NuGet 开发中就丢掉了。不生效。官方提供了 IsTool 属性可以使用，但这依然不能阻止 B 安装了 A 包之后，C 包被迫安装 A 包的问题。更新：官方的 NuGet 在更新到 4.9 及以上之后，此属性再次生效。添加方法是在 csproj 文件中添加一行属性：&amp;lt;DevelopmentDependency&amp;gt;&amp;lt;/DevelopmentDependency&amp;gt;添加后，如果开发者安装了此 NuGet 包，将自动生成以下代码，于是依赖就不会传递。&amp;lt;PackageReference Include=&quot;dotnetCampus.SourceYard&quot; Version=&quot;0.1.7213-alpha&quot;&amp;gt; &amp;lt;PrivateAssets&amp;gt;all&amp;lt;/PrivateAssets&amp;gt; &amp;lt;IncludeAssets&amp;gt;runtime; build; native; contentfiles; analyzers; buildtransitive&amp;lt;/IncludeAssets&amp;gt;&amp;lt;/PackageReference&amp;gt;由于官方解决掉这个 Bug，所以你只需要更新到 NuGet 4.9 以上的版本即可。后面的博客内容无需阅读。至于如何查看自己的 NuGet 版本号，请参见：获取 Nuget 版本号 - 林德熙我试图寻找的解决方案为 A 项目添加去除依赖的代码我们创建一个项目 Walterlv.PackageDemo.A 模拟前面提到的包 A，创建一个项目 Walterlv.PackageDemo.B 模拟前面提到的包 B，创建一个项目 Walterlv.ProjectDemo.C 模拟前面的项目 C。注意，实际场景中，这三个项目通常在不同的仓库中，由不同的开发者开发。不过，为了方便起见，我打算直接在一个解决方案中模拟这样的效果：我在 A 中试图创建一个 build\\Walterlv.PackageDemo.A.props 或 build\\Walterlv.PackageDemo.A.targets 文件，并在里面写一些阻止 A 被依赖的代码。&amp;lt;Project&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;PackageReference Update=&quot;Walterlv.PackageDemo.A&quot; PrivateAssets=&quot;All&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt;&amp;lt;/Project&amp;gt;为了通用一点，我取名为 Package.targets 文件，并在 A 项目编译的时候改名为 Walterlv.PackageDemo.A.targets。▲ 项目的结构以下是 A 项目的 csproj 文件，包含将 Package.targets 在打包 NuGet 包时改名的部分。&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;TargetFramework&amp;gt;netcoreapp2.1&amp;lt;/TargetFramework&amp;gt; &amp;lt;GeneratePackageOnBuild&amp;gt;true&amp;lt;/GeneratePackageOnBuild&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;None Include=&quot;Assets\\build\\Package.targets&quot; Pack=&quot;True&quot; PackagePath=&quot;build\\$(PackageId).targets&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt;&amp;lt;/Project&amp;gt;在 B 项目中进行测试本地调试当然用不着推送到 https://nuget.org。我们本地新建一个源，专门用于调试。在 “工具 -&amp;gt; 选项 -&amp;gt; NuGet 包管理器” 中，我们可以设置 NuGet 源：▲ 添加调试用的 NuGet 源我们把刚刚 A 项目的输出目录填进去添加一个新的源。于是我们就能在 B 项目中安装 A 包了。于是 B 项目的 csproj 文件全文内容如下：&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;TargetFramework&amp;gt;netcoreapp2.1&amp;lt;/TargetFramework&amp;gt; &amp;lt;GeneratePackageOnBuild&amp;gt;true&amp;lt;/GeneratePackageOnBuild&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;PackageReference Include=&quot;Walterlv.PackageDemo.A&quot; Version=&quot;1.0.0&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt;&amp;lt;/Project&amp;gt;当以上 A 和 B 项目被 Visual Studio 编译的时候，一切符合预期；就像下图这样，B 项目中没有声明对 A 的依赖：令人遗憾的结果然而使用命令行编译的时候，就不按照预期工作了；如下图这样，B 项目中出现了对 A 的依赖。命令行编译时使用这些命令效果都是一样的不管用。nuget restoremsbuilddotnet restoredotnet build不过，令人难以置信的时，如果此时 Visual Studio 打开了此项目，命令行编译却能符合预期。另外，我还尝试将 Package.targets 中的所有内容放到 &amp;lt;Target /&amp;gt; 里面以获得延迟到编译期执行的效果，但结论依然与上面一致，即仅能在 Visual Studio 中正常工作。&amp;lt;Project&amp;gt; &amp;lt;Target Name=&quot;ForceWalterlvDemoPrivateAssets&quot; BeforeTargets=&quot;CollectPackageReferences&quot;&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;PackageReference Update=&quot;Walterlv.PackageDemo.A&quot; PrivateAssets=&quot;All&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;/Target&amp;gt;&amp;lt;/Project&amp;gt;" }, { "title": "电脑总是意外从睡眠状态唤醒，可以找出原因然后解决", "url": "/post/find-out-the-reason-that-wakes-the-pc-up.html", "categories": "", "tags": "windows", "date": "2019-02-27 14:09:22 +0800", "snippet": "在昏暗的夜晚，一个人躺在房间的床上，静静的思考着什么。突然间电脑屏幕亮了！什么鬼！到底是谁唤醒了我的电脑！！！本文将介绍如何寻找唤醒电脑的真凶。调查是谁唤醒了电脑使用命令查看上一次是谁唤醒了电脑。powercfg -lastwake从图中可知上一次唤醒我计算机的是 英特尔® 以太网连接 I219-V 82186。查看还有谁可以唤醒电脑使用命令查看所有可以唤醒电脑的设备。powercfg -devicequery wake_armed发现能唤醒我电脑的设备是键盘鼠标以及刚刚的以太网。查看下一次计划的唤醒使用命令可以查看下一次计划的唤醒。powercfg -waketimers当然这只能查到计划的唤醒，类似鼠标键盘还有以太网这种根据硬件状态触发的唤醒是看不到的。修复意外的唤醒由于我不知道到底是谁通过以太网唤醒了我的电脑，所以我直接关掉以太网的唤醒即可。前往设备管理器，找到刚刚发现的硬件设备，查看属性。然后我关闭了此设备唤醒电脑的设置。参考资料 How to find out why your PC wakes up, and how to stop it - gHacks Tech News" }, { "title": "将友盟（cnzz）站点的访问数据报告分享给其他人", "url": "/post/share-cnzz-report-to-others.html", "categories": "", "tags": "web", "date": "2019-02-27 13:48:30 +0800", "snippet": "友盟（cnzz）可以帮助我们分析站点的访问数据。不过如果有更多的决策者，则需要更多人可以访问到友盟的数据。本文介绍两种将自己站点的访问数据报告分享给其他人的方法。首先，你必须有一个友盟产品的账号，如果还没有，去 注册吧！使用查看密码分享设置进入 站点列表 页面。点击网站右侧的“设置”。然后进入查看密码标签，开启查看密码服务，然后输入查看密码。这种方式的好处在于非常简单，你只需要告诉他人你的查看密码，其他人随时可以点开你网站的数据统计链接查看站点的访问数据。Web 端查看在 Web 端点开站点底部的访问数据即可进入数据报表页面。输入查看密码即可查看。在移动端查看cnzz 移动端下载安装后首页有四个按钮。点击“查看密码”后输入站点 Id 或扫码，然后输入密码即可查看数据。不过移动端的 cnzz 做得很烂，如果登录过自己的站点查看数据，那么使用密码查看必崩，而且至今未修复。使用授权账号分享本来使用密码查看是非常方便的，但是为了解决崩溃问题，还是需要使用授权账号来查看数据。设置进入 站点列表 页面。点击网站右上角的“授权”。如果还没有授权给其他人，则可以点击“添加授权账号”。然后输入对方的友盟账号和邮箱，添加对方的权限。在 Web 端查看进入 站点列表 页面，可以在被授权站点看到授权查看的站点数据了。在移动端查看cnzz 移动端下载安装后首页有四个按钮。点击“网站统计”后可以看到自己的站点和被授权的站点。" }, { "title": "全局或为单独的项目添加自定义的 NuGet 源", "url": "/post/add-custom-nuget-source.html", "categories": "", "tags": "nuget, visualstudio", "date": "2019-02-27 12:26:12 +0800", "snippet": "本文介绍如何添加自定义的 NuGet 源。包括全局所有项目生效的 NuGet 源和仅在某些特定项目中生效的 NuGet 源。你可以前往 我收集的各种公有 NuGet 源 以发现更多的 NuGet 源，然后使用本文的方法添加到你自己的配置中。使用命令行添加在使用命令行之前，你需要先在 https://www.nuget.org/downloads 下载最新的 nuget.exe 然后加入到环境变量中。现在，我们使用命令行来添加一个包含各种日构建版本的 NuGet 源 MyGet：nuget sources add -Name &quot;MyGet&quot; -Source &quot;https://dotnet.myget.org/F/dotnet-core/api/v3/index.json&quot;如果你添加的只是一个镜像源（比如华为云 huaweicloud），那么其功能和官方源是重合的，可以禁用掉官方源：nuget sources Disable -Name &quot;nuget.org&quot;nuget sources add -Name &quot;huaweicloud&quot; -Source &quot;https://mirrors.huaweicloud.com/repository/nuget/v3/index.json&quot;在 Visual Studio 中添加在 Visual Studio 中打开 工具 -&amp;gt; 选项 -&amp;gt; NuGet 包管理器 -&amp;gt; 包源：然后在界面上添加、删除、启用和禁用 NuGet 源。值得注意的是： 在 Visual Studio 中是不能禁用掉官方源 nuget.org 的，无论你如何取消勾选，实际都不会生效。 如果要取消，你需要用命令行或者手工编辑配置文件。 你可以添加一个本地路径作为本地 NuGet 源，而那个路径只要存在 *.nupkg 文件就够了。 对于 .NET Core 项目，勾选编译后生成 NuGet 包则会在输出路径生成这样的文件，于是你可以本地调试。 直接修改配置文件NuGet 的全局配置文件在 %AppData\\NuGet\\NuGet.config，例如：C:\\Users\\lvyi\\AppData\\Roaming\\NuGet\\NuGet.Config直接修改这个文件的效果跟使用命令行和 Visual Studio 的界面配置是等价的。&amp;lt;configuration&amp;gt; &amp;lt;packageSources&amp;gt; &amp;lt;add key=&quot;huaweicloud&quot; value=&quot;https://repo.huaweicloud.com/repository/nuget/v3/index.json&quot; /&amp;gt; &amp;lt;add key=&quot;nuget.org&quot; value=&quot;https://api.nuget.org/v3/index.json&quot; protocolVersion=&quot;3&quot; /&amp;gt; &amp;lt;add key=&quot;Walterlv.Debug&quot; value=&quot;C:\\Users\\lvyi\\Debug\\Walterlv.NuGet&quot; /&amp;gt; &amp;lt;add key=&quot;Microsoft Visual Studio Offline Packages&quot; value=&quot;C:\\Program Files (x86)\\Microsoft SDKs\\NuGetPackages\\&quot; /&amp;gt; &amp;lt;add key=&quot;MyGet&quot; value=&quot;https://dotnet.myget.org/F/dotnet-core/api/v3/index.json&quot; /&amp;gt; &amp;lt;/packageSources&amp;gt; &amp;lt;disabledPackageSources&amp;gt; &amp;lt;add key=&quot;Microsoft Visual Studio Offline Packages&quot; value=&quot;true&quot; /&amp;gt; &amp;lt;add key=&quot;Walterlv.Debug&quot; value=&quot;true&quot; /&amp;gt; &amp;lt;add key=&quot;nuget.org&quot; value=&quot;true&quot; /&amp;gt; &amp;lt;/disabledPackageSources&amp;gt;&amp;lt;/configuration&amp;gt;为单独的项目添加自定义的 NuGet 源NuGet.config 文件是有优先级的。nuget.exe 会先把全局配置加载进来；然后从当前目录中寻找 NuGet.config 文件，如果没找到就去上一级目录找，一直找到驱动器的根目录；找到后添加到已经加载好的全局配置中成为一个合并的配置。所以我们只需要在项目的根目录放一个 NuGet.config 文件并填写相比于全局 NuGet.config 新增的配置即可为单独的项目添加 NuGet 配置。&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;configuration&amp;gt; &amp;lt;packageSources&amp;gt; &amp;lt;!-- 下一行的 clear 如果取消了注释，那么就会清除掉全局的 NuGet 源，而注释掉可以继承全局 NuGet 源，只是额外添加。 --&amp;gt; &amp;lt;!-- &amp;lt;clear /&amp;gt; --&amp;gt; &amp;lt;add key=&quot;MyGet&quot; value=&quot;https://dotnet.myget.org/F/dotnet-core/api/v3/index.json&quot; /&amp;gt; &amp;lt;/packageSources&amp;gt;&amp;lt;/configuration&amp;gt;" }, { "title": "使用 Visual Studio 调试多进程的程序", "url": "/post/debug-multi-process-application-using-visual-studio.html", "categories": "", "tags": "dotnet, visualstudio", "date": "2019-02-21 15:24:56 +0800", "snippet": "当你的编写的是一个多进程的程序的时候，调试起来可能会比较困难，因为 Visual Studio 默认只会把你当前设置的启动项目的启动调试。本文将介绍几种用 Visual Studio 调试多进程程序的方法，然后给出每种方法的适用条件和优劣。Visual Studio 多启动项目（推荐）在 Visual Studio 的解决方案上点击右键，属性。在公共属性节点中选择启动项目。在这里，你可以给多个项目都设置成启动项目，就像下图这样：当然，这些项目都必须要是能够启动的才行（不一定是可执行程序）。此方案的好处是 Visual Studio 原生支持。但此方案的使用必须满足两个前提： 要调试的多个进程必须是不同的项目编译出来的； 这些项目之间的启动顺序不能有明显的依赖关系（所以你可能需要修改你的代码使得这两个进程之间可以互相唤起）。Microsoft Child Process Debugging Power Tool 插件（推荐）安装和配置插件请先安装 Microsoft Child Process Debugging Power Tool 插件。安装插件后启动 Visual Studio，可以在 Debug -&amp;gt; Other Debugging Targets 中找到 Child Process Debugging Settings。然后你可以按照下图的设置开启此项目的子进程调试：配置项目启动选项但是，子进程要能够调试，你还必须开启混合模式调试，开启方法请参见我的另一篇博客：在 Visual Studio 新旧不同的 csproj 项目格式中启用混合模式调试程序（开启本机代码调试） - walterlv。现在，你只需要开始调试你的程序，那么你程序中启动的新的子进程都将可以自动加入调试。例子源码和效果现在，我们拿下面这段代码作为例子来尝试子进程的调试。下面的代码中，if 中的代码会运行在子进程中，而 else 中的代码会运行在主进程中。using System;using System.Diagnostics;using System.Linq;namespace Walterlv.Debugging{ class Program { static void Main(string[] args) { if (args.Any()) { Console.WriteLine(&quot;Walterlv child application&quot;); Console.WriteLine(string.Join(Environment.NewLine, args)); Console.ReadLine(); } else { Console.WriteLine(&quot;Walterlv main application&quot;); var process = new Process { StartInfo = new ProcessStartInfo(Process.GetCurrentProcess().MainModule.FileName, &quot;--child&quot;), }; process.Start(); process.WaitForExit(); } } }}我们在 if 和 else 中都打上断点。正常情况下运行，只有 else 中的代码可以进断点；而如果以上子进程调试配置正确，那么两边你都可以进入断点（如下图）。值得注意的是，只要启动了本机代码调试，就不能在程序暂停之后修改代码了（像平时调试纯托管代码那样）。在代码中编写“附加调试器”调用 Debugger.Launch() 可以启动一个调试器来调试此进程。于是我们可以在我们被调试的程序中写下如下代码：#if DEBUG if (!Debugger.IsAttached) { Debugger.Launch(); }#endif仅在 DEBUG 条件下，如果当前没有附加任何调试器，那么就启动一个新的调试器来调试它。当存在以上代码时，运行会弹出一个对话框，用于选择调试器。这里选择的调试器有个不太方便的地方，如果调试器已经在使用，那么就不能选择。对于我们目前的场景，我们的主进程已经在调试了，所以子进程选择调试器的时候不能再选择主进程调试所用的 Visual Studio 了，而只能选择一个新的 Visual Studio；这一点很不方便。对于此方法，我的建议是平常不要在团队项目中使用（这会让团队中的其他人不方便）。但是由于代码简单不需要配置，所以临时使用的话还是非常建议的。在代码中调用 Visual Studio 的 COM 组件 API编写中……总结综上，虽然我给出了 4 种不同的方法，但实际上没有任何一种方法能够像我们调试单个原生托管程序那样方便。每一种方法都各有优劣，一般情况下建议你使用我标注了“推荐”的方法；不过也建议针对不同的情况采用不同的方案。 简单的个人项目，希望快速开始多进程/子进程调试 使用附加调试器 你有多个项目组成的多进程，并且这些进程恰好可以互相唤起，它们之间的启动顺序不影响父子进程的组成 使用 Visual Studio 的多启动项目 你只有单个项目组成的多进程，或者多个进程之间依赖于启动顺序来组成父子进程 安装插件 Microsoft Child Process Debugging Power Tool 参考资料 Azure DevOps Blog - Introducing the Child Process Debugging Power Tool Microsoft Child Process Debugging Power Tool - Visual Studio Marketplace attach a process to current visual studio debugger silently using command line .. How to get DTE from Visual Studio process ID? – Kirill Osenkov How to start Visual Studio programmatically – Kirill Osenkov EnvDTE Namespace - Microsoft Docs c# - Using the EnvDTE assembly - Stack Overflow" }, { "title": "将 svn 仓库迁移到 git 仓库", "url": "/post/migrating-svn-to-git.html", "categories": "", "tags": "git", "date": "2019-02-20 10:22:31 +0800", "snippet": "我找到了一个很久很久以前编写的项目，然而当时是使用 svn 进行版本管理的。然而现在的版本管理全部是 git，不愿意再装一个 svn 工具来管理这些古老的项目，于是打算将其迁移到 git 中。本文介绍如何将古老的 svn 项目迁移到 git。找回 svn 仓库的 url如果你能记得你 svn 仓库的 url，或者这个仓库是一个纯本地仓库，那么你直接复制这个 url 就好了。然而如果这是一个有 svn 远程服务器的仓库，那么你可能依然需要临时安装一下 svn 工具。我们只是为了拿回 url 而已。这里我使用当时使用的小乌龟 TortoiseSVN。在 svn 仓库空白处右击选择版本库浏览器（Repo-browser），小乌龟会自动定位到当前仓库所在的远程 svn 服务器的对应文件夹。我们所要做的只有一件事——复制顶部那个 url。得到了这个 url 后，像我这种洁癖就卸载 TortoiseSVN 了。将 svn 仓库迁移到 git 仓库命令行在一个新的文件夹中，我们输入如下命令：git.exe svn clone &quot;https://svn.walterlv.com/LvYi/Timer&quot; &quot;.\\Walterlv.RepoFromSvn&quot;如果那个 svn 目录中包含 trunk、branches 和 tags 结构，那么可以在后面添加相应的参数以便在 clone 完成后保留分支和标签信息。git.exe svn clone &quot;https://svn.walterlv.com/LvYi/Timer&quot; &quot;.\\Walterlv.RepoFromSvn&quot; -T trunk -b branches -t tags需要注意的是，上面的 Walterlv.RepoFromSvn 文件夹是不允许提前存在的，如果存在将无法迁移成功。TortoiseGit这里特地照顾一下从 TortoiseSVN 迁移来继续考虑 TortoiseGit 的小伙伴。在 TortoiseGit 中的操作是： 在某个文件夹中右键（或者 Shift+右键） 选择克隆 按照下图填写来自 url 的远程服务器 url 和本地文件夹，并打勾“从SVN版本库”参考资料 Git - Migrating to Git How to get svn remote repository URL? - Stack Overflow Migrate from Subversion (SVN) to Git - Microsoft Docs" }, { "title": ".NET/C# 将一个命令行参数字符串转换为命令行参数数组 args", "url": "/post/convert-command-line-string-to-args-array.html", "categories": "", "tags": "dotnet, csharp, windows", "date": "2019-02-19 21:49:15 +0800", "snippet": "我们通常得到的命令行参数是一个字符串数组 string[] args，以至于很多的命令行解析库也是使用数组作为解析的参数来源。然而如我我们得到了一整个命令行字符串呢？这个时候可能我们原有代码中用于解析命令行的库或者其他辅助函数不能用了。那么如何转换成数组呢？在 Windows 系统中有函数 CommandLineToArgvW 可以直接将一个字符串转换为命令行参数数组，我们可以直接使用这个函数。LPWSTR * CommandLineToArgvW( LPCWSTR lpCmdLine, int *pNumArgs);此函数在 shell32.dll 中，于是我们可以在 C# 中调用此函数。为了方便使用，我将其封装成了一个静态方法。using System;using System.ComponentModel;using System.Runtime.InteropServices;namespace Walterlv{ public static class CommandLineExtensions { public static string[] ConvertCommandLineToArgs(string commandLine) { var argv = CommandLineToArgvW(commandLine, out var argc); if (argv == IntPtr.Zero) { throw new Win32Exception(&quot;在转换命令行参数的时候出现了错误。&quot;); } try { var args = new string[argc]; for (var i = 0; i &amp;lt; args.Length; i++) { var p = Marshal.ReadIntPtr(argv, i * IntPtr.Size); args[i] = Marshal.PtrToStringUni(p); } return args; } finally { Marshal.FreeHGlobal(argv); } } [DllImport(&quot;shell32.dll&quot;, SetLastError = true)] static extern IntPtr CommandLineToArgvW([MarshalAs(UnmanagedType.LPWStr)] string lpCmdLine, out int pNumArgs); }}参考资料 CommandLineToArgvW function - Microsoft Docs Converting Command Line String to Args[] using CommandLineToArgvW() API - IntelliTect Split string containing command-line parameters into string[] in C# - Stack Overflow" }, { "title": "git 合并策略", "url": "/post/git-merge-strategy.html", "categories": "", "tags": "git", "date": "2019-02-15 14:31:09 +0800", "snippet": "不清楚 git 冲突的表示方法，不了解 git 的合并原理，不知道 git 解冲突的多种策略。即便如此，大多数人依然可以正常使用 git 完成合并、拉取操作，并且解一些冲突。这得益于 git 默认情况下的合并方式可以处理大多数情况下的正常合并。然而，你是否遭遇 git 自动合并炸掉的情况？命名提示没有冲突，代码却早已无法编译通过。本文将介绍 git 的合并策略，你可能可以更好的使用不同的策略来解决冲突。git 合并策略典型的使用指定 git 合并策略的命令这么写：$ git merge 要合并进来的分支名 --strategy=合并策略例如：$ git merge origin/master --strategy=resolve或者使用简写 -s，例如：$ git merge origin/master -s resolve可以指定的合并策略有： resolve recursive octopus ours subtreeresolve这使用的是三路合并算法。不过我们在 git 的合并原理（递归三路合并算法） 中说过，普通的三路合并算法会存在发现多个共同祖先的问题。此策略会“仔细地”寻找其中一个共同祖先。由于不需要递归合并出虚拟节点，所以此方法合并时会比较快速，但也可能会带来更多冲突。不敢说带来更多冲突是好事还是坏事，因为自动合并成功并不一定意味着在代码含义上也算是正确的合并。所以如果自动合并总是成功但代码含义上会失败，可以考虑此合并策略，这将让更多的冲突变成手工合并而不是自动合并。recursive这是默认的合并策略，如果你不指定策略参数，那么将使用这个合并策略。这将直接使用递归三路合并算法进行合并，详见：git 的合并原理（递归三路合并算法）。当指定为此策略时，可以额外指定下面的这些参数，方法是：$ git merge 要合并进来的分支名 --strategy=合并策略 -X diff-algorithm=参数例如：$ git merge origin/master -s recursive -X diff-algorithm=patience由于 recursive 是默认的合并策略，所以可以简化成：$ git merge origin/master -X diff-algorithm=patienceours如果不冲突，那么与默认的合并方式相同。但如果发生冲突，将自动应用自己这一方的修改。注意策略里面也有一个 ours，与这个不同的。theirs这与 ours 相反。如果不冲突，那么与默认的合并方式相同。但如果发生冲突，将自动应用来自其他人的修改（也就是 merge 参数中指定的那个分支的修改）。patience此策略的名称叫“耐心”，因为 git 将话费更多的时间来进行合并一些看起来不怎么重要的行，合并的结果也更加准确。当然，使用的算法是 recursive 即递归三路合并算法。不过此名称也难以准确描述到底如何准确，不过可以举一个例子来说明：int Foo(){ // 一些省略的代码。}int Baz(){ // 一些省略的代码。}然后在这两个函数中增加另一个函数：int Bar(){ // 一些省略的代码。}默认情况下 git 会认为修改是这样的：+ }++ int Bar()+ {+ // 一些省略的代码。然而使用 patience 策略后，git 将认为修改是这样的：+ int Bar()+ {+ // 一些省略的代码。+ }+如果你经常合并出现这些括号丢失或者符号不再匹配的问题，可以考虑使用 patience 策略进行合并。no-renames默认情况下 git 会识别出你重命名或者移动了文件，以便在你移动了文件之后依然可以与原文件进行合并。如果指定此策略，那么 git 将不再识别重命名，而是当作增加和删除了文件。其他的参数 diff-algorithm=[patience|minimal|histogram|myers] renormalize no-renormalize find-renames[=&amp;lt;n&amp;gt;] rename-threshold=&amp;lt;n&amp;gt; subtree[=&amp;lt;path&amp;gt;]octopus又是一个奇怪的名字——章鱼。章鱼有很多的触手，此合并策略就像这么多的触手一样。此策略允许合并多个 git 提交节点（分支）。不过，如果会出现需要手工解决的冲突，那么此策略将不会执行。此策略就是用来把多个分支聚集在一起的。$ git merge t/lvyi t/walterlv -s octopuserror: Merge requires file-level mergingTrying really trivial in-index merge...Nope.Merge with strategy octopus failed.ours在合并的时候，无论有多少个合并分支，当前分支就直接是最终的合并结果。无论其他人有多少修改，在此次合并之后，都将不存在（当然历史里面还有）。你可能觉得这种丢失改动的合并策略没有什么用。但如果你准备重新在你的仓库中进行开发（程序员最喜欢的重构），那么当你的修改与旧分支合并时，采用此合并策略就非常有用，你新的重构代码将完全不会被旧分支的改动所影响。注意 recursive 策略中也有一个 ours 参数，与这个不同的。subtree此策略使用的是修改后的递归三路合并算法。与 recursive 不同的是，此策略会将合并的两个分支的其中一个视为另一个的子树，就像 git subtree 中使用的子树一样。参考资料 Git merge strategy options &amp;amp; examples - Atlassian Git Tutorial diff - Any example to use git merge patience strategy? - Stack Overflow Git - merge-strategies Documentation When would you use the different git merge strategies? - Stack Overflow -X patience vs -X diff-algorithm=patience with git merge-recursive - Stack Overflow Git diff –patience not working - Stack Overflow" }, { "title": "git 的合并原理（递归三路合并算法）", "url": "/post/git-merge-principle.html", "categories": "", "tags": "git", "date": "2019-02-14 21:03:00 +0800", "snippet": "如果 git 只是一行行比较，然后把不同的行报成冲突，那么你在合并的时候可能会遇到大量的冲突；这显然不是一个好的版本管理工具。本文介绍 git 合并分支的原理。git 的冲突表示例如我们有这样的三个提交 a、b、c。a、b 是在 master 上的其他修改，c 是我自己基于 master 上的 a 的修改。现在，将 master 分支合并到我自己的 t/walterlv 分支：a 提交：Console.WriteLine(&quot;Hello World!&quot;);b 提交：Console.WriteLine(&quot;Hello Master!&quot;);c 提交：Console.WriteLine(&quot;Hello Walterlv!&quot;);于是现在将 c 提交合并到 master 的时候就会出现冲突。冲突的表示会是这样：&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEADConsole.WriteLine(&quot;Hello Walterlv!&quot;);=======Console.WriteLine(&quot;Hello Master!&quot;);&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; master以 &amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; 表示冲突开头，&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; 表示冲突结尾，======= 分隔冲突的不同修改。上面是 HEAD，也就是在合并之前的工作目录上的最近提交；下面是合并进来的分支，通常是来自其他人的修改。三路合并加入上面的 b 提交修改的是其他文件。然后依然按照前面的方式进行合并。当出现冲突时，如果你只能看到不同的两行，那么你根本不知道究竟应该如何修改的。就像下面这样：&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEADConsole.WriteLine(&quot;Hello Walterlv!&quot;);=======Console.WriteLine(&quot;Hello World!&quot;);&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; master只看这点你怎么知道两行应该采用哪一行？这是二路合并算法带来的问题。在此算法下，你的每次拉取代码可能都会带来大量的冲突；这显然是不能接受的。三路合并算法会找到合并的这两个提交的共同祖先。在这里也就是 a 提交。master 的此文件对 a 没有修改，而当前分支 t/walterlv 对此文件有修改，于是就会应用此分支的修改。当然，前一节的问题依然会冲突，因为两个分支相对于共同的祖先节点 a 对同一个文件都有修改。递归三路合并从上面我们可以看到三路合并解决了二路合并中对于相同行不知道用哪一个的问题。不过实际的 git 提交树会更加复杂，就像下图那样纵横交错：相比于本文一开始，我们只是新增了两个提交而已，现在 f 提交是我们正在合并的提交。如果现在找 e 和 d 的共同祖先，你会发现并不唯一，b 和 c 都是。那么此时怎么合并呢？ git 会首先将 b 和 c 合并成一个虚拟的提交 x，这个 x 当作 e 和 d 的共同祖先。 而要合并 b 和 c，也需要进行同样的操作，即找到一个共同的祖先 a。我们这里的 a、b、c 只是个比较简单的例子，实际上提交树往往更加复杂，这就需要不断重复以上操作以便找到一个真实存在的共同祖先，而这个操作是递归的。这便是“递归三路合并”的含义。这是 git 合并时默认采用的策略。快进式合并git 还有非常简单的快进式（Fast-Forward）合并。快进式合并要求合并的两个分支（或提交）必须是祖孙/父子关系。例如上面的 e 和 d 并不满足此关系，所以无法进行快进式合并。在上面的例子合并出了 f 之后，如果将 t/walterlv 合并到 master，那么就可以使用快进式合并。这时，直接将 master 分支的 HEAD 指向 f 提交即完成了合并。当然，可以生成也可以不生成新的 g 提交，但内容与 f 的内容完全一样。参考资料 version control - Why is a 3-way merge advantageous over a 2-way merge? - Stack Overflow Guiffy SureMerge - A Trustworthy 3-Way Merge git merge - Which version of the git file will be finally used: LOCAL, BASE or REMOTE? - Stack Overflow Git merge strategy options &amp;amp; examples - Atlassian Git Tutorial git-merge-base (1) - Find as good common ancestors as possible for a merge" }, { "title": "将 .NET Core 项目打一个最简单的 NuGet 源码包，安装此包就像直接把源码放进项目一样", "url": "/post/the-simplest-way-to-pack-a-source-code-nuget-package.html", "categories": "", "tags": "dotnet, visualstudio, nuget, msbuild", "date": "2019-01-30 22:33:24 +0800", "snippet": "NuGet 原本就提供了生成源码包的功能。不过，NuGet 原生的源码包仅用于调试时自带调试信息和调试源码。本文将以最简单的方式制作一个源码引用包。安装 NuGet 包后，不会生成任何程序集引用，而是相当于将源码直接放入被安装的程序集中一样。准备工作我们需要一个可以用来打 NuGet 包的 .NET Core 项目，只需要在 Visual Studio 中新建一个即可。在本例中，我的项目名字是 Walterlv.Demo。将源码加入 NuGet 包在 项目文件中的已知 NuGet 属性（使用这些属性，创建 NuGet 包就可以不需要 nuspec 文件啦） 中，我说到了项目文件中的各种 NuGet 属性。在本文中，我们将使用到其中的一部分。这些属性将设置到项目文件 Walterlv.Demo.csproj 中。&amp;lt;!-- 将源码引入包中。 --&amp;gt;&amp;lt;IncludeSource&amp;gt;true&amp;lt;/IncludeSource&amp;gt;&amp;lt;!-- 如果指定为 true，那么生成的 dll 将拷贝到 NuGet 包的 tools 目录下。 --&amp;gt;&amp;lt;IsTool&amp;gt;true&amp;lt;/IsTool&amp;gt;为了避免将打出来的 NuGet 包作为 dll 被安装的程序集引用，我们需要设置 &amp;lt;IsTool&amp;gt;true&amp;lt;/IsTool&amp;gt; 属性。这样，生成的 dll 将只会放入 tools 文件夹中，而不会被引用。这时，项目的 csproj 文件像这样：&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;TargetFramework&amp;gt;netstandard2.0&amp;lt;/TargetFramework&amp;gt; &amp;lt;GeneratePackageOnBuild&amp;gt;true&amp;lt;/GeneratePackageOnBuild&amp;gt; &amp;lt;IncludeSource&amp;gt;True&amp;lt;/IncludeSource&amp;gt; &amp;lt;NoPackageAnalysis&amp;gt;true&amp;lt;/NoPackageAnalysis&amp;gt; &amp;lt;IsTool&amp;gt;True&amp;lt;/IsTool&amp;gt; &amp;lt;DevelopmentDependency&amp;gt;true&amp;lt;/DevelopmentDependency&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;/Project&amp;gt;设置后编译项目，我们将在输出目录得到 Walterlv.Demo.nupkg 和 Walterlv.Demo.1.0.0.symbols.nupkg 两个文件。这种带后缀形式的包在只是 NuGet 的辅助包而已，不是主包。在 How to create NuGet symbol packages - Microsoft Docs 中说明这种 symbols 的包只是用于调试的。然而，我们需要的是将其作为直接引用的主包。这种情况下，Walterlv.Demo.nupkg 因为不能满足我们的目的，所以我们并不能使用它。所以，我们需要做的是，将 Walterlv.Demo.1.0.0.symbols.nupkg 变成主包。于是，我们编写一个 &amp;lt;Target /&amp;gt; 将 symbols 包替换主包：&amp;lt;Target Condition=&quot;$(IncludeSource) == &#39;True&#39; Or $(IncludeSymbols) == &#39;True&#39;&quot; Name=&quot;UseSymbolsInsteadOfLib&quot; AfterTargets=&quot;GenerateNuspec&quot;&amp;gt; &amp;lt;Delete Files=&quot;$(PackageOutputAbsolutePath)$(PackageId).$(PackageVersion).nupkg&quot; /&amp;gt; &amp;lt;Move SourceFiles=&quot;$(PackageOutputAbsolutePath)$(PackageId).$(PackageVersion).symbols.nupkg&quot; DestinationFiles=&quot;$(PackageOutputAbsolutePath)$(PackageId).$(PackageVersion).nupkg&quot; /&amp;gt;&amp;lt;/Target&amp;gt;这里使用到了 &amp;lt;Delete /&amp;gt; 和 &amp;lt;Move /&amp;gt; 两个自带的 Task，用于将功能不全的主包删除，然后将我们的源码包替换成为主包。我此前写过 如何编写基于 Microsoft.NET.Sdk 的跨平台的 MSBuild Target 介绍了一些自带的 Task。如果你想了解更多 &amp;lt;Target /&amp;gt; 编写相关的知识，也可以阅读这篇文章。在增加了上面的一段 &amp;lt;Target /&amp;gt; 之后，最终我们将只会得到一个 NuGet 包，打开后能发现其中包含源码。安装 NuGet 包时引入源码为了让源码能随着包的安装加入到目标项目，我们需要 targets 文件来将源码引入。在项目中新建 Assets 文件夹，这将用来放即将存入 NuGet 包中的文件。新建 Assets\\build\\Package.targets 文件，这个文件会被自动引入到被安装的项目中。于是我们在 csproj 中额外添加一些代码将这个文件在打包时改名为正确的名称。&amp;lt;ItemGroup&amp;gt; &amp;lt;None Include=&quot;Assets\\build\\*.targets&quot; Pack=&quot;True&quot; PackagePath=&quot;build\\$(PackageId).targets&quot; /&amp;gt;&amp;lt;/ItemGroup&amp;gt;于是，整个 csproj 文件看起来是这样：&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;TargetFramework&amp;gt;netstandard2.0&amp;lt;/TargetFramework&amp;gt; &amp;lt;GeneratePackageOnBuild&amp;gt;true&amp;lt;/GeneratePackageOnBuild&amp;gt; &amp;lt;IncludeSource&amp;gt;True&amp;lt;/IncludeSource&amp;gt; &amp;lt;NoPackageAnalysis&amp;gt;true&amp;lt;/NoPackageAnalysis&amp;gt; &amp;lt;IsTool&amp;gt;True&amp;lt;/IsTool&amp;gt; &amp;lt;DevelopmentDependency&amp;gt;true&amp;lt;/DevelopmentDependency&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;None Include=&quot;Assets\\build\\*.targets&quot; Pack=&quot;True&quot; PackagePath=&quot;build\\$(PackageId).targets&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;Target Condition=&quot;$(IncludeSource) == &#39;True&#39;&quot; Name=&quot;UseSymbolsInsteadOfLib&quot; AfterTargets=&quot;GenerateNuspec&quot;&amp;gt; &amp;lt;Delete Files=&quot;$(PackageOutputAbsolutePath)$(PackageId).$(PackageVersion).nupkg&quot; /&amp;gt; &amp;lt;Move SourceFiles=&quot;$(PackageOutputAbsolutePath)$(PackageId).$(PackageVersion).symbols.nupkg&quot; DestinationFiles=&quot;$(PackageOutputAbsolutePath)$(PackageId).$(PackageVersion).nupkg&quot; /&amp;gt; &amp;lt;/Target&amp;gt;&amp;lt;/Project&amp;gt;而至于我们刚刚新建的 Package.targets 文件中，我们也需要为目标项目填写一些内容：&amp;lt;Project&amp;gt; &amp;lt;Target Name=&quot;WalterlvDemoIncludeSource&quot; BeforeTargets=&quot;CoreCompile&quot;&amp;gt; &amp;lt;Message Text=&quot;$(MSBuildThisFileDirectory)..\\src\\Walterlv.Demo\\**\\*.cs&quot; /&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;Compile Include=&quot;$(MSBuildThisFileDirectory)..\\src\\Walterlv.Demo\\**\\*.cs&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;/Target&amp;gt;&amp;lt;/Project&amp;gt;这样，一旦目标程序集安装了这个 NuGet 包，便会将所有的 cs 文件加入到目标项目的编译中。" }, { "title": "ReSharper 在 C 盘占用了太多空间了，本文告诉你如何安全地删除或转移这些文件", "url": "/post/safely-remove-jetbrains-resharper-cache-folder.html", "categories": "", "tags": "dotnet, resharper, windows", "date": "2019-01-30 20:34:19 +0800", "snippet": "一个不小心，我的 SSD 又满了。到底是谁占用了那么多的空间！如果你是 ReSharper 的重度用户，那么可能你的调查结果会直指 JetBrains ReSharper。本文将告诉你如何安全地删除这些文件来释放你的 C 盘空间，然后在 ReSharper 中设置其他的缓存目录。消失的 C 盘空间SSD 很贵的，看看都满成什么样儿了……我一个 SSD 分成了 C 和 D 两个分区，都满了。你可以使用 SpaceSniffer 来快速调查占用你大量 C 盘空间的到底是些什么文件。我之前写过一篇文章介绍如何使用它： 找回你 C 盘丢失的空间（SpaceSniffer）当你是 ReSharper 的重度用户的时候，你很有可能会看到如下的场景：是的，JetBrains 家的软件竟然占用了 17.2GB 的 C 盘空间！他们一定认为所有的用户都是土豪，能够买 500GB 以上的 SSD 全部分配给 C 盘。好的，吐槽就到这里，我们进入正题——删除这些文件。删除 ReSharper 的缓存目录注意：只有 Transient 文件夹是可以删除的！ReSharper 安装时的目录都在 %LocalAppData%\\JetBrains 中。虽然运行时的缓存也在这里，但是如果你直接把这个目录删掉了，那么 ReSharper 插件以及 JetBrains 全家桶也就不能正常使用了。Transient 意思跟 Temporary 差不多，就是短暂使用的文件。不过 ReSharper 竟然在这里堆了这么多。删除掉这个文件夹不影响 ReSharper 及其他 JetBrains 全家桶的正常运行。ReSharper 在设置中提供了清除缓存的按钮，但那个按钮点了其实释放不了多少空间的，本文最后一句将说明这个问题。转移 ReSharper 的缓存目录 从 Visual Studio 的菜单中进入 ReSharper 的设置界面：ReSharper -&amp;gt; Options； 进入缓存设置选项：Environment -&amp;gt; General -&amp;gt; Caches -&amp;gt; Store solution。在这里可以修改 ReSharper 缓存文件的存储位置。不过可得提醒你一下，ReSharper 这么耗性能的插件，还是老老实实放 SSD 里面吧，SSD 再怎么贵比起你的时间来说可便宜多了呀！可以在这个界面中看到，ReSharper 其实是提供了清除缓存的按钮（Clear）的，但是这个按钮点击之后其实只是会删除当前项目的缓存。而实际上 ReSharper 在你的电脑上积攒久了是众多缓存文件一起占用的太多空间，只删除最近正在使用的这个项目其实根本释放不了多少空间的。（比如我打开我的 Walterlv.CloudKeyboard 项目清除结果只删掉了不到 100M 的空间。）参考资料 Remove old caches – ReSharper Support - JetBrains" }, { "title": "WPF&#39;s multi-threaded UI is not thread safe", "url": "/post/wpf-multi-thread-ui-is-not-thread-safe-en.html", "categories": "", "tags": "wpf, dotnet", "date": "2019-01-29 12:10:56 +0800", "snippet": "WPF supports multiple UI threads in its framework. You can create multiple UI thread windows or create multiple UI threads in a single window. But unfortunately, this is not really thread-safe.There is a very low probability that WPF application will crash when you creating a multi-thread UI. In this post, I’ll tell how this happens.The IssueNecessary conditions: Create multiple WPF UI threads In fact, two are enough, one is the main UI thread with the App class we usually write; a background UI thread, for example, to display the UI thread that starts the splash screen. If you use two threads, you need a lot of repetitive trials to reproduce; and by creating more threads you can greatly improve the probability of a single recurrence These UI threads all display WPF windows This issue will occur in both WPF on .NET Core 3 and WPF on .NET Framework 4.7.2.phenomenon: - An exception is thrown and the application crashesFor example, the following is one of the exceptions:Exception thrown: &#39;System.NullReferenceException&#39; in WindowsBase.dllObject reference not set to an instance of an object.System.NullReferenceException: Object reference not set to an instance of an object. at System.IO.Packaging.PackagePart.CleanUpRequestedStreamsList() at System.IO.Packaging.PackagePart.GetStream(FileMode mode, FileAccess access) at System.Windows.Application.LoadComponent(Object component, Uri resourceLocator) at Walterlv.Bugs.MultiThreadedUI.SplashWindow.InitializeComponent() in C:\\Users\\lvyi\\Desktop\\Walterlv.Bugs.MultiThreadedUI\\Walterlv.Bugs.MultiThreadedUI\\SplashWindow.xaml:line 1 at Walterlv.Bugs.MultiThreadedUI.SplashWindow..ctor() in C:\\Users\\lvyi\\Desktop\\Walterlv.Bugs.MultiThreadedUI\\Walterlv.Bugs.MultiThreadedUI\\SplashWindow.xaml.cs:line 24 at Walterlv.Bugs.MultiThreadedUI.Program.&amp;lt;&amp;gt;c__DisplayClass1_0.&amp;lt;RunSplashWindow&amp;gt;b__0() in C:\\Users\\lvyi\\Desktop\\Walterlv.Bugs.MultiThreadedUI\\Walterlv.Bugs.MultiThreadedUI\\Program.cs:line 33The following image is an exception caught in WPF on .NET Core 3 that is shown in visual studio 2019:How to Reproduce Create a new WPF project (either .NET Core 3 or .NET Framework 4.7.2) Keep the automatically generated App and MainWindow unchanged, we create a new window SplashWindow. Create a new Program class containing the Main function and set Program as the startup object (instead of App) in the project properties.All other files remain the same as the default code generated by Visual Studio, and the code of Program.cs is as follows:using System;using System.Threading;using System.Windows.Threading;namespace Walterlv.Bugs.MultiThreadedUI{ public class Program { [STAThread] private static void Main(string[] args) { for (var i = 0; i &amp;lt; 50; i++) { RunSplashWindow(i); } var app = new App(); app.InitializeComponent(); app.Run(); } private static void RunSplashWindow(int index) { var thread = new Thread(() =&amp;gt; { var window = new SplashWindow { Title = $&quot;SplashWindow {index.ToString().PadLeft(2, &#39; &#39;)}&quot;, }; window.Show(); Dispatcher.Run(); }) { IsBackground = true, }; thread.SetApartmentState(ApartmentState.STA); thread.Start(); } }}Remarks: Even if you add this code just before the Splash Window creating, this exception still occurs.SynchronizationContext.SetSynchronizationContext( new DispatcherSynchronizationContext( Dispatcher.CurrentDispatcher));" }, { "title": "WPF 支持的多线程 UI 并不是线程安全的", "url": "/post/wpf-multi-thread-ui-is-not-thread-safe.html", "categories": "", "tags": "wpf, dotnet", "date": "2019-01-29 12:02:50 +0800", "snippet": "WPF 支持创建多个 UI 线程，跨窗口的或者窗口内的都是可以的；但是这个过程并不是线程安全的。你有极低的概率会遇到 WPF 多线程 UI 的线程安全问题，说直接点就是崩溃。本文将讲述其线程安全问题。简述这个线程安全问题必要条件： 创建多个 WPF UI 线程 其实两个就够了，一个我们平时写的 App 类所在的主 UI 线程；一个后台 UI 线程，例如用来显示启动闪屏的 UI 线程 两个线程的话你需要大量重复试验才能复现；而创建更多线程可以大大提高单次复现概率 这些 UI 线程都显示 WPF 窗口 无论是 .NET Framework 4.7.2 版本的 WPF，还是 .NET Core 3 版本的 WPF 都会出现此问题现象： 抛出异常，程序崩溃比如下面是其中一种异常：Exception thrown: &#39;System.NullReferenceException&#39; in WindowsBase.dllObject reference not set to an instance of an object.System.NullReferenceException: Object reference not set to an instance of an object. at System.IO.Packaging.PackagePart.CleanUpRequestedStreamsList() at System.IO.Packaging.PackagePart.GetStream(FileMode mode, FileAccess access) at System.Windows.Application.LoadComponent(Object component, Uri resourceLocator) at Walterlv.Bugs.MultiThreadedUI.SplashWindow.InitializeComponent() in C:\\Users\\lvyi\\Desktop\\Walterlv.Bugs.MultiThreadedUI\\Walterlv.Bugs.MultiThreadedUI\\SplashWindow.xaml:line 1 at Walterlv.Bugs.MultiThreadedUI.SplashWindow..ctor() in C:\\Users\\lvyi\\Desktop\\Walterlv.Bugs.MultiThreadedUI\\Walterlv.Bugs.MultiThreadedUI\\SplashWindow.xaml.cs:line 24 at Walterlv.Bugs.MultiThreadedUI.Program.&amp;lt;&amp;gt;c__DisplayClass1_0.&amp;lt;RunSplashWindow&amp;gt;b__0() in C:\\Users\\lvyi\\Desktop\\Walterlv.Bugs.MultiThreadedUI\\Walterlv.Bugs.MultiThreadedUI\\Program.cs:line 33下图是 .NET Core 3 版本的 WPF 中在 Visual Studio 2019 抓到的异常：复现步骤 创建一个新的 WPF 项目（无论是 .NET Framework 4.7.2 还是 .NET Core 3） 保持自动生成的 App 和 MainWindow 不变，我们额外创建一个窗口 SplashWindow。 创建一个新的包含 Main 函数的 Program 类，并在项目属性中设置 Program 为启动对象（替代 App）。其他文件全部保持 Visual Studio 生成的默认代码不变，而 Program.cs 的代码如下：using System;using System.Threading;using System.Windows.Threading;namespace Walterlv.Bugs.MultiThreadedUI{ public class Program { [STAThread] private static void Main(string[] args) { for (var i = 0; i &amp;lt; 50; i++) { RunSplashWindow(i); } var app = new App(); app.InitializeComponent(); app.Run(); } private static void RunSplashWindow(int index) { var thread = new Thread(() =&amp;gt; { var window = new SplashWindow { Title = $&quot;SplashWindow {index.ToString().PadLeft(2, &#39; &#39;)}&quot;, }; window.Show(); Dispatcher.Run(); }) { IsBackground = true, }; thread.SetApartmentState(ApartmentState.STA); thread.Start(); } }}说明：即便在 new SplashWindow 代码之前调用以下方法修改 SynchronizationContext 也依然会发生异常。SynchronizationContext.SetSynchronizationContext( new DispatcherSynchronizationContext( Dispatcher.CurrentDispatcher));" }, { "title": ".NET/C# 编译期间能确定的相同字符串，在运行期间是相同的实例", "url": "/post/same-strings-at-compile-time-are-the-same-instances-at-runtime.html", "categories": "", "tags": "dotnet, csharp", "date": "2019-01-25 15:47:13 +0800", "snippet": "我们知道，在编译期间相同的字符串，在运行期间就会是相同的字符串实例。然而，如果编译期间存在字符串的运算，那么在运行期间是否是同一个实例呢？只要编译期间能够完全确定的字符串，就会是同一个实例。字符串在编译期间能确定的运算包括： A + B 即字符串的拼接 $&quot;{A}&quot; 即字符串的内插字符串拼接对于拼接，我们不需要运行便能知道是否是同一个实例：private const string X = &quot;walterlv is a&quot;;private const string Y = &quot;逗比&quot;;private const string Z = X + Y;以上这段代码是可以编译通过的，因为能够写为 const 的字符串，一定是编译期间能够确定的。字符串内插对于字符串内插，以上代码我们不能写成 const：错误提示为：常量的初始化必须使用编译期间能够确定的常量。然而，这段代码不能在编译期间确定吗？实际上我们有理由认为编译器其实是能够确定的，只是编译器这个阶段没有这么去做而已。实际上在 2017 年就有人在 GitHub 上提出了这个问题，你可以在这里看讨论： [Discussion] Constant string interpolation · Issue #2077 · dotnet/csharplang String interpolation constants · Issue #384 · dotnet/csharplang [Discussion] Constant string interpolation · Issue #11259 · dotnet/roslyn但是，我们写一个程序来验证这是否是同一个实例：using System;namespace Walterlv.Demo{ class Program { static void Main(string[] args) { Console.WriteLine(ReferenceEquals(A, A)); Console.WriteLine(ReferenceEquals(C, C)); Console.WriteLine(ReferenceEquals(E, E)); Console.WriteLine(ReferenceEquals(G, G)); Console.ReadKey(true); } private static string A =&amp;gt; $&quot;walterlv is a {B}&quot;; private static string B =&amp;gt; &quot;逗比&quot;; private static string C =&amp;gt; $&quot;walterlv is a {D}&quot;; private static string D = &quot;逗比&quot;; private static string E =&amp;gt; $&quot;walterlv is a {F}&quot;; private static readonly string F = &quot;逗比&quot;; private static string G =&amp;gt; $&quot;walterlv is a {H}&quot;; private const string H = &quot;逗比&quot;; }}以上代码的输出为：FalseFalseFalseTrue也就是说，对于最后一种情况，也就是内插的字符串是常量的时候，得到的字符串是同一个实例；这能间接证明编译期间完全确定了字符串 G。注意，其他情况都不能完全确定： 属性内插时一定不确定； 静态字段内插时，无论是否是只读的，都不能确定。（谁知道有没有人去反射改掉呢？）我们可以通过 IL 来确定前面的间接证明（代码太长，我只贴出来最重要的 G 字符串，以及一个用来比较的 E 字符串）：.method private hidebysig static specialname string get_G() cil managed{ .maxstack 8 // [22 36 - 22 56] IL_0000: ldstr &quot;walterlv is a 逗比&quot; IL_0005: ret}.method private hidebysig static specialname string get_E() cil managed{ .maxstack 8 // [20 36 - 20 56] IL_0000: ldstr &quot;walterlv is a &quot; IL_0005: ldsfld string Walterlv.Demo.Roslyn.Program::F IL_000a: call string [System.Runtime]System.String::Concat(string, string) IL_000f: ret}可以发现，实际上 G 已经在编译期间完全确定了。扩展：修改编译期间的字符串前面我们说到可以在编译期间完全确定的字符串。呃，为什么一定要抬杠额外写一节呢？下面我们修改编译期间确定的字符串，看看会发生什么：static unsafe void Main(string[] args){ // 这里的 G 就是前面定义的那个 G。 Console.WriteLine(&quot;walterlv is a 逗比&quot;); Console.WriteLine(G); fixed (char* ptr = &quot;walterlv is a 逗比&quot;) { *ptr = &#39;W&#39;; } Console.WriteLine(&quot;walterlv is a 逗比&quot;); Console.WriteLine(G); Console.ReadKey(true);}运行结果是：walterlv is a 逗比walterlv is a 逗比Walterlv is a 逗比Walterlv is a 逗比虽然我们看起来只是在修改我们自己局部定义的一个字符串，但是实际上已经修改了另一个常量以及属性 G。少年，使用指针修改字符串是很危险的！鬼知道你会把程序改成什么样！参考资料 $ - string interpolation - C# Reference - Microsoft Docs [Discussion] Constant string interpolation · Issue #2077 · dotnet/csharplang String interpolation constants · Issue #384 · dotnet/csharplang [Discussion] Constant string interpolation · Issue #11259 · dotnet/roslyn" }, { "title": "使用 Xamarin 开发 iOS 应用中需要注意的若干个问题", "url": "/post/tips-for-developing-xamarin-ios-app.html", "categories": "", "tags": "xamarin, ios", "date": "2019-01-22 09:11:53 +0800", "snippet": "本文收集整理使用 Xamarin 开发 iOS 应用时可能会遇到的各种问题。需要注册 Apple Developer Portal不管你用什么开发 iOS 应用，成为一个 Apple 的开发者是必要的。 访问：https://developer.apple.com/register/ 登录 同意协议完成！虽然简单，但是如果没有成为开发者，那么你在所有工具上都无法成功部署应用。Could not find any available provisioning profiles for iOS这个错误可能出现在你是用 Visual Studio 或者 Visual Studio for Mac 部署真机调试的时候出现。只有 XCode 才能生成 provisioning profiles！所以，如果你希望只使用 Visual Studio 或者 Visual Studio For Mac 或者 Xamarin 来部署是不可能的。如果出现了此错误，你需要使用 XCode 提前生成一份 provisioning profiles 然后在 Visual Studio 中使用这份 profiles。方法： 在 XCode 中新建一个项目； 填写 Bundle Identifier： 注意：必须写成跟你待会儿用 Visual Studio 部署时项目一模一样的 Bundle Identifier！ 比如你在 Visual Studio for Mac 中准备部署的应用为 com.walterlv.CloudKeyboard，那么在这里也必须填写 com.walterlv.CloudKeyboard。 在 XCode 中部署这个临时的项目； 你必须确保真的成功部署到真机上了。 换回 Visual Studio，理论上你现在就可以成功部署了。至于那个在 XCode 中临时建的项目，你可以丢掉，也可以留着。毕竟这种方式创建的 provisioning profiles 只有 6 天的有效期。如果过期了，你就需要再来一次。如果依然不能部署，你需要去项目中设置一下，Visual Studio 中的设置方法如下图：Visual Studio for Mac 中的设置方法则是选中这个项目的 Info.plist 文件，然后点击 Bundle Signing，在对话框中选。需要注册 Apple Developer Program注意，注册 Apple Developer Program 需要付 $99 美元的年费。即便没有注册，也可以部署真机调试，但如上文所说，只有 6 天的有效期。如果注册了，那么有一年。参考资料 How to check whether Xcode downloaded all profiles? - Stack Overflow" }, { "title": "C# 永远不会返回的方法真的不会返回", "url": "/post/method-that-never-returns-does-need-not-return.html", "categories": "", "tags": "csharp", "date": "2019-01-20 15:36:40 +0800", "snippet": "一般情况下，如果一个方法声明了返回值，但是实际上在编写代码的时候没有返回，那么这个时候会出现编译错误。然而，如果方法内部出现了永远也不会退出的死循环，那么这个时候就不会出现编译错误。请看下面这一段代码，RunAndNeverReturns 方法声明了返回值 int 但实际上方法内部没有返回。这段代码是可以编译通过而且可以正常运行的。namespace Walterlv.Demo{ class Program { static void Main(string[] args) { RunAndNeverReturns(); } private static int RunAndNeverReturns() { while (true) { Thread.Sleep(1000); Console.WriteLine(&quot;Walterlv will always appear.&quot;); } // 注意看，这个方法其实没有返回。 } }}如果观察其 IL 代码，会发现此方法的 IL 代码里面是没有 ret 语句的。而其他正常的方法，即便返回值是 void，也是有 ret 语句的。" }, { "title": "CentOS 的终端中如何搜索文件", "url": "/post/search-file-in-the-centos-command-line.html", "categories": "", "tags": "linux", "date": "2019-01-20 15:05:40 +0800", "snippet": "CentOS 中搜索文件可以使用 find 命令。如果需要在当前文件夹中搜索文件，那么可以使用命令：~$ find -name filename其中 filename 是你需要找的文件或文件夹的名称。我们没有指定搜索文件的路径，默认是当前文件夹。如果你希望在所有文件夹中查找，那么可以使用命令：~$ find / -name filename这里的 / 是根目录的意思，当然，你也可以指定为其他路径。比如我要搜索 dotnet 的 SDK，可以使用：~$ find / -name dotnet/usr/share/dotnet/usr/share/dotnet/dotnet返回了两个 dotnet 文件夹。也可以使用通配符：~$ find / -name *.cs参考资料 linux - How to search for a file in the CentOS command line - Stack Overflow" }, { "title": "不使用 U 盘等任何工具全新安装 Windows 操作系统", "url": "/post/install-windows-via-re-without-any-other-external-tools.html", "categories": "", "tags": "windows", "date": "2019-01-17 20:13:38 +0800", "snippet": "安装 Windows 有非常多种方法，现在我们要解决的问题是： 手头没有量产的 U 盘，或者懒得花时间去用 iso 文件量产 U 盘； 不想在 Windows 现有系统下安装（可能是为了全新安装，也可能是为了跳过安装序列号/产品密钥）于是本文教你如何一步一步在 Windows RE 环境下安装操作系统。准备工作 Windows 10 的安装文件 例如 cn_windows_10_consumer_editions_version_1809_updated_jan_2019_x64_dvd_34b4d4fb.iso 现有系统是 Windows 8/8.1/10 操作系统第一步：解压 iso 文件将 iso 文件解压到一个文件夹中，例如，我解压到 D:\\Windows10 文件夹中。第二步：重启进入 RE 环境现在，在开始菜单中点击电源按钮，这时会弹出电源选择菜单。注意：请按住 Shift 键不放，然后点击重启按钮，重启按钮点完之后才能松开 Shift 键。第三步：等待进入 RE 环境这时重启会进入 RE 环境。Windows RE 指的是 Windows Recovery Environment，也就是 Windows 恢复环境。你可以在这里进行很多系统之外的操作。相比于 PE 需要一个光盘或者 U 盘来承载，RE 是直接在你安装 Windows 8/8.1/10 时直接自带到机器硬盘上的。第四步：进入 RE 环境的命令提示符依次进入 疑难解答 -&amp;gt; 高级选项 -&amp;gt; 命令提示符 -&amp;gt; 选择自己的账号 -&amp;gt; 输入自己的密码注意，在选择命令提示符之后，计算机还会再重启一次，所以需要等一会儿才会到选择账号的界面。第五步：在命令提示符中找到安装程序我们一开始将系统解压到了 D:\\Windows10 文件夹下。一般来说，现在也应该是在 D 盘的 Windows10 文件夹下。不过有时候你会发现这里的 D 盘并不是你想象中那个 D 盘，你找不到那个文件夹和里面那个安装文件。这个时候可以去 C 盘、E 盘、F 盘等地方也看看。命令提示符的操作这里就不赘述了，无非是 D: 跳转到某个盘符，cd 跳转到某个文件夹下，setup.exe 打开 setup.exe 这个程序。第六步：按照熟悉的安装系统的流程安装操作系统现在，你应该可以看到熟悉的 Windows 10 安装界面了。比如，你可以在这里跳过产品密钥的输入：比如可以使用在 Windows 内部安装无法使用的“自定义”安装方式：甚至能在这里格式化所有分区，删除所有磁盘：剩下的，祝你好运！" }, { "title": "C#/.NET 如何确认一个路径是否是合法的文件路径", "url": "/post/verify-a-string-as-a-file-path.html", "categories": "", "tags": "csharp, dotnet", "date": "2019-01-16 20:18:20 +0800", "snippet": "很多方法要求传入一个字符串作为文件名或者文件路径，不过方法在实际执行到使用文件名的时候才会真正使用到这个文件名；于是这这种时候才会因为各种各样的异常发现文件名或者文件路径是不合法的。有没有方法能够提前验证文件名或者文件路径是否是合法的路径呢？这是一个不幸的结论 —— 没有！实际上由我们自己写代码判断一个字符串是否是一个合法的文件路径是非常困难的，因为： 不同操作系统的路径格式是不同的； 同一个操作系统有各种各样不同的路径用途。但你可能会说，就算有各种不同，也是可以穷举出来的。那么来看看穷举这些不同的情况需要多少代码吧： Path.Windows.cs PathHelper.Windows.cs PathInternal.Windows.cs看完这些代码，你是不是可以考虑放弃做 100% 精确的提前验证了？放弃是正解。那么接下来如何验证呢？使用 new FileInfo(string fileName) 类型和 Path.GetFullPath(string path) 方法来判断，则会使用到以上的代码，不过副作用是在路径不合法的时候抛出异常。然而作为 API，验证路径的合法性也是需要抛出异常的，所以大可以继续使用这样的方法，用方法内部抛出的异常来提醒开发者传入的路径不合法。但有时候是作为与用户的交互来判断路径或者文件名是否合法的，那么这个时候使用异常就不太合适了。毕竟 C#/.NET 的异常机制不应该参与正常的逻辑流程。那么可以使用 Path.GetInvalidFileNameChars() 和 GetInvalidPathChars() 来判断字符串中是否包含不合法的文件名字符或者路径字符。以下代码来自 .NET Core 的库源码 Path.Windows.cs：public static char[] GetInvalidFileNameChars() =&amp;gt; new char[]{ &#39;\\&quot;&#39;, &#39;&amp;lt;&#39;, &#39;&amp;gt;&#39;, &#39;|&#39;, &#39;\\0&#39;, (char)1, (char)2, (char)3, (char)4, (char)5, (char)6, (char)7, (char)8, (char)9, (char)10, (char)11, (char)12, (char)13, (char)14, (char)15, (char)16, (char)17, (char)18, (char)19, (char)20, (char)21, (char)22, (char)23, (char)24, (char)25, (char)26, (char)27, (char)28, (char)29, (char)30, (char)31, &#39;:&#39;, &#39;*&#39;, &#39;?&#39;, &#39;\\\\&#39;, &#39;/&#39;};public static char[] GetInvalidPathChars() =&amp;gt; new char[]{ &#39;|&#39;, &#39;\\0&#39;, (char)1, (char)2, (char)3, (char)4, (char)5, (char)6, (char)7, (char)8, (char)9, (char)10, (char)11, (char)12, (char)13, (char)14, (char)15, (char)16, (char)17, (char)18, (char)19, (char)20, (char)21, (char)22, (char)23, (char)24, (char)25, (char)26, (char)27, (char)28, (char)29, (char)30, (char)31};参考资料 .net - Determine via C# whether a string is a valid file path - Stack Overflow c# - How do I check if a given string is a legal/valid file name under Windows? - Stack Overflow c# - Windows filepath and filename validation - Code Review Stack Exchange Path.Windows.cs PathHelper.Windows.cs PathInternal.Windows.cs" }, { "title": "让 MSBuild Target 支持 Clean", "url": "/post/support-clean-for-msbuild-target.html", "categories": "", "tags": "msbuild, visualstudio", "date": "2019-01-16 15:20:39 +0800", "snippet": "我们有时候会使用解决方案的清理（Clean）功能来解决一些项目编译过程中非常诡异的问题。这通常是一些 Target 生成了一些错误的中间文件，但又不知道到底是哪里错了。我们自己编写 Target 的时候，也可能会遇到这样的问题，所以让我们自己的 Target 也能支持 Clean 可以在遇到诡异问题的时候，用户可以自己通过清理解决方案来消除错误。以下代码来自于 SourceFusion/Package.targets。这是我主导开发的一个预编译框架，用于在编译期间执行各种代码，以便优化代码的运行期性能。&amp;lt;PropertyGroup&amp;gt; &amp;lt;CleanDependsOn&amp;gt;$(CleanDependsOn);_SourceFusionClean&amp;lt;/CleanDependsOn&amp;gt;&amp;lt;/PropertyGroup&amp;gt; &amp;lt;!--清理 SourceFusion 计算所得的文件--&amp;gt;&amp;lt;Target Name=&quot;_SourceFusionClean&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;_DefaultSourceFusionWorkingFolder Condition=&quot;&#39;$(_DefaultSourceFusionWorkingFolder)&#39; == &#39;&#39;&quot;&amp;gt;obj\\$(Configuration)\\&amp;lt;/_DefaultSourceFusionWorkingFolder&amp;gt; &amp;lt;SourceFusionWorkingFolder Condition=&quot;&#39;$(SourceFusionWorkingFolder)&#39; == &#39;&#39;&quot;&amp;gt;$(_DefaultSourceFusionWorkingFolder)&amp;lt;/SourceFusionWorkingFolder&amp;gt; &amp;lt;SourceFusionToolsFolder&amp;gt;$(SourceFusionWorkingFolder)SourceFusion.Tools\\&amp;lt;/SourceFusionToolsFolder&amp;gt; &amp;lt;SourceFusionGeneratedCodeFolder&amp;gt;$(SourceFusionWorkingFolder)SourceFusion.GeneratedCodes\\&amp;lt;/SourceFusionGeneratedCodeFolder&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;RemoveDir Directories=&quot;$(SourceFusionToolsFolder);$(SourceFusionGeneratedCodeFolder)&quot; /&amp;gt;&amp;lt;/Target&amp;gt;这段代码的作用便是支持 Visual Studio 中的解决方案清理功能。通过指定 CleanDependsOn 属性的值给一个新的 Target，使得在 Clean 的时候，这个 Target 能够执行。我在 Target 中删除了我生成的所有中间文件。你可以通过阅读 通过重写预定义的 Target 来扩展 MSBuild / Visual Studio 的编译过程 来了解这个 Target 是如何工作起来的。参考资料 How to: Clean a Build - Visual Studio - Microsoft Docs" }, { "title": "出于迁移项目的考虑，GitHub 中 Fork 出来的项目，如何与原项目断开 Fork 关系？", "url": "/post/how-to-detach-the-fork-in-github.html", "categories": "", "tags": "github, git", "date": "2019-01-15 19:50:33 +0800", "snippet": "如果需要为 GitHub 上的项目做贡献，我们通常会 Fork 到自己的名称空间下。在推送代码之后添加 pull request 时，GitHub 会自动为我们跨仓库建立 pull request 的连接，非常方便。但是，如果 Fork 是出于项目的迁移，例如从个人名下迁移到某个组织下或者反过来，那么这种自动的 pull request 的设置就很影响效率了。那么这种情况如何处理呢？如何断开 Fork 连接呢？在 GitHub 的官方帮助页面 Commit was made in a fork 中，有这一段话： To detach the fork and turn it into a standalone repository on GitHub, contact GitHub Support or GitHub Premium Support. If the fork has forks of its own, let support know if the forks should move with your repository into a new network or remain in the current network. For more information, see “About forks.”也就是说，你是不能通过自己的操作来断开 Fork 联系的。这是当然的，毕竟随意就能断开的话，开源的一方就非常容易失去对源码的控制权，这很不利于开源社区的贡献。你需要做的，是进入 GitHub 支持页面 https://github.com/contact 在里面填写你的请求，要求 GitHub 官方支持人员手动断开 Fork 关联。填写完之后，等待 GitHub 官方人员处理：当 GitHub 官方人员处理完之后，会给出回复邮件，告知 Fork 关系已经反转：参考资料 Delete fork dependency of a GitHub repository - Stack Overflow Why are my contributions not showing up on my profile? - User Documentation Contact GitHub" }, { "title": ".NET 中 GetHashCode 的哈希值有多大概率会相同（哈希碰撞）", "url": "/post/hash-collisions-of-gethashcode.html", "categories": "", "tags": "dotnet", "date": "2019-01-10 11:41:48 +0800", "snippet": "如果你试图通过 GetHashCode 得到的一个哈希值来避免冲突，你可能要失望了。因为实际上 GetHashCode 得到的只是一个 Int32 的结果，而 Int32 只有 32 个 bit。32 个 bit 的哈希，有多大概率是相同的呢？本文将计算其概率值。对于 GetHashCode 得到的哈希值， 9292 个对象的哈希值冲突概率为 1%； 77163 个对象的哈希值冲突概率为 50%。计算方法计算哈希碰撞概率的问题可以简化为这样： 有 1, 2, 3, … \\(n\\) 这些数字； 现在，随机从这些数字中取出 \\(k\\) 个； 计算这 \\(k\\) 个数字里面出现重复数字的概率。例如： 有 1, 2, 3, 4 这四个不同的数字； 现在从中随机抽取 2 个。那么抽取出来的可能的情况总数为：\\[4^2\\]一定不会重复的可能的情况总数为：\\[4\\times3\\]意思是，第一次抽取的时候有 4 个数字可以选，而第二次抽取的时候就只有 3 个数字可以选了。那么，会出现重复的概率就是：\\[1-\\frac{4\\times3}{4^2}\\]也就是 25% 的概率会出现重复。那么现在，我们随机抽取 3 个会怎样呢？ 有 1, 2, 3, 4 这四个不同的数字； 现在从中随机抽取 3 个。那么，会出现重复的概率就是：\\[1-\\frac{4\\times3\\times2}{4^3}\\]也就是 37.5%，64 种可能里面，有 24 种是有重复的。现在，我们推及到 GetHashCode 函数的重复情况。GetHashCode 实际上返回的是一个 Int32 值，占 32 bit。也就是说，我们有 \\(2^{32}\\) 个数字可以选。现在问题是： 有 1, 2, 3, … \\(2^{32}\\) 这些数字，我们把 \\(2^{32}\\) 记为 \\(n\\)； 现在从中随机抽取 \\(k\\) 个。那么会出现重复的概率为：\\[1-\\frac{n\\times(n-1)\\times(n-2)\\times...(n-k+1)}{n^k}\\]当然，分子分母都有的 \\(n\\) 可以约去：\\[1-\\frac{(n-1)\\times(n-2)\\times...(n-k+1)}{n^{k-1}}\\]计算的简化而 \\(k\\) 很大的时候，此概率的计算非常复杂。然而我们可以取近似值简化成如下形式 [1]：\\[1-e^{\\frac{-k(k-1)}{2n}}\\]当然，实际上此计算在 \\(k\\) 取值较小的时候还可以进一步简化成：\\[\\frac{k(k-1)}{2n}\\]于是，在日常估算的时候，你甚至可以使用计算器估算出哈希值碰撞的概率。你可以阅读 Hash Collision Probabilities 了解更多关于计算简化的内容。概率图为了直观感受到 32 bit 的哈希值的碰撞概率与对象数量之间的关系，我从 Socks, birthdays and hash collisions 和 Hash Collision Probabilities 找到了计算好的概率数据，并绘制成一张图：参考资料 c# - Probability of getting a duplicate value when calling GetHashCode() on strings - Stack Overflow Socks, birthdays and hash collisions – Fabulous Adventures In Coding Hash Collision Probabilities" }, { "title": "int? 竟然真的可以是 null！.NET/C# 确定可空值类型 Nullable&lt;T&gt; 实例的真实类型", "url": "/post/how-to-identify-a-nullable-type.html", "categories": "", "tags": "csharp, dotnet", "date": "2019-01-08 18:01:14 +0800", "snippet": "使用 Nullable&amp;lt;T&amp;gt; 我们可以为原本不可能为 null 的值类型像引用类型那样提供一个 null 值。不过注意：Nullable&amp;lt;T&amp;gt; 本身也是个 struct，是个值类型哦。这意味着你随时可以调用 .HasValue 这样的方法，而不用担心会出现 NullReferenceException。等等！除了本文提到的一些情况。Nullable 中的 null注意看以下的代码。我们创建了一个值为 null 的 int?，然后依次输出 value 的值、value.GetType()。你觉得可以得到什么结果呢？public class Program{ public static void Main(string[] args) { int? value = GetValue(null); Console.WriteLine($&quot;value = {value}&quot;); Console.WriteLine($&quot;type = {value.GetType()}&quot;); Console.WriteLine($&quot;TYPE = {typeof(int?)}&quot;); Console.ReadLine(); } private static int? GetValue(int? source) =&amp;gt; source;}结果是……果是……是……………崩掉了……那么我们在 value 后面加个空传递运算符：-- Console.WriteLine($&quot;type = {value.GetType()}&quot;);++ Console.WriteLine($&quot;type = {value?.GetType()}&quot;);现在再次运行，我们确认了 value?.GetType() 的值为 null；而 typeof(int?) 的类型为 Nullable&amp;lt;Int32&amp;gt;。然而，我们现在将 value 的值从 null 改为 1：-- int? value = GetValue(null);++ int? value = GetValue(1);竟然 value.GetType() 得到的类型是 Int32。于是我们可以得出结论： 对于可空值类型，当为 null 时，GetType() 会出现空引用异常； 对于可空值类型，当不为 null 时，GetType() 返回的是对应的基础类型，而不是可空值类型； typeof(int?) 能够得到可空值类型。Object.GetType() 和 is 对 Nullable 的作用在 docs.microsoft.com 中，有一段对此的描述： When you call the Object.GetType method on an instance of a nullable type, the instance is boxed to Object. As boxing of a non-null instance of a nullable type is equivalent to boxing of a value of the underlying type, GetType returns a Type object that represents the underlying type of a nullable type.意思是说，当你对一个可空值类型 Nullable&amp;lt;T&amp;gt; 调用 Object.GetType() 方法的时候，这个实例会被装箱，会被隐式转换为一个 object 对象。然而对可空值类型的装箱与对值类型本身的装箱是同样的操作，所以调用 GetType() 的时候都是返回这个对象对应的实际基础类型。例如对一个 int? 进行装箱和对 int 装箱得到的 object 对象是一样的，于是 GetType() 实际上是不能区分这两种情况的。那什么样的装箱会使得两个不同的类型被装箱为同一个了呢？另一篇文档描述了 Nullable&amp;lt;T&amp;gt; 装箱的过程： If HasValue returns false, the null reference is produced. If HasValue returns true, a value of the underlying value type T is boxed, not the instance of Nullable. 如果 HasValue 返回 false，那么就装箱一个 null 如果 HasValue 返回 true，那么就将 Nullable&amp;lt;T&amp;gt; 中的 T 进行装箱，而不是 Nullable&amp;lt;T&amp;gt; 的实例。这才是为什么 GetType() 会得到以上结果的原因。同样的，也不能使用 is 运算符来确定这个类型到底是不是可空值类型：Console.WriteLine($&quot;value is int = {value is int}&quot;);Console.WriteLine($&quot;value is int? = {value is int?}&quot;);最终得到两者都是 True。应该如何判断可空值类型的真实类型使用 Nullable.GetUnderlyingType(type) 方法，能够得到一个可空值类型中的基础类型，也就是得到 Nullable&amp;lt;T&amp;gt; 中 T 的类型。如果得不到就返回 null。所以使用以下方法可以判断 type 的真实类型。bool IsNullable(Type type) =&amp;gt; Nullable.GetUnderlyingType(type) != null;然而，这个 type 的实例怎么来呢？根据前面的示例代码，我们又不能调用 GetType() 方法。实际上，这个 type 的实例就是拿不到，在运行时是不能确定的。我们只能在编译时确定，就像下面这样：bool IsOfNullableType&amp;lt;T&amp;gt;(T _) =&amp;gt; Nullable.GetUnderlyingType(typeof(T)) != null;如果你是运行时拿到的可空值类型的实例，那么实际上此方法也是无能为力的。public class Program{ public static void Main(string[] args) { Console.Title = &quot;walterlv&#39;s demo&quot;; int? value = GetValue(1); object o = value; Console.WriteLine($&quot;value is nullable? {IsOfNullableType(value)}&quot;); Console.WriteLine($&quot;o is nullable? {IsOfNullableType(o)}&quot;); Console.ReadLine(); } private static int? GetValue(int? source) =&amp;gt; source; static bool IsOfNullableType&amp;lt;T&amp;gt;(T _) =&amp;gt; Nullable.GetUnderlyingType(typeof(T)) != null;}参考资料 c# - Nullable type is not a nullable type? - Stack Overflow How to: Identify a nullable type - C# Programming Guide - Microsoft Docs Using nullable types - C# Programming Guide - Microsoft Docs" }, { "title": "签署 Centennial Program Addendum，使用 Desktop Bridge 将 Win32 应用转制成 UWP", "url": "/post/windows-desktop-bridge.html", "categories": "", "tags": "dotnet", "date": "2019-01-08 18:01:14 +0800", "snippet": "能上架 Windows 应用商店的并不一定必须是 UWP 应用程序或者 PWA 程序，也可以是普通的 Win32 应用程序。典型的上架应用商店的应用有微信、Telegram、Snipaste 等。使用 Desktop Bridge，我们即可以为我们的普通 Win32 应用程序做一个 UWP 的包来。商店中那些转制的应用如果你并没有感受到 Win32 转制的商店应用和原生的 UWP 或 PWA 应用有什么不同，可以尝试体验下面的三款转制应用。 微信 For Windows https://www.microsoft.com/store/productId/9NBLGGH4SLX7 Telegram Desktop https://www.microsoft.com/store/productId/9NZTWSQNTD0S Snipaste https://www.microsoft.com/store/productId/9P1WXPKB68KX了解 Desktop BridgeDesktop Bridge，可能还可以叫做“桌面桥”，它存在的目的便是将已有的 WPF 程序、Windows Forms 程序和其他 Win32 应用转换成应用商店应用。而桌面桥提供了一种与 UWP 一致的 Windows 应用包，使用这种 Windows 应用包，普通的 Win32 应用也能访问 UWP 的 API。需要注意的是，Desktop Bridge 要求的 Windows 系统最低版本为 1607。也就是说，如果要选择 SDK 的版本，需要选择 10.0.14393 或以上版本。当然，并不是所有的 Win32 应用程序都支持直接转制到 UWP，如果应用会动态加载不在安装包中的 dll 或者会试图修改系统文件和配置，那么必须去掉这些代码才能完成转制。如果希望了解更多不支持的类型，建议阅读官方文档：Prepare to package an app (Desktop Bridge) - UWP app developer - Microsoft Docs。在 Visual Studio 中创建 Windows 应用打包工程使用 Visual Studio 打开原来的 Win32 程序的解决方案，在解决方案中新建一个 Windows 应用程序包项目（Windows Application Packaging Project）。我们将使用这个项目为转制应用打包。在选择 SDK 时，目标版本我选择了 17134，但注意最低版本必须是 14393 或以上。稍等片刻，我们便能看到 Visual Studio 已经为我们准备好的应用程序包工程。在 Applications（应用程序）一栏我们右击选择添加引用。随后展开 Applications（应用程序）一栏，将我们的 Win32 程序右击设为入口点。编译刚刚设置好的打包项目。如果之前的项目能够编译通过，那么这个新的打包项目理论上也是能编译通过的。将这个新项目设置为启动项目，启动它即可进行正常的调试，能够正常断点、单步等等。修改包清单并发布应用各种元数据另外，转制的应用和原生的 UWP 应用一样，发布之前也需要为应用设计图标，设置应用显示名称、包名称、关联应用商店。不得不说，为商店应用设计图标是一件非常繁杂的工作，不过，最终的效果确实非常喜人的。需要注意，在 https://dev.windows.com 上发布应用时，由于我们是转制的应用，所以 runFullTrust 是必选项。如果你在提交应用时遇到了以下提示框，微软的官方文档提示无需写明理由。 This capability is also required for any desktop application that is delivered as an appx package (as with the Desktop Bridge), and it will automatically appear in your manifest when packaging these apps using the Desktop App Converter (DAC) or Visual Studio. You won’t need to request approval to use this capability if you already received permission using our form.建议在给审核人员的提示中，写明我们是转制应用，以引起审核人员的注意。通过认证如果没有接受 Centennial Program Addendum，那么提交是不被允许的，并且在上传 appxupload 的时候会有警告开始提示了： Package acceptance validation warning: You must contact partnerops@microsoft.com and get approval before you can submit this app.当然，你可以忽略这样的警告继续提交，但那样的话最终认证会失败，并提示： Notes To Developer Your developer account has not been approved to submit apps converted with the Desktop Bridge as you have not yet accepted the Centennial Program Addendum. Please resubmit your request for approval.如果无视警告，那么下次提交提示就会变成错误而不是警告了： Package acceptance validation error: You need to accept the Centennial Program Addendum before you can submit this app.▲ You need to accept the Centennial Program Addendum before you can submit this app.提示要求我们必须同意 Centennial Program Addendum 协议，然而我们在 https://partner.microsoft.com/en-us/dashboard/windows/overview 的设置中点进去 Agreements 是找不到这项协议的。以下划重点！！！你需要先提交应用，并时常关注 https://partner.microsoft.com/en-us/dashboard/account/agreements 中是否会新增一项协议提示，就是下图这个：当出现时，点击接受即可。这项协议在微软商店发给你的三天之内才会出现，超过三天还没有同意，这项协议就会自动移除。在我的实际提交中，等待邮件通知之时，三天基本上都过完了，所以稍微不及时收邮件，这项协议就点不开了，就只能看到下面这张图片感叹一声 —— 又要重来！在同意了协议之后，你的协议列表中就会额外出现 Centennial Program Addendum 协议了。以后你可以继续提交转制应用。参考资料 Desktop Bridge - UWP app developer - Microsoft Docs App capability declarations - UWP app developer - Microsoft Docs “Package acceptance validation error” when you submit a UWP + Desktop Bridge app on the Store – App Consult Team Preparing a Desktop Bridge application for the Store submission – App Consult Team Publish your packaged desktop app to a Windows store or sideload it onto one or more devices. - UWP app developer - Microsoft Docs" }, { "title": "C# 中委托实例的命名规则", "url": "/post/name-convention-of-delegate-instance.html", "categories": "", "tags": "dotnet, csharp", "date": "2019-01-08 17:09:07 +0800", "snippet": "我们知道一个类中的属性应该用名词或名词性短语，方法用动词或动宾短语；但是委托的实例却似乎有一些游离。因为在 .NET 中委托代表的是一个动作，既可以把它看作是名词，也可以看作是动词。在用法上，既可以像属性和变量一样被各种传递，也可以像一个方法一样被调用。那么委托实例的命名，应该遵循属性和变量的命名，还是遵循方法的命名呢？委托的实例可以当作属性或者变量使用：var action = () =&amp;gt; Console.WriteLine(&quot;walterlv is a 逗比&quot;);委托的实例也可以当作方法使用：var action = () =&amp;gt; Console.WriteLine(&quot;walterlv is a 逗比&quot;);action();于是委托的命名方式迁就名词还是动词呢？在微软的官方文档 Naming Guidelines 中提到了 .NET 中约定的命名方式。对于委托的命名，实际上只在 Names of Type Members 中提到了，不过提及的实际上是事件型的委托，而不是一般的委托实例。然后，微软其他地方的官方文档中也没有单独提及委托的命名方式。为了弄清楚第一方代码的命名规则，我去 https://source.dot.net/ 上找了一些使用了委托的代码，然后发现，对于 Action 和 Func 系列委托的命名，有以下这些（部分名称只保留了后缀进行合并）：使用名词的： action function callback continuation method factory valueFactory creator valueGetter initializer _target attributeComputer argumentsPromise taskProvider使用动词的： getSource使用缩略词的： localInit我把缩略词单独拿出来，是因为缩写了以下就看不出来这到底是缩自名词还是缩自动词。基本上可以确定：委托实例的命名是 —— 一个表示动作的名词！参考资料 Source Browser" }, { "title": "三值 bool? 进行与或运算后的结果", "url": "/post/the-semantics-of-three-value-bool.html", "categories": "", "tags": "dotnet, csharp", "date": "2019-01-06 20:52:33 +0800", "snippet": "bool? 实际上是 Nullable&amp;lt;Boolean&amp;gt; 类型，可以当作三值的 bool 类型来使用。不过三值的布尔进行与或运算时的结果与二值有什么不同吗？重载条件逻辑运算符“与”（&amp;amp;&amp;amp;）“或”（||） 在 [C# 重载条件逻辑运算符（&amp;amp;&amp;amp; 和   ）](/post/overload-conditional-and-and-or-operators-in-csharp) 一文中我说明了如何重载条件逻辑运算符 &amp;amp;&amp;amp; 和 ||。 这两个运算符不能直接重载，但可以通过重载 &amp;amp; 和 | 运算符来间接完成。对于 bool?，重载了这样两个运算符： bool? operator &amp;amp;(bool? x, bool? y) bool? operator |(bool? x, bool? y)于是我们可以得到三值 bool? 的与或结果。三值 bool? 的与或结果 x y x&amp;amp;y x|y true true true true true false false true true null null true false true false true false false false false false null false null null true null true null false false null null null null null 参考资料 Using nullable types - C# Programming Guide - Microsoft Docs" }, { "title": "为什么我们不应该使用微信或者 QQ 作为团队协作的 IM 工具？", "url": "/post/why-we-need-another-im-tool-only-for-work.html", "categories": "", "tags": "team", "date": "2019-01-06 18:52:36 +0800", "snippet": "如果你的团队没有觉得微信是低效的团队 IM 工具，那只有两种可能： 团队成员很少使用微信进行私人的生活和娱乐。 你就是一个低效的团队，而且还不自知。微信，连接一切微信，连接一切。除了家人、朋友、同学这些熟人关系，还有同事、客户、用户、企业号这些工作上的关系，还有各种各种办事小程序、各种资讯公众号、各种商店服务号、快递通知等生活和私人的快捷入口。每个人都有微信微信的一大目标是让所有人都能用，所以其 UX 体验必须照顾所有人——要尽一切可能简单。这里我不需要说张小龙是如何做到这一点的，但是他就是做到了。因为即便是家里常年不碰手机的老人们都能够使用微信发一些语音消息，抢一些红包，秀一秀朋友圈了。曾经见面要电话联系方式，因为知道每个人都有电话，一定能要得到的。而现在见面会要微信，因为确认每个人都有微信的。所以使用微信来做任何事情的习惯会不断在人群中传播。在某个线下活动中见了一面加一个微信和一堆微信群，在某个工作事件中加一堆内部和外部的微信群。反正，所有人的所有活动都用微信连接着你。微信，低成本的沟通方式发短信不是一个能确保送达的方式，因为现在的短信功能基本上只有广告和验证码的功能，没有人会认真去查阅短信收件箱的。所以短信的成本从原来的套餐价格成本提升到了别人可能不看的成本。为了能够打一个电话，你得差不多确认对方应该有空才行，自己也需要一个可以大声说话的场合。而且打过去对方不一定方便接听。这就是较高的接听成本。邮件，就像写信一样。我们很重视写信，会尽可能说明要点，写明事情。于是写邮件这个过程就是一个高成本的过程。而微信，你无需进行过多的思考，只要你想，打几个字就能发出去。而且你还不用担心对方是否有空，因为当他有空的时候也一定会看见。所以发送的成本低，确保别人收到的成本也低。所以所有种类的人都可以有事没事在微信里面找你一下。不间断的交叉消息干扰咚！技术大佬发话了……咚！快递到了……咚！新的缴费通知……咚！你有一些新的资讯……咚！最新的客户问题跟进如何了……咚！今晚要不要出去聚餐……每时每刻，微信不断有消息袭来。早上、上午、中午、下午、晚上、深夜……一个眨眼的功夫，微信图标上就会多几个数字。我们将一个群设置为免打扰，是因为这个群会说到一些有用的信息，只是有效信息密度太低。虽然可以设置群消息免打扰，但不能屏蔽。免打扰的群消息依然占据一个聊天会话的位置。甚至我想找某人聊一些事情的时候，前一秒正准备点击那个会话，后一秒就被其他群的新消息置顶改变了会话顺序，于是会点错。知识工作者思考打断的恢复成本很高。在工作期间会收到各种社区、朋友和第三方服务等非工作消息，在非工作期间会收到各种工作类的消息。这种交叉干扰使得我们做任何一件事情都比以前更难专注。如果不去看消息，又不能知道哪些消息是重要紧急的，哪些消息是自己关心的，哪些消息是无关紧要可以随后再看的。于是，这种手工的消息分类和过滤，会发生在一天的每一个时刻，深入到工作和生活的每一个角落。不止是消息的交叉干扰以上只是痛点问题，而实际上还有其他的效率问题：微信是为移动端而优化的应用。而实际上一旦说到效率，PC 端是远胜于移动端的。PC 端的信息承载量大、而键盘和鼠标能够快速处理大量信息；这一点是单页的移动端应用和触摸操作远不能比的。然而，微信的 PC 端每次登录需要使用手机扫码或者点击，每天一次就意味着不断在无效的操作上浪费时间。另外，微信的移动端和 PC 端是不自动互通的，具体来说是消息不互通，如果先在移动端收到了一份文件，还需要折腾一阵才能在 PC 端打开使用。别随便什么事儿都拉一个群当然，我指的是工作上的事情。因为多数人更关心工作上的效率，而不是娱乐上的效率。微信上的消息那么多，如果这件事情与对方的关系不大，你根本不能指望对方能够时刻关注着群里事件的最新动向。嗯，这个群在对方的微信里面，只是众多垃圾信息中的一个而已。IM 不适合用来沟通事情的进展，只是用来沟通。所以经常总结进展，仅在必要某人的时候将某人加入，阅读总结的进展才是高效的。好一些的 QQ/TIMTIM 不像微信那样期望所有人用，所以可以在里面放上更多高级的功能。比如群的消息屏蔽，可以设置为完全屏蔽到一个群助手里面。比如群管理，可以有更多的管理方式。使用 TIM 至少可以根据群的有效信息密度划分更多等级的提示级别，可以比微信更容易的筛选和过滤对自己有用的消息。另外，QQ/TIM 的移动端和 PC 端的同步是实时的自动的。可以随时在 PC 端继续，而无需受限在移动端上。不过，QQ/TIM 依然聚合了各种维度的信息，依然会存在各种信息的交叉干扰。我们需要新的消息过滤和聚合方式实际上，只要团队协作不使用 QQ 或者微信这种聚合所有交流的工具进行团队协作，就能够大大降低团队成员的信息过滤的成本。在工作期间，只注重团队专用 IM 工具发来的消息，而对于 QQ/微信发来的消息可以延迟统一查看。如果这款工具做得更好，那么可以为团队 IM 的不同消息进行分级： 紧急的工作任务，应该只在紧急情况使用，可以打断相关成员。 协同工作所需的聊天，应该只打扰相关的协同方；其他人可以关注进展，但不应该被打扰。 工作期间也可以吹水，但这些信息一定不能不断打断团队成员。 还有其他的消息过滤级别。于是，我们在手机上可以通过 App 的不同来进行消息分级，避免不同种类的消息交叉干扰。在 PC 上通过任务栏上不同的软件来避免消息的交叉干扰；甚至工作期间在 PC 上可以不启动非工作用的软件。考虑使用工作专用的 IM 工具TIM 相比于 QQ，提供了更适合于工作场合的 UI/UX。可以让我们更加专注于工作本身而不必被 QQ 的其他功能打扰。不过 TIM 和 QQ 的消息是完全互通的，这样就做不到消息的自动过滤，依然存在消息之间的交叉干扰。企业微信与微信的消息不是直接互通的，而是作为企业外部人员来对待。钉钉是一款全新的 IM，所以消息自然不会互通。这就断开了企业内部的消息和其他消息的交叉干扰。当工作时，会只注重由企业微信或者钉钉发来的消息，微信或者 QQ 的消息就可以延迟查看；而离开工作时，可以延迟关注来自于企业微信或者钉钉发来的消息，更加关注朋友与技术社区，专注于情感的建立与个人的成长。反正，无论你用什么，只要不是 QQ 或者微信，团队的 IM 效率就能得到提升。考虑使用 Slack可以试试 Slack，这也是一款以 IM 为主的团队协作工具。不过，它还带了更多的扩展 API 可以使用，可以接入到团队正在使用的各种系统中来。帮助我们将大量的手工任务改造成自动化完成的任务。" }, { "title": "Slack 开发入门之 Incoming Webhooks：往 Slack 的 Channel 中发消息", "url": "/post/slack-api-starter-incoming-webhooks.html", "categories": "", "tags": "slack, web", "date": "2019-01-06 15:29:19 +0800", "snippet": "一个工程师团队使用 Slack 进行团队协作比 QQ / 微信流的效率高多啦。除了基本的 IM 之外，它的扩展性也是非常重要的一点。本文介绍 Slack 的开发入门：Incoming Webhooks 篇。创建一个新 Slack 应用如果你已经创建了一个 Slack 应用，可以跳过这一节。在这里 https://api.slack.com/apps/new 创建一个新的 Slack 应用：填写完两个信息之后，你就可以选择五种不同的应用类型： Incoming Webhooks Post messages from external sources into Slack. 将外部的资源作为一个消息发送到 Slack 中。 Interactive Components Add buttons to your app’s messages, and create an interactive experience for users. 为 Slack 中消息添加一个按钮，以便让你的应用与用户之间可以有交互。 Slash Commands Allow users to perform app actions by typing commands in Slack. 允许用户在 Slack 中敲入命令来控制应用的行为。 Event Subscriptions Make it easy for your app to respond to activity in Slack. 允许你的应用响应 Slack 中的一些活动。 Bots Add a bot to allow users to exchange messages with your app. 开发一个机器人，与 Slack 中的其他人进行交流。 Permissions Configure permissions to allow your app to interact with the Slack API. 管理你的应用与 Slack API 之间的权限。 创建 Webhooks 应用本文，我们选中 Incoming Webhooks。或者如果这已经是你创建好的应用了，可以左边的列表中选择 Incoming Webhooks。然后按一下右上角的激活按钮，使得 Incoming Webhooks 功能激活。如果顶部有提示因为权限问题需要重新安装，那么就点进去重新安装。添加一个 Webhook Url继续把网页往下滑，点击 [Add New Webhook to Workspace]。然后选择需要发消息的 Channel：这时，页面还会继续回到添加 Url 的地方，但示例 Demo 已经换上了真实的 Url，而且你可以复制到剪贴板。模拟发送一个消息为了迅速验证，我们可以使用 Postman 来发送这条消息。关于下载和使用 Postman，你可以参考我的另一篇博客：使用 Postman 调试 ASP.NET Core 开发的 API。填写要 POST 的 Url，然后在消息的 Body 中填写 JSON 格式的消息内容：{ &quot;text&quot;: &quot;Hi! 给你个 **任务** 玩玩。&quot;}这时，点击 Send 按钮，消息发送成功。于是我的 Slack 通道中收到了一条来自这个应用发来消息：你可以用这个来做什么？当你可以随时向 Slack 的某个通道发送消息之后，你可以用来做什么呢？你可以定时发送团队的代码审查发送发现的问题，可以发送自动化编译失败的信息，可以发送每周的任务计划和总结，等等。当然，Slack 上本身就提供了大量的应用可以直接下载安装，自己做开发是解决更定制化的需求。参考资料 Enabling interactions with bots - Slack" }, { "title": "WPF 中那些可跨线程访问的 DispatcherObject（WPF Free Threaded Dispatcher Object）", "url": "/post/wpf-free-threaded-dispatcher-object.html", "categories": "", "tags": "wpf, dotnet", "date": "2019-01-03 09:03:45 +0800", "snippet": "众所周知的，WPF 中多数对象都继承自 DispatcherObject，而 DispatcherObject 带给这些对象一个特点：不能跨线程访问。不过，WPF 中依然存在一些例外。本文将介绍 WPF 那些可跨线程访问的 DispatcherObject，如何充分利用这个特点提高应用程序的性能，以及如何自己编写这样的 DispatcherObject。什么样的 DispatcherObject 可以跨线程访问？要了解什么样的 DispatcherObject 可以跨线程访问，需要知道 WPF 是如何限制对象的跨线程访问的。Dispatcher 属性DispatcherObject 类有一个 Dispatcher 属性，它长下面这样：public Dispatcher Dispatcher{ get { // This property is free-threaded. return _dispatcher; }}属性在 Dispatcher 的构造函数中被赋值：protected DispatcherObject(){ _dispatcher = Dispatcher.CurrentDispatcher;}CheckAccess 和 VerifyAccessDispatcherObject 提供了两种验证 Dispatcher 的方法，CheckAccess 和 VerifyAccess；他们内部的实现是调用 Dispatcher 类型的 CheckAccess 和 VerifyAccess 方法。CheckAccess 用于检查调用线程对此对象是否有访问权，如果有访问权，则返回 true，否则返回 false。而 VerifyAccess 也是用于检查调用线程对此对象是否有访问权，如果没有访问权会抛出异常。你可以阅读这两个方法的代码来了解其实现原理。每个方法只有短短的一两行而已，非常容易理解。/// &amp;lt;summary&amp;gt;/// Checks that the calling thread has access to this object./// &amp;lt;/summary&amp;gt;/// &amp;lt;remarks&amp;gt;/// Only the dispatcher thread may access DispatcherObjects./// &amp;lt;p/&amp;gt;/// This method is public so that any thread can probe to/// see if it has access to the DispatcherObject./// &amp;lt;/remarks&amp;gt;/// &amp;lt;returns&amp;gt;/// True if the calling thread has access to this object./// &amp;lt;/returns&amp;gt;[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]public bool CheckAccess(){ return Thread == Thread.CurrentThread;}/// &amp;lt;summary&amp;gt;/// Verifies that the calling thread has access to this object./// &amp;lt;/summary&amp;gt;/// &amp;lt;remarks&amp;gt;/// Only the dispatcher thread may access DispatcherObjects./// &amp;lt;p/&amp;gt;/// This method is public so that derived classes can probe to/// see if the calling thread has access to itself./// &amp;lt;/remarks&amp;gt;[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]public void VerifyAccess(){ if(!CheckAccess()) { throw new InvalidOperationException(SR.Get(SRID.VerifyAccess)); }}需要说明的是，只有调用这两个方法才会对线程的访问权限进行检查。如果你写一个类继承自 DispatcherObject 而在你的属性和方法中不直接或间接调用 VerifyAccess，那么这是不受线程访问限制的。只不过，WPF 封装的大多对象和属性都调用了 VerifyAccess（例如依赖项属性），所以很大程度上限制了 WPF UI 的线程访问权限。_dispatcher 的重新赋值Dispatcher 属性的获取实际上就是在拿 _dispatcher 字段的值。于是我们现在仔细寻找 _dispatcher 的所有赋值代码，只有三处，就是下面这三个方法： 构造函数，会赋值为当前线程的 Dispatcher； DetachFromDispatcher，会赋值为 null； MakeSentinel，会赋值为另一个线程的 Dispatcher 的值（即一个线程创建，但由另一个线程来使用）。/// &amp;lt;summary&amp;gt;/// Instantiate this object associated with the current Dispatcher./// &amp;lt;/summary&amp;gt;protected DispatcherObject(){ _dispatcher = Dispatcher.CurrentDispatcher;}// This method allows certain derived classes to break the dispatcher affinity// of our objects.[FriendAccessAllowed] // Built into Base, also used by Framework.internal void DetachFromDispatcher(){ _dispatcher = null;}// Make this object a &quot;sentinel&quot; - it can be used in equality tests, but should// not be used in any other way. To enforce this and catch bugs, use a special// sentinel dispatcher, so that calls to CheckAccess and VerifyAccess will// fail; this will catch most accidental uses of the sentinel.[FriendAccessAllowed] // Built into Base, also used by Framework.internal void MakeSentinel(){ _dispatcher = EnsureSentinelDispatcher();}private static Dispatcher EnsureSentinelDispatcher(){ if (_sentinelDispatcher == null) { // lazy creation - the first thread reaching here creates the sentinel // dispatcher, all other threads use it. Dispatcher sentinelDispatcher = new Dispatcher(isSentinel:true); Interlocked.CompareExchange&amp;lt;Dispatcher&amp;gt;(ref _sentinelDispatcher, sentinelDispatcher, null); } return _sentinelDispatcher;}于是我们发现，实际上 Dispatcher 属性虽然在 DispatcherObject 对象创建的时候会赋值，但实际上提供了多种方法来修改值。有的是修改成另一个线程的 Dispatcher，而有的就是粗暴地赋值为 null。_dispatcher 赋值为 null无论是 CheckAccess 还是 VerifyAccess 方法，实际上都对 null 进行了判断。public bool CheckAccess(){ // This method is free-threaded. bool accessAllowed = true; Dispatcher dispatcher = _dispatcher; // Note: a DispatcherObject that is not associated with a // dispatcher is considered to be free-threaded. if(dispatcher != null) { accessAllowed = dispatcher.CheckAccess(); } return accessAllowed;}public void VerifyAccess(){ // This method is free-threaded. Dispatcher dispatcher = _dispatcher; // Note: a DispatcherObject that is not associated with a // dispatcher is considered to be free-threaded. if(dispatcher != null) { dispatcher.VerifyAccess(); }}注释中说明： Note: a DispatcherObject that is not associated with a dispatcher is considered to be free-threaded.也就是说，如果一个 DispatcherObject 对象没有任何被关联的 Dispatcher，那么就被认为这个 DispatcherObject 没有线程访问限制，此对象将允许被任何线程访问。哪些 DispatcherObject 是可以跨线程访问的？通过阅读 DispatcherObject 的源码，我们可以知道 DispatcherObject 其实是允许跨线程访问的，它只是在刚刚创建的时候如果没有其他额外的方法调用使得 Dispatcher 属性改变，那么就只能被创建它的线程访问。但也需要注意，能够改变 Dispatcher 属性值的两个方法 DetachFromDispatcher 和 MakeSentinel 都是 internal 的。这意味着只有微软自己在 WindowsBase、PresentationCore 和 PresentationFramework 程序集中编写的类型才能修改其值。可是，有哪些类呢？通过查找 DetachFromDispatcher 的引用，我找到了以下类型： Freezable Style StyleHelper TriggerBase BeginStoryboard ResourceDictionary也就是说，这些类型的实例会在某种特定的条件下从单线程访问权限变为可被任意跨线程访问。（实际上 ResourceDictionary 并不是一个 DispatcherObject，不过它会访问 Owner，这是一个 DependencyObject；所以也会涉及到一点跨线程问题。）而查找 MakeSentinel 的引用，又可以找到： ItemsControl也就是说，ItemsControl 类在某种情况下提供了一种在一个线程中创建对象，在另外一个线程中使用的特性。FreezableFreezable 是继承自 DispatcherObject 的一个抽象类，其出现的主要目的就是解决 WPF 单线程模型带来的负面性能影响。Freezable 主要由那些与图形渲染强相关的 WPF 类型继承，比如 Brush、Transform、Geometry、D3DImage 还有各种动画等。典型的，这些类型都对高性能渲染有要求。这些类型的刚开始创建的时候只能由创建的对象对它进行修改，而且在修改的时候还会引发 Changed 事件以便相关类型对其进行处理。不过，一旦 Freeze，这些类型将变成不可修改，这时不会也不需要再引发 Changed 事件，可以提升性能，同时对所有线程开放访问权限，这样能继续提升性能。你可以对 Freezable 对象调用 Freeze() 方法，调用之后，其 Dispatcher 属性会被设为 null，于是对象可以跨线程访问。在 XAML 中，你可以通过指定 PresentationOptions:Freeze 特性达到同样的目的。如下面的例子，SolidColorBrush 对象在创建完设置完所有的值之后，会调用 Freeze 冻结这个对象以便跨线程访问。&amp;lt;Page xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:PresentationOptions=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation/options&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; mc:Ignorable=&quot;PresentationOptions&quot;&amp;gt; &amp;lt;!-- 如果你的 mc:Ignorable 有多个，请用空格隔开。 --&amp;gt; &amp;lt;Page.Resources&amp;gt; &amp;lt;!-- 注意，在 Resource 中的 SolidColorBrush 默认情况下是不会自动 Freeze 的， --&amp;gt; &amp;lt;!-- 但是，你可以通过指定 PresentationOptions:Freeze 特性使得它在创建完后 Freeze。 --&amp;gt; &amp;lt;!-- 对象在 Resources 中不会自动创建，它会在第一次被使用的时候创建， --&amp;gt; &amp;lt;!-- 也就是说，你如果要验证它的跨线程访问，需要使用两个不同的线程访问它。 --&amp;gt; &amp;lt;SolidColorBrush x:Key=&quot;Walterlv.Brush.Demo&quot; PresentationOptions:Freeze=&quot;True&quot; Color=&quot;Red&quot; /&amp;gt; &amp;lt;/Page.Resources&amp;gt;&amp;lt;/Page&amp;gt;对于以上代码，有一些是需要说明的： 如果你的 mc:Ignorable 有多个，请用空格隔开。 在 Resource 中的 SolidColorBrush 默认情况下是不会自动 Freeze 的；但是，你可以通过指定 PresentationOptions:Freeze 特性使得它在创建完后 Freeze。 对象在 Resources 中不会自动创建，它会在第一次被使用的时候创建；也就是说，你如果要验证它的跨线程访问，需要使用两个不同的线程访问它（仅仅用一个后台线程去验证它，你会发现后台线程依然能够正常访问它的依赖项属性的值）。StyleStyle 是直接继承自 DispatcherObject 的类型，并没有 Freeze 相关的方法。不过这不重要，因为重要的是能够访问到内部的 DetachFromDispatcher 方法。Style 访问 DetachFromDispatcher 的代码在 public 的 Seal 方法中，这是继承自 internal 的 ISealable 接口的方法。internal interface ISealable{ bool CanSeal { get; } void Seal(); bool IsSealed { get; }}为了方便理解，我把 Seal 方法进行简化后贴在下面：/// &amp;lt;summary&amp;gt;/// This Style and all factories/triggers are now immutable/// &amp;lt;/summary&amp;gt;public void Seal(){ // Verify Context Access VerifyAccess(); // 99% case - Style is already sealed. if (_sealed) return; // 省略一些验证代码。 // Seal setters if (_setters != null) _setters.Seal(); // Seal triggers if (_visualTriggers != null) _visualTriggers.Seal(); // Will throw InvalidOperationException if we find a loop of // BasedOn references. (A.BasedOn = B, B.BasedOn = C, C.BasedOn = A) CheckForCircularBasedOnReferences(); // Seal BasedOn Style chain if (_basedOn != null) _basedOn.Seal(); // Seal the ResourceDictionary if (_resources != null) _resources.IsReadOnly = true; // // Build shared tables // // Process all Setters set on the selfStyle. This stores all the property // setters on the current styles into PropertyValues list, so it can be used // by ProcessSelfStyle in the next step. The EventSetters for the current // and all the basedOn styles are merged into the EventHandlersStore on the // current style. ProcessSetters(this); // Add an entry in the EventDependents list for // the TargetType&#39;s EventHandlersStore. Notice // that the childIndex is 0. StyleHelper.AddEventDependent(0, this.EventHandlersStore, ref EventDependents); // Process all PropertyValues (all are &quot;Self&quot;) in the Style // chain (base added first) ProcessSelfStyles(this); // Process all TriggerBase PropertyValues (&quot;Self&quot; triggers // and child triggers) in the Style chain last (highest priority) ProcessVisualTriggers(this); // Sort the ResourceDependents, to help avoid duplicate invalidations StyleHelper.SortResourceDependents(ref ResourceDependents); // All done, seal self and call it a day. _sealed = true; // Remove thread affinity so it can be accessed across threads DetachFromDispatcher();}具体来说，就是将 Style 中的所有属性进行 Seal，将资源设为只读；然后，将自己的 Dispatcher 属性设为 null。Template不过，我们通常使用 Style 的方式都是在 Style 中写控件模板。如果控件模板不支持 Seal，那么 Style 即便 Seal，多数情况下也是没有用的。在 StyleHelper 类型中，处理了控件模板的 Seal。它处理的是 FrameworkTemplate，这是控件模板的基类，具体来说，有这些类型： ControlTemplate DataTemplate ItemsPanelTemplate ItemContainerTemplate HierarchicalDataTemplate ContentPresenter.DefaultTemplate ContentPresenter.UseContentTemplate以下是 StyleHelper.SealTemplate 方法。这里原本是 FrameworkTemplate 内部的 Seal 方法的实现，不过 Seal 内部调到了 StyleHelper.SealTemplate 静态方法了。为了便于理解，我也对其进行了精简。internal static void SealTemplate( FrameworkTemplate frameworkTemplate, ref bool isSealed, FrameworkElementFactory templateRoot, TriggerCollection triggers, ResourceDictionary resources, HybridDictionary childIndexFromChildID, ref FrugalStructList&amp;lt;ChildRecord&amp;gt; childRecordFromChildIndex, ref FrugalStructList&amp;lt;ItemStructMap&amp;lt;TriggerSourceRecord&amp;gt;&amp;gt; triggerSourceRecordFromChildIndex, ref FrugalStructList&amp;lt;ContainerDependent&amp;gt; containerDependents, ref FrugalStructList&amp;lt;ChildPropertyDependent&amp;gt; resourceDependents, ref ItemStructList&amp;lt;ChildEventDependent&amp;gt; eventDependents, ref HybridDictionary triggerActions, ref HybridDictionary dataTriggerRecordFromBinding, ref bool hasInstanceValues, ref EventHandlersStore eventHandlersStore){ // This template has already been sealed. There is no more to do. if (isSealed) return; // Seal template nodes (if exists) if (frameworkTemplate != null) frameworkTemplate.ProcessTemplateBeforeSeal(); if (templateRoot != null) templateRoot.Seal(frameworkTemplate); // Seal triggers if (triggers != null) triggers.Seal(); // Seal Resource Dictionary if (resources != null) resources.IsReadOnly = true; // Build shared tables StyleHelper.ProcessTemplateTriggers( triggers, frameworkTemplate, ref childRecordFromChildIndex, ref triggerSourceRecordFromChildIndex, ref containerDependents, ref resourceDependents, ref eventDependents, ref dataTriggerRecordFromBinding, childIndexFromChildID, ref hasInstanceValues, ref triggerActions, templateRoot, ref eventHandlersStore, ref frameworkTemplate.PropertyTriggersWithActions, ref frameworkTemplate.DataTriggersWithActions, ref hasHandler ); frameworkTemplate.HasLoadedChangeHandler = hasHandler; frameworkTemplate.SetResourceReferenceState(); // All done, seal self and call it a day. isSealed = true; // Remove thread affinity so it can be accessed across threads frameworkTemplate.DetachFromDispatcher();}其中，frameworkTemplate.DetachFromDispatcher() 方法即调用基类 DispatcherObject 中的 DetachFromDispatcher 方法。方法内部也是对各种属性进行了 Seal 和只读化处理。最后，将自己的 Dispatcher 属性设为 null。Style 和 Template由于每次应用模板的时候，都是创建新的 UI 控件，所以实际上通过模板创建的 UI 对象并不会产生跨线程访问的问题。也就是说，当 Style 和 Template 设置为可跨线程访问之后，是可以被多个线程同时访问创建控件而不会产生跨线程访问的问题。写在 XAML 中的 ISealable 在创建的时候就会执行 Seal()。也就是说，你只要在 XAML 中写下了这个对象，那么就会在创建完后 Seal。这点跟 Freezable 是不一样的，Freezable 是需要自己主动编写 XAML 或 C# 代码进行 Freeze 的。从这里可以推论出，你在 XAML 中写的样式，可以被跨线程访问而不会出现线程安全问题。强制让一个 DispatcherObject 跨线程访问从前面的各种源码分析来看，使用常规方法让任意一个对象进行跨线程访问几乎是不可能的了。剩下的就只是做一些邪恶的事情了，比如 —— 反射。可以反射调用 DetachFromDispatcher 方法，将 Dispatcher 属性值清空，这样的对象将可以跨所有线程访问。不过要小心，你随意写的对象可能实际上是不具备跨线程访问能力的，这样的修改可能导致线程安全问题，你需要自行承担后果。可以反射直接修改 _dispatcher 字段的值，改为目标线程中的 Dispatcher。这样的做法只是切换了一个线程，效果和调用 MakeSentinel 是一样的。使用这样的方式可以让创建对象的线程和使用对象的线程分开，适用于创建对象需要花费大量时间的对象 —— 如 BitmapImage。特别的，如果你的对象中有子 DispatcherObject 对象，你需要像上面的源码那样将所有子对象的 Dispatcher 属性都进行替换才行。为了方便，我写了一个辅助方法来完成这样的 Dispatcher 属性值切换。using System;using System.Reflection;using System.Threading;using System.Windows.Threading;namespace Walterlv.Windows.Threading{ /// &amp;lt;summary&amp;gt; /// 包含 &amp;lt;see cref=&quot;DispatcherObject&quot;/&amp;gt; 及其派生类对象切换所属线程的相关方法。 /// &amp;lt;/summary&amp;gt; public static class DispatcherSwitcher { /// &amp;lt;summary&amp;gt; /// 延迟初始化 &amp;lt;see cref=&quot;Dispatcher&quot;/&amp;gt; 类型中的 _dispatcher 字段。 /// &amp;lt;/summary&amp;gt; private static readonly Lazy&amp;lt;FieldInfo&amp;gt; DispatcherFieldInfo = new Lazy&amp;lt;FieldInfo&amp;gt;(() =&amp;gt; typeof(DispatcherObject).GetField(&quot;_dispatcher&quot;, BindingFlags.NonPublic | BindingFlags.Instance), LazyThreadSafetyMode.None); /// &amp;lt;summary&amp;gt; /// 将指定的 &amp;lt;see cref=&quot;DispatcherObject&quot;/&amp;gt; 对象的所属线程切换至指定调度器所属的线程。 /// 注意：如果此对象包含嵌套的其他对象，则极有可能会发生跨线程访问的异常，请谨慎使用！ /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;d&quot;&amp;gt;&amp;lt;/param&amp;gt; /// &amp;lt;param name=&quot;dispatcher&quot;&amp;gt;&amp;lt;/param&amp;gt; internal static void SwitchTo(DispatcherObject d, Dispatcher dispatcher) { if (d.Dispatcher == dispatcher) return; var field = DispatcherFieldInfo.Value; if (field == null) { throw new FieldAccessException(); } field.SetValue(d, dispatcher); } }}总结 为什么 DispatcherObject 可以限制跨线程访问？ 因为内部有 CheckAccess 和 VerifyAccess 方法检查线程的访问权限 众多子类的属性和方法在使用前调用了 VerifyAccess 来验证调用方的线程 在 XAML 中编写的代码时，定义在 FrameworkElement 的 Resources 中的对象，哪些可以跨线程访问，哪些不可以跨线程访问？ 非继承自 DispatcherObject 的对象可以跨线程访问（这里就不要钻牛角尖说自己写的烂类了） 比如 &amp;lt;system:String&amp;gt;Walterlv&amp;lt;/system:String&amp;gt; 继承自 DispatcherObject 的对象，但是同时实现了内部 ISealable 接口的对象 比如 Style、Template、DataTemplate、ItemTemplate 等 继承自 Freezable 的对象 指定了 PresentationOptions:Freeze=&quot;True&quot; 特性的对象可以跨线程访问 没有指定此特性的对象不可以跨线程访问 这些对象比如 Brush、Transform、Geometry、D3DImage 还有各种动画等 其他 DispatcherObject 对象 不可以跨线程访问（当然你自己写的类型，没有访问基类的 VerifyAccess 的话就没事） 可以随意切换 DispatcherObject 关联的 Dispatcher 吗？ 不可以随意切换，因为切换关联 Dispatcher 的方法都是 internal 的 不过我们可以使用反射来间接实现这个效果（当然，你需要自行承担线程安全后果，以及切换不完全造成的跨线程访问问题） 参考资料 Freezable Objects Overview - Microsoft Docs mc:Ignorable Attribute - Microsoft Docs DispatcherObject.cs" }, { "title": ".NET 使用 XPath 来读写 XML 文件（顺带解决 XML 命名空间的问题）", "url": "/post/read-write-xml-using-xpath-in-dotnet.html", "categories": "", "tags": "dotnet", "date": "2019-01-01 11:34:30 +0800", "snippet": "XPath 是 XML 路径语言（XML Path Language），用来确定XML文档中某部分位置的语言。无论是什么语言什么框架，几乎都可以使用 XPath 来高效查询 XML 文件。本文将介绍 .NET 中的 XPath 相关类型的使用。本文读写的 XML 文件会以 文章末尾的代码 - 假设的 XML 文件 作为示例。关于 XPath 语法，可以阅读 XML 的 XPath 语法 了解更多。一切从这里开始.NET 中支持 XPath 的 XML 文档类有两种读取方法，一种是 XPathDocument，以只读的方式读取；另一种是 XmlDocument，不止可以读，还可以编辑。// 得到 walterlv.xml 文档在内存中的快速只读表示形式。var xPathDocument = new XPathDocument(&quot;walterlv.xml&quot;);// 以可读可写的方式打开 walterlv.xml 文件。var xmlDocument = new XmlDocument(); xmlDocument.Load(&quot;walterlv.xml&quot;); 如果要确定 XML 的文件编码，需要使用 XmlTextReader 来读 XML 文件；它的基类 XmlReader 没有提供编码信息。XmlTextReader 作为参数传入 XPathDocument 的构造函数或 XmlDocument.Load 方法中即可。无论是 XPathDocument 还是 XmlDocument，因为都实现了 IXPathNavigable，所以都有 CreateNavigator(); 方法，调用能得到 XPathNavigator 对象。不过前者的 CanEdit 是 false，后者的 CanEdit 是 true。var navigator1 = xPathDocument.CreateNavigator();var navigator2 = xmlDocument.CreateNavigator();上手 XPath路径查询XPathNavigator 对象提供了下面两种通用的 XPath 表达式的使用检索方法。 Select SelectSingleNode比如希望检索本文末尾的 XML 文件中的 id，使用 /package/metadata/id 即可检索。当然，事实上这个 XML 文件是不能这样检索出来 id 的，因为它带有命名空间。带有命名空间的检索需要使用到 XmlNamespaceManager 类，并写成下面这样：var namespaceManager = new XmlNamespaceManager(new NameTable());namespaceManager.AddNamespace(&quot;d&quot;, &quot;http://schemas.microsoft.com/packaging/2012/06/nuspec.xsd&quot;);navigator.Select(&quot;/d:package/d:metadata/d:id&quot;, namespaceManager);这里其实略微奇怪，因为命名 package、id 等都在默认的命名空间下，我们却必须显式加一个命名空间前缀。微软对此的解释是如果不指定命名空间前缀，默认都是 null，而不是 XML 声明的那个默认命名空间。这里是原文： XPath treats the empty prefix as the null namespace. In other words, only prefixes mapped to namespaces can be used in XPath queries. This means that if you want to query against a namespace in an XML document, even if it is the default namespace, you need to define a prefix for it.路径检索的语法也有很多种，可以参考我的另一篇文章 XML 的 XPath 语法。为了提升性能，XPathNavigator 额外提供了这些方法，用于替代 XPath 中的部分对应的语法： SelectChildren SelectAncestors SelectDescendantsXPath 函数调用Compile 和 Evaluate 提供了复杂的 XPath 函数调用。比如下面我们把几种 url 都拼接在一起得到一个新字符串。XPathExpression query = navigator.Compile(&quot;concat(//licenseUrl/text(), //projectUrl/text(), //iconUrl/text())&quot;);string urls = (string) navigator.Evaluate(query);节点匹配Matches 用来检查当前的节点是否满足某个条件。比如下面的例子便是检查当前节点的父节点是否是 group 并且其 targetFramework 属性为 .NETStandard2.0。显然，符合这个条件的只有最后的那个 dependency 节点。navigator.Matches(&quot;../group/@targetFramework=&#39;.NETStandard2.0&#39;&quot;);XPath 导航XPathNavigator 可以在节点、属性中间移动，以便能够不止从根节点进行查询。 MoveTo MoveToChild MoveToFirst MoveToFirstChild MoveToFollowing MoveToId MoveToNext MoveToParent MoveToPrevious MoveToRoo MoveToAttribute MoveToFirstAttribute MoveToNextAttribute MoveToNamespace MoveToFirstNamespace MoveToNextNamespace在导航到需要的节点或者属性后，可以使用 navigator.OuterXml 拿到节点的所有 XML 字符串。也可以使用下面这些方法拿到节点内部的值。 ValueAsBoolean ValueAsDateTime ValueAsDouble ValueAsInt ValueAsLong ValueAs编辑 XML由于我们要编辑 XML 数据，所以加载 XML 文件的方式不能是 XPathDocument 了，得是 XmlDocument。插入使用 Insert 相关的方法，删除使用 Delete 相关的方法。而修改数据使用 SetValue。保存 XML 到文件保存 XML 使用 XmlDocument 的 Save 或者 WriteTo 方法即可。假设的 XML 文件&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;package xmlns=&quot;http://schemas.microsoft.com/packaging/2012/06/nuspec.xsd&quot;&amp;gt; &amp;lt;metadata&amp;gt; &amp;lt;id&amp;gt;MSTestEnhancer&amp;lt;/id&amp;gt; &amp;lt;version&amp;gt;1.6.0&amp;lt;/version&amp;gt; &amp;lt;authors&amp;gt;walterlv&amp;lt;/authors&amp;gt; &amp;lt;owners&amp;gt;walterlv&amp;lt;/owners&amp;gt; &amp;lt;requireLicenseAcceptance&amp;gt;false&amp;lt;/requireLicenseAcceptance&amp;gt; &amp;lt;licenseUrl&amp;gt;https://github.com/easiwin/MSTestEnhancer/blob/master/LICENSE&amp;lt;/licenseUrl&amp;gt; &amp;lt;projectUrl&amp;gt;https://easiwin.github.io/mstest-enhancer&amp;lt;/projectUrl&amp;gt; &amp;lt;iconUrl&amp;gt;https://easiwin.github.io/mstest-enhancer/icon.png&amp;lt;/iconUrl&amp;gt; &amp;lt;description&amp;gt;MSTestEnhancer helps you to write unit tests without naming any method. You can write method contract descriptions instead of writing confusing test method name when writing unit tests.&amp;lt;/description&amp;gt; &amp;lt;releaseNotes&amp;gt;Support passing null into WithArgument method.&amp;lt;/releaseNotes&amp;gt; &amp;lt;copyright&amp;gt;Copyright (c) 2018 dotnet职业技术学院&amp;lt;/copyright&amp;gt; &amp;lt;repository type=&quot;git&quot; url=&quot;https://github.com/easiwin/MSTestEnhancer.git&quot; /&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;group targetFramework=&quot;.NETFramework4.5&quot;&amp;gt; &amp;lt;dependency id=&quot;MSTest.TestFramework&quot; version=&quot;1.2.0&quot; exclude=&quot;Build,Analyzers&quot; /&amp;gt; &amp;lt;dependency id=&quot;System.ValueTuple&quot; version=&quot;4.4.0&quot; exclude=&quot;Build,Analyzers&quot; /&amp;gt; &amp;lt;/group&amp;gt; &amp;lt;group targetFramework=&quot;.NETFramework4.7&quot;&amp;gt; &amp;lt;dependency id=&quot;MSTest.TestFramework&quot; version=&quot;1.2.0&quot; exclude=&quot;Build,Analyzers&quot; /&amp;gt; &amp;lt;/group&amp;gt; &amp;lt;group targetFramework=&quot;.NETStandard2.0&quot;&amp;gt; &amp;lt;dependency id=&quot;MSTest.TestFramework&quot; version=&quot;1.2.0&quot; exclude=&quot;Build,Analyzers&quot; /&amp;gt; &amp;lt;/group&amp;gt; &amp;lt;/dependencies&amp;gt; &amp;lt;/metadata&amp;gt;&amp;lt;/package&amp;gt;参考资料 使用 XPath 导航选择节点 - Microsoft Docs Process XML Data Using the XPath Data Model - Microsoft Docs XPath Queries and Namespaces - Microsoft Docs .NET(C#)：使用XPath查询带有命名空间(有xmlns)的XML - Mgen .net - How to use XPath with XElement or LINQ? - Stack Overflow" }, { "title": "基于 task 为 VSCode 添加自定义的外部命令", "url": "/post/add-run-external-executable-tools-for-vscode.html", "categories": "", "tags": "vscode", "date": "2018-12-30 17:00:43 +0800", "snippet": "我们有很多全局的工具能在各处使用命令行调用，针对某个仓库特定的命令可以放到仓库中。不过，如果能够直接为顺手的文本编辑器添加自定义的外部命令，那么执行命令只需要简单的快捷键即可，不需要再手工敲了。写一个外部命令的调用由于是调用外部工具，所以工具本身用什么语言写已经不重要的了，只要有环境，没有什么是不能执行的。这里以我博客中使用的外部命令 mdmeta 为例。我将此工具使用 mklink 命令链接到了 /build 文件夹中（当然，如果需要多人协作开发，可以使用 git-lfs 或者 git-submodule 来管理仅项目的外部命令）。关于 mklink 的使用，可以参考 解决 mklink 使用中的各种坑（硬链接，软链接/符号链接，目录链接）。于是，在 /build 文件夹中添加可执行的脚本，例如：dotnet build\\mdmeta\\mdmeta.dll wupdate --ignore-in-hour 6让 VSCode 使用此外部命令如果你说使用 VSCode 嵌入的终端来使用外部命令，那我们其实没做什么，就像使用普通的脚本或者命令一样。但是，VSCode 自带有 Tasks 机制，可以将命令与 VSCode 集成。关于 Tasks，可以阅读 VSCode 的官方文档：Tasks in Visual Studio Code。具体来说，是写一个配置文件 /.vscode/tasks.json。tasks.json 中有少量的默认内容，如果你完全不知道如可开始编写，可以按 F1，选择 Configure ... 随便配置一个 Task，然后基于它修改。这里，我定义了两个命令： Init Metadata Update Metadata{ // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format &quot;version&quot;: &quot;2.0.0&quot;, &quot;tasks&quot;: [ { &quot;label&quot;: &quot;Init Metadata&quot;, &quot;type&quot;: &quot;shell&quot;, &quot;command&quot;: &quot;${workspaceRoot}\\\\build\\\\mdinit.ps1&quot;, &quot;problemMatcher&quot;: [] }, { &quot;label&quot;: &quot;Update Metadata&quot;, &quot;type&quot;: &quot;shell&quot;, &quot;command&quot;: &quot;${workspaceRoot}\\\\build\\\\mdupdate.ps1&quot;, &quot;problemMatcher&quot;: [], &quot;group&quot;: { &quot;kind&quot;: &quot;build&quot;, &quot;isDefault&quot;: true } } ]}当然，这是按照我自己的需求写了两个命令，前者用来初始化我的博客仓库，后者用来更新我所有博客文章的 YAML 元数据。由于后者才是需要频繁使用的命令，所以我将其设为编译类型的命令（&quot;kind&quot;: &quot;build&quot;）。具体来说，设定为编译类型并指定为默认（&quot;isDefault&quot;: true）将获得 Ctrl+Shift+B 快捷键的原生支持。使用快捷键执行外部命令当然，如果你有其他的编译命令，或者你有很多个命令，可以自己指定快捷键。比如我希望按下 Ctrl+U 时更新我的元数据（即执行以上第二条命令），直接在命令上加上 &quot;key&quot;: &quot;ctrl+u&quot; 即可。{ &quot;label&quot;: &quot;Update Metadata&quot;, &quot;type&quot;: &quot;shell&quot;, &quot;key&quot;: &quot;ctrl+u&quot;, &quot;command&quot;: &quot;${workspaceRoot}\\\\build\\\\mdupdate.ps1&quot;, &quot;problemMatcher&quot;: [], &quot;group&quot;: { &quot;kind&quot;: &quot;build&quot;, &quot;isDefault&quot;: true }}参考资料 Tasks in Visual Studio Code" }, { "title": ".NET 中使用 Mutex 进行跨越进程边界的同步", "url": "/post/mutex-in-dotnet.html", "categories": "", "tags": "dotnet, windows, csharp", "date": "2018-12-30 16:41:54 +0800", "snippet": "Mutex 是 Mutual Exclusion 的缩写，是互斥锁，用于防止两个线程同时对计算机上的同一个资源进行访问。不过相比于其他互斥的方式，Mutex 能够跨越线程边界。Mutex 是什么？与其他线程同步的方式一样，Mutex 也提供对资源的互斥访问；不过 Mutex 使用的系统资源会比 Monitor 更多，而 Monitor 就是实现 C# 中 lock 关键字所用的锁。用更多的系统资源，带来更强大的功能 —— Mutex 能进行跨越应用程序域边界的封送，能进行跨越进程边界的线程同步。简单的 Mutex（不能跨进程互斥）最简单的 Mutex 的使用方法就是直接 new 出来，然后使用 Wait 进行等待，使用 ReleaseMutex 进行释放。private readonly Mutex _mutex = new Mutex();private void UseResource(){ _mutex.WaitOne(); // 等待一小段时间，假装正在使用公共资源。这里的一段代码在单个进程之内将无法重入。 Thread.Sleep(500); _mutex.ReleaseMutex();}参数中有一个 initiallyOwned 参数，如果指定为 true 表示创建这个 Mutex 的线程拥有这个资源（不需要等待），当这个线程调用 ReleaseMutex 之后其他线程的 WaitOne 才会生效。不过这种方式不能达到跨进程同步的效果，所以实际上本文并不会过多描述这种互斥方式。创建跨进程互斥的 Mutex要创建跨进程互斥的 Mutex，必须要给 Mutex 指定名称。使用 new Mutex(false, &quot;Walterlv.Mutex&quot;) 创建一个命名的互斥锁，以便进行跨进程的资源互斥访问。在使用这个构造函数重载的时候，第一个参数 initiallyOwned 建议的取值为 false。因为当你指定为 true 时，说明你希望此线程是初始创建此 Mutex 的线程，然而由于你是直接 new 出来的，所以你实质上是无法得知你到底是不是第一个 new 出来的。class Program{ static async Task Main(string[] args) { var program = new Program(); while (true) { // 不断地尝试访问一段资源。这样，当多个进程运行的时候，可以很大概率模拟出现资源访问冲突。 program.UseResource(); await Task.Delay(50); } } private void UseResource() { var mutex = new Mutex(false, &quot;Walterlv.Mutex&quot;); mutex.WaitOne(); // 正在使用公共资源。 // 这里的一段代码将无法重入，即使是两个不同的进程。 var path = @&quot;C:\\Users\\lvyi\\Desktop\\walterlv.log&quot;; Console.WriteLine($&quot;[{DateTime.Now:O}] 开始写入文件……&quot;); File.AppendAllText(path, $&quot;[{DateTime.Now:O}] 开始写入文件……&quot;, Encoding.UTF8); Thread.Sleep(1000); File.AppendAllText(path, $&quot;[{DateTime.Now:O}] 写入文件完成。&quot;, Encoding.UTF8); Console.WriteLine($&quot;[{DateTime.Now:O}] 写入文件完成。&quot;); mutex.ReleaseMutex(); }}注意此程序在两个进程下的运行效果，明明我们等待使用资源的时间间隔只有 50 ms，但实际上等待时间是 1000 ms 左右。在关掉其中一个进程之后，间隔恢复到了 50 ms 左右。这说明 Mutex 的等待在这里起到了跨进程互斥的作用。当你需要在是否是第一次创建出来的时候进行一些特殊处理，就使用带 createdNew 参数的构造函数。 private void UseResource() {-- var mutex = new Mutex(false, &quot;Walterlv.Mutex&quot;);++ var mutex = new Mutex(true, &quot;Walterlv.Mutex&quot;, out var createdNew);-- mutex.WaitOne();++ // 如果这个 Mutex 是由此处创建出来的，即 createdNew 为 true，说明第一个参数 initiallyOwned 是真的发生了，于是我们就不需要等待。++ // 反之，当 createdNew 为 false 的时候，说明已经有一个现成的 Mutex 已经存在，我们在这里需要等待。++ if (!createdNew)++ {++ mutex.WaitOne();++ } …… mutex.ReleaseMutex(); }处理异常情况ApplicationExceptionmutex.ReleaseMutex(); 方法只能被当前拥有它的线程调用，如果某个线程试图调用这个函数，却没有拥有这个 Mutex，就会抛出 ApplicationException。怎样为拥有呢？还记得前面构造函数中的 initiallyOwned 参数吗？就是在指定自己是否是此 Mutex 的拥有者的（实际上我们还需要使用 createdNew 来辅助验证这一点）。当一个线程没有拥有这个 Mutex 的时候，需要使用 WaitOne 来等待获得这个锁。AbandonedMutexExceptionclass Program{ static async Task Main(string[] args) { // 开启一个线程，在那个线程中丢掉获得的 Mutex。 var thread = new Thread(AbandonMutex); thread.Start(); // 不要让进程退出，否则 Mutex 就会被系统回收。 Console.Read(); } private static void AbandonMutex() { // 获得一个 Mutex，然后就不再释放了。 // 由于此线程会在 WaitOne 执行结束后退出，所以这个 Mutex 就被丢掉了。 var mutex = new Mutex(false, &quot;Walterlv.Mutex&quot;); mutex.WaitOne(); }}上面的这段代码，当你第一次运行此进程并且保持此进程不退出的时候并没有什么异样。但是你再启动第二个进程实例的话，就会在 WaitOne 那里收到一个异常 —— AbandonedMutexException。所以如果你不能在一处代码中使用 try-finally 来确保在获得锁之后一定会释放的话，那么强烈建议在 WaitOne 的时候捕获异常。顺便提醒，try-finally 中不能有异步代码，你可以参见：在有 UI 线程参与的同步锁（如 AutoResetEvent）内部使用 await 可能导致死锁。也就是说，当你需要等待的时候，catch 一下异常。在 catch 完之后，你并不需要再次使用 WaitOne 来等待，因为即便发生了异常，你也依然获得了锁。这一点你可以通过调用 ReleaseMutex 来验证，因为前面我们说了只有拥有锁的线程才可以释放锁。private static void WaitOne(){ var mutex = new Mutex(false, &quot;Walterlv.Mutex&quot;); try { mutex.WaitOne(); } catch (AbandonedMutexException ex) { Console.WriteLine(&quot;发现被遗弃的锁&quot;); } Console.WriteLine(&quot;获得了锁&quot;);}参考资料 Mutexes - Microsoft Docs Mutex Constructor (System.Threading) - Microsoft Docs Mutex Class (System.Threading) - Microsoft Docs" }, { "title": "谨慎使用 FileInfo.Exists 实例方法，而是使用 File.Exists 静态方法替代", "url": "/post/file-exists-vs-fileinfo-exists.html", "categories": "", "tags": "dotnet, windows", "date": "2018-12-30 16:41:21 +0800", "snippet": "如果你在代码中使用了 FileInfo.Exists 实例方法来判断一个文件是否存在，也许会发现此方法可能错误地判断来一个文件是否真的存在。这是一个坑。本文将介绍坑的原因，并提供填坑的办法。问题代码我们使用两种不同的方式判断文件是否存在： FileInfo.Exists 实例方法 File.Exists 静态方法static async Task Main(string[] args){ var filePath = @&quot;C:\\Users\\lvyi\\Desktop\\walterlv.log&quot;; var fileInfo = new FileInfo(filePath); while (true) { Console.WriteLine($&quot;FileInfo.Exists = {fileInfo.Exists}&quot;); Console.WriteLine($&quot; File.Exists = {File.Exists(filePath)}&quot;); Console.WriteLine(&quot;----&quot;); await Task.Delay(1000); }}现在运行这个程序，我们会发现，中途删除了 walterlv.log 文件之后，FileInfo.Exists 依然返回了 true，而 File.Exists 已经开始返回 false 了。原因分析实际翻阅代码可以发现，FileInfo.Exists 和 File.Exists 方法最终都是使用相同的方法来完成文件存在与否的判断。这是 FileInfo.Exists 的判断：public override bool Exists{ [SecuritySafeCritical] get { try { if (this._dataInitialised == -1) this.Refresh(); if (this._dataInitialised != 0) return false; return (this._data.fileAttributes &amp;amp; 16) == 0; } catch { return false; } }}这是 File.Exists 的最终判断：public static bool FileExists(string fullPath){ Interop.Kernel32.WIN32_FILE_ATTRIBUTE_DATA data = new Interop.Kernel32.WIN32_FILE_ATTRIBUTE_DATA(); int errorCode = FillAttributeInfo(fullPath, ref data, returnErrorOnNotFound: true); return (errorCode == 0) &amp;amp;&amp;amp; (data.dwFileAttributes != -1) &amp;amp;&amp;amp; ((data.dwFileAttributes &amp;amp; Interop.Kernel32.FileAttributes.FILE_ATTRIBUTE_DIRECTORY) == 0);}只不过，FileInfo.Exists 只会在没有初始化的时候初始化一次，而 File.Exists 是没有缓存的，每次都是直接去获取文件的属性（这就涉及到 IO）。解决办法所以，如果你正在处理的文件在不同的时间可能存在也可能不存在，那么最好使用 File.Exists 来判断文件存在与否，而不是使用 FileInfo.Exists 来判断。不过，如果你需要一次性判断文件的非常多的信息（而不只是文件存在与否），那么依然建议使用 FileInfo，只不过在使用之前需要调用 Refresh 进行一次刷新。" }, { "title": "C#/.NET 使用 CommandLineParser 来标准化地解析命令行", "url": "/post/introduce-command-line-parser.html", "categories": "", "tags": "dotnet, csharp", "date": "2018-12-30 16:10:22 +0800", "snippet": "CommandLineParser 是一款用于解析命令行参数的 NuGet 包。你只需要关注你的业务，而命令行解析只需要极少量的配置代码。本文将介绍如何使用 CommandLineParser 高效写出自己程序的命令行解析部分。NuGet 包和 GitHub 开源仓库 NuGet 包：CommandLineParser GitHub 开源仓库：commandlineparser/commandline最简单的命令行解析using System;using System.Collections.Generic;using CommandLine;namespace Walterlv.Demo{ class Program { public class Options { [Option(&#39;f&#39;, &quot;file&quot;, Required = true, HelpText = &quot;需要处理的文件。&quot;)] public IEnumerable&amp;lt;string&amp;gt; Files { get; set; } [Option(&#39;o&#39;, &quot;override&quot;, Required = false, HelpText = &quot;是否覆盖原有文件。&quot;)] public bool Override { get; set; } } static void Main(string[] args) { Parser.Default.ParseArguments&amp;lt;Options&amp;gt;(args).WithParsed(Run); } private static void Run(Options option) { // 使用解析后的命令行参数进行操作。 foreach (var file in option.Files) { var verb = option.Override ? &quot;覆盖&quot; : &quot;使用&quot;; Console.WriteLine($&quot;walterlv 正在{verb}文件 {file}&quot;); } } }}这个简单的 Demo 程序使用 Options 类来封装命令行参数，Parser.Default.ParseArguments 解析到的参数将存入 Options 类型的实例中。而只需要加上 WithParsed 即可在一个新的方法中使用我们解析后的 Options 实例。这时，在命令行中就可以使用命令了：dotnet demo.dll -f C:\\Users\\lvyi\\Desktop\\Test.txt由于我们标记 Files 是必要属性，所以如果此参数没有指定，将返回命令行的使用说明。此使用说明中就包含了我们在 Option 参数中编写的 HelpText。如果你的 Options 类中单次是多单词的短语，那么建议在指定名称的时候为每一个单词之间添加一个空格。这样参数就不会让多个单词连成一片难以辨认。例如：public class Options{ [Option(&quot;long-name&quot;, Required = true, HelpText = &quot;需要处理的文件。&quot;)] public string LongName { get; set; }}那么命令是：dotnet demo.dll --long-name xxx如果不指定，那么就是 --longname，这显然不好看。包含多个方法的命令行解析如果一个命令行程序只做一件事情，那么以上代码足以应付大多数的情况。可是有时候一个命令行程序是为了做一类事情的 —— 典型的例子就是 git 程序。当你运行 git 的时候，你可以在 git 后面加一个谓词（动词），表示执行的是哪一个命令。后面的参数是每个命令都不同的，并且第一个参数是不用指定名称的。using System;using System.Collections.Generic;using System.Diagnostics;using CommandLine;namespace Walterlv.Demo{ [Verb(&quot;check&quot;, HelpText = &quot;检查&quot;)] class CheckOptions { [Value(0, HelpText = &quot;一个 .sln 文件，一个或者多个 .csproj 文件。&quot;)] public IEnumerable&amp;lt;string&amp;gt; InputFiles { get; set; } } [Verb(&quot;fix&quot;, HelpText = &quot;修复&quot;)] class FixOptions { [Value(0, HelpText = &quot;一个 .sln 文件，一个或者多个 .csproj 文件。&quot;)] public IEnumerable&amp;lt;string&amp;gt; InputFiles { get; set; } [Option(&#39;o&#39;, &quot;outputFiles&quot;, Required = true, HelpText = &quot;修复之后的文件集合。&quot;)] public IEnumerable&amp;lt;string&amp;gt; OutputFiles { get; set; } [Option(Required = false, HelpText = &quot;是否自动决定版本号，这将使用冲突版本号中的最新版本。&quot;)] public bool AutoVersion { get; set; } } class Program { static int Main(string[] args) { var exitCode = Parser.Default.ParseArguments&amp;lt;CheckOptions, FixOptions&amp;gt;(args) .MapResult( (CheckOptions o) =&amp;gt; CheckSolutionOrProjectFiles(o), (FixOptions o) =&amp;gt; FixSolutionOrProjectFiles(o), error =&amp;gt; 1); return exitCode; } private static int CheckSolutionOrProjectFiles(CheckOptions options) { return 0; } private static int FixSolutionOrProjectFiles(FixOptions options) { return 0; } }}对于这一段程序，我们可以使用两种不同的谓词来执行命令：dotnet demo.dll check C:\\Users\\lvyi\\Desktop\\Test\\Test.csprojdotnet demo.dll fix C:\\Users\\lvyi\\Desktop\\Test\\Test.csproj -o C:\\Users\\lvyi\\Desktop\\TestFix\\Test.csprojVerb，Option 和 ValueVerb 是在一个命令行选项的 Option 类上标记的，用于指定命令的类别。每一个 Verb 标记的类别都可以有自己独立的一套命令行参数。Option 是命名的命令行参数。在命令行中，你必须指定命令行缩写或者全称来指定命令行参数的不同类型。Value 是命令行的无名参数，它是靠在命令行谓词后面的参数位置来确定解析到哪一个属性上的。参考资料 commandlineparser/commandline: The best C# command line parser that brings standardized *nix getopt style, for .NET. Includes F# support Home · commandlineparser/commandline Wiki C＃命令行解析工具 - 林德熙 The week in .NET – Command Line Parser Library, .NET South East - .NET Blog" }, { "title": "只需 5 秒钟，你就能取到 WPF 程序的超高分辨率超高清截图", "url": "/post/how-to-get-high-resolution-view-of-a-wpf-app.html", "categories": "", "tags": "wpf", "date": "2018-12-26 12:54:01 +0800", "snippet": "我想要截取一个 WPF 程序的图标，但是它太小了。如果我就这样截屏截下来，是很不高清的。由于我需要制作一份课件，所以我需要超高清版本，可是，如何做才能最快速拿到 WPF 程序的超高清截图呢？本文分享一个方法，只需 5 秒钟，你就能拿到！第一步：打开 Snoop如果你没有 Snoop，请前往下载：Release Snoop 2.10.0 · cplotts/snoopwpf。第二步：使用 Snoop 的放大功能将你的鼠标放到两个瞄准按钮的左边那个上面，你可以看到提示： Drag and drop this crosshairs over a WPF window in order to Magnify it.于是，你将这个按钮拖拽到你希望放大的 WPF 程序上面，松开鼠标。这时，会弹出一个新的窗口出来，将其最大化：你就能看到 WPF 应用的超高清版本了。使用鼠标滚轮可以继续放大或缩小。查看效果比如一个按钮，现在可以放到这么大来看了。截图可以截出高清版本。实际上前面的 Snoop 界面也是这样放大的，注意到了吗？" }, { "title": "Write a MSBuild Target to detect whether the project is rebuilding or not", "url": "/post/detecting-rebuild-switch-using-msbuild-target-en.html", "categories": "", "tags": "visualstudio, msbuild", "date": "2018-12-25 08:07:34 +0800", "snippet": "MSBuild or the dotnet build command both supports Incremental Building for compiling performance. You can read How to: Build Incrementally - Visual Studio - Microsoft Docs to lean more about incremental building. When a target supports increment building and the project is rebuilding for the moment, the Target will not execute. So if it affects followed other Targets, it cannot be set to incremental building.But how can I detect a incremental building behavior and do something different things if my Target affects followed other Targets? In this post, I’ll talk about that.The ProblemSourceFusion is a pre-compile framework and allows you to change you code during the compiling. You can visit dotnet-campus/SourceFusion: SourceFusion is a pre-compile framework based on Roslyn. It helps you to build high-performance .NET code. to view the open-source project.The Target in the SourceFusion takes long time and affects followed Targets such as the CoreCompile Target. If it use a completely incremental building, the Target will be skipped when building and no more source code will be added or removed before the CoreCompile Target. So nothing will happen during a incremental building and the SourceFusion changes nothing.The SolutionWe can write another Target helps us to detect rebuilding behavior. We can define a property to tell us whether it is a incremental building or not.&amp;lt;Target Name=&quot;_WalterlvDemoRebuildingTest&quot; BeforeTargets=&quot;WalterlvDemoCoreTarget&quot; Inputs=&quot;$(MSBuildProjectFullPath)&quot; Outputs=&quot;$(WalterlvDemoFolder)RebuildingTest.txt&quot;&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;RebuildingTestLine Include=&quot;true&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;CallTarget Targets=&quot;_WalterlvDemoRebuildingTestInitialize&quot; /&amp;gt; &amp;lt;WriteLinesToFile File=&quot;$(WalterlvDemoFolder)RebuildingTest.txt&quot; Lines=&quot;@(RebuildingTestLine)&quot; Overwrite=&quot;True&quot; /&amp;gt;&amp;lt;/Target&amp;gt;&amp;lt;Target Name=&quot;_WalterlvDemoRebuildingTestInitialize&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;WalterlvDemoRebuildRequired&amp;gt;true&amp;lt;/SourceFusionRebuildRequired&amp;gt; &amp;lt;/PropertyGroup&amp;gt;&amp;lt;/Target&amp;gt;In this code, I write two Targets and the second one doesn’t define any BeforeTargets or AfterTargets attributes. So this Target will not be executed automatically unless you call it explicitly. I define a property named SourceFusionRebuildRequired in it to flag the rebuilding status.I call this separated Target in the first target which defines Inputs and Outputs attributes. We can know that if a Target want to support incremental building the two attributes are important. So this Target supports that.These are the three mentioned Targets: _WalterlvDemoRebuildingTest The Target that supports the incremental building _WalterlvDemoRebuildingTestInitialize The Target to assign a value to property SourceFusionRebuildRequired WalterlvDemoCoreTarget The long-time Target that will use the incremental building test valueI use a csproj file as a input file and another temp file as a output file. Then if a project file changed and a rebuilding will happen. To generate a temp output file I should use WriteLinesToFile Task to write one.I need WalterlvDemoRebuildRequired property to detect the rebuilding behavior. If the project is rebuilding the property will be assigned because the _WalterlvDemoRebuildingTestInitialize is called and if the project is incremental building the property will not be assigned.Then we can check the value of WalterlvDemoRebuildRequired to detect a rebuilding or incremental building.How to use this propertyFor the long-time Target WalterlvDemoCoreTarget, it should detect the property and do something different.&amp;lt;Target Name=&quot;WalterlvDemoCoreTarget&quot; BeforeTargets=&quot;CoreCompile&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;WalterlvDemoRebuildRequired Condition=&quot;&#39;$(WalterlvDemoRebuildRequired)&#39; == &#39;&#39;&quot;&amp;gt;false&amp;lt;/WalterlvDemoRebuildRequired&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;Exec ConsoleToMSBuild=&quot;True&quot; Command=&quot;WalterlvDemo.exe -r $(WalterlvDemoRebuildRequired)&quot; /&amp;gt;&amp;lt;/Target&amp;gt;We define the same property only if it is not been assigned. But we assign it as a false value which is different to the _WalterlvDemoRebuildingTestInitialize Target.Then pass the property value to the core Task, and the Task will know whether it is completely rebuilding or incremental building.References CallTarget Task - Visual Studio - Microsoft Docs How to: Build Incrementally - Visual Studio - Microsoft Docs Property Functions - Visual Studio - Microsoft Docs" }, { "title": "编写 Target 检测 MSBuild / dotnet build 此次编译是否是差量编译", "url": "/post/detecting-rebuild-switch-using-msbuild-target.html", "categories": "", "tags": "visualstudio, msbuild", "date": "2018-12-25 07:43:28 +0800", "snippet": "MSBuild 或 Roslyn 编译项目时均支持差量编译，毕竟为了性能。我在 每次都要重新编译？太慢！让跨平台的 MSBuild/dotnet build 的 Target 支持差量编译 一文中介绍了如何使一个 Target 支持差量编译。在那篇文章中我说到差量编译会导致 Target 不执行；也就是说，如果一个 Target 对后续的编译会产生影响，那么一定不能设置为差量编译。不过，真的会写出一些非常耗时的 Target，但是它会对后续的编译产生影响。这些 Target 如果要做差量编译，那么就不能直接使用原生的差量编译方案了。本文将介绍如何处理这样的情况。我们遇到的问题SourceFusion 是一个预编译框架，它在你编译期间对你的代码做一些改变。dotnet-campus/SourceFusion: SourceFusion is a pre-compile framework based on Roslyn. It helps you to build high-performance .NET code.。这意味着，这个耗时的 Target 是会改变后续的编译的，典型的是 —— 它会在编译期间增加和删除几个源代码文件。如果完全使用 Target 原生的差量编译，那么一旦这个 Target 跳过，那么也就不会增加和删除任何源代码文件了。解决方案解决方案是，我们写一个前置的 Target，这个 Target 支持差量编译。于是我们可以利用它的差量编译特性得知当前是否处于差量编译的状态。&amp;lt;Target Name=&quot;_WalterlvDemoRebuildingTest&quot; BeforeTargets=&quot;WalterlvDemoCoreTarget&quot; Inputs=&quot;$(MSBuildProjectFullPath)&quot; Outputs=&quot;$(WalterlvDemoFolder)RebuildingTest.txt&quot;&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;RebuildingTestLine Include=&quot;true&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;CallTarget Targets=&quot;_WalterlvDemoRebuildingTestInitialize&quot; /&amp;gt; &amp;lt;WriteLinesToFile File=&quot;$(WalterlvDemoFolder)RebuildingTest.txt&quot; Lines=&quot;@(RebuildingTestLine)&quot; Overwrite=&quot;True&quot; /&amp;gt;&amp;lt;/Target&amp;gt;&amp;lt;Target Name=&quot;_WalterlvDemoRebuildingTestInitialize&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;WalterlvDemoRebuildRequired&amp;gt;true&amp;lt;/SourceFusionRebuildRequired&amp;gt; &amp;lt;/PropertyGroup&amp;gt;&amp;lt;/Target&amp;gt;随后再写一个新的 Target。这个新的 Target 没有任何 BeforeTargets 或者 AfterTargets 的设置。也就是说，如果没有显式地去执行它或者将它设置为默认的 Target，它将完全不会执行。而我们在这个 Target 里面会设置一个属性，标记此时正在处于“重新编译”的状态（即不是差量状态）。我们使用那个支持差量编译的 Target，通过 CallTarget 来显式调用这个新的 Target。如果当前处于差量状态，那么这个 CallTarget 不会执行；而如果处于全量编译状态，那么 CallTarget 就会调用那个新的 Target 以便设置一个属性。上面写了两个 Target，但涉及到三个 Target： _WalterlvDemoRebuildingTest 是我给这个差量编译测试 Target 取的名字 _WalterlvDemoRebuildingTestInitialize 是差量编译初始化赋值的 Target WalterlvDemoCoreTarget 是那个耗时的 Target。根据我在 每次都要重新编译？太慢！让跨平台的 MSBuild/dotnet build 的 Target 支持差量编译 一文中的差量编译的做法，我使用 $(MSBuildProjectFullPath) 也就是 csproj 文件的改变来决定差量检测的输入，用一个临时的文件 RebuildingTest.txt 来决定差量编译的输出。在这里，我们一定需要一个文件来输出，这样 MSBuild 或者 Roslyn 检测差量的时候才能正确完成。这样，为了得到这个文件，我们实际上需要通过这个 Target 真的写一个文件出来，所以我们用了 WriteLinesToFile。实际上，我们真正需要的是 WalterlvDemoRebuildRequired 这个属性，而这个属性我们在 _WalterlvDemoRebuildingTestInitialize 中进行设置。在 _WalterlvDemoRebuildingTest 中，只有全量编译时才会调用 _WalterlvDemoRebuildingTestInitialize 而差量编译是不会调用的。所以差量编译时，WalterlvDemoRebuildRequired 不会初始化。这样，我们便可以通过这个属性判断是否设置为 true 来得知当前是否处于全量编译状态。后续使用对于我们真实的耗时的 Target，则需要检测这个 WalterlvDemoRebuildRequired 的值，进行不同的处理。&amp;lt;Target Name=&quot;WalterlvDemoCoreTarget&quot; BeforeTargets=&quot;CoreCompile&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;WalterlvDemoRebuildRequired Condition=&quot;&#39;$(WalterlvDemoRebuildRequired)&#39; == &#39;&#39;&quot;&amp;gt;false&amp;lt;/WalterlvDemoRebuildRequired&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;Exec ConsoleToMSBuild=&quot;True&quot; Command=&quot;WalterlvDemo.exe -r $(WalterlvDemoRebuildRequired)&quot; /&amp;gt;&amp;lt;/Target&amp;gt;我们在核心的 Target 里面判断 WalterlvDemoRebuildRequired 的值，如果没有被设置，说明前面的 Target 没有执行，也就是“被差量”了，我们就可以将之指定为 false。这样，核心的 Target 里面，也就是 WalterlvDemo.exe 执行参数中，就可以拿到正确的差量状态了。true 表示正在重新编译，而 false 表示正在差量编译。一些坑如果不写那个新的 Target 是否可行呢？我们能否把这个属性的赋值直接放到差量编译的那个 _WalterlvDemoRebuildingTest 中？其实这是不靠谱的。MSBuild 在计算属性的时候，不同的 csproj 格式、不同版本的计算情况不同。实际上在不断的试验中我并没有找到哪些情况下差量 Target 的属性会被计算哪些情况不会被计算。所以最好的办法是 —— 不要依赖于这些不确定的属性变化。所以我们写一个新的 Target，Target 执行则属性赋值，不执行则不赋值，非常确定。参考资料 CallTarget Task - Visual Studio - Microsoft Docs How to: Build Incrementally - Visual Studio - Microsoft Docs Property Functions - Visual Studio - Microsoft Docs" }, { "title": "在 Roslyn 分析语法树时添加条件编译符号的支持", "url": "/post/roslyn-syntax-tree-supporting-preprocessor-symbols.html", "categories": "", "tags": "roslyn, csharp, visualstudio, msbuild", "date": "2018-12-24 22:36:28 +0800", "snippet": "我们在代码中会写 #if DEBUG 或者 [Conditional(&quot;DEBUG&quot;)] 来使用已经定义好的条件编译符号。而定义条件编译符号可以在代码中使用 #define WALTERLV 来实现，也可以通过在项目属性中设置条件编译符号（Conditional Compilation Symbols）来实现。然而如果我们没有做任何特殊处理，那么使用 Roslyn 分析使用了条件编译符号的源码时，就会无法识别这些源码。如果你不知道条件编译符号是什么或者不知道怎么设置，请参见： .NET/C# 项目如何优雅地设置条件编译符号？我们在使用 Roslyn 分析语法树时，会创建语法树的一个实例。如果使用默认的构造函数，那么就不会识别设置了条件编译符号的语句，如下图：而实际上构造函数的参数中带有 preprocessorSymbols 参数，即预处理符号。在传入此预处理符号的情况下，Roslyn 就可以识别此符号了：方法是传入 preprocessorSymbols 参数：var preprocessorSymbols = new[] {&quot;DEBUG&quot;, &quot;TRACE&quot;, &quot;WALTERLV&quot;, &quot;NETCOREAPP2_1&quot;};var syntaxTree = CSharpSyntaxTree.ParseText(originalText, new CSharpParseOptions( LanguageVersion.Latest, DocumentationMode.None, SourceCodeKind.Regular, preprocessorSymbols)此后，你可以拿 syntaxTree 做其他事情了：var compileTypeVisitor = new CompileTypeVisitor();compileTypeVisitor.Visit(syntaxTree.GetRoot());Types = compileTypeVisitor.Types.ToList();当然这段代码你可能编译不通过，因为这是另一篇博客中的源码： Roslyn 入门：使用 Roslyn 静态分析现有项目中的代码本文所用的查看语法树的插件，你可以查看另一篇博客： Roslyn 入门：使用 Visual Studio 的语法可视化（Syntax Visualizer）窗格查看和了解代码的语法树" }, { "title": ".NET 中什么样的类是可使用 await 异步等待的？", "url": "/post/what-is-an-awaiter.html", "categories": "", "tags": "dotnet", "date": "2018-12-23 15:17:11 +0800", "snippet": "我们已经知道 Task 是可等待的，但是去看看 Task 类的实现，几乎找不到哪个基类、接口或者方法属性能够告诉我们与 await 相关。而本文将探索什么样的类是可使用 await 异步等待的？Dixin’s Blog - Understanding C# async / await (2) The Awaitable-Awaiter Pattern 一文解决了我们的疑惑。async/await 是给编译器用的，只要我们的类包含一个 GetAwaiter 方法，并返回合适的对象，我们就能让这个类的实例被 await 使用了。既然需要一个 GetAwaiter 方法，那我们先随便写个方法探索一下：Test DoAsync(){ return new Test();}class Test{ void GetAwaiter() { }}尝试调用：await DoAsync();编译器告诉我们： Test.GetAwaiter() 不可访问，因为它具有一定的保护级别。原来 GetAwaiter 方法需要是可以被调用方访问到的才行。于是我们将 GetAwaiter 前面的访问修饰符改成 public。现在提示变成了： await 要求类型 Test 包含适当的 GetAwaiter 方法。考虑到一定要获取到某个对象才可能有用，于是我们返回一个 Test2 对象：public class Test{ public Test2 GetAwaiter() { return new Test2(); }}public class Test2{}这时编译器又告诉我们： Test2 未包含 IsCompleted 的定义。加上 public bool IsCompleted { get; }，编译器又说： Test2 不实现 INotifyCompletion。于是我们实现之，编译器又告诉我们： Test2 未包含 GetResult 的定义。于是我们加上一个空的 GetResult 方法，现在编译器终于不报错了。现在我们一开始的 DoAsync 和辅助类型变成了这样：// 注：此处为试验代码。private Test DoAsync(){ return new Test();}public class Test{ public Test2 GetAwaiter() { return new Test2(); }}public class Test2 : INotifyCompletion{ public bool IsCompleted { get; } public void GetResult() { } public void OnCompleted(Action continuation) { }}总结起来，要想使一个方法可被 await 等待，必须具备以下条件： 这个方法返回一个类 A 的实例，这个类 A 必须满足后面的条件。 此类 A 有一个可被访问到的 GetAwaiter 方法（扩展方法也行，这算是黑科技吗？），方法返回类 B 的实例，这个类 B 必须满足后面的条件； 此类 B 实现 INotifyCompletion 接口，且拥有 bool IsCompleted { get; } 属性、GetResult() 方法、void OnCompleted(Action continuation) 方法。更多编写自定义 Awaiter 的文章可以阅读：入门篇： .NET 中什么样的类是可使用 await 异步等待的？ 定义一组抽象的 Awaiter 的实现接口，你下次写自己的 await 可等待对象时将更加方便 .NET 除了用 Task 之外，如何自己写一个可以 await 的对象？实战篇： 在 WPF/UWP 中实现一个可以用 await 异步等待 UI 交互操作的 Awaiter .NET 编写一个可以异步等待循环中任何一个部分的 Awaiter参考资料 Dixin’s Blog - Understanding C# async / await (2) The Awaitable-Awaiter Pattern" }, { "title": ".NET 除了用 Task 之外，如何自己写一个可以 await 的对象？", "url": "/post/understand-and-write-custom-awaiter.html", "categories": "", "tags": "dotnet, csharp", "date": "2018-12-23 15:17:09 +0800", "snippet": ".NET 中的 async / await 写异步代码用起来真的很爽，就像写同步一样。我们可以在各种各样的异步代码中看到 Task 返回值，这样大家便可以使用 await 等待这个方法。不过，有时需要写一些特别的异步方法，这时需要自己来实现一个可以异步等待的对象。本文将讲述如何实现一个可等待对象，一个自定义的 Awaiter。Awaiter 系列文章入门篇： .NET 中什么样的类是可使用 await 异步等待的？ 定义一组抽象的 Awaiter 的实现接口，你下次写自己的 await 可等待对象时将更加方便 .NET 除了用 Task 之外，如何自己写一个可以 await 的对象？实战篇： 在 WPF/UWP 中实现一个可以用 await 异步等待 UI 交互操作的 Awaiter .NET 编写一个可以异步等待循环中任何一个部分的 Awaiter可等待对象我们希望大家在调用下面的 CallWalterlvAsync 方法的时候，可以使用 await 关键字来异步等待：await CallWalterlvAsync();public WalterlvOperation CallWalterlvAsync(){ // 返回一个 WalterlvOperation，以便外面调用方可以异步等待。 return new WalterlvOperation();}所以我们需要实现一个 WalterlvOperation。编写基本的 Awaiter 框架代码先写一个空的类型，然后为它编写一个空的 GetAwaiter 方法，返回新的 WalterlvAwaiter 类型。/// &amp;lt;summary&amp;gt;/// 委托 walterlv 来完成一项特殊的任务。/// 通过在代码当中调用，可以让他在现实中为你做一些事情。/// &amp;lt;/summary&amp;gt;public class WalterlvOperation{ public WalterlvAwaiter GetAwaiter() { return new WalterlvAwaiter(); }}接着，我们编写 WalterlvAwaiter 类：public class WalterlvAwaiter : INotifyCompletion{ public bool IsCompleted { get; } public void GetResult() { } public void OnCompleted(Action continuation) { }}必须实现 INotifyCompletion 接口，此接口带来了 OnCompleted 方法。另外两个方法不是接口带来的，但是也是实现一个自定义的 Awaiter 必要的方法。在你编写完以上两段代码之后，你的 await 就可以编译通过了。额外说明一下，GetResult 方法是可以修改返回值的，只要返回值不是 void，那么 await 等待的地方将可以在 await 完成之后获得一个返回值。public class WalterlvAwaiter : INotifyCompletion{ public bool IsCompleted { get; } public string GetResult() { } public void OnCompleted(Action continuation) { }}// 于是你可以拿到一个字符串类型的返回值。string result = await CallWalterlvAsync(&quot;写博客&quot;);实现基本的 Awaiter以上代码只能编译通过，但实际上如果你跑起来，会发现 await 一旦进入，是不会再往下执行的。因为我们还没有实现 WalterlvAwaiter 类型。最重要的，是需要调用 OnCompleted 方法传入的 continuation 委托。public void OnCompleted(Action continuation){ continuation.Invoke();}像以上这么写之后，await 之后的代码便可以执行了。如果你只是希望了解如何实现一个 Awaiter，那么写出以上的代码就足以。因为这才是最本质最核心的 Awaiter 的实现。不过，以上代码的执行是立即执行，没有任何异步的效果。因为 OnCompleted 被调用的时候，我们立刻调用了 continuation 的执行。实现异步的 Awaiter要真正达到异步的效果，OnCompleted 执行的时候，我们不能立刻去调用参数传进来的委托，而只是将他记录下来，等到任务真正完成的时候再去调用。以下的代码就不再是通用的代码了，你需要针对你的不同业务去设计如何异步完成一个任务，然后再通知到异步等待的代码继续执行。例如，现在我们期望 walterlv 代理去写博客，于是我们为 WalterlvOperation 加一点功能，真正去做一些异步的事情。CallWalterlvAsync 的实现现在真的开启了一个异步操作。public WalterlvOperation CallWalterlvAsync(string task){ var operation = new WalterlvOperation(task); operation.Start(); return operation;}然后为了实现我们自己添加的 Start 方法，我们在里面去做一些事情。里面第一句就离开了当前线程前往线程池中的其他线程去执行 Console.WriteLine 了。/// &amp;lt;summary&amp;gt;/// 委托 walterlv 来完成一项特殊的任务。/// 通过在代码当中调用，可以让他在现实中为你做一些事情。/// &amp;lt;/summary&amp;gt;public class WalterlvOperation{ private readonly string _task; private readonly WalterlvAwaiter _awaiter; public WalterlvOperation(string task) { _task = task; _awaiter = new WalterlvAwaiter(); } public async void Start() { await Task.Delay(100).ConfigureAwait(false); Console.WriteLine($&quot;walterlv 已经收到任务：{_task}&quot;); Console.WriteLine($&quot;开始执行&quot;); await Task.Delay(2000).ConfigureAwait(false); Console.WriteLine($&quot;walterlv 已经完成 {_task}。&quot;); _awaiter.ReportCompleted(); } /// &amp;lt;summary&amp;gt; /// 返回一个可等待对象，以便能够使用 await 关键字进行异步等待。 /// &amp;lt;/summary&amp;gt; public WalterlvAwaiter GetAwaiter() { return _awaiter; }}于是现在可以通过下面的代码来要求 walterlv 去写博客了。await CallWalterlvAsync(&quot;写博客&quot;);然而实际上，我们上面还留了一个 _awaiter.ReportCompleted 方法没有实现。由于我们的操作全部是异步的了，这个方法的实现就是为了通知所有正在使用 await 等待的代码，异步任务完成了，可以继续往后面执行了。public class WalterlvAwaiter : INotifyCompletion{ private Action _continuation; public bool IsCompleted { get; private set; } public void GetResult() { // 这个函数我们暂时还没有真正实现，因为需要进行同步等待比较复杂。 // 我们将在本文后面附的其他博客中实现。 } public void OnCompleted(Action continuation) { // 当这个 Awaiter 被 await 等待的时候，此代码会被调用。 // 每有一处 await 执行到，这里就会执行一次，所以在任务完成之前我们需要 +=。 if (IsCompleted) { continuation?.Invoke(); } else { _continuation += continuation; } } public void ReportCompleted() { // 由 WalterlvOperation 来通知这个任务已经完成。 IsCompleted = true; var continuation = _continuation; _continuation = null; continuation?.Invoke(); }}现在运行程序，会按照异步任务来执行，可以异步等待：static async Task Main(string[] args){ await CallWalterlvAsync(&quot;写博客&quot;); Console.Read();}" }, { "title": "定义一组抽象的 Awaiter 的实现接口，你下次写自己的 await 可等待对象时将更加方便", "url": "/post/abstract-awaitable-and-awaiter.html", "categories": "", "tags": "dotnet, csharp", "date": "2018-12-23 15:17:04 +0800", "snippet": "我在几篇文章中都说到了在 .NET 中自己实现 Awaiter 情况。async / await 写异步代码用起来真的很爽，就像写同步一样。然而实现 Awaiter 没有现成的接口，它需要你按照编译器的要求为你的类型添加一些具有特定名称的属性和方法。然而没有接口的帮助，我们编写起来就很难获得工具（如 ReSharper）自动生成代码的支持。本文将分享我提取的自己实现 Awaiter 的接口。你只需要实现这些接口当中的 2 个，就能正确实现一个 Awaitable 和 Awaiter。接口代码你可以在 GitHub 上找到这段代码：https://github.com/walterlv/sharing-demo/blob/master/src/Walterlv.Core/Threading/AwaiterInterfaces.cs。public interface IAwaitable&amp;lt;out TAwaiter&amp;gt; where TAwaiter : IAwaiter{ TAwaiter GetAwaiter();}public interface IAwaitable&amp;lt;out TAwaiter, out TResult&amp;gt; where TAwaiter : IAwaiter&amp;lt;TResult&amp;gt;{ TAwaiter GetAwaiter();}public interface IAwaiter : INotifyCompletion{ bool IsCompleted { get; } void GetResult();}public interface ICriticalAwaiter : IAwaiter, ICriticalNotifyCompletion{}public interface IAwaiter&amp;lt;out TResult&amp;gt; : INotifyCompletion{ bool IsCompleted { get; } TResult GetResult();}public interface ICriticalAwaiter&amp;lt;out TResult&amp;gt; : IAwaiter&amp;lt;TResult&amp;gt;, ICriticalNotifyCompletion{}接口实现在 ReSharper 工具的帮助下，你可以在继承接口之后快速编写出实现代码来：▲ 使用 ReSharper 快速实现 Awaiter▲ 使用 ReSharper 快速实现 Awaitable于是我们可以迅速得到一对可以编译通过的 Awaitable 和 Awaiter：public sealed class Awaiter : IAwaiter&amp;lt;string&amp;gt;{ public void OnCompleted(Action continuation) { throw new NotImplementedException(); } public bool IsCompleted { get; } public string GetResult() { throw new NotImplementedException(); }}public sealed class Awaitable : IAwaitable&amp;lt;Awaiter, string&amp;gt;{ public Awaiter GetAwaiter() { throw new NotImplementedException(); }}当然，你也可以在一个类里面实现这两个接口：public sealed class Awaiter : IAwaiter&amp;lt;string&amp;gt;, IAwaitable&amp;lt;Awaiter, string&amp;gt;{ public void OnCompleted(Action continuation) { throw new NotImplementedException(); } public bool IsCompleted { get; } public string GetResult() { throw new NotImplementedException(); } public Awaiter GetAwaiter() { return this; }}实现业务需求我有另外两篇文章在实现真正可用的 Awaiter： 在 WPF/UWP 中实现一个可以用 await 异步等待 UI 交互操作的 Awaiter .NET 除了用 Task 之外，如何自己写一个可以 await 的对象？更多 Awaiter 系列文章入门篇： .NET 中什么样的类是可使用 await 异步等待的？ 定义一组抽象的 Awaiter 的实现接口，你下次写自己的 await 可等待对象时将更加方便 .NET 除了用 Task 之外，如何自己写一个可以 await 的对象？实战篇： 在 WPF/UWP 中实现一个可以用 await 异步等待 UI 交互操作的 Awaiter .NET 编写一个可以异步等待循环中任何一个部分的 Awaiter" }, { "title": "了解 .NET 的默认 TaskScheduler 和线程池（ThreadPool）设置，避免让 Task.Run 的性能急剧降低", "url": "/post/default-task-scheduler-and-thread-pool.html", "categories": "", "tags": "dotnet", "date": "2018-12-23 15:16:55 +0800", "snippet": ".NET Framework 4.5 开始引入 Task.Run，它可以很方便的帮助我们使用 async / await 语法，同时还使用线程池来帮助我们管理线程。以至于我们编写异步代码可以像编写同步代码一样方便。不过，如果滥用，也可能导致应用的性能急剧下降。本文将说明在默认线程池配置（ThreadPoolTaskScheduler）的情况下，应该如何使用 Task.Run 来避免性能的急剧降低。如何使用 Task.Run？ 对于 IO 操作，尽量使用原生提供的 Async 方法（不要自己使用 Task.Run 调用一个同步的版本占用线程池资源）； 对于没有 Async 版本的 IO 操作，如果可能耗时很长，则指定 CreateOptions 为 LongRunning。 其他短时间执行的任务才推荐使用 Task.Run。接下来分析原因：示例程序和示例代码在开始之前，我们先准备一个测试程序。这个程序一开始就使用 Task.Run 跑起来 10 个异步任务，每一个里面都等待 5 秒。可以发现，虽然我们是同一时间启动的 10 个异步任务，但任务的实际开始时间并不相同 —— 前面 8 个任务立刻开始了，而后面每隔一秒才会启动一个新的异步任务。示例程序的代码如下：class Program{ static async Task Main(string[] args) { Console.Title = &quot;walterlv task demo&quot;; var task = Enumerable.Range(0, 10).Select(i =&amp;gt; Task.Run(() =&amp;gt; LongTimeTask(i))).ToList(); await Task.WhenAll(task); Console.Read(); } private static void LongTimeTask(int index) { var threadId = Thread.CurrentThread.ManagedThreadId.ToString().PadLeft(2, &#39; &#39;); var line = index.ToString().PadLeft(2, &#39; &#39;); Console.WriteLine($&quot;[{line}] [{threadId}] [{DateTime.Now:ss.fff}] 异步任务已开始……&quot;); // 这一句才是关键，等待。其他代码只是为了输出。 Thread.Sleep(5000); Console.ForegroundColor = ConsoleColor.Green; Console.WriteLine($&quot;[{line}] [{threadId}] [{DateTime.Now:ss.fff}] 异步任务已结束……&quot;); Console.ForegroundColor = ConsoleColor.White; }}TaskScheduler造成以上异步任务不马上开始的原因，与 Task 使用的 TaskScheduler 有关。默认情况下，Task.Run 使用的是 .NET 提供的默认 Scheduler，可以通过 TaskScheduler.Default 获取到。Task 使用 TaskScheduler 来决定何时执行一个异步任务，如果你不设置，默认的实现是 ThreadPoolTaskScheduler。你可以前往 .NET Core 的源码页面查看源码：ThreadPoolTaskScheduler.QueueTask。于是，你在线程池中的设置将决定一个 Task 将在何时开启一个线程执行。ThreadPool通过 ThreadPool.GetMinThreads 可以获得最小的线程数和异步 IO 完成线程数；通过 ThreadPool.GetMaxThreads 来获得其最大值。通过对应的 set 方法来设置最小值和最大值。在 ThreadPool.GetMinThreads(Int32, Int32) Method (System.Threading) - Microsoft Docs 线程池按需提供新的工作线程或 I/O 完成线程直到它达到每个类别的最小值。 默认情况下，最小线程数设置为在系统上的处理器数。 当达到最小值时，线程池可以创建该类别中的其他线程或等待，直到一些任务完成。 需求较低时，线程池线程的实际数量可以低于最小值。于是便会出现我们在本文一开始运行时出现的结果图。在我的计算机上（八核），最小线程数是 8，于是开始的 8 个任务可以立即开始执行。当达到数量 8 而依然没有线程完成执行的时候，线程池会尝试等待任务完成。但是，1 秒后依然没有任务完成，于是线程池创建了一个新的线程来执行新的任务；接下来是每隔一秒会开启一个新的线程来执行现有任务。当有任务完成之后，就可以直接使用之前完成了任务的线程继续完成新的任务。不过，每个类别创建线程的总数量受到最大线程数限制。推荐的使用方法了解到 ThreadPoolTaskScheduler 的默认行为之后，我们可以做这些事情来充分利用线程池带来的优势： 对于 IO 操作，尽量使用原生提供的 Async 方法，这些方法使用的是 IO 完成端口，占用线程池中的 IO 线程而不是普通线程（不要自己使用 Task.Run 占用线程池资源）； 对于没有 Async 版本的 IO 操作，如果可能耗时很长，则指定 CreateOptions 为 LongRunning（这样便会直接开一个新线程，而不是使用线程池）。 其他短时间执行的任务才推荐使用 Task.Run。参考资料 TaskScheduler Class (System.Threading.Tasks) - Microsoft Docs TaskCreationOptions Enum (System.Threading.Tasks) - Microsoft Docs Parallel Tasks - Microsoft Docs Attached and Detached Child Tasks - Microsoft Docs 在 ThreadPool.GetMinThreads(Int32, Int32) Method (System.Threading) - Microsoft Docs Managed Threading Best Practices - Microsoft Docs" }, { "title": "Turn on Mobile Hotspot (Wi-Fi) in Windows 10", "url": "/post/open-mobile-hotspot-in-windows-10-en.html", "categories": "", "tags": "windows", "date": "2018-12-23 13:35:01 +0800", "snippet": "We’ll learn how to turn on Mobile Hotspot (Wi-Fi) in Windows 10.This post is written in multiple languages. Please select yours: 中文 English Go to Settings -&amp;gt; 网络和 Internet -&amp;gt; 移动热点Turn on Share my Internet connection with other devices.If you want to change your Network name and Network password, just click Edit.You’ll find this hotspot in your other devices. After you connect your device to this hotspot you’ll soon find that all the devices are listed in the Devices connected section.Click the network icon in the task bar notification area and you can also turn on the Wi-Fi hotspot there." }, { "title": "在 Windows 10 中开启移动 WLAN 热点", "url": "/post/open-mobile-hotspot-in-windows-10.html", "categories": "", "tags": "windows", "date": "2018-12-23 13:27:54 +0800", "snippet": "本文将介绍如何在 Windows 10 中开启移动 Wi-Fi 热点。This post is written in multiple languages. Please select yours: 中文 English 要在 Windows 10 中开启移动 WLAN，需要进入设置 -&amp;gt; 网络和 Internet -&amp;gt; 移动热点开启“与其他设备共享我的 Internet 连接”。如果你需要修改网络名称和密码，点击下面的编辑即可。在开启之后，你可以在其他设备中发现这个新的热点，连接上之后就可以在下面“已连接的设备”中看到所有正在连接的设备。还有其他的开启方式，直接在任务栏的通知区域，打开网络图标，最右边就有移动热点的开关。" }, { "title": "在 WPF/UWP 中实现一个可以用 await 异步等待 UI 交互操作的 Awaiter", "url": "/post/write-dispatcher-awaiter-for-ui.html", "categories": "", "tags": "dotnet, csharp, wpf, uwp", "date": "2018-12-22 19:54:48 +0800", "snippet": ".NET 和 C# 共同给我们带来的 async/await 异步编程模型（TAP）用起来真的很爽。为了实现异步等待，我们只需要在一切能够能够异步等待的方法前面加上 await 即可。能够异步等待的最常见的类型莫过于 Task，但也有一些其他类型。即便有些耗时操作没有返回可等待的类型，我们也可以用一句 Task.Run(action) 来包装（同步转异步 - 林德熙 中也有说明）；不过副作用就是 Run 里面的方法在后台线程执行了（谁知道这是好处呢还是坏处呢 ^_^）。问题就在于，有些“耗时”操作根本就无法放入后台线程，典型的莫过于“耗时”的 UI 操作。本文将通过实现一个适用于 UI 的可等待类型来解决这种 UI 的“耗时”等待问题。Awaiter 系列文章入门篇： .NET 中什么样的类是可使用 await 异步等待的？ 定义一组抽象的 Awaiter 的实现接口，你下次写自己的 await 可等待对象时将更加方便 .NET 除了用 Task 之外，如何自己写一个可以 await 的对象？实战篇： 在 WPF/UWP 中实现一个可以用 await 异步等待 UI 交互操作的 Awaiter .NET 编写一个可以异步等待循环中任何一个部分的 Awaiter本文阅读建议本文代码较多，阅读建议： 标注为“本文推荐的完整代码”的代码块可直接放入自己的项目中使用，也贴出了 GitHub 上我以 MIT 开源的源代码（可能 GitHub 上会经常更新）。 标注“此处为试验代码”的代码块表明此处代码并不完善，仅用于本文分析使用，不建议放到自己的项目中使用。 没有注释标注的代码块是用于研究的代码片段，不需要使用。 可点击下面的导航跳转到你希望的地方。我们的需求这里说的 UI “耗时”，“耗时”打了引号，是因为严格来说并不是真的卡死了 UI，而是某个函数的执行需要更多的 UI 操作才能继续。这句话可能比较难懂，但举两个例子就好懂了。 某个函数的执行需要显示一个用户控件，用户填写控件中的信息并确定后，函数才继续执行。这种感觉很像模态窗口，但我们却是在同一个窗口内实现，不能通过模态窗口来实现我们的功能。（UWP 中的 ContentDialog 就是这么干的。） 我们需要在后台线程创建一个控件，创建完毕之后在原线程返回。这样我们就能得到一个在后台线程创建的控件了。本文将以实现第 2 条为目标，一步步完善我们的代码，并做出一个非常通用的 UI 可等待类出来。最终你会发现，我们的代码也能轻松应对第 1 条的需求。实现目标 DispatcherAsyncOperation现在，我们来实现我们的目标。回顾一下，我们希望实现一个方法，要求能够在后台线程创建一个 UI 控件。不使用自定义的 Awaiter，使用现有的 Task 可以写出如下代码：// 注：此处为试验代码。public static class UIDispatcher{ public static async Task&amp;lt;T&amp;gt; CreateElementAsync&amp;lt;T&amp;gt;() where T : Visual, new() { return await CreateElementAsync(() =&amp;gt; new T()); } public static async Task&amp;lt;T&amp;gt; CreateElementAsync&amp;lt;T&amp;gt;([NotNull] Func&amp;lt;T&amp;gt; @new) where T : Visual { if (@new == null) throw new ArgumentNullException(nameof(@new)); var element = default(T); Exception exception = null; var resetEvent = new AutoResetEvent(false); var thread = new Thread(() =&amp;gt; { try { SynchronizationContext.SetSynchronizationContext( new DispatcherSynchronizationContext(Dispatcher.CurrentDispatcher)); element = @new(); resetEvent.Set(); Dispatcher.Run(); } catch (Exception ex) { exception = ex; } }) { Name = $&quot;{typeof(T).Name}&quot;, IsBackground = true, }; thread.SetApartmentState(ApartmentState.STA); thread.Start(); await Task.Run(() =&amp;gt; { resetEvent.WaitOne(); resetEvent.Dispose(); }); if (exception != null) { ExceptionDispatchInfo.Capture(exception).Throw(); } return element; }}说明一下：SynchronizationContext.SetSynchronizationContext(new DispatcherSynchronizationContext(Dispatcher.CurrentDispatcher)); 这句话是为了确保创建的新 UI 线程里执行的 async/await 代码在 await 异步等待之后能够继续回到此 UI 线程，而不是随便从线程池找一个线程执行。试一下：var element = await UIDispatcher.CreateElementAsync&amp;lt;Button&amp;gt;();确实拿到了后台线程创建的 UI 对象。然而，注意这一句：await Task.Run(() =&amp;gt;{ resetEvent.WaitOne(); resetEvent.Dispose();});这里开启了一个新的线程，专门等待后台线程执行到某个关键位置，实在是太浪费。如果我们实现的是本文开头的第一个需求，需要等待用户输入完信息点击确认后才继续，那么这个 WaitOne 则可能会等非常久的时间（取决于用户的心情，啥时候想点确定啥时候才结束）。线程池里一个线程就这样白白浪费了，可惜！可惜！于是，我们换自己实现的 Awaiter，节省这个线程的资源。取个名字，既然用于 UI 线程使用，那么就命名为 DispatcherAsyncOperation 好了。我打算让这个类同时实现 IAwaitable 和 IAwaiter 接口，因为我又不会去反复等待，只用一次。那么开始，既然要去掉 Task.Run，那么我们需要在后台线程真正完成任务的时候自动去执行接下来的任务，而不是在调用线程中去等待。经过反复修改，我的 DispatcherAsyncOperation 类如下：// 此段代码为本文推荐的完整版本。// 可复制或前往我的 GitHub 页面下载：// https://github.com/walterlv/sharing-demo/blob/master/src/Walterlv.Demo.Sharing/Utils/Threading/DispatcherAsyncOperation.csnamespace Walterlv.Demo.Utils.Threading{ public class DispatcherAsyncOperation&amp;lt;T&amp;gt; : DispatcherObject, IAwaitable&amp;lt;DispatcherAsyncOperation&amp;lt;T&amp;gt;, T&amp;gt;, IAwaiter&amp;lt;T&amp;gt; { private DispatcherAsyncOperation() { } public DispatcherAsyncOperation&amp;lt;T&amp;gt; GetAwaiter() { return this; } public bool IsCompleted { get; private set; } public T Result { get; private set; } public T GetResult() { if (_exception != null) { ExceptionDispatchInfo.Capture(_exception).Throw(); } return Result; } public DispatcherAsyncOperation&amp;lt;T&amp;gt; ConfigurePriority(DispatcherPriority priority) { _priority = priority; return this; } public void OnCompleted(Action continuation) { if (IsCompleted) { continuation?.Invoke(); } else { _continuation += continuation; } } private void ReportResult(T result, Exception ex) { Result = result; _exception = ex; IsCompleted = true; if (_continuation != null) { Dispatcher.InvokeAsync(_continuation, _priority); } } private Action _continuation; private DispatcherPriority _priority = DispatcherPriority.Normal; private Exception _exception; public static DispatcherAsyncOperation&amp;lt;T&amp;gt; Create([NotNull] out Action&amp;lt;T, Exception&amp;gt; reportResult) { var asyncOperation = new DispatcherAsyncOperation&amp;lt;T&amp;gt;(); reportResult = asyncOperation.ReportResult; return asyncOperation; } }}解释一下： Create() 静态方法会返回一个可以等待的 DispatcherAsyncOperation&amp;lt;T&amp;gt; 实例，在写实现代码的地方当然不是用来等的，这个值是用来给外部使用 await 的开发者返回的。但是，它会 out 一个 Action，调用这个 Action，则可以报告操作已经结束。 OnCompleted 方法会在主线程调用的代码结束后立即执行。参数中的 continuation 是对 await 后面代码的一层包装，调用它即可让 await 后面的代码开始执行。但是，我们却并不是立即就能得到后台线程的返回值。于是我们需要等到后台线程执行完毕，调用 ReportResult 方法的时候才执行。 _continuation += continuation; 需要使用 “+=” 是因为这里的 GetAwaiter() 返回的是 this，也就是说，极有可能发生同一个实例被 await 多次的情况，需要将每次后面的任务都执行才行。 _continuation 可能为空，是因为任务执行完毕的时候也没有任何地方 await 了此实例。在有了新的 DispatcherAsyncOperation 的帮助下，我们的 UIDispatcher 改进成了如下模样：// 注：此处为试验代码。public static class UIDispatcher{ public static DispatcherAsyncOperation&amp;lt;T&amp;gt; CreateElementAsync&amp;lt;T&amp;gt;() where T : Visual, new() { return CreateElementAsync(() =&amp;gt; new T()); } public static DispatcherAsyncOperation&amp;lt;T&amp;gt; CreateElementAsync&amp;lt;T&amp;gt;( Func&amp;lt;T&amp;gt; @new) where T : Visual { var awaitable = DispatcherAsyncOperation&amp;lt;T&amp;gt;.Create(out var reportResult); var thread = new Thread(() =&amp;gt; { try { var dispatcher = Dispatcher.CurrentDispatcher; SynchronizationContext.SetSynchronizationContext( new DispatcherSynchronizationContext(dispatcher)); var value = @new(); reportResult(value, null); Dispatcher.Run(); } catch (Exception ex) { reportResult(null, ex); } }) { Name = $&quot;{typeof(T).Name}&quot;, IsBackground = true, }; thread.SetApartmentState(ApartmentState.STA); thread.Start(); return awaitable; }}为了让 UIDispatcher 更加通用，我们把后台线程创建 UI 控件的代码移除，现在 UIDispatcher 里面只剩下用于创建一个后台线程运行的 Dispatcher 的方法了。// 此段代码为本文推荐的完整版本。// 可复制或前往我的 GitHub 页面下载：// https://github.com/walterlv/sharing-demo/blob/master/src/Walterlv.Demo.WPF/Utils/Threading/UIDispatcher.csnamespace Walterlv.Demo{ public static class UIDispatcher { public static DispatcherAsyncOperation&amp;lt;Dispatcher&amp;gt; RunNewAsync([CanBeNull] string name = null) { var awaitable = DispatcherAsyncOperation&amp;lt;Dispatcher&amp;gt;.Create(out var reportResult); var thread = new Thread(() =&amp;gt; { try { var dispatcher = Dispatcher.CurrentDispatcher; SynchronizationContext.SetSynchronizationContext( new DispatcherSynchronizationContext(dispatcher)); reportResult(dispatcher, null); Dispatcher.Run(); } catch (Exception ex) { reportResult(null, ex); } }) { Name = name ?? &quot;BackgroundUI&quot;, IsBackground = true, }; thread.SetApartmentState(ApartmentState.STA); thread.Start(); return awaitable; } }}回顾完整的代码至此，我们得到了三个完整的代码文件（在 GitHub 上，以下所有代码文件均有详尽的中文注释）： AwaiterInterfaces.cs 用于定义一组完整的 Awaitable/Awaiter 接口，方便开发者实现自定义可等待对象。 DispatcherAsyncOperation.cs 一个自定义的，适用于 UI 的自定义可等待（awaitable）类；使用此类可以避免浪费一个线程用于等待 UI 操作的结束。 UIDispatcher.cs 用于在后台线程启动一个 Dispatcher，以便在这个 Dispatcher 中方便地创建控件。回顾需求现在，在以上三个完整代码文件的帮助下，我们实现我们的那两个需求。（手动斜眼一下，我只说拿第 2 个需求当例子进行分析，并不是说只实现第 2 个。我们的目标是写出一份通用的组件来，方便实现大部分主流需求。）实现第 2 个需求后台创建一个 UI 控件：public async Task&amp;lt;T&amp;gt; CreateElementAsync&amp;lt;T&amp;gt;([CanBeNull] Dispatcher dispatcher = null) where T : UIElement, new(){ return await CreateElementAsync(() =&amp;gt; new T(), dispatcher);}public async Task&amp;lt;T&amp;gt; CreateElementAsync&amp;lt;T&amp;gt;(Func&amp;lt;T&amp;gt; @new, [CanBeNull] Dispatcher dispatcher = null) where T : UIElement{ dispatcher = dispatcher ?? await UIDispatcher.RunNewAsync($&quot;{typeof(T).Name}&quot;); return await dispatcher.InvokeAsync(@new);}可以这样用：var result = CreateElementAsync(() =&amp;gt;{ var box = new TextBox() { Text = &quot;123&quot;, Opacity = 0.5, Margin = new Thickness(16), }; return box;});也可以这样用：var result = CreateElementAsync&amp;lt;Button&amp;gt;();还可以不用新建线程和 Dispatcher，直接利用现成的：var result = CreateElementAsync&amp;lt;Button&amp;gt;(dispatcher);实现第 1 个需求显示一个用户控件，等用户点击了确定后异步返回：private Action&amp;lt;bool, Exception&amp;gt; _reportResult;public DispatcherAsyncOperation&amp;lt;bool&amp;gt; ShowAsync(){ var awaiter = DispatcherAsyncOperation&amp;lt;bool&amp;gt;.Create(out _reportResult); Host.Visibility = Visibility.Visible; return awaiter;}private void OkButton_Click(object sender, RoutedEventArgs e){ Host.Visibility = Visibility.Collapsed; _reportResult(true, null);}private void CancelButton_Click(object sender, RoutedEventArgs e){ Host.Visibility = Visibility.Collapsed; _reportResult(false, null);}可以这样用：var result = await someControl.ShowAsync();if (result){ // 用户点了确定。}else{ // 用户点了取消。。}全文总结读者读到此处，应该已经学会了如何自己实现一个自定义的异步等待类，也能明白某些场景下自己写一个这样的类代替原生 Task 的好处。不过不管是否明白，通过阅读本文还收获了三份代码文件呢！我已经把这些文件以 MIT 开源到了 walterlv/sharing-demo 中，大家可以随意使用。本文较长，如果阅读的过程中发现了任何不正确的地方，希望能回复帮我指出；如果有难以理解的地方，也请回复我，以便我能够调整我的语句，使之更易于理解。以上。参考资料 Dixin’s Blog - Understanding C# async / await (1) Compilation Dixin’s Blog - Understanding C# async / await (2) The Awaitable-Awaiter Pattern await anything; - Parallel Programming with .NET 【C#】【多线程】【05-使用C#6.0】08-自定义awaitable类型 - L.M AsyncMethodBuilder" }, { "title": ".NET 编写一个可以异步等待循环中任何一个部分的 Awaiter", "url": "/post/write-an-awaiter-that-await-part-of-a-loop.html", "categories": "", "tags": "dotnet, csharp", "date": "2018-12-22 19:50:54 +0800", "snippet": "林德熙 小伙伴希望保存一个文件，并且希望如果出错了也要不断地重试。然而我认为如果一直错误则应该对外抛出异常让调用者知道为什么会一直错误。这似乎是一个矛盾的要求。然而最终我想到了一个办法：让重试一直进行下去，谁需要关心异常谁就去 catch 异常，不需要关心异常的模块则跟着一直重试直到成功。我们通过编写一个自己的 Awaiter 来实现，本文将说明其思路和最终实现的代码。Awaiter 系列文章入门篇： .NET 中什么样的类是可使用 await 异步等待的？ 定义一组抽象的 Awaiter 的实现接口，你下次写自己的 await 可等待对象时将更加方便 .NET 除了用 Task 之外，如何自己写一个可以 await 的对象？实战篇： 在 WPF/UWP 中实现一个可以用 await 异步等待 UI 交互操作的 Awaiter .NET 编写一个可以异步等待循环中任何一个部分的 Awaiter遇到了什么问题有一个任务，可能会出错，然而重试有可能可以解决。典型的例子是写入文件，你可能因为其他进程占用的问题而导致无法写入，然而一段时间之后重试是可以解决的。现在，不同业务对这同一个操作有不同的需求： 有的业务不关心写入结果到底如何 有的业务由于时间有限，只能接受几次的重试 有的业务关心写入过程中的异常 而有的业务非常闲，只要一直写入就行了，最终成功告诉我就好可是，我们如何在一个任务中同时对所有不同的业务需求进行不同种类的响应呢？思路我的思路是： 当有业务发起请求之后，就开启一个不断重试的任务； 针对这个请求的业务，返回一个专为此业务定制的可等待对象； 如果在重试完成之前，还有新的业务请求发起，那么则返回一个专为此新业务定制的可等待对象； 一旦重试任务成功完成，那么所有的可等待对象强制返回成功； 而如果重试中有的可等待对象已经等待结束但任务依旧没有成功，则在可等待对象中引发任务重试过程中发生过的异常。这样，任务不断重试。而且，无论多少个业务请求到来，都只是加入到循环中的一部分来，不会开启新的循环任务。每个业务的等待时长和异常处理都是自己的可等待对象中处理的，不影响循环任务的继续执行。关于源代码说明本文所述的所有源代码可以在 https://gist.github.com/walterlv/d2aecd02dfad74279713112d44bcd358 查看和下载到最新版本。期望如何使用这个新的 Awaiterpublic class WalterlvDemo{ // 记录一个可以重试的循环。 private readonly PartialAwaitableRetry _loop; public WalterlvDemo() { // 初始化一个可以重试的循环，循环内部执行的方法是 TryCoreAsync。 _loop = new PartialAwaitableRetry(TryCoreAsync); } // 如果外界期望使用这个类试一下，那么就调用此方法。默认尝试 10 次，但也可以指定为 -1 尝试无数次。 public ContinuousPartOperation TryAsync(int tryCount = 10) { // 加入循环中，然后返回一个可以异步等待 10 次循环的对象。 return _loop.JoinAsync(tryCount); } // 此方法就是循环的内部执行的方法。 private async Task&amp;lt;OperationResult&amp;gt; TryCoreAsync(PartialRetryContext context) { // 每 1 秒执行一次循环重试，当然你也可以尝试指数退避。 await Task.Delay(1000).ConfigureAwait(false); // 执行真正需要重试而且可能出现异常的方法。 await DoSomethingIOAsync().ConfigureAwait(false); // 如果执行成功，那么就返回 true。当然，上面的代码如果出现了异常，也是可以被捕获到的。 return true; } // 这就是那个有可能会出错，然后出错了需要不断重试的方法。 private async Task DoSomethingIOAsync() { // 省略实际执行的代码。 }}写一个可以不断循环的循环，并允许不同业务加入等待上面的代码中，我们使用到了两个新的类型：用于循环执行某个委托的 PartialAwaitableRetry，以及用于表示单次执行结果的 OperationResult。以下只贴出此代码的关键部分，全部源码请至本文末尾查看或下载。public class PartialAwaitableRetry{ // 省略构造函数和部分字段，请至本文文末查看完整代码。 private readonly List&amp;lt;CountLimitOperationToken&amp;gt; _tokens = new List&amp;lt;CountLimitOperationToken&amp;gt;(); public ContinuousPartOperation JoinAsync(int countLimit) { var token = new CountLimitOperationToken(countLimit); // 省略线程安全代码，请至本文文末查看完整代码。 _tokens.Add(token); if (!_isLooping) { Loop(); } return token.Operation; } private async void Loop() { while(true) { await _loopItem.Invoke(context).ConfigureAwait(false); // 省略线程安全处理和异常处理，请至本文文末查看完整代码。 foreach (var token in _tokens) { token.Pass(1); } } }}维护一个 CountLimitOperationToken 的集合，然后在每次循环的时候更新集合中的所有项。这样，通过 JsonAsync 创建的每一个可等待对象就能更新其状态 —— 将异常传入或者将执行的次数传入。由于我们在创建可等待对象 CountLimitOperationToken 的时候，传入了等待循环的次数，所以我么可以在 CountLimitOperationToken 内部实现每次更新循环执行次数和异常的时候，更新其等待状态。如果次数已到，那么就通知异步等待完成。关于 OperationResult 类，是个简单的运算符重载，用于表示单次循环中的成功与否的状态和异常情况。可以在本文文末查看其代码。写一个可等待对象，针对不同业务返回不同的可等待对象实例我写了三个不同的类来完成这个可等待对象： CountLimitOperationToken 上面的代码中我们使用到了这个类型，目的是为了生成 ContinuousPartOperation 这个可等待对象。 我将这个 Token 和实际的 Awaitable 分开，是为了隔离执行循环任务的代码和等待循环任务的代码，避免等待循环任务的代码可以修改等待的过程。 ContinuousPartOperation 这个是实际的可等待对象，这个类型的实例可以直接使用 await 关键字进行异步等待，也可以使用 Wait() 方法进行同步等待。 我把这个 Awaitable 和 Awaiter 分开，是为了隔离 await 关键字的 API 和编译器自动调用的方法。避免编译器的大量方法干扰使用者对这个类的使用。 ContinuousPartOperation.Awaiter 这是实际上编译器自动调用方法的一个类，有点类似于我们为了支持 foreach 而实现的 IEnumerator。（而集合应该继承 IEnumerable） 所以其实这三个类是在干同一件事情，都是为了实现一个可 await 异步等待的对象。关于如何编写一个自己的 Awaiter，可以参考我的 Awaiter 入门篇章： .NET 中什么样的类是可使用 await 异步等待的？ 定义一组抽象的 Awaiter 的实现接口，你下次写自己的 await 可等待对象时将更加方便 .NET 除了用 Task 之外，如何自己写一个可以 await 的对象？以及实战篇章： 在 WPF/UWP 中实现一个可以用 await 异步等待 UI 交互操作的 Awaiter .NET 编写一个可以异步等待循环中任何一个部分的 Awaiter这几个类的实际代码可以在文末查看和下载。附全部源码" }, { "title": ".NET 中使用 TaskCompletionSource 作为线程同步互斥或异步操作的事件", "url": "/post/use-task-completion-source-as-await-locker.html", "categories": "", "tags": "dotnet, csharp", "date": "2018-12-22 15:50:23 +0800", "snippet": "你可以使用临界区（Critical Section）、互斥量（Mutex）、信号量（Semaphores）和事件（Event）来处理线程同步。然而，在编写一些异步处理函数，尤其是还有 async 和 await 使用的时候，还有一些更方便的类型可以用来处理线程同步。使用 TaskCompletionSource，你可以轻松地编写既可以异步等待，又可以同步等待的代码来。等待事件我们创建一个 TaskCompletionSource&amp;lt;object&amp;gt; 对象，这样，我们便可以写出一个既可以同步等待又可以异步等待的方法：public class WalterlvDemo{ private readonly TaskCompletionSource&amp;lt;object&amp;gt; _source = new TaskCompletionSource&amp;lt;object&amp;gt;(); public Task WaitAsync() =&amp;gt; _source.Task; public void Wait() =&amp;gt; _source.Task.GetAwaiter().GetResult();}等待时可以同步：demo.Wait();也可以异步：await demo.WaitAsync();而同步的那个方法，便可以用来做线程同步使用。引发事件要像一个事件一样让同步等待阻塞着的线程继续跑起来，则需要设置这个事件。而 TaskCompletionSource&amp;lt;object&amp;gt; 提供了很多让任务完成的方法：可以通过让这个 TaskCompletionSource&amp;lt;object&amp;gt; 完成、取消或设置异常的方式让这个 Task 进入完成、取消或错误状态，然后等待它的线程就会继续执行；当然如果有异常，就会让等待的线程收到一个需要处理的异常。_source.SetResult(null);" }, { "title": "使用 WPF 开发一个 Windows 屏幕保护程序", "url": "/post/write-a-windows-screen-saver-using-wpf.html", "categories": "", "tags": "windows, wpf", "date": "2018-12-22 10:24:33 +0800", "snippet": "最近有小伙伴问我如何可以让 Windows 静置一段时间不操作之后，显示一个特殊的界面。我想了想，屏幕保护程序可以做到这一点，而且，屏幕保护程序的开发也是非常简单的。本文将介绍如何为 Windows 这一悠久的功能进行开发。屏幕保护程序的本质屏幕保护程序本质上就是一个 Win32 窗口应用程序。好了，这一节真的结束了……编译好一个窗口应用程序之后，把扩展名改为 scr，于是你的屏幕保护程序就做好了。安装屏幕保护程序现在，在你的 scr 程序上点击右键，可以看到一个 “安装” 选项，点击之后就安装了。安装之后，你会立即看到我们的屏幕保护程序已经运行起来了。为了方便截图，我调了下窗口大小。实际上本应该是 Visual Studio 创建的空 WPF 程序的默认大小。处理屏幕保护程序参数我的屏幕保护程序是一个非常简单的程序，几乎就是默认的模板。只是，现在加上了一点文字，输出命令行参数。&amp;lt;Window x:Class=&quot;Walterlv.DirextXDemo.Wpf.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; mc:Ignorable=&quot;d&quot; Title=&quot;Walterlv.ScreenSaver&quot; Height=&quot;450&quot; Width=&quot;800&quot;&amp;gt; &amp;lt;Grid&amp;gt; &amp;lt;TextBlock x:Name=&quot;ArgsTextBlock&quot; VerticalAlignment=&quot;Center&quot; TextAlignment=&quot;Center&quot; /&amp;gt; &amp;lt;/Grid&amp;gt;&amp;lt;/Window&amp;gt;public partial class MainWindow : Window{ public MainWindow() { InitializeComponent(); Loaded += OnLoaded; } private async void OnLoaded(object sender, RoutedEventArgs e) { var args = Environment.GetCommandLineArgs().Skip(1).ToArray(); Args.Text = string.Join(Environment.NewLine, args); }}在前面的截图中，我们看到参数是 “/p 8457636”，这是表示此程序需要在预览窗格中进行预览。还有其他参数，用于处理其他情况： /s 屏幕保护程序开始，或者用户点击了 “预览” 按钮 /c:463970 用户点击了 “设置” 按钮 /p 8457636 用户选中屏幕保护程序之后，在预览窗格中显示实际上屏幕保护程序开始和预览是不同的。预览的时候，只会启动你的程序；而实际开始的时候，Windows 会先为你创建一个白色的背景，覆盖所有的屏幕，然后你的屏幕保护程序窗口显示在那个白色的背景之上。请预防一些坑你可能会发现 Windows 自带的屏幕保护程序在 C:\\Windows\\System32 文件夹中。但！那不是你放屏幕保护程序的地方！如果把你的屏幕保护程序拷贝到那个 Windows 的受信任目录下，你的程序是无法运行起来的。正确的做法，是右键，使用 “安装” 选项进行安装。我后面附的链接中可能说屏幕保护程序还要有一些其他的要求，例如必须全屏、不要显示到任务栏等等。但那其实并不是强制性的要求，比如本文就显示了一个普通的窗口。参考资料 Create a screensaver with .NET and WPF" }, { "title": "优化 UWP 中图片的内存占用", "url": "/uwp/2017/09/17/optimize-image-in-uwp.html", "categories": "", "tags": "uwp", "date": "2018-12-21 16:51:33 +0800", "snippet": "跟图片打交道的 UWP 应用或多或少都会遇到图片带来的性能问题，就算不主要处理图片，做个论坛做个新闻客户端都涉及到大量图片。一个帖子、一篇文章里多半都是些高清大图，这些图片一张即可占用程序 1~2M 的内存空间。普通的写法内存很快就爆了，那么 UWP 中我们可以用哪些方法优化呢？1. DecodePixelWidth/DecodePixelHeight对于那些高分辨率图像，直接设置其 DecodePixelWidth 和 DecodePixelHeight 的值为较小的值即可大大节省内存空间。以下两种方法中，后者对内存空间的节省非常显著。&amp;lt;!-- 性能不好 --&amp;gt;&amp;lt;Image Source=&quot;ms-appx:///static/posts/high-resolution-image.jpg&quot; Width=&quot;300&quot; Height=&quot;200&quot;/&amp;gt;&amp;lt;!-- 性能不错 --&amp;gt;&amp;lt;Image&amp;gt; &amp;lt;Image.Source&amp;gt; &amp;lt;BitmapImage UriSource=&quot;ms-appx:///static/posts/high-resolution-image.jpg&quot; DecodePixelWidth=&quot;300&quot; DecodePixelHeight=&quot;200&quot;/&amp;gt; &amp;lt;/Image.Source&amp;gt;&amp;lt;/Image&amp;gt;2. 利用好自带的布局机制如果没有指定 DecodePixelWidth/DecodePixelHeight，那么 XAML 会根据布局自动调整图片的解码大小。不过，微软才不会让你这么开心地就用！如果你做了这些事，就当布局自带的内存优化不存在好了： 你先调了 SetSourceAsync 或设置了 UriSource，然后才把 BitmapImage 连接到活动的 XAML 树 使用异步解码（如 SetSource）解码图像。 把图像或父控件的 Opacity 设成了 0，或者 Visibility 设为 Collapsed ImageBrush 的 Strech 设成了 None 图像用作点九图（参见 NineGrid） 给图像或父控件设置了 CacheMode=&quot;BitmapCache&quot; ImageBrush 绘制到不是矩形的地方 (试过画到文字上或形状上吗？)关于第 1 条，这里有一些官方的代码作为例子：&amp;lt;!-- 推荐写法，直接在 XAML 里指定 UriSoruce --&amp;gt;&amp;lt;Image x:Name=&quot;myImage&quot; UriSource=&quot;Assets/cool-image.png&quot;/&amp;gt;&amp;lt;!-- 但如果没有在 XAML 中指定，也可以去后台代码指定。 --&amp;gt;&amp;lt;Image x:Name=&quot;myImage&quot;/&amp;gt;// 后台代码如果这样写就不错，因为先把 BitmapImage 放到了活动的 XAML 树上。var bitmapImage = new BitmapImage();myImage.Source = bitmapImage;bitmapImage.UriSource = new URI(&quot;ms-appx:///static/posts/cool-image.png&quot;, UriKind.RelativeOrAbsolute);// 然而这样写就不太推荐了，因为先设置了 UriSource，再把 BitmapImage 放到活动的 XAML 树上。var bitmapImage = new BitmapImage();bitmapImage.UriSource = new URI(&quot;ms-appx:///static/posts/cool-image.png&quot;, UriKind.RelativeOrAbsolute);myImage.Source = bitmapImage;3. 利用好自带的缓存机制如果你用 UriSource 属性，那么恭喜，你将获得自带的图片缓存！如果多次使用相同的 Uri，那么会共用同一份内存空间。除此之外就没啦，比如自己创建一个流啊什么的；这就是说并不建议自己用 FileStream。另外，微软提供了这么好用的 SetSourceAsync，但是用了这个就没有缓存了！于是我到底是用还是不用呢？4. GetThumbnailAsync如果你使用本机文件，那么恭喜，你直接获得了拿到系统自带缩略图的机会！使用系统自带的缩略图比前面的方法都更好，因为如果系统已经生成好了缩略图，你根本连解码图像都不需要。FileOpenPicker picker = new FileOpenPicker();picker.FileTypeFilter.Add(&quot;.bmp&quot;);picker.FileTypeFilter.Add(&quot;.jpg&quot;);picker.FileTypeFilter.Add(&quot;.jpeg&quot;);picker.FileTypeFilter.Add(&quot;.png&quot;);picker.SuggestedStartLocation = PickerLocationId.PicturesLibrary;StorageFile file = await picker.PickSingleFileAsync();StorageItemThumbnail fileThumbnail = await file.GetThumbnailAsync(ThumbnailMode.SingleItem, 64);BitmapImage bmp = new BitmapImage();bmp.SetSource(fileThumbnail);Image img = new Image();img.Source = bmp;关于 GetThumbnailAsync 的详细用法，我的好朋友林德熙有更详细的说明，参见：win10 uwp 获得缩略图。" }, { "title": "文件和文件夹不存在的时候，FileSystemWatcher 监听不到文件的改变？如果递归地监听就可以了", "url": "/post/watch-file-change-even-the-file-or-directory-not-exist.html", "categories": "", "tags": "dotnet, windows", "date": "2018-12-20 10:05:38 +0800", "snippet": "当你需要监视文件或文件夹的改变的时候，使用 FileSystemWatcher 便可以完成。不过，FileSystemWatcher 对文件夹的监视要求文件夹必须存在，否则会产生错误“无效路径”。那么，如果文件或文件夹不存在的时候可以怎么监视文件的改变呢？更麻烦的是如果顶层很多级文件夹都不存在，怎么能监视呢？本文将告诉你方法。本文的代码适用于 .NET Framework 和 .NET Core，同时不需要任何第三方依赖。方法一：创建文件夹（在逃避问题，但也不失为一种解决思路）如果文件夹不存在，把它创建出来就可以监视了嘛！这其实是在逃避问题。不过我把它写出来是因为如果我不说，可能有些小伙伴原本简单的问题就会变得复杂化。public void Watch(string file){ path = Path.GetFullPath(file); var directory = Path.GetDirectoryName(path); var file = Path.GetFileName(path); // 如果文件夹不存在，则创建文件夹。 if (!Directory.Exists(directory)) { Directory.CreateDirectory(directory); } // 监视 directory 文件夹下的 file 文件的改变 var watcher = new FileSystemWatcher(directory, file) { EnableRaisingEvents = true, NotifyFilter = NotifyFilters.LastWrite, }; watcher.Changed += FinalFile_Changed; // 使用 watcher 做其他的事情。}private void FinalFile_Changed(object sender, FileSystemEventArgs e){ // 当文件改变的时候，这里的代码会执行。}以上代码的含义是： 将文件路径取出来，分为文件夹部分和文件部分； 判断文件夹是否存在，如果不存在，则创建文件夹； 监视文件夹中此文件的改变。需要说明的是，FileSystemWatcher 原本是监视文件夹的，第一个参数是监视的文件夹的路径，而第二个参数是监视文件或文件夹的过滤通配符。不过，官方文档的说明是： To watch a specific file, set the Filter property to the file name. For example, to watch for changes in the file MyDoc.txt, set the Filter property to “MyDoc.txt”.如果你需要监听一个特定的文件，那么直接将后面的过滤器设定为文件名，那么就会直接监视到对应的文件。如果你的业务当中，反正始终都是要创建这个文件的，那么一开始创建了这个文件夹就能避免不少的麻烦。这也是我把这个方法放到这里作为首选方法的原因。虽然实际上这是在逃避问题，但真的是一个好方法。方法二：递归监视文件夹这种方法适用于如果文件或者文件夹不存在时，你不能创建这个文件夹的情况。也许是你的业务需要，也许因为你正在写库，库作为最为通用的业务，不希望改变用户的环境。这时，我们可以考虑的思路是 —— 递归地监视文件或文件夹。例如，我们有这样的文件夹结构： C:\\a\\b\\x.txt希望监听 x.txt 的改变。那么，如果 b 文件夹不存在，就监听 a 文件夹，如果 a 文件夹也不存在，那么就监听 C: 驱动器。实际上，我们不需要再去考虑 C: 驱动器也不存在的情况了（当你真的遇到的时候，考虑业务上规避吧……）。代码实现既然需要递归监视，那么我们需要查找第一次监视的时候，需要到哪一层。这里，我们可以用一个 while 循环来进行，一层一层查找文件夹。直到能够找到一层，文件夹存在而子文件夹不存在的情况。这时我们便能够监视子文件夹的创建了。我写了一个函数，用于返回这时存在的那个文件夹，和不存在的那个子文件夹或者文件。当然有特殊情况，就是文件直接就已经存在的情况下，也是返回文件所在的文件夹和此文件名的。private (string directory, string file) FindWatchableLevel(){ var path = _file.FullName; // 如果文件存在，就返回文件所在的文件夹和文件本身。 if (File.Exists(path)) { return (Path.GetDirectoryName(path), Path.GetFileName(path)); } // 如果文件不存在，但文件夹存在，也是返回文件夹和文件本身。 // 这一点在下面的第一层循环中体现。 // 对于每一层循环。 while (true) { var directory = Path.GetDirectoryName(path); var file = Path.GetFileName(path); // 检查文件夹是否存在，只要文件夹存在，那么就可以返回。 if (Directory.Exists(directory)) { return (directory, file); } // 如果连文件夹都不存在，那么就需要查找上一层文件夹。 path = directory; }}接下来，根据得到的文件夹和文件，判断其存在与否，决定是监视这个文件的改变，还是监视文件/文件夹结构的改变。如果文件/文件夹的结构改变，那么就需要重新调用这个方法再查找应该监视的文件夹了。public void Watch(){ var (directory, file) = FindWatchableLevel(); if (File.Exists(_file.FullName)) { // 如果文件存在，说明这是最终的文件。 // 注意使用 File.Exists 判断已存在的同名文件夹时会返回 false。 _watcher = new FileSystemWatcher(directory, file) { EnableRaisingEvents = true, NotifyFilter = NotifyFilters.LastWrite, }; _watcher.Changed += FinalFile_Changed; _watcher.Deleted += FileOrDirectory_CreatedOrDeleted; } else { // 注意这里的 file 可能是文件也可能是文件夹。 _watcher = new FileSystemWatcher(directory, file) { EnableRaisingEvents = true, }; _watcher.Created += FileOrDirectory_CreatedOrDeleted; _watcher.Renamed += FileOrDirectory_CreatedOrDeleted; _watcher.Deleted += FileOrDirectory_CreatedOrDeleted; }}我们通过 File.Exists(_file.FullName) 来判断最终的文件是否存在，用以区分是在监视最终的文件改变，还是监视文件夹结构的改变。private void FileOrDirectory_CreatedOrDeleted(object sender, FileSystemEventArgs e){ // 在文件/文件夹结构发生改变的时候，重新监视。 _watcher?.Dispose(); Watch();}private void FinalFile_Changed(object sender, FileSystemEventArgs e){ // 这里就是最终文件改变的地方了。}完整的代码和使用方法由于代码还是有一点点多。如果放到你原有的业务当中，对你的业务代码确实是一种污染。所以我封装了一个类 FileWatcher。它不需要依赖任何就可以使用，你可以将它拷贝到你的项目当中。代码可以阅读本文文末，或者前往 gist 查看：FileWatcher that helps you to watch a single file change even if the file or it’s owner folders does not exists.。使用方法与 FileSystemWatcher 类似，但是更简单：_watcher = new FileWatcher(@&quot;C:\\Users\\walterlv\\Desktop\\demo.txt&quot;);_watcher.Changed += OnFileChanged;_watcher.Watch();private void OnFileChanged(object sender, EventArgs e){ // 最纯粹的文件改变事件，仅在文件的内容真的改变的时候触发。}此方法的特点，优势和不足实际上，FileSystemWatcher 的监视也是有一些空洞的。如果你只是监视一级文件夹而不是递归监视子文件夹（通过设置 IncludeSubdirectories 属性来指定），那么就会存在一些情况是监视不到的。然而如果你真的递归监视子文件夹，又会监听到大量的事件需要过滤。那么此方法可以支持和不支持的情况有哪些呢？依然假设监视的文件是：C:\\a\\b\\x.txt 。支持这些情况： 一开始文件 x.txt 不存在，而后创建。 一开始 b\\x.txt 不存在，而后依次创建。 从 y.txt 文件重命名到 x.txt。 一开始文件 x.txt 存在，而后删除，再然后重新创建。不支持这些情况： 一开始文件存在，但你直接删除了 a 或者 b 文件夹，而不是先删除了 x.txt。 一开始文件存在，但直接将 b\\x.txt 连文件带文件夹一起移走，然后删除文件或文件夹。 一开始 b\\x.txt 都不存在，但现在保持文件夹结构连文件带文件夹一起移入到 a 文件夹中。当然，也有一些意外的发现： 一开始文件存在，但直接将 b\\x.txt 连文件带文件夹一起移走，这时依然能监听到 x.txt 文件的改变，但它已经不在原来的目录了。附所有源码如果看不到，请访问：FileWatcher that helps you to watch a single file change even if the file or it’s owner folers does not exists.。参考资料 FileSystemWatcher Class (System.IO) - Microsoft Docs c# - How can i use FileSystemWatcher to watch directory if directory not exist? - Stack Overflow FileSystemWatcher - Pure Chaos (Part 1 of 2) - CodeProject FileSystemWatcher - Pure Chaos (Part 2 of 2) - CodeProject Recursive Directory Watch - CodeProject How does Read File watch for changes? - Grasshopper c# - Reading file after writing it - Stack Overflow" }, { "title": "StyleCop 是什么，可以帮助团队带来什么价值？", "url": "/post/what-is-stylecop.html", "categories": "", "tags": "dotnet, csharp, visualstudio", "date": "2018-12-15 16:14:38 +0800", "snippet": "StyleCop 本质上是一个 C# 源代码规则分析器，可以帮助团队成员强制执行一组代码样式和一致性规则。本文将简述 StyleCop 以及它能为团队带来的价值。StyleCop 是什么？StyleCop 本质上是一个 C# 源代码规则分析器，可以帮助团队成员强制执行一组代码样式和一致性规则。划重点 —— “强制”。只要你愿意，你甚至可以让多写了一个空格的小伙伴无法成功编译项目！！！StyleCop 能做什么，不能做什么？实际在团队中使用的时候，StyleCop 有三种不同的方式为我们所用： 作为静态检查工具检查代码格式化规范； 作为编写代码时的自动格式化规则； 作为 API 扩展自定义的源代码检查的规则。不过，StyleCop 没有原生提供可以帮助辅助编写符合 StyleCop 规则的代码的工具或插件。也就是说，如果你希望编写出符合 StyleCop 规范的代码，那么你可能需要手工编写，调整格式。如果你的团队所有成员都是用 ReSharper，那么可以将 StyleCop 的规则也配置一遍到 ReSharper 中，这样编写时便可以符合 StyleCop 中定义的规范。关于使用 ReSharper 编写符合 StyleCop 规范的代码，可以参见：使用 ReSharper，输入即遵循 StyleCop 的代码格式化规范。StyleCop 的优势和价值StyleCop 的最大优势在于其“强制性”。无论你使用哪种 IDE 进行开发，由于其检查过程可以嵌入到编译过程中，所以如果你开发出不符合 StyleCop 规范要求的代码，直接可以无法成功编译项目。对于格式或其他代码风格要求非常高的项目，可以持续保持项目的一致性。" }, { "title": "UWP 中的 LaunchUriAsync，使用默认浏览器或其他应用打开链接", "url": "/uwp/2017/09/25/launch-uri-async.html", "categories": "", "tags": "uwp", "date": "2018-12-14 09:54:33 +0800", "snippet": "古老的 Win32 应用启动其他程序太过方便，以至于一部分开发者都已经不记得 Windows 能通过关联协议（参见 桌面应用程序关联协议）的方式通过统一资源定位符（URI）来启动应用程序了。转到 UWP 后，使用 URI 启动应用似乎成为了最推荐的方式。于是一句 LaunchUriAsync 就能解决大多数问题。常用的 Windows 10 内置协议 URI 协议 启动 http: 默认网页浏览器 mailto: 默认电子邮件 ms-settings: 设置 ms-store: 应用商店 于是，只要 URI 带这些协议头，就能够用表格中的那些应用打开相应的功能了。如果想知道 ms-settings 里有哪些可用，请参见：启动 Windows 设置应用 - UWP app developer；想知道 ms-store 可以如何帮助我们前往商店的具体页面，请参见：启动 Windows 应用商店应用 - UWP app developer。LaunchUriAsync要想简单地在代码中使用，一句足以：await Launcher.LaunchUriAsync(new Uri(@&quot;https://blog.walterlv.com&quot;));如果你希望在调用成功或失败后执行一些操作，则可以多写一些： var myblog = new Uri(@&quot;https://blog.walterlv.com/blog&quot;); var success = await Launcher.LaunchUriAsync(myblog); if (success) { // 如果你感兴趣，可以在成功启动后在这里执行一些操作。 } else { // 如果你感兴趣，可以在这里处理启动失败的一些情况。 }}然而，UWP 还提供了更多的选项：LauncherOptions。LauncherOptions在写以上代码时不难发现，LaunchUriAsync 提供了重载传入 LauncherOptions 参数，这个参数似乎是指定启动时的一些选项。查看注释后，可以发现这些选项：/// &amp;lt;summary&amp;gt;获取或设置指示启动与文件或 URI 关联的应用程序时系统是否应显示文件或 URI 可能会不安全的警告的值。&amp;lt;/summary&amp;gt;/// &amp;lt;returns&amp;gt;如果应显示警告，则为 true；否则为 false。&amp;lt;/returns&amp;gt;public bool TreatAsUntrusted { get; set; }/// &amp;lt;summary&amp;gt;获取或设置一个值，该值指示每当调用关联启动 API 时是否要显示**打开方式**对话框。&amp;lt;/summary&amp;gt;/// &amp;lt;returns&amp;gt;如果应始终显示**打开方式**对话框，则为 true；否则为 false。&amp;lt;/returns&amp;gt;public bool DisplayApplicationPicker { get; set; }/// &amp;lt;summary&amp;gt;在启动默认应用程序时获取用户界面 (UI) 选项。&amp;lt;/summary&amp;gt;/// &amp;lt;returns&amp;gt;UI 选项。&amp;lt;/returns&amp;gt;public LauncherUIOptions UI { get; }/// &amp;lt;summary&amp;gt;获取或设置表示没有处理文件类型或 URI 的应用程序时，用户应安装的应用程序在存储区中的包系列名称的值。&amp;lt;/summary&amp;gt;/// &amp;lt;returns&amp;gt;应用的程序包系列名称。&amp;lt;/returns&amp;gt;public string PreferredApplicationPackageFamilyName { get; set; }/// &amp;lt;summary&amp;gt;获取或设置一个值，该值表示没有处理文件类型或 URI 的应用程序时，用户应安装的应用程序在存储区中的显示名称。&amp;lt;/summary&amp;gt;/// &amp;lt;returns&amp;gt;应用程序的显示名称。&amp;lt;/returns&amp;gt;public string PreferredApplicationDisplayName { get; set; }/// &amp;lt;summary&amp;gt;获取或设置表示没有处理文件类型或 URI 的应用程序时，用户应转到的浏览器中的 URI 的值。&amp;lt;/summary&amp;gt;/// &amp;lt;returns&amp;gt;用户应转到的浏览器中的 URI。&amp;lt;/returns&amp;gt;public global::System.Uri FallbackUri { get; set; }/// &amp;lt;summary&amp;gt;获取或设置与表示网络上文件的 URI 相关的内容类型。&amp;lt;/summary&amp;gt;/// &amp;lt;returns&amp;gt;URL 的内容类型。&amp;lt;/returns&amp;gt;public string ContentType { get; set; }/// &amp;lt;summary&amp;gt;启动目标应用程序，并通过与目标应用程序平分空间或占用比目标应用程序更多或更少的空间，让当前运行的源应用程序保留在屏幕上。&amp;lt;/summary&amp;gt;/// &amp;lt;returns&amp;gt;Windows.UI.ViewManagement.ViewSizePreference 类型的值，指定应用程序所需的视图大小。&amp;lt;/returns&amp;gt;public ViewSizePreference DesiredRemainingView { get; set; }/// &amp;lt;summary&amp;gt;启动文件或 URI 时应使用的目标包的包系列名称。 此属性是可选的。&amp;lt;/summary&amp;gt;/// &amp;lt;returns&amp;gt;启动文件或 URI 时应使用的目标包的包系列名称。 此属性是可选的。&amp;lt;/returns&amp;gt;public string TargetApplicationPackageFamilyName { get; set; }/// &amp;lt;summary&amp;gt;让应用能访问与用于激活应用的文件相关的文件。&amp;lt;/summary&amp;gt;/// &amp;lt;returns&amp;gt;包含相关文件列表的查询。&amp;lt;/returns&amp;gt;public StorageFileQueryResult NeighboringFilesQuery { get; set; }/// &amp;lt;summary&amp;gt;指示是否忽略可以处理 http(s) 方案（如浏览器）的处理程序。 相反，启动将回退到默认浏览器。&amp;lt;/summary&amp;gt;/// &amp;lt;returns&amp;gt;**true** 指示可以处理 http(s) 方案的应用程序将被忽略，而是在默认浏览器中打开该 URI；否则为 **false**。&amp;lt;/returns&amp;gt;public bool IgnoreAppUriHandlers { get; set; }/// &amp;lt;summary&amp;gt;获取或设置是否将启动器的选取器限制为当前应用程序及其相关联的 URI 处理程序。&amp;lt;/summary&amp;gt;/// &amp;lt;returns&amp;gt;如果启动器应将选取器限制为当前应用程序及其相关联的 URI 处理程序，则为 true；否则为 false。&amp;lt;/returns&amp;gt;public bool LimitPickerToCurrentAppAndAppUriHandlers { get; set; }比如其中 TreatAsUntrusted 表示标记此次打开是不受信任的。如果打开程序自己内置的链接，通常置为 false，以便能直接打开。但有时程序需要处理用户输入的数据，这时就不一定真的是期望打开了。于是标记为不安全后，Windows 10 会为我们弹出一个提示框，告诉我们是否真的要切换应用。截图中的 MarkdownMail 是我的一个开源项目，可以前往 markdown-mail @ github 多多支持。我们还可以指定推荐用哪个应用打开（设置 PreferredApplicationPackageFamilyName），指定期望显示的窗口大小（设置 DesiredRemainingView，不过不是具体的大小，而是几种选项），指定只打开自己当前这款应用（设置 LimitPickerToCurrentAppAndAppUriHandlers）。具体查看注释是能够了解的。参考资料 启动 URI 的默认应用 - UWP app developer 启动 Windows 设置应用 - UWP app developer 启动 Windows 应用商店应用 - UWP app developer" }, { "title": "WPF/UWP 绑定中的 UpdateSourceTrigger", "url": "/uwp/2017/09/25/binding-update-source-trigger.html", "categories": "", "tags": "uwp", "date": "2018-12-14 09:54:33 +0800", "snippet": "在开发 markdown-mail 时遇到了一些诡异的情况。代码是这么写的：&amp;lt;TextBox Text=&quot;{Binding Text, Mode=TwoWay}&quot;/&amp;gt;然而在 TextChanged 事件之后延时执行了一些操作时，从 ViewModel 里拿到的值却始终是旧的。阅读本文将了解其原因和解决办法。无论是 WPF 还是 UWP，Binding 中都有 UpdateSourceTrigger 属性。在 WPF 中，其可取的值为：public enum UpdateSourceTrigger{ Default, PropertyChanged, LostFocus, Explicit}在 UWP 中，其可取的值为：public enum UpdateSourceTrigger{ Default, PropertyChanged, Explicit}这些值代表的含义是： Default 默认值，多数情况下与 PropertyChanged 一样，然而对 TextBox.Text 属性来说，却是 LostFocus（WPF）或 Explicit（UWP）。 Explicit 必须在显式地调用 BindingExpression.UpdateSource 的情况下才会更新源值。 LostFocus（WPF 专属，不过 UWP 的预览版里也有） 目标控件失去焦点的时候更新源值。 PropertyChanged 绑定的目标值改变的时候就会更新源值，至于检测方法，则完全由 WPF/UWP 的绑定系统完成 于是，为了解决一开始的问题，我们需要在 TextBox 的 Text 属性的双向绑定里重新设置新的 UpdateSourceTrigger 的值。&amp;lt;TextBox Text=&quot;{Binding Text, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}&quot;/&amp;gt;没错，就是加这半句就好了。参考资料 How to: Control When the TextBox Text Updates the Source - Microsoft Docs c# - WPF two-way binding not working - Stack Overflow The UpdateSourceTrigger property - The complete WPF tutorial UpdateSourceTrigger Enum (Windows.UI.Xaml.Data) - UWP app developer - Microsoft Docs UpdateSourceTrigger Enum (System.Windows.Data) - Microsoft Docs TextBox.Text Property (System.Windows.Controls) - Microsoft Docs" }, { "title": "用微软拼音快速输入自定义格式的时间和日期", "url": "/ime/2017/09/18/date-time-format-using-microsoft-pinyin.html", "categories": "", "tags": "ime", "date": "2018-12-14 09:54:33 +0800", "snippet": "用微软拼音输入 rq 或者 sj，我们可以在第五个候选词分别得到 2017年9月18日 和 22点05分。但是，其实我想输入的是：2017-09-18 和 2017-09-18 22:05:51 +0800。在设置里面折腾一番没找到之后，原本以为只好自己输入了，没想到后面还是找到了方法。我不会告诉你我要一个这样的日期是为了写这篇博客的时候能方便地填写编辑时间……效果这是我们平时输入日期和时间的方法和效果：这是通过阅读本文可以达到的效果：方法Windows 10：设置→时间和语言→区域和语言→中文(中华人民共和国)→选项→微软拼音→选项→词库和自学习→添加新的或编辑现有的用户自定义短语→添加。（不想吐槽为什么藏得这么深……）然后在短语里面输入以下代码：%yyyy%-%MM%-%dd% %HH%:%mm%:%ss% +0800一些基本的格式化字符串是： 变量 含义 yyyy 4 位年 MM 2 位月 dd 2 位日 HH 2 位小时（24 小时制） mm 2 位分钟数 ss 2 位秒数 更多格式化变量请参考：Custom Date and Time Format Strings重要的说明 需要注意，你只能在添加的时候这么写！ 需要注意，你只能在添加的时候这么写！ 需要注意，你只能在添加的时候这么写！如果是添加后再编辑，你会发现日期已经变成你点击“编辑”那一刻的时间固定下来了，你必须再把上面的代码敲一遍保存才行！如果你找不到设置到底在哪里，下面是附图" }, { "title": "在 Visual Studio 中使用 EditorConfig 统一代码风格（含原生与插件）", "url": "/post/editor-config-for-visual-studio.html", "categories": "", "tags": "visualstudio, csharp, dotnet", "date": "2018-12-14 09:54:00 +0800", "snippet": "EditorConfig 是一种被各种编辑器广泛支持的配置，使用此配置有助于项目在整个团队中保持一致的代码风格。Visual Studio 2017 开始原生支持 EditorConfig。本文将介绍 Visual Studio 对 EditorConfig 的支持情况（含原生与插件），并给出符合 .NET 和 C# 约定的 EditorConfig 详细设置。EditorConfig 的广泛支持在 EditorConfig 官网中，贴出了一些可以纯原生无需任何插件支持 EditorConfig 代码风格配置的编辑器：▲ 原生支持 EditorConfig 的编辑器然后还贴出了可以通过插件支持的编辑器：▲ 可以通过插件支持 EditorConfig 的编辑器EditorConfig 本身只定义了一个核心集，表示所有语言都共同遵循的代码格式规范：EditorConfig 属性的核心集。同时，还有一些其他定义的规范：EditorConfig 的完整属性，不过这里不包括语言特定的规范。Visual Studio 对 EditorConfig 的支持程度Visual Studio 2017 开始添加了对 EditorConfig 的原生支持（你当然能在上面看到 Visual Studio 的图标啦）。原生的 Visual Studio 2017 支持 EditorConfig 属性的核心集和一些语言的特定属性。具体来说，是这一些： 核心属性 indent_style indent_size tab_width end_of_line charset trim_trailing_whitespace insert_final_newline root 语言特定属性 所有 Visual Studio 支持的语言（XML 除外）均支持 EditorConfig 编辑器设置。 此外，EditorConfig 还支持适用于 C# 和 Visual Basic 的代码样式约定和命名约定。 也就是说，当你的项目中存在 EditorConfig 的配置文件 .editorconfig 的时候，Visual Studio 就会应用 EditorConfig 的设置，而且可以适用于多数情况下的编程约定。Visual Studio 中 .NET 相关语言（C# VB）的 EditorConfig 属性，可以参考 .NET coding convention settings For EditorConfig。在 Visual Studio 中添加 EditorConfig 配置Visual Studio 支持 EditorConfig 对编程规范的约束。对于多数开发者来说，不需要安装任何插件的情况下这个编程规范的约束就会生效。不过，还是需要有一些小伙伴进行编程规范的设置。设置规范可以使用很多个插件，比如 EditorConfig Language Service 和 Visual Studio IntelliCode。当然，前者会更加专业，后者只是因为需要使用到 EditorConfig 的配置，顺便带上了 EditorConfig 的编辑体验。安装了 EditorConfig Language Service 插件之后，在解决方案上右键，添加 .editorconfig 文件。▲ 添加 .editorconfig 文件当然，也许你会发现在我的图中，两个插件都能生成 .editorconfig 文件。EditorConfig Language Service 生成的 .editorconfig 文件是空的，而 IntelliCode 一经添加便提供了丰富的 C# 语言约定的属性设置。不过，IntelliCode 提供的设置多少取决于你目前解决方案中的项目类型，这些属性是从 这里 推断的。如果你使用 EditorConfig Language Service 生成了 .editorconfig 文件，则可以继续点击小灯泡生成按照微软约定的编程规范：▲ 生成规范在 Visual Studio 中开启 EditorConfig 支持实际上，Visual Studio 一旦检测到 .editorconfig 文件的存在，格式约定就会自动生效。在 ReSharper 中开启 EditorConfig 支持一样的，ReSharper 默认是开启了 EditorConfig 配置的检测的，也就是说只要存在 .editorconfig 文件，那么 EditorConfig 也会在 ReSharper 的格式化中生效。ReSharper 对于 EditorConfig 的支持情况可以参考：Using EditorConfig - Help - ReSharper。效果体验我们来看一段风格十分混乱不忍直视的代码：using System;using System.Threading.Tasks;namespace Walterlv.Demo{ public static class Program { [STAThread] private static int Main(string[] args) { var logger = (ILogger) new Logger(); var logger2 = (ILogger)new Logger(); var managerTask = Task.Run( () =&amp;gt; { var manager = new Manager(logger); manager.Run(); return manager; }); var app = new App(managerTask) { }; app.InitializeComponent(); app.Run(); return 0; } }}无论你是使用什么方式，最终都能格式化成下面这样： 你可以直接输入，在遇到 } 和 ; 的时候就会格式化 你可以 Ctrl+V 粘贴，粘贴后直接就是格式化后的代码 你可以按下 Ctrl+Alt+Enter（ReSharper），这样整份文档就会格式化 你可以按下 Ctrl+K, D（Visual Studio 的 Cleanup），这样也能格式化using System;using System.Threading.Tasks;namespace Walterlv.Demo{ public static class Program { [STAThread] private static int Main(string[] args) { var logger = (ILogger)new Logger(); var logger2 = (ILogger)new Logger(); var managerTask = Task.Run(() =&amp;gt; { var manager = new Manager(logger); manager.Run(); return manager; }); var app = new App(managerTask) { }; app.InitializeComponent(); app.Run(); return 0; } }}附 EditorConfig Language Service 生成的属性集[*]end_of_line = crlfcharset = utf-8-bomindent_size = 4insert_final_newline = truetab_width = 4trim_trailing_whitespace = true[*.xml]indent_style = space[*.{cs,vb}]dotnet_sort_system_directives_first = truedotnet_style_coalesce_expression = true:suggestiondotnet_style_collection_initializer = true:suggestiondotnet_style_explicit_tuple_names = true:suggestiondotnet_style_null_propagation = true:suggestiondotnet_style_object_initializer = true:suggestiondotnet_style_parentheses_in_arithmetic_binary_operators = always_for_clarity:silentdotnet_style_parentheses_in_other_binary_operators = always_for_clarity:silentdotnet_style_parentheses_in_other_operators = never_if_unnecessary:silentdotnet_style_parentheses_in_relational_binary_operators = always_for_clarity:silentdotnet_style_predefined_type_for_locals_parameters_members = true:silentdotnet_style_predefined_type_for_member_access = true:silentdotnet_style_prefer_auto_properties = true:silentdotnet_style_prefer_conditional_expression_over_assignment = truedotnet_style_prefer_conditional_expression_over_return = truedotnet_style_prefer_inferred_anonymous_type_member_names = true:suggestiondotnet_style_prefer_inferred_tuple_names = true:suggestiondotnet_style_prefer_is_null_check_over_reference_equality_method = true:silentdotnet_style_qualification_for_event = false:silentdotnet_style_qualification_for_field = false:silentdotnet_style_qualification_for_method = false:silentdotnet_style_qualification_for_property = false:silentdotnet_style_readonly_field = true:suggestiondotnet_style_require_accessibility_modifiers = for_non_interface_members:silent[*.cs]csharp_indent_case_contents = truecsharp_indent_labels = flush_leftcsharp_indent_switch_labels = truecsharp_new_line_before_catch = truecsharp_new_line_before_else = truecsharp_new_line_before_finally = truecsharp_new_line_before_members_in_anonymous_types = truecsharp_new_line_before_members_in_object_initializers = truecsharp_new_line_before_open_brace = allcsharp_new_line_between_query_expression_clauses = truecsharp_preferred_modifier_order = public,private,protected,internal,static,extern,new,virtual,abstract,sealed,override,readonly,unsafe,volatile,async:suggestioncsharp_prefer_braces = true:silentcsharp_prefer_simple_default_expression = true:suggestioncsharp_preserve_single_line_blocks = truecsharp_preserve_single_line_statements = truecsharp_space_after_cast = falsecsharp_space_after_colon_in_inheritance_clause = truecsharp_space_after_keywords_in_control_flow_statements = truecsharp_space_around_binary_operators = before_and_aftercsharp_space_before_colon_in_inheritance_clause = truecsharp_space_between_method_call_empty_parameter_list_parentheses = falsecsharp_space_between_method_call_name_and_opening_parenthesis = falsecsharp_space_between_method_call_parameter_list_parentheses = falsecsharp_space_between_method_declaration_empty_parameter_list_parentheses = falsecsharp_space_between_method_declaration_parameter_list_parentheses = falsecsharp_space_between_parentheses = falsecsharp_style_conditional_delegate_call = true:suggestioncsharp_style_deconstructed_variable_declaration = true:suggestioncsharp_style_expression_bodied_accessors = true:silentcsharp_style_expression_bodied_constructors = false:silentcsharp_style_expression_bodied_indexers = true:silentcsharp_style_expression_bodied_methods = false:silentcsharp_style_expression_bodied_operators = false:silentcsharp_style_expression_bodied_properties = true:silentcsharp_style_inlined_variable_declaration = true:suggestioncsharp_style_pattern_local_over_anonymous_function = true:suggestioncsharp_style_pattern_matching_over_as_with_null_check = true:suggestioncsharp_style_pattern_matching_over_is_with_cast_check = true:suggestioncsharp_style_throw_expression = true:suggestioncsharp_style_var_elsewhere = true:silentcsharp_style_var_for_built_in_types = true:silentcsharp_style_var_when_type_is_apparent = true:silent[*.vb]visual_basic_preferred_modifier_order = Partial,Default,Private,Protected,Public,Friend,NotOverridable,Overridable,MustOverride,Overloads,Overrides,MustInherit,NotInheritable,Static,Shared,Shadows,ReadOnly,WriteOnly,Dim,Const,WithEvents,Widening,Narrowing,Custom,Async:suggestion:suggestion附 IntelliCode 生成的属性集# Rules in this file were initially inferred by Visual Studio IntelliCode from the C:\\Users\\lvyi\\Walterlv.Demo codebase based on best match to current usage at 2018/11/20# You can modify the rules from these initially generated values to suit your own policies# You can learn more about editorconfig here: https://docs.microsoft.com/en-us/visualstudio/ide/editorconfig-code-style-settings-reference[*.cs]#Core editorconfig formatting - indentation#use soft tabs (spaces) for indentationindent_style = space#Formatting - indentation options#indent switch case contents.csharp_indent_case_contents = true#csharp_indent_case_contents_when_blockcsharp_indent_case_contents_when_block = false#indent switch labelscsharp_indent_switch_labels = true#Formatting - new line options#place catch statements on a new linecsharp_new_line_before_catch = true#place else statements on a new linecsharp_new_line_before_else = true#require finally statements to be on a new line after the closing bracecsharp_new_line_before_finally = true#require braces to be on a new line for methods, accessors, control_blocks, lambdas, properties, and types (also known as &quot;Allman&quot; style)csharp_new_line_before_open_brace = methods, accessors, control_blocks, lambdas, properties, types#Formatting - organize using options#sort System.* using directives alphabetically, and place them before other usingsdotnet_sort_system_directives_first = true#Formatting - spacing options#require a space before the colon for bases or interfaces in a type declarationcsharp_space_after_colon_in_inheritance_clause = true#require a space after a keyword in a control flow statement such as a for loopcsharp_space_after_keywords_in_control_flow_statements = true#require a space before the colon for bases or interfaces in a type declarationcsharp_space_before_colon_in_inheritance_clause = true#remove space within empty argument list parenthesescsharp_space_between_method_call_empty_parameter_list_parentheses = false#remove space between method call name and opening parenthesiscsharp_space_between_method_call_name_and_opening_parenthesis = false#do not place space characters after the opening parenthesis and before the closing parenthesis of a method callcsharp_space_between_method_call_parameter_list_parentheses = false#remove space within empty parameter list parentheses for a method declarationcsharp_space_between_method_declaration_empty_parameter_list_parentheses = false#place a space character after the opening parenthesis and before the closing parenthesis of a method declaration parameter list.csharp_space_between_method_declaration_parameter_list_parentheses = false#Formatting - wrapping options#leave code block on single linecsharp_preserve_single_line_blocks = true#leave statements and member declarations on the same linecsharp_preserve_single_line_statements = true#Style - expression bodied member options#prefer block bodies for accessorscsharp_style_expression_bodied_accessors = false:suggestion#prefer block bodies for constructorscsharp_style_expression_bodied_constructors = false:suggestion#prefer block bodies for indexerscsharp_style_expression_bodied_indexers = false:suggestion#prefer block bodies for methodscsharp_style_expression_bodied_methods = false:suggestion#prefer block bodies for propertiescsharp_style_expression_bodied_properties = false:suggestion#Style - expression level options#prefer out variables to be declared before the method callcsharp_style_inlined_variable_declaration = false:suggestion#prefer the language keyword for member access expressions, instead of the type name, for types that have a keyword to represent themdotnet_style_predefined_type_for_member_access = true:suggestion#Style - implicit and explicit types#prefer var is used to declare variables with built-in system types such as intcsharp_style_var_for_built_in_types = true:suggestion#prefer var when the type is already mentioned on the right-hand side of a declaration expressioncsharp_style_var_when_type_is_apparent = true:suggestion#Style - language keyword and framework type options#prefer the language keyword for local variables, method parameters, and class members, instead of the type name, for types that have a keyword to represent themdotnet_style_predefined_type_for_locals_parameters_members = true:suggestion#Style - qualification options#prefer events not to be prefaced with this. or Me. in Visual Basicdotnet_style_qualification_for_event = false:suggestion#prefer fields not to be prefaced with this. or Me. in Visual Basicdotnet_style_qualification_for_field = false:suggestion#prefer methods not to be prefaced with this. or Me. in Visual Basicdotnet_style_qualification_for_method = false:suggestion#prefer properties not to be prefaced with this. or Me. in Visual Basicdotnet_style_qualification_for_property = false:suggestion参考资料 Using EditorConfig settings in Visual Studio - Visual Studio - Microsoft Docs .NET coding convention settings For EditorConfig - Visual Studio - Microsoft Docs" }, { "title": "使用 Windows 10 中的加速度计（Accelerometer，重力传感器）", "url": "/post/uwp-accelerometer.html", "categories": "", "tags": "uwp", "date": "2018-12-14 09:54:00 +0800", "snippet": "在做 UWP 应用开发的时候还有什么理由可以用到加速度计呢？场景很多啦，比如做游戏，做类似 Surface Hub 那种一边旋转，一边所有内容跟着一起转的效果。Windows 10 UWP 中的加速度计使用非常简单，只需要简单几句代码即可。重力迷宫游戏这里有一个利用加速度计的好玩的例子：▲ 用 Lumia 950XL 玩重力迷宫画质太渣了？确实太渣了。那就看看桌面版吧…… 反正是 UWP，两边看起来是一样的。▲ 重力迷宫桌面版画面（高清版）初始化 AccelerometerAccelerometer 在 Windows.Devices.Sensors 命名空间下，使用时需要在类顶部加上 using。using Windows.Devices.Sensors;而获得加速度计的实例只需要一句话：_accelerometer = Accelerometer.GetDefault();如果设备上没有加速度计，那么这里拿到的实例就会是 null。所以注意需要进行 null 判断，毕竟大部分 Windows 10 设备都是普通电脑，没有加速度计的。现在，我们对加速度计进行一些简单的初始化：_accelerometer = Accelerometer.GetDefault();if (_accelerometer != null){ // 设置加速度计读数的报告间隔。这里我们与 16ms 进行判断，如果小于 16ms 就设为 16ms。 // 因为我们在做游戏，帧数就是 60Hz，也就是说，我们不需要更高的读数间隔。 uint minReportInterval = _accelerometer.MinimumReportInterval; uint reportInterval = minReportInterval &amp;gt; 16 ? minReportInterval : 16; _accelerometer.ReportInterval = reportInterval; // 监听 ReadingChanged 事件，以便在加速度计读数改变时做一些操作。 _accelerometer.ReadingChanged += Accelerometer_ReadingChanged;}得到 Accelerometer 的读数在监听事件的 Accelerometer_ReadingChanged 事件中，我们可以得到加速度计的读数。private float _xAxis;private float _yAxis;private float _zAxis;private void Accelerometer_ReadingChanged(Accelerometer sender, AccelerometerReadingChangedEventArgs e){ AccelerometerReading reading = e.Reading; _xAxis = (float) reading.AccelerationX; _yAxis = (float) reading.AccelerationY; _zAxis = (float) reading.AccelerationZ;}这些读数是 -1 到 1 之间的数值。将 Accelerometer 的读数转化成倾斜角度在 Win2D 中的游戏循环：CanvasAnimatedControl 一文中，我在 PC 上玩这款游戏，也是在模拟桌子的倾角。于是我们也需要将读数转化成 Windows 10 设备的倾斜角度。private (float xAngle, float yAngle) GetTiltAngles(){ if (_accelerometer != null) { // 从加速度计中读取读数，然后转换成设备倾斜角度。 return ((float) (-_yAxis * Math.PI / 2), (float) (-_xAxis * Math.PI / 2)); } else { // 如果没有加速度计，则从键盘获得模拟的倾斜角度。 return GetTiltAnglesByKeyboard(); }}这里的 _xAxis 和 _yAxis 就是前面在 Accelerometer_ReadingChanged 事件中获得的读数数值。这里计算所得的角度值是下面图片中所指示的角度值。▲ X 方向数值▲ Y 方向数值参考资料 Use the accelerometer - UWP app developer - Microsoft Docs" }, { "title": ".NET/C# 在代码中测量代码执行耗时的建议（比较系统性能计数器和系统时间）", "url": "/post/dotnet-high-precision-performance-counting.html", "categories": "", "tags": "dotnet, csharp", "date": "2018-12-14 09:54:00 +0800", "snippet": "我们有很多种方法评估一个方法的执行耗时，比如使用性能分析工具，使用基准性能测试。不过传统的在代码中编写计时的方式依然有效，因为它可以生产环境或用户端得到真实环境下的执行耗时。如果你希望在 .NET/C# 代码中编写计时，那么阅读本文可以获得一些建议。阅读本文也可以了解到 QueryPerformanceCounter、Get­System­Time­As­File­Time 等方法的差异。基本的计时计时一般采用下面这种方式，在方法执行之前获取一次时间，在方法结束之后再取得一次时间。// 在方法开始之前。Foo();// 在方法执行之后。这样，前后两次获取的时间差即为方法 Foo 的执行耗时。这里我不会提到性能测试工具或者基准性能测试这些方法，因为这些测试代码不会运行于用户端。你可以阅读以下博客获得这两者的使用： C# 标准性能测试 - 林德熙 C# 标准性能测试高级用法 - 林德熙 .NET/C# 反射的的性能数据，以及高性能开发建议（反射获取 Attribute 和反射调用方法） - 吕毅结论：使用什么方法计时先说结论：System.Diagnostics 命名空间下有一个 Stopwatch 类。如果你要为你方法的执行时间进行统计，那么就使用这个类。Stopwatch 类有一些静态属性、也有一些实例方法和实例属性。此类型的时间统计是按照高性能和高精度的要求来做的，于是你可以用它获得高精度的计时效果。不过，如果你对性能要求近乎苛刻，例如你的方法会被数百万次或更高频地执行，那么就需要开始斟酌如何调用里面的属性了。简单的使用如下面这样：var watch = Stopwatch.StartNew();Foo();watch.Stop();var elapsed = watch.Elapsed;当然，你也可以直接使用 Stopwatch 的构造函数，new 出来之后再 Start，不过 StartNew 静态方法可以将两句合并为一句。各种计时 API 及其比较计时还有很多的方法，你可以针对不同需求场景使用不同的方法。不过，如果你根本没有了解过其他方法的话，那么建议直接使用上面的 Stopwatch，不要想太多。现在，我们看看 Windows 下的计时还有哪些 API： 基于 QPC 的高精度 API Query­Performance­Counter Query­Performance­Frequency 基于系统时间的非高精度 API Get­Tick­Count, Get­Tick­Count64 Get­Message­Time Get­System­Time, Get­Local­Time, Get­System­Time­As­File­Time Query­Interrupt­Time, Query­Unbiased­Interrupt­Time 基于 QPC 和系统时间的 API Get­System­Time­Precise­As­File­Time Query­Interrupt­Time­Precise, Query­Unbiased­Interrupt­Time­Precise 基于系统性能计数器（QPC）的 APIQueryPerformanceCounter，微软文档中把它称之为 QPC。一般情况下使用的 QueryPerformanceCounter，内核驱动开发者使用的 KeQueryPerformanceCounter 和 .NET 开发者使用的 System.Diagnostics.Stopwatch 都是基于 QPC 的 API。QPC 是通过计算机上独立运行的高精度硬件计时模块来获得时间戳的。这意味着，使用此 API 获得的时间戳是本机时间戳，不包含任何时区等信息。由于 QPC 的高精度特性，所以非常适合在单个设备上测量一个小段时间的时间间隔。而这也符合我们本文一开始说到的方法执行耗时测量需求。QueryPerformanceCounter 得到的值是 Ticks，单位是 100 ns。1 tick = 100 ns1 us = 1000 ns1 ms = 1000 us1 s = 1000 ms基于系统时间的 API如果你的需求不止是测量获取一个时间间隔，而是需要一个长期保存的时间，或者需要将时间与其他设备进行通信，那么基于单台设备的 QPC 就不符合要求了。GetSystemTimeAsFileTime 可以用来获取系统时钟时间。这个时间就是基于系统时钟的，所以如果你的时间戳是用来通信的，那么就很有用。当然，如果要在设备之间进行与时间信息相关的同步，还可能需要使用 NTP（Network Time Protocol）先同步时间。DateTime.Now 获取时间的方法就是这个：[MethodImplAttribute(MethodImplOptions.InternalCall)]internal static extern long GetSystemTimeAsFileTime();这里有一些比较有趣的说法，基于系统时间的 API 也会说成是获取高精度时间，那么跟 QPC 有什么不同呢？这里我只能拿英文来说话了。来自微软的 Raymond Chen 在它的 The Old New Thing 一书中说，基于系统时间的 API 获取的时间戳精度用的是 “所谓的 Precise”，但实际上应该称之为 “Accurate”，而 QPC 才能称之为实质上的 “Precise”。纠结起来就是 QPC 比基于系统时间的 API 得到的时间戳精度更高。基于 QPC 和系统时间的 APIGet­System­Time­Precise­As­File­Time 这些 API 既可以获得 QPC 的高精度，又与系统时钟相关，于是你可以使用这些 API 同时获得以上测量的好处。当然，这以性能成本为代价的。参考资料 Acquiring high-resolution time stamps - Microsoft Docs How accurate are the various Windows time-querying functions? – The Old New Thing windows平台时间函数性能比较QueryPerformanceCounter，GetTickCount，ftime，time,GetLocalTime，GetSystemTimeAsFileTime - 小 楼 一 夜 听 春 雨 - 博客园 c# - Is DateTime.Now the best way to measure a function’s performance? - Stack Overflow c# - How do I measure how long a function is running? - Stack Overflow c# - Calculate the execution time of a method - Stack Overflow Stopwatch.IsHighResolution Field (System.Diagnostics) - Microsoft Docs Stopwatch.cs timespan.cs" }, { "title": ".NET/C# 反射的的性能数据，以及高性能开发建议（反射获取 Attribute 和反射调用方法）", "url": "/post/dotnet-high-performance-reflection-suggestions.html", "categories": "", "tags": "dotnet, csharp", "date": "2018-12-14 09:54:00 +0800", "snippet": "大家都说反射耗性能，但是到底有多耗性能，哪些反射方法更耗性能；这些问题却没有统一的描述。本文将用数据说明反射各个方法和替代方法的性能差异，并提供一些反射代码的编写建议。为了解决反射的性能问题，你可以遵循本文采用的各种方案。反射各方法的性能数据我使用 BenchmarkDotNet 基准性能测试来评估反射各个方法的性能。测试的程序基于 .NET Core 2.1 开发。先直观地贴出我的运行结果：▲ 各反射不同方法的运行基准测试结果我把上面的表格复制下来成为文字，这样你也可以拿走我的这部分数据： Method Mean Error StdDev Median Assembly 13.5315 ns 0.3004 ns 0.4764 ns 13.4878 ns Attributes 7.0893 ns 0.1248 ns 0.1168 ns 7.0982 ns CustomAttributes 1,489.1654 ns 29.4428 ns 27.5408 ns 1,482.5038 ns GetCustomAttributesData 1,514.5503 ns 29.6863 ns 39.6303 ns 1,507.2949 ns GetCustomAttributes 1,171.8969 ns 22.5305 ns 27.6695 ns 1,167.2777 ns GetCustomAttribute 1,139.8609 ns 22.8043 ns 24.4003 ns 1,140.5437 ns GetCustomAttribute_Generic 1,115.0049 ns 13.1929 ns 11.6952 ns 1,111.4426 ns GetCustomAttributes_Generic 1,164.5132 ns 22.7775 ns 24.3716 ns 1,165.2747 ns New 0.0003 ns 0.0013 ns 0.0012 ns 0.0000 ns Lambda 0.0063 ns 0.0149 ns 0.0139 ns 0.0000 ns Activator_CreateInstance 48.8633 ns 0.6300 ns 0.5893 ns 48.8906 ns Activator_CreateInstance_Generic 47.7029 ns 0.9649 ns 1.0724 ns 47.5851 ns Expression_New 75,634.4035 ns 1,467.3285 ns 1,372.5400 ns 75,413.2837 ns CachedExpression_New 7.8923 ns 0.1988 ns 0.4105 ns 7.7004 ns 如果你希望了解以上每一项的意思，可以通过阅读本文文末的代码来了解其实现。基本上名称就代表着反射调用相同的方法。你一定会说这张表不容易看出性能差距。那么我一定会放图：那个 Expression_New 在图中独树一帜，远远把其他方法甩在了后面。那是个什么方法？那是在使用 Expression 表达式创建一个类型的新实例：var @new = Expression.New(typeof(ReflectionTarget));var lambda = Expression.Lambda&amp;lt;Func&amp;lt;ReflectionTarget&amp;gt;&amp;gt;(@new).Compile();var instance = lambda.Invoke();也就是说，如果你只是希望创建一个类型的新实例，就不要考虑使用 Expression.New 的方式了。除非此方法将执行非常多次，而你把那个 lambda 表达式缓存下来了。这对应着图表中的 CachedExpression_New。其他的现在都看不出来性能差异，于是我们把耗时最长的 Expression_New 一项去掉：我们立刻可以从图中得到第二梯队的性能巨头 —— 就是 CustomAttributes 系列。我使用了多种不同的 CustomAttribute 获取方法，得到的结果差异不大，都“比较耗时”。不过在这些耗时的方法里面找到不那么耗时的，就是 Type 的扩展方法系列 GetCustomAttribute 了，比原生非扩展方法的性能稍好。不过其他的性能差异又被淹没了。于是我们把 CustomAttributes 系列也删掉：于是我们又得到了第三梯队的性能大头 —— Activator.CreateInstance 系列。而是否调用泛型方法的耗时差异不大。然后，我们把 Activator.CreateInstance 也干掉，可以得到剩下其他的性能消耗。也就是说，只是获取 Type 中的一些属性，例如 Assembly 和 Attributes 也是比较“耗时”的；当然，这是纳秒级别，你可以将它忽略。要不要试试把第四梯队的也干掉呢？于是你可以得到 new 和 Lambda 的差异：原本在上面所有图中看起来都没有时间的 new 和 Lambda 竟然差异如此巨大；不过，这都是千分之一纳秒级别了；如果你创建的类数量不是百万级别以上，你还真的可以忽略。而 new 指的是 new Foo()，Lambda 指的是 var func = () =&amp;gt; new Foo(); func();。对于 GetCustomAttribute，还有另一个方法值得注意：IsDefined；可以用来判断是否定义了某个特定的 Attribute。var isDefined = _targetType.IsDefined(typeof(ReflectionTargetAttribute), false);if (isDefined){ var attribute = _targetType.GetCustomAttribute&amp;lt;ReflectionTargetAttribute&amp;gt;();}而这个方法与 GetCustomAttribute 的性能差距也有些大： Method Mean Error StdDev Ratio RatioSD IsDefined 653.8 ns 13.07 ns 16.53 ns 1.00 0.00 GetCustomAttribute 1,149.6 ns 22.97 ns 22.56 ns 1.76 0.06 GetGenericCustomAttribute 1,216.5 ns 24.15 ns 54.51 ns 1.81 0.07 咋看之下似乎与 GetCustomAttribute 方法重复，而且如果先判断再获取，可能总时间更长。不过这种方法就是适用于一次性对大量类型进行判断，如果只有少量类型定义了某种 Attribute，那么提前使用 IsDefined 判断可以获得总体更加的性能。反射的高性能开发建议创建类型的实例如果你能访问到类型： 建议直接使用 new，性能最好。 如果不希望直接 new 出来，可以考虑使用 Func 或者 Lazy 创建。这时会多消耗一些性能，不过基数小，增量不大。如果你不能访问到类型： 如果只能从 Type 创建，则使用 Activator.CreateInstance 系列。 如果你使用其他方式创建，请一定使用缓存。除了使用 Expression 创建，你还可以使用 Emit 创建，不过这也要求能够访问到类型： 使用 Emit 生成 IL 代码 - 吕毅对于缓存，可以参考： .NET Core/Framework 创建委托以大幅度提高反射调用的性能 - 吕毅 .NET/C# 推荐一个我设计的缓存类型（适合缓存反射等耗性能的操作，附用法） - 吕毅对于创建对象更多的性能数据，可以参考： C# 直接创建多个类和使用反射创建类的性能 - 林德熙 C# 性能分析 反射 VS 配置文件 VS 预编译 - 林德熙反射获取 Attribute获取 Attribute 也是耗时的操作。 如果你只是获取极少数类型的 Attribute，建议直接调用 GetCustomAttribute 扩展方法。 如果你需要判断大量类型的 Attribute，建议先使用 IsDefined 判断是否存在，如果存在才使用 GetCustomAttribute 方法获取真实实例。反射调用公共 / 私有方法反射调用方法与构造方法几乎是一样的，不同之处就在于公共方法可以创建出委托缓存，而私有方法却不行。有了委托缓存，你只有第一次才需要真的调用反射，后续可以使用缓存的委托或 Lambda 表达式；而私有方法是无法创建的，你每次都需要通过反射来调用相关方法。关于私有方法的反射： C# 使用反射获取私有属性的方法 C# 反射调用私有事件关于缓存： .NET Core/Framework 创建委托以大幅度提高反射调用的性能 - 吕毅 .NET/C# 推荐一个我设计的缓存类型（适合缓存反射等耗性能的操作，附用法） - 吕毅使用预编译框架使用预编译框架，你可以在编译期间将那些耗时的反射操作编译成类似 new 和属性 get 这样的简单 CLR 调用，性能差距近乎于最开始图表中第二张图和第五张图那样，具有数千倍的差距。 课程 预编译框架，开发高性能应用 - 微软技术暨生态大会 2018 - walterlv dotnet-campus/SourceFusion: SourceFusion is a pre-compile framework based on Roslyn. It helps you to build high-performance .NET code.附本文性能测试所用的代码本文性能测试使用 BenchmarkDotNet，在 Main 函数中调用以下代码跑起来：BenchmarkRunner.Run&amp;lt;Reflections&amp;gt;();你可以阅读 C# 标准性能测试 - 林德熙 了解基准性能测试的基本用法，在 C# 标准性能测试高级用法 - 林德熙 中了解到更多基准测试方法的使用。所有反射相关方法using BenchmarkDotNet.Attributes;using System;using System.Linq;using System.Linq.Expressions;using System.Reflection;namespace Walterlv.Demo.Reflection{ public class Reflections { private static readonly Type _targetType = typeof(ReflectionTarget); private static Func&amp;lt;ReflectionTarget&amp;gt; _cachedExpressionFunc; private static Func&amp;lt;ReflectionTarget&amp;gt; CachedExpressionFunc { get { if (_cachedExpressionFunc == null) { var @new = Expression.New(typeof(ReflectionTarget)); var lambda = Expression.Lambda&amp;lt;Func&amp;lt;ReflectionTarget&amp;gt;&amp;gt;(@new).Compile(); _cachedExpressionFunc = lambda; } return _cachedExpressionFunc; } } [Benchmark] public void Assembly() { var assembly = _targetType.Assembly; } [Benchmark] public void Attributes() { var attributes = _targetType.Attributes; } [Benchmark] public void CustomAttributes() { var attribute = _targetType.CustomAttributes.FirstOrDefault( x =&amp;gt; x.AttributeType == typeof(ReflectionTargetAttribute)); } [Benchmark] public void GetCustomAttributesData() { var attribute = _targetType.GetCustomAttributesData().FirstOrDefault( x =&amp;gt; x.AttributeType == typeof(ReflectionTargetAttribute)); } [Benchmark] public void GetCustomAttributes() { var attribute = _targetType.GetCustomAttributes(typeof(ReflectionTargetAttribute), false).FirstOrDefault(); } [Benchmark] public void GetCustomAttribute() { var attribute = _targetType.GetCustomAttribute(typeof(ReflectionTargetAttribute), false); } [Benchmark] public void GetCustomAttribute_Generic() { var attribute = _targetType.GetCustomAttribute&amp;lt;ReflectionTargetAttribute&amp;gt;(false); } [Benchmark] public void GetCustomAttributes_Generic() { var attribute = _targetType.GetCustomAttributes&amp;lt;ReflectionTargetAttribute&amp;gt;(false); } [Benchmark] public void New() { var instance = new ReflectionTarget(); } [Benchmark] public void Lambda() { var instance = new ReflectionTarget(); } [Benchmark] public void Activator_CreateInstance() { var instance = (ReflectionTarget) Activator.CreateInstance(_targetType); } [Benchmark] public void Activator_CreateInstance_Generic() { var instance = Activator.CreateInstance&amp;lt;ReflectionTarget&amp;gt;(); } [Benchmark] public void Expression_New() { var @new = Expression.New(typeof(ReflectionTarget)); var lambda = Expression.Lambda&amp;lt;Func&amp;lt;ReflectionTarget&amp;gt;&amp;gt;(@new).Compile(); var instance = lambda.Invoke(); } [Benchmark] public void CachedExpression_New() { var instance = CachedExpressionFunc.Invoke(); } }}IsDefined 和 GetCustomAttribute 的专项比较using System;using System.Reflection;using BenchmarkDotNet.Attributes;namespace Walterlv.Demo.Reflection{ public class IsDefinedVsGetCustomAttribute { private static readonly Type _targetType = typeof(ReflectionTarget); [Benchmark(Baseline = true)] public void IsDefined() { var isDefined = _targetType.IsDefined(typeof(ReflectionTargetAttribute), false); } [Benchmark] public void GetCustomAttribute() { var attribute = _targetType.GetCustomAttribute(typeof(ReflectionTargetAttribute), false); } [Benchmark] public void GetGenericCustomAttribute() { var attribute = _targetType.GetCustomAttribute&amp;lt;ReflectionTargetAttribute&amp;gt;(false); } }}参考资料 c# - Is there a benefit of using IsDefined over GetCustomAttributes - Stack Overflow Accessing Attributes by Using Reflection (C#) - Microsoft Docs win10 uwp 反射 Reference Source A Super-Fast C# Extension Method using Expression Trees to Create an instance from a Type Retrieving Custom Attributes Using Reflection - Scott Dorman Showtime - BenchmarkDotNet Choosing RunStrategy - BenchmarkDotNet" }, { "title": ".NET/C# 异常处理：写一个空的 try 块代码，而把重要代码写到 finally 中（Constrained Execution Regions）", "url": "/post/empty-try-block.html", "categories": "", "tags": "dotnet, csharp", "date": "2018-12-14 09:54:00 +0800", "snippet": "不知你是否见过 try { } finally { } 代码中，try 块留空，而只往 finally 中写代码的情况呢？这种写法有其特殊的目的。本文就来说说这种不一样的写法。空的 try 块你可以点开这个链接查看 Exception 类，在里面你可以看到一段异常处理的代码非常奇怪：// 代码已经过简化。internal void RestoreExceptionDispatchInfo(ExceptionDispatchInfo exceptionDispatchInfo){ // 省略代码。 try{} finally { // 省略代码。 } // 省略代码。}神奇之处就在于，其 try 块是空的，重要代码都放在 finally 中。那为什么会这么写呢？在代码注释中的解释为： We do this inside a finally clause to ensure ThreadAbort cannot be injected while we have taken the lock. This is to prevent unrelated exception restorations from getting blocked due to TAE.翻译过来是：在 finally 子句中执行此操作以确保在获取锁时无法注入 ThreadAbort。这是为了防止不相关的异常恢复因 TAE 而被阻止。也就是说，此方法是为了与 Thread.Abort 对抗，防止 Thread.Abort 中断此处代码的执行。 Thread.Abort 的执行交给 CLR 管理，finally 的执行也是交给 CLR 管理。CLR 确保 finally 块执行的时候不会被 Thread.Abort 阻止。代码在 .NET Core 和 .NET Framework 中的实现完全一样：// This is invoked by ExceptionDispatchInfo.Throw to restore the exception stack trace, corresponding to the original throw of the// exception, just before the exception is &quot;rethrown&quot;.[SecuritySafeCritical]internal void RestoreExceptionDispatchInfo(System.Runtime.ExceptionServices.ExceptionDispatchInfo exceptionDispatchInfo){ bool fCanProcessException = !(IsImmutableAgileException(this)); // Restore only for non-preallocated exceptions if (fCanProcessException) { // Take a lock to ensure only one thread can restore the details // at a time against this exception object that could have // multiple ExceptionDispatchInfo instances associated with it. // // We do this inside a finally clause to ensure ThreadAbort cannot // be injected while we have taken the lock. This is to prevent // unrelated exception restorations from getting blocked due to TAE. try{} finally { // When restoring back the fields, we again create a copy and set reference to them // in the exception object. This will ensure that when this exception is thrown and these // fields are modified, then EDI&#39;s references remain intact. // // Since deep copying can throw on OOM, try to get the copies // outside the lock. object _stackTraceCopy = (exceptionDispatchInfo.BinaryStackTraceArray == null)?null:DeepCopyStackTrace(exceptionDispatchInfo.BinaryStackTraceArray); object _dynamicMethodsCopy = (exceptionDispatchInfo.DynamicMethodArray == null)?null:DeepCopyDynamicMethods(exceptionDispatchInfo.DynamicMethodArray); // Finally, restore the information. // // Since EDI can be created at various points during exception dispatch (e.g. at various frames on the stack) for the same exception instance, // they can have different data to be restored. Thus, to ensure atomicity of restoration from each EDI, perform the restore under a lock. lock(Exception.s_EDILock) { _watsonBuckets = exceptionDispatchInfo.WatsonBuckets; _ipForWatsonBuckets = exceptionDispatchInfo.IPForWatsonBuckets; _remoteStackTraceString = exceptionDispatchInfo.RemoteStackTrace; SaveStackTracesFromDeepCopy(this, _stackTraceCopy, _dynamicMethodsCopy); } _stackTraceString = null; // Marks the TES state to indicate we have restored foreign exception // dispatch information. Exception.PrepareForForeignExceptionRaise(); } }}你可以在 这里 查看 .NET Framework 版本，在这里 查看 .NET Core 的版本。受约束的执行区域（Constrained Execution Regions）这种现象在微软官方文档 可靠性最佳做法 中有介绍。 Doing so instructs the just-in-time compiler to prepare all the code in the finally block before running the try block. This guarantees that the code in the finally block is built and will run in all cases. It is not uncommon in a CER to have an empty try block. Using a CER protects against asynchronous thread aborts and out-of-memory exceptions. See ExecuteCodeWithGuaranteedCleanup for a form of a CER that additionally handles stack overflows for exceedingly deep code.使用 try-finally 形成一个受约束的执行区域，使得 finally 中的代码被可靠地执行。参考资料 可靠性最佳做法 - Microsoft Docs 受约束的执行区域 - Microsoft Docs exception.cs - Reference Source RestoreExceptionDispatchInfo The empty try block mystery - Some Creativity c# - Why use try {} finally {} with an empty try block? - Stack Overflow corefx/System.Runtime.cs at master · dotnet/corefx" }, { "title": "C# 重载条件逻辑运算符（&amp;&amp; 和 ||）", "url": "/post/overload-conditional-and-and-or-operators-in-csharp.html", "categories": "", "tags": "csharp", "date": "2018-12-14 09:54:00 +0800", "snippet": "在微软的官方文档中，规定 &amp;amp;&amp;amp; 和 || 运算符不可被重载，但允许通过重载 &amp;amp;、|、true 和 false 实现间接重载。本文将介绍重载方法和原理。感谢 Opportunity 的指导。条件逻辑运算符是可以重载的在微软的官方文档 true Operator (C# Reference) - Microsoft Docs 中，解释了 &amp;amp;&amp;amp; 和 || 这两个条件逻辑运算符的重载方法： A type cannot directly overload the Caseal logical operators (&amp;amp;&amp;amp; and ||), but an equivalent effect can be achieved by overloading the regular logical operators and operators true and false. 类型不能直接重载条件逻辑运算符（&amp;amp;&amp;amp; 和 ||），但通过重载常规逻辑运算符 &amp;amp;、| 及运算符 true 和 false 可以达到同样的效果。也就是说，在官方的概念中，&amp;amp;&amp;amp; 和 || 是允许被重载的，只是不能直接重载。原因在于，&amp;amp;&amp;amp; 和 || 是短路运算符（Circuit Operator），具有短路求值特性。具体来说，A &amp;amp;&amp;amp; B 运算中，如果 A 是 false，那么 B 的值便不会计算；同样的，A || B 中，如果 A 是 true，那么 B 的值也不会计算。于是，如果允许自定义 &amp;amp;&amp;amp; 和 || 运算符，那么必然会导致这个运算符重载的方法有两个参数传入，于是这两个参数一定会被计算值；这样就无法实现短路求值了。于是对于 &amp;amp;&amp;amp; 和 || 的重载采用的方案是重载 &amp;amp; 和 | 运算符，然后重载 true 和 false 运算符来指定短路求值。试错实验我们写一个类型进行实验：using System;namespace Walterlv.Demo{ public class Case { public static bool operator &amp;amp;(Case a, Case b) { throw new NotImplementedException(); } }}直接使用 &amp;amp; 是没有问题的，但如果使用 &amp;amp;&amp;amp; 就会提示错误。var a = new Case();var b = new Case();if (a &amp;amp;&amp;amp; b){} Error CS0217: In order to be applicable as a short circuit operator a user-defined logical operator (‘Case.operator &amp;amp;(Case, Case)’) must have the same return type and parameter types Error CS0217: 为了可以像短路运算符一样应用，用户定义的逻辑运算符(“Case.operator &amp;amp;(Case, Case)”)的返回类型和参数类型必须相同也就是说，本身重载 &amp;amp; 运算符的时候允许返回不同的类型；但如果希望 &amp;amp;&amp;amp; 运算符在此重载下也生效，就必须确保 &amp;amp; 的返回类型与参数中的类型相同。public static Case operator &amp;amp;(Case a, Case b){ throw new NotImplementedException();}var a = new Case();var b = new Case();var c = a &amp;amp;&amp;amp; b;改为相同的类型后，还会继续提示需要定义 true 和 false 运算符。 Error CS0218: In order for ‘Case.operator &amp;amp;(Case, Case)’ to be applicable as a short circuit operator, its declaring type ‘Case’ must define operator true and operator false重载 &amp;amp;&amp;amp; 和 ||以下代码中，true 表示字符串中包含大写字母，false 表示字符串中不包含大写字母（null 和没有大小写的区域也属于不包含大写字母）。&amp;amp; 运算符仅留下两者共有的字符；| 则取所有字符。public class Case{ private string _value; public Case(string value) { _value = value; } public static Case operator &amp;amp;(Case a, Case b) { if (a is null || b is null) return null; if (a._value is null || b._value is null) return new Case(null); return new Case(new string(b._value.Except(a._value.Except(b._value)).ToArray())); } public static Case operator |(Case a, Case b) =&amp;gt; new Case(a._value + b._value); public static bool operator true(Case a) =&amp;gt; a?._value != null &amp;amp;&amp;amp; !a._value.ToLower(CultureInfo.CurrentCulture).Equals(a._value); public static bool operator false(Case a) =&amp;gt; a?._value == null || a._value.ToLower(CultureInfo.CurrentCulture).Equals(a._value); public override string ToString() =&amp;gt; _value;}测试重载了条件逻辑运算符的类型我们测试以上代码所用的代码如下：var a = new Case(&quot;A&quot;);var b = new Case(&quot;b&quot;);Console.WriteLine(a);Console.WriteLine(b);Console.WriteLine(a ? &quot;a 是 truthy&quot; : &quot;a 是 falsy&quot;);Console.WriteLine(b ? &quot;b 是 truthy&quot; : &quot;b 是 falsy&quot;);Console.WriteLine(a &amp;amp; b);Console.WriteLine(a | b);Console.WriteLine(a &amp;amp;&amp;amp; b);Console.WriteLine(a || b);以上各个 Console.WriteLine 的输出为：[1] A[2] b[3] a 是 truthy[4] b 是 falsy[5] [6] Ab[7] [8] A注意，空行其实指的是输出 null。truthy 和 falsy刚刚的测试代码中，我们使用了 truthy 和 falsy 概念，而这是逻辑判断概念： 如果在逻辑判断中，对象与 true 等价，但其数值上并非 true（不等于 true），那么称此对象为 truthy； 如果在逻辑判断中，对象与 false 等价，但其数值上并非 false（不等于 false），那么称此对象为 falsy。对以上测试输出的解释第 5 行由于 a 和 b 没有共有字符，所以得到 null。第 7 行的执行过程是这样的： 对 a 求值，即 a 本身； 对 a 进行 truthy / falsy 逻辑判断，得到 truthy； 由于 a 为 truthy，对于 &amp;amp;&amp;amp; 运算符而言，可以对 b 求值，于是对 b 求值得到 b 本身； 对 a 和 b 进行 &amp;amp; 运算，得到 ` ，也就是 null`。第 8 行的执行过程是这样的： 对 a 求值，即 a 本身； 对 a 进行 truthy / falsy 逻辑判断，得到 truthy； 由于 a 为 truthy，对于 || 运算符而言，已无需对 b 求值，最终得到的结果为 a，也就是 A。参考资料 C# 中那些可以被重载的操作符 - walterlv - 请阅读文章末尾的评论 true Operator (C# Reference) - Microsoft Docs JavaScript: Truthy? Falsy? - 格物致知" }, { "title": "在 WPF 中使用 x:Reference", "url": "/post/wpf-x-reference.html", "categories": "", "tags": "dotnet, wpf", "date": "2018-12-14 09:54:00 +0800", "snippet": "x:Reference 是 XAML 2009 中引入的功能，也算是比较早的功能了；ElementName 是 XAML 一开始出现便开始有的功能。二者在使用时在感觉上是比较相似的，但多数情况下都更有优势。本文将解释 x:Reference。典型的使用 x:Reference 的例子是：&amp;lt;object property=&quot;{x:Reference instancexName}&quot; .../&amp;gt;其中，instancexName 是另一个用 x:Name 指定名称的元素。x:Reference 前面带了一个 x 命名空间前缀，所以可想而知这是与 x:Name 类似的 XAML 编译相关的标记。在微软官方文档中描述为： In WPF and XAML 2006, element references are addressed by the framework-level feature of ElementName binding. For most WPF applications and scenarios, ElementName binding should still be used. Exceptions to this general guidance might include cases where there are data context or other scoping considerations that make data binding impractical and where markup compilation is not involved.用中文来描述就是说：以前在 XAML 2006 的时候，使用 ElementName 在绑定中获得对应到元素的绑定源，而这能适用于大多数情况。不过，如果绑定上下文中拥有不同的命名边界，那么这时使用 ElementName 可能无法找到绑定源。这时可以使用 x:Reference 替代。你可以阅读 WPF 的 ElementName 在 ContextMenu 中无法绑定成功？试试使用 x:Reference！ - walterlv 了解 x:Reference 替代 ElementName 解决绑定中命名边界的问题。另外，ElementName 是在运行时通过查找可视化树或逻辑树来确定名称边界（NameScope）的，所以一定程度上性能也不那么好。参考资料 x:Reference Markup Extension - Microsoft Docs wpf - What is the difference between x:Reference and ElementName? - Stack Overflow binding - When is x:Reference in WPF resolved and why does XAML element order affect it? - Stack Overflow wpf – x：Reference和ElementName之间有什么区别？ - 代码日志" }, { "title": "UWP 轻量级样式定义（Lightweight Styling）", "url": "/post/uwp-lightweight-xaml-styling.html", "categories": "", "tags": "dotnet, csharp, uwp", "date": "2018-12-14 09:54:00 +0800", "snippet": "在 UWP 中，可以通过给控件直接设置属性或在 Style 中设置属性来定制控件的样式；不过这样的样式定义十分有限，比如按钮按下时的样式就没法儿设置。当然可以通过修改 Template 来设置控件的样式，然而 UWP 中控件的样式代码实在是太多太复杂了，还不容易从 Blend 中复制了大量代码出来改，下个版本样式又不一样，于是我们就丢了不少功能。本文将介绍 UWP 轻量级样式定义（Lightweight styling），你既不用写太多代码，又能获得更多的样式控制。轻量级样式定义看一段简单的代码，你一定能立刻明白本文想说的是什么。&amp;lt;Page.Resources&amp;gt; &amp;lt;ResourceDictionary&amp;gt; &amp;lt;ResourceDictionary.ThemeDictionaries&amp;gt; &amp;lt;ResourceDictionary x:Key=&quot;Light&quot;&amp;gt; &amp;lt;SolidColorBrush x:Key=&quot;ButtonBackground&quot; Color=&quot;Transparent&quot;/&amp;gt; &amp;lt;SolidColorBrush x:Key=&quot;ButtonForeground&quot; Color=&quot;#dd5145&quot;/&amp;gt; &amp;lt;SolidColorBrush x:Key=&quot;ButtonBorderBrush&quot; Color=&quot;#dd5145&quot;/&amp;gt; &amp;lt;/ResourceDictionary&amp;gt; &amp;lt;/ResourceDictionary.ThemeDictionaries&amp;gt; &amp;lt;/ResourceDictionary&amp;gt;&amp;lt;/Page.Resources&amp;gt;本段代码摘抄自 XAML Lightweight styling - UWP app developer - Microsoft Docs▲ 按钮的颜色定制以上代码可以写在 Page 中，即可在 Page 范围内获得这些主题资源的重写。当然，如果需要更大范围，可以考虑去 App 类中重写。官网上举例的这种类型的样式定义其实普通的 Style 也能很容易实现的，真正厉害的是 Style 里设置不了的那些鼠标滑过颜色和鼠标按下颜色。于是，我们额外添加一些代码：&amp;lt;SolidColorBrush x:Key=&quot;ButtonBackground&quot; Color=&quot;Transparent&quot;/&amp;gt;&amp;lt;SolidColorBrush x:Key=&quot;ButtonForeground&quot; Color=&quot;#dd5145&quot;/&amp;gt;&amp;lt;SolidColorBrush x:Key=&quot;ButtonBorderBrush&quot; Color=&quot;#dd5145&quot;/&amp;gt;&amp;lt;SolidColorBrush x:Key=&quot;ButtonBackgroundPointerOver&quot; Color=&quot;#10dd5145&quot;/&amp;gt;&amp;lt;SolidColorBrush x:Key=&quot;ButtonForegroundPointerOver&quot; Color=&quot;#ffcd44&quot;/&amp;gt;&amp;lt;SolidColorBrush x:Key=&quot;ButtonBorderBrushPointerOver&quot; Color=&quot;#ffcd44&quot;/&amp;gt;&amp;lt;SolidColorBrush x:Key=&quot;ButtonBackgroundPressed&quot; Color=&quot;#10ca5100&quot;/&amp;gt;&amp;lt;SolidColorBrush x:Key=&quot;ButtonForegroundPressed&quot; Color=&quot;#ca5100&quot;/&amp;gt;&amp;lt;SolidColorBrush x:Key=&quot;ButtonBorderBrushPressed&quot; Color=&quot;#ca5100&quot;/&amp;gt;现在我们只是设置一些颜色值即修改了按钮在多种状态下的外观。而且在按下的过程中，还保留了按钮按下时的倾斜效果。▲ 按钮更多的颜色定制相比于 Template -&amp;gt; Edit Copy 这种重量级的样式与模板定义，在保证足够的样式定义的情况下，代码量是不是少了非常多了呢？如何找到控件支持的主题资源前面我们知道了如何定制轻量级样式，但实际做 UI 的时候，我怎么知道有哪些样式主题资源的值可以使用呢？一种方法是直接看微软官方文档，比如这里 XAML theme resources；你可以在这篇文章中找到很多通用的主题资源的 Key 用来重写。不过实际上由于 Windows Community Toolkit 以及各种第三方控件库的存在，所以没有什么文档是可以把这些 Key 写全的；所以更重要的方法是我们能自己找到有哪些 Key 可以使用。找到 Key 的方法和定义一个全新的 Style / Template 一样，都可以通过 Visual Studio 的设计器视图（或者 Blend）实现。第一步：前往 Visual Studio 设计器视图▲ Visual Studio 设计器视图第二步：在其中一个你想定制样式的控件上 右键 -&amp;gt; 编辑模板 -&amp;gt; 编辑副本▲ 编辑模板特别注意，如果你发现你的 “编辑副本” 是灰色的，说明你已经定制过样式了。将你已经定制的样式删除后，就可以再编辑副本了。▲ 灰色的 “编辑副本”第三步：寻找你感兴趣的主题资源的 Key，记下来准备定义在编辑副本后，你可以在副本的代码中找到按钮的原生样式定义。比如一个按钮的样式是这样的：&amp;lt;Style x:Key=&quot;ButtonStyle1&quot; TargetType=&quot;Button&quot;&amp;gt; &amp;lt;Setter Property=&quot;Background&quot; Value=&quot;{ThemeResource ButtonBackground}&quot;/&amp;gt; &amp;lt;Setter Property=&quot;Foreground&quot; Value=&quot;{ThemeResource ButtonForeground}&quot;/&amp;gt; &amp;lt;Setter Property=&quot;BorderBrush&quot; Value=&quot;{ThemeResource ButtonBorderBrush}&quot;/&amp;gt; &amp;lt;Setter Property=&quot;BorderThickness&quot; Value=&quot;{ThemeResource ButtonBorderThemeThickness}&quot;/&amp;gt; &amp;lt;Setter Property=&quot;Padding&quot; Value=&quot;8,4,8,4&quot;/&amp;gt; &amp;lt;Setter Property=&quot;HorizontalAlignment&quot; Value=&quot;Left&quot;/&amp;gt; &amp;lt;Setter Property=&quot;VerticalAlignment&quot; Value=&quot;Center&quot;/&amp;gt; &amp;lt;Setter Property=&quot;FontFamily&quot; Value=&quot;{ThemeResource ContentControlThemeFontFamily}&quot;/&amp;gt; &amp;lt;Setter Property=&quot;FontWeight&quot; Value=&quot;Normal&quot;/&amp;gt; &amp;lt;Setter Property=&quot;FontSize&quot; Value=&quot;{ThemeResource ControlContentThemeFontSize}&quot;/&amp;gt; &amp;lt;Setter Property=&quot;UseSystemFocusVisuals&quot; Value=&quot;{StaticResource UseSystemFocusVisuals}&quot;/&amp;gt; &amp;lt;Setter Property=&quot;FocusVisualMargin&quot; Value=&quot;-3&quot;/&amp;gt; &amp;lt;Setter Property=&quot;Template&quot;&amp;gt; &amp;lt;Setter.Value&amp;gt; &amp;lt;ControlTemplate TargetType=&quot;Button&quot;&amp;gt; &amp;lt;Grid x:Name=&quot;RootGrid&quot; Background=&quot;{TemplateBinding Background}&quot;&amp;gt; &amp;lt;VisualStateManager.VisualStateGroups&amp;gt; &amp;lt;VisualStateGroup x:Name=&quot;CommonStates&quot;&amp;gt; &amp;lt;VisualState x:Name=&quot;Normal&quot;&amp;gt; &amp;lt;Storyboard&amp;gt; &amp;lt;PointerUpThemeAnimation Storyboard.TargetName=&quot;RootGrid&quot;/&amp;gt; &amp;lt;/Storyboard&amp;gt; &amp;lt;/VisualState&amp;gt; &amp;lt;VisualState x:Name=&quot;PointerOver&quot;&amp;gt; &amp;lt;Storyboard&amp;gt; &amp;lt;ObjectAnimationUsingKeyFrames Storyboard.TargetName=&quot;RootGrid&quot; Storyboard.TargetProperty=&quot;Background&quot;&amp;gt; &amp;lt;DiscreteObjectKeyFrame KeyTime=&quot;0&quot; Value=&quot;{ThemeResource ButtonBackgroundPointerOver}&quot;/&amp;gt; &amp;lt;/ObjectAnimationUsingKeyFrames&amp;gt; &amp;lt;ObjectAnimationUsingKeyFrames Storyboard.TargetName=&quot;ContentPresenter&quot; Storyboard.TargetProperty=&quot;BorderBrush&quot;&amp;gt; &amp;lt;DiscreteObjectKeyFrame KeyTime=&quot;0&quot; Value=&quot;{ThemeResource ButtonBorderBrushPointerOver}&quot;/&amp;gt; &amp;lt;/ObjectAnimationUsingKeyFrames&amp;gt; &amp;lt;ObjectAnimationUsingKeyFrames Storyboard.TargetName=&quot;ContentPresenter&quot; Storyboard.TargetProperty=&quot;Foreground&quot;&amp;gt; &amp;lt;DiscreteObjectKeyFrame KeyTime=&quot;0&quot; Value=&quot;{ThemeResource ButtonForegroundPointerOver}&quot;/&amp;gt; &amp;lt;/ObjectAnimationUsingKeyFrames&amp;gt; &amp;lt;PointerUpThemeAnimation Storyboard.TargetName=&quot;RootGrid&quot;/&amp;gt; &amp;lt;/Storyboard&amp;gt; &amp;lt;/VisualState&amp;gt; &amp;lt;VisualState x:Name=&quot;Pressed&quot;&amp;gt; &amp;lt;Storyboard&amp;gt; &amp;lt;ObjectAnimationUsingKeyFrames Storyboard.TargetName=&quot;RootGrid&quot; Storyboard.TargetProperty=&quot;Background&quot;&amp;gt; &amp;lt;DiscreteObjectKeyFrame KeyTime=&quot;0&quot; Value=&quot;{ThemeResource ButtonBackgroundPressed}&quot;/&amp;gt; &amp;lt;/ObjectAnimationUsingKeyFrames&amp;gt; &amp;lt;ObjectAnimationUsingKeyFrames Storyboard.TargetName=&quot;ContentPresenter&quot; Storyboard.TargetProperty=&quot;BorderBrush&quot;&amp;gt; &amp;lt;DiscreteObjectKeyFrame KeyTime=&quot;0&quot; Value=&quot;{ThemeResource ButtonBorderBrushPressed}&quot;/&amp;gt; &amp;lt;/ObjectAnimationUsingKeyFrames&amp;gt; &amp;lt;ObjectAnimationUsingKeyFrames Storyboard.TargetName=&quot;ContentPresenter&quot; Storyboard.TargetProperty=&quot;Foreground&quot;&amp;gt; &amp;lt;DiscreteObjectKeyFrame KeyTime=&quot;0&quot; Value=&quot;{ThemeResource ButtonForegroundPressed}&quot;/&amp;gt; &amp;lt;/ObjectAnimationUsingKeyFrames&amp;gt; &amp;lt;PointerDownThemeAnimation Storyboard.TargetName=&quot;RootGrid&quot;/&amp;gt; &amp;lt;/Storyboard&amp;gt; &amp;lt;/VisualState&amp;gt; &amp;lt;VisualState x:Name=&quot;Disabled&quot;&amp;gt; &amp;lt;Storyboard&amp;gt; &amp;lt;ObjectAnimationUsingKeyFrames Storyboard.TargetName=&quot;RootGrid&quot; Storyboard.TargetProperty=&quot;Background&quot;&amp;gt; &amp;lt;DiscreteObjectKeyFrame KeyTime=&quot;0&quot; Value=&quot;{ThemeResource ButtonBackgroundDisabled}&quot;/&amp;gt; &amp;lt;/ObjectAnimationUsingKeyFrames&amp;gt; &amp;lt;ObjectAnimationUsingKeyFrames Storyboard.TargetName=&quot;ContentPresenter&quot; Storyboard.TargetProperty=&quot;BorderBrush&quot;&amp;gt; &amp;lt;DiscreteObjectKeyFrame KeyTime=&quot;0&quot; Value=&quot;{ThemeResource ButtonBorderBrushDisabled}&quot;/&amp;gt; &amp;lt;/ObjectAnimationUsingKeyFrames&amp;gt; &amp;lt;ObjectAnimationUsingKeyFrames Storyboard.TargetName=&quot;ContentPresenter&quot; Storyboard.TargetProperty=&quot;Foreground&quot;&amp;gt; &amp;lt;DiscreteObjectKeyFrame KeyTime=&quot;0&quot; Value=&quot;{ThemeResource ButtonForegroundDisabled}&quot;/&amp;gt; &amp;lt;/ObjectAnimationUsingKeyFrames&amp;gt; &amp;lt;/Storyboard&amp;gt; &amp;lt;/VisualState&amp;gt; &amp;lt;/VisualStateGroup&amp;gt; &amp;lt;/VisualStateManager.VisualStateGroups&amp;gt; &amp;lt;ContentPresenter x:Name=&quot;ContentPresenter&quot; AutomationProperties.AccessibilityView=&quot;Raw&quot; BorderThickness=&quot;{TemplateBinding BorderThickness}&quot; BorderBrush=&quot;{TemplateBinding BorderBrush}&quot; ContentTemplate=&quot;{TemplateBinding ContentTemplate}&quot; Content=&quot;{TemplateBinding Content}&quot; ContentTransitions=&quot;{TemplateBinding ContentTransitions}&quot; HorizontalContentAlignment=&quot;{TemplateBinding HorizontalContentAlignment}&quot; Padding=&quot;{TemplateBinding Padding}&quot; VerticalContentAlignment=&quot;{TemplateBinding VerticalContentAlignment}&quot;/&amp;gt; &amp;lt;/Grid&amp;gt; &amp;lt;/ControlTemplate&amp;gt; &amp;lt;/Setter.Value&amp;gt; &amp;lt;/Setter&amp;gt;&amp;lt;/Style&amp;gt;从中我们可以找到这些可以定义的主题资源 Key： ButtonBackground ButtonForeground ButtonBorderBrush ButtonBorderThemeThickness ContentControlThemeFontFamily ControlContentThemeFontSize ButtonBackgroundPointerOver ButtonBorderBrushPointerOver ButtonForegroundPointerOver ButtonBackgroundPressed ButtonBorderBrushPressed ButtonForegroundPressed ButtonBackgroundDisabled ButtonBorderBrushDisabled ButtonForegroundDisabled第四步：轻量级样式定义请先删除这份副本样式，这样你就可以进行 “轻量级样式定义” 了。代码量相比于上面这份完整样式可以少非常多。" }, { "title": "UWP 中的各种文件路径（用户、缓存、漫游、安装……）", "url": "/post/all-kinds-of-paths-in-uwp.html", "categories": "", "tags": "dotnet, uwp", "date": "2018-12-14 09:54:00 +0800", "snippet": "UWP 提供了多种不同文件路径访问方式，对应到不同的文件路径中。可能我们只是简单用 ApplicationData.Current 获取一下可以读写的路径便能应付我们应用日常所需的各种文件读写需求，不过，UWP 还提供了更多的路径选项。本文将和你一起总结 UWP 中的各种各样的路径。UWP 中的路径种类UWP 中可访问的路径有这些： ApplicationData 用于储存应用的各种数据 Package.InstalledLocation 提供对应用程序包中各种文件的访问 特殊文件夹 提供用户文档、用户收藏夹等特殊文件夹的访问 ApplicationDataApplicationData 提供应用程序自己创建的数据的读写能力。它包含这些文件夹： Local: 储存在设备上，可被云端备份，在更新之后此数据保留 LocalCache: 储存在当前设备上，不备份，在更新后此数据保留 SharedLocal: 储存在设备上，为所有用户共享 Roaming: 对于同一个用户，会存在于安装了此应用的所用设备中 Temporary: 允许操作系统在任何时刻删除的临时文件在智能感知提示的帮助下，你也可以找到对应的这几个文件夹：▲ ApplicationData 的智能感知提示这些不同的文件夹有着不同建议的用途。Local 文件夹，用来储存用户产生的数据（例如用户创建的文档等）；这部分数据在进行备份的时候会被备份下来。相比之下，LocalCache 和 Temporary 是不受备份影响的。额外的，Package.InstalledLocation应用程序可以访问安装后程序包所在的路径，使用 Package.Current.InstalledLocation 即可获取到应用程序包所在路径。当然，这部分的路径有更多的快捷访问方式，比如 Uri 以 / 开头，就是访问程序包所在路径：var uri = new Windows.Foundation.Uri(&quot;/samples/logo.png&quot;);还可以以 ms-appx:/// 协议开头：var uri = new Windows.Foundation.Uri(&quot;ms-appx:///samples/logo.png&quot;);var file = Windows.Storage.StorageFile.GetFileFromApplicationUriAsync(uri);特殊文件夹特殊文件夹可以通过 KnownFolders 类型获取，可以获取到照片、图片、音乐、视频等文件夹。 KnownFolders Class (Windows.Storage) - UWP app developer - Microsoft Docs" }, { "title": "C# 空合并操作符（??）不可重载？其实有黑科技可以间接重载！", "url": "/post/overload-null-coalescing-operator-in-csharp.html", "categories": "", "tags": "csharp", "date": "2018-12-14 09:54:00 +0800", "snippet": "?? 操作符叫做 null-coalescing operator，即 null 合并运算符。如果此运算符的左操作数不为 null，则此运算符将返回左操作数；否则返回右操作数。在微软的官方 C# 文档中，此操作符被定义为不可重载。不过我们有方法可以间接实现这样的重载。运算符重载你可以阅读 C# 中那些可以被重载的操作符，以及使用它们的那些丧心病狂的语法糖 了解 C# 中提供的所有可以重载的操作符。在此文中，?? 被明确定义为不可重载。你更可以在微软官方文档中找到这样的说法： Overloadable operators (C# Programming Guide) 可重载运算符（C# 编程指南） =, ., ?:, ??, -&amp;gt;, =&amp;gt;, f(x), as, checked, unchecked, default, delegate, is, new, sizeof, typeofThese operators cannot be overloaded.这些运算符无法进行重载。编写 NullableString 的 ?? 重载我们先写一个空壳子。连构造函数都是 private 的，这个类当然几乎不可用啦。特别注意，我们的 Walterlv.NullableString 用的是 struct 类型，这样能与 Nullable&amp;lt;T&amp;gt; 的用法上接近。也就是说，我们可以确保其值实际上永不为 null。namespace Walterlv{ public struct NullableString { private readonly string _value; private NullableString(string value) { _value = value; } }}现在我们挑战一下官方说好了不能重载的 ?? 重载（作死）：▲ 试着重载 ??很明显，既不是可重载的一员运算符也不是可重载的二元运算符。现在我们试试隐式转换：public static implicit operator NullableString(string value){ return new NullableString(value);}public static implicit operator string(NullableString nullableString){ return nullableString._value;}然而这样的写法实际上并无实际用途。但是，我们可以在 NullableString 后面加上 ?：public static implicit operator NullableString?(string value){ return string.IsNullOrEmpty(value) ? (NullableString?) null : new NullableString(value);}public static implicit operator string(NullableString? nullableString){ return nullableString?.ToString() ?? string.Empty;}也就是说，C# 竟然允许隐式转换的时候，参数和返回值都不是此类型。当然，实际上这只对 Nullable&amp;lt;T&amp;gt; 生效，如果你试图写别的类型，是不可以的。为了方便，我们重写一下 ToString()，部分场景下可以代替隐式转换，少写一些代码。public override string ToString(){ return string.IsNullOrEmpty(_value) ? string.Empty : _value;}于是，我们的 NullableString 类型的完整代码如下：namespace Walterlv{ public readonly struct NullableString { private readonly string _value; private NullableString(string value) { _value = value; } public static implicit operator NullableString?(string value) { return string.IsNullOrEmpty(value) ? (NullableString?) null : new NullableString(value); } public static implicit operator string(NullableString? nullableString) { return nullableString?.ToString() ?? string.Empty; } public override string ToString() { return string.IsNullOrEmpty(_value) ? string.Empty : _value; } }}注释就你自己添加吧。一些注意事项这里有一些好玩的事情需要分享。比如我们写出如下代码：NullableString? value = &quot;&quot;;var value0 = value?.ToString();var value1 = value.ToString();你觉得 value0 和 value1 分别会得到什么呢？呃……value0 得到 null，而 value1 得到 &quot;&quot;。另外，如果你将一开始的初始值设为 null，那又可以得到什么结果呢？NullableString? value = null;var value0 = value?.ToString();var value1 = value.ToString();一样的，value0 得到 null，而 value1 得到 &quot;&quot;。另外，你可以从 null 强转出你需要的类：var value = (NullableString?) null;" }, { "title": "让控制台支持 ANSI 转义序列，输出下划线、修改颜色或其他控制", "url": "/post/enable-virtual-terminal-processing.html", "categories": "", "tags": "windows, dotnet, csharp", "date": "2018-12-14 09:54:00 +0800", "snippet": "各种操作系统的控制台都支持 ANSI 转义序列（ANSI Escape Code）。使用转义序列，可以对控制台进行很多额外的定制，例如修改颜色、修改标题栏，将文字添加下划线等。当然，.NET 已经帮助我们封装了很大的一部分功能了，我们重点可以放在 .NET 没有封装的那部分上。基本的准备代码在开始之前，我们先添加一些基础性代码，这是对系统核心功能的调用。const int STD_OUTPUT_HANDLE = -11;const uint ENABLE_VIRTUAL_TERMINAL_PROCESSING = 0x0004;[DllImport(&quot;kernel32.dll&quot;, SetLastError = true)]static extern IntPtr GetStdHandle(int nStdHandle);[DllImport(&quot;kernel32.dll&quot;)]static extern bool GetConsoleMode(IntPtr hConsoleHandle, out uint lpMode);[DllImport(&quot;kernel32.dll&quot;)]static extern bool SetConsoleMode(IntPtr hConsoleHandle, uint dwMode);在 Main 函数中，添加一些调用：static void Main(string[] args){ Console.Title = &quot;Walterlv.Demo&quot;; var handle = GetStdHandle(STD_OUTPUT_HANDLE); GetConsoleMode(handle, out var mode); mode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING; SetConsoleMode(handle, mode); // 我们准备在这里添加新的代码。 Console.Read();}开始使用 ANSI 转义序列添加下划线const string UNDERLINE = &quot;\\x1B[4m&quot;;const string RESET = &quot;\\x1B[0m&quot;;Console.WriteLine($&quot;Some {UNDERLINE}underlined{RESET} text&quot;);▲ 下划线转义修改颜色const string RED = &quot;\\x1B[31m&quot;;Console.WriteLine($&quot;Some {UNDERLINE}underlined{RESET} and {RED}red{RESET} text&quot;);▲ 颜色转义（当然，.NET 封装有 API）其他转义序列其他转义序列，可阅读 ANSI escape code - Wikipedia。不过 Windows 能支持的并不多。关于颜色，不同控制台上对于相同转义序列的颜色值和颜色支持程度也不同。关于 ENABLE_VIRTUAL_TERMINAL_PROCESSING这是用来开启虚拟终端处理的一个标识，Windows 从一开始就默认关闭这个标识，必须通过 SetConsoleMode 手工开启。虽然在 10.0.10586 版本时短暂开启了一个版本，随后在 10.0.14393 中又再次默认关闭了。参考资料 SetConsoleMode function - Windows Console - Microsoft Docs Win10 New Console: Enable ENABLE_VIRTUAL_TERMINAL_PROCESSING by default (or with a flag) · Issue #92 · rprichard/winpty (Re?)enable ENABLE_VIRTUAL_TERMINAL_PROCESSING by default – Welcome to the Windows developer feedback site! ANSI escape code - Wikipedia c# - adding text decorations to console output - Stack Overflow Windows 10 Command Prompt: New Console vs. Legacy Console - Password Recovery" }, { "title": "UWP 应用中 CoreApplication / Application, CoreWindow / Window 之间的区别", "url": "/post/core-application-window-of-uwp.html", "categories": "", "tags": "uwp", "date": "2018-12-14 09:54:00 +0800", "snippet": "在 StackOverflow 上看到有小伙伴询问 CoreApplication, CoreApplicationView, Application, ApplicationView, CoreWindow, Window 它们的含义以及它们之间的区别。于是我整理了这篇文章。This post is written in multiple languages. Please select yours: 中文 English StackOverflow 上的地址：c# - CoreApplicationView vs CoreWindow vs ApplicationView - Stack Overflow。命名空间类的完整含义经常需要配合其命名空间查看，所以我们有必要将这几个类的完整名称拿出来看： Windows.ApplicationModel.Core.CoreApplication Windows.ApplicationModel.Core.CoreApplicationView Windows.UI.Xaml.Application Windows.UI.ViewManagement.ApplicationView Windows.UI.Core.CoreWindow Windows.UI.Xaml.Window额外的，如果你关心标题栏，还有： Windows.ApplicationModel.Core.CoreApplicationViewTitleBar Windows.UI.ViewManagement.ApplicationViewTitleBar再额外的，如果你关心线程模型，还有： Windows.UI.Core.CoreDispatcher Windows.UI.Xaml.DispatcherTimer可以看到，大的命名空间分类有 Windows.ApplicationModel 和 Windows.UI 两类。也就是说，CoreApplication 和 CoreApplicationView 是管理应用程序模型的，而 Application、CoreWindow 和 Window 是管理应用内 UI 的。小的命名空间分类有 Core 和 Xaml 两类。也就是说，CoreApplication、CoreApplicationView 和 CoreWindow 是管理核心功能，而 Application 和 Window 是管理 XAML UI 的。自顶向下Application 到 Window 到 XAML 内容，很明显地就能直到其是自顶向下的关系，应用内包含窗口，窗口内包含 XAML 内容。那么它们之间的关系呢？CoreApplication 管理一个 UWP 应用中的所有视图（View），而 CoreApplication 直接管理的视图是 CoreApplicationView；也就是说，UWP 应用 CoreApplication 管理所有的应用视图 CoreApplicationView。而一个 CoreApplicationView 包含一个窗口和一个线程调度模型，即 CoreWindow 和 CoreDispatcher。▲ UWP 应用视图在 让 UWP 应用显示多个窗口（多视图） 一文中，由于一个应用对应多个视图，所以可以更容易地理解它们之间的关系。CoreWindow 就是我们所理解的窗口。为了方便使用，Windows.UI.XAML.Window 类型封装了这个 CoreWindow。CoreDispatcher 是基于消息循环的线程调度模型，正是因为有了消息循环，所以此窗口才能一直显示而不被销毁。对外，还是对内？我们是站在 UWP 普通开发者的角度来思考这个问题的，普通 UWP 开发者是从 MainPage 开始写 UWP 应用的。所以在这里，“外” 指的是页面之外，或者叫做我们直接编写的 XAML 内容之外，那些非 XAML 内容；而 “内” 指的是页面之内，也就是我们通常写的 XAML 内容。对外的部分有 CoreApplication、CoreApplicationView 和 CoreWindow，对内的部分有 Application 和 Window。其中，Window 是对 CoreWindow 的封装，提供了更多与 XAML 相关的功能。这里的 ApplicationView 也是这样，是对 CoreApplication 的封装，提供了 XAML 相关的功能。具体来说，CoreWindow 是与操作系统、与整个应用打交道的类型，提供了诸如窗口的尺寸、位置、输入状态等设置或调用；Window 是与应用内 UI 打交道的类型，比如可以设置窗口内显示的 UI，设置内部哪个控件属于标题栏，获取此窗口内的 Compositor。与之对应的，CoreApplicationView 是应用与操作系统交互，与窗口消息循环机制协同工作的类型，包含窗口客户区和非客户区设置；ApplicationView 也是与应用内 UI 打交道的类型，它可以使用 XAML 相关的类型对应用程序视图进行更方便的设置。总结起来，CoreWindow 和 CoreApplicationView 提供更加核心的操作系统或应用底层功能，而 Window 和 ApplicationView 对前者进行了封装，使得我们能够使用 Windows.UI.Xaml 命名空间下的类型对窗口和应用视图进行控制。关于这些概念的更多应用我有另外一些文章用到了这些概念： 从零开始创建一个 UWP 程序 让 UWP 应用显示多个窗口（多视图） UWP 扩展/自定义标题栏参考资料 Title bar customization - UWP app developer - Microsoft Docs" }, { "title": "UWP CoreApplication / Application Vs CoreApplicationView / ApplicationView Vs CoreWindow / Window", "url": "/post/core-application-window-of-uwp-en.html", "categories": "", "tags": "uwp", "date": "2018-12-14 09:54:00 +0800", "snippet": "I find a question on Stack Overflow CoreApplicationView vs CoreWindow vs ApplicationView, so I write this post for the answer.This post is written in multiple languages. Please select yours: 中文 English The namespaceSometimes we have to view the full class names with namespaces to determine their meanings. Windows.ApplicationModel.Core.CoreApplication Windows.ApplicationModel.Core.CoreApplicationView Windows.UI.Xaml.Application Windows.UI.Core.CoreWindow Windows.UI.Xaml.WindowExtra, if you’re interested in the titlebar, Windows.ApplicationModel.Core.CoreApplicationViewTitleBar Windows.UI.ViewManagement.ApplicationViewTitleBarExtra, if you’re interested in the threading model, Windows.UI.Core.CoreDispatcher Windows.UI.Xaml.DispatcherTimerWe can split them into Windows.ApplicationModel and Windows.UI, or split them into Core and Xaml.The CoreApplication and CoreApplicationView manage the application model, and the Application, CoreWindow and Window manage the application inner UI. The CoreApplication, CoreApplicationView and CoreWindow manages the core functions, but the Application and Window manage the XAML UI.From top to bottomFrom top to bottom is from Application to Window, then to XAML. It’s obvious that the application contains windows and the window contains the inner XAML UI. Then, what’s the real relationship?The CoreApplication manages all the views of a UWP application and the CoreApplicationView is the view that it manages directly. A CoreApplicationView contains a CoreWindow as the window and a CoreDispatcher as the threading model.▲ UWP application viewYou can read Show multiple views for an app - UWP app developer - Microsoft Docs to learn how to write multiple views applications. You’ll know more about the relationship between the CoreApplication and the CoreApplicationView.CoreWindow is the window that we are all familiar with. Windows.UI.XAML.Window encapsulate the CoreWindow for easier usage. CoreDispatcher is the threading model based on the windows message loop. It’s the CoreDispatcher that keeps the window to show all the time without being disposed.For outer or for innerMost UWP developers are normal developers, so we should stand on their side to think about the outer and the inner. Normal UWP developers start writing code from MainPage, so the outer is out of the page and the inner is the XAML content of the page.The outer part contains CoreApplication, CoreApplicationView and CoreWindow while the inner part contains Application and Window. Is it strange that the Application and the Window are the inner part? The reason is that they manage the XAML part of the application and the window.The Window is the encapsulation of the CoreWindow to provide extra XAML UI functions. The same to the ApplicationView, it is the encapsulation of the CoreApplication providing extra XAML UI functions.In details, the CoreWindow is the class that interop with the Windows Operating System and the UWP application model. It provides those functions such as the window size, location, the input status, etc. The Window is the class that provides the ability to use XAML UI for the window, such as setting the XAML content of the window, setting the titlebar of the window, or getting the Compositor of the window. The CoreApplicationView is the class that interop with the Windows Operating System and provides the mechanism of windows message loop and the ability to change the client area and the non-client area. The ApplicationView is the same as the Window, provides the ability to use XAML UI for the application.In conclusion, the CoreWindow and the CoreApplicationView provide the low-level core functions of the operating system and the application model. The Window and the ApplicationView encapsulates them for XAML usage.Some usages of these conceptsI’ve written some other posts about UWP that take advantages of these concepts. Unfortunately, they are all not in English. Create a UWP application from zero. Show multiple views for a UWP application Extends the titlebar of a UWP applicationReferences Title bar customization - UWP app developer - Microsoft Docs" }, { "title": "UWP 扩展/自定义标题栏的方法，一些概念和一些注意事项", "url": "/post/tips-for-customize-uwp-title-bar.html", "categories": "", "tags": "uwp", "date": "2018-12-14 09:54:00 +0800", "snippet": "在 Windows 10 的前几个版本中将页面内容扩展到标题栏上还算简单，主要是没什么坑。直到一些新控件的引入和一些外观设计趋势变化之后，扩展标题栏开始出现一些坑了。本文将重温 UWP 自定义标题栏或者扩展标题栏的方法，但更重要的是解决一些坑。扩展/自定义标题栏要扩展标题栏，只需要拿到 CoreApplicationView 的实例，然后设置 TitleBar 的 ExtendViewIntoTitleBar 属性为 true 即可。var applicationView = CoreApplication.GetCurrentView();applicationView.TitleBar.ExtendViewIntoTitleBar = true;要自定义标题栏，只需要拿到 ApplicationView 的实例，然后设置 TitleBar 里各种属性接口。var titleBar = ApplicationView.GetForCurrentView().TitleBar;titleBar.BackgroundColor = Colors.Khaki;titleBar.ButtonBackgroundColor = Colors.Transparent;一些概念那么问题来了，为什么前者需要拿到 CoreApplicationView 的实例，后者需要拿到 ApplicationView 的实例？它们到底是什么区别？我在 CoreApplication/Application、CoreWindow/Window 之间的区别 一文中提到过 CoreApplication、CoreWindow 和 CoreDispatcher 之间的关系。继续借用那篇文章中的图：其中，Window 是对 CoreWindow 的封装，提供了更多与 XAML 相关的功能。这里的 ApplicationView 也是这样，是对 CoreApplication 的封装，提供了 XAML 相关的功能。那篇文章中详细描述了这几个概念之间的关系和区别。考虑到阅读的一致性，我摘抄过来： 具体来说，CoreWindow 是与操作系统、与整个应用打交道的类型，提供了诸如窗口的尺寸、位置、输入状态等设置或调用；Window 是与应用内 UI 打交道的类型，比如可以设置窗口内显示的 UI，设置内部哪个控件属于标题栏，获取此窗口内的 Compositor。与之对应的，CoreApplicationView 是应用与操作系统交互，与窗口消息循环机制协同工作的类型，包含窗口客户区和非客户区设置；ApplicationView 也是与应用内 UI 打交道的类型，它可以使用 XAML 相关的类型对应用程序视图进行更方便的设置。 总结起来，CoreWindow 和 CoreApplicationView 提供更加核心的操作系统或应用底层功能，而 Window 和 ApplicationView 对前者进行了封装，使得我们能够使用 Windows.UI.Xaml 命名空间下的类型对窗口和应用视图进行控制。于是，我们便能够理解为什么扩展标题栏和设置标题栏颜色会使用到两个不一样的类型了。ExtendViewIntoTitleBar 是改变了窗口的客户区（Client Area）和非客户区（Non-client Area）组成，这是传统 Win32 编程中的概念，是更接近操作系统底层的概念。BackgroundColor 和 ButtonBackgroundColor 这里需要用到 Windows.UI.Xaml 命名空间中的颜色，而 CoreApplicationView 太底层，无法使用 XAML 颜色。一些坑控件在标题栏区域无法交互想必当你扩展到标题栏后，在标题栏区域增加一些按钮的时候，肯定会遇到下面的情况：▲ 按钮在标题栏区域的一半无法交互这显然是无法接受的。然而，当我们将一个 XAML 控件指定为标题栏之后，就只会是那个控件所在的区域响应标题栏操作，其他地方就会恢复正常。// TitleBar 是我在 XAML 中写的一个 x:Name=&quot;TitleBar&quot; 的控件。Window.Current.SetTitleBar(TitleBar);▲ 按钮在标题栏区域现在可以交互了特别说明一下，SetTitleBar 传入的是 UIElement 类型的实例，也就是说这也是 XAML 交互的一部分。我们需要使用 Window 的实例，而不是 CoreWindow 的实例。更高的标题栏，或者被遮挡如果被指定为标题栏的控件更大，超出标题栏区域了，它还会成为标题栏吗？如果被其他控件遮挡了，它还会响应标题栏事件吗？实际看来，无论它多大，都能响应标题栏事件；但被遮挡的部分就真的被遮挡了，没有标题栏响应。▲ 更高的标题栏，或者被遮挡事实上，指定为标题栏的控件可以在界面的任何地方，不需要一定在顶部。只不过，绝大多数不作死的应用都不会这样设置吧！在什么时机调用？扩展标题栏用的是 CoreApplicationView，自定义标题栏颜色用的是 ApplicationView，将控件指定为标题栏用的是 Window。如果我们的应用只有一个视图，其实我们随便找一个初始化的地方调用就好了。但如果我们的应用有多个视图，那么给非主要视图调用的时候就需要在其初始化之后了。阅读 理解 UWP 视图的概念，让 UWP 应用显示多个窗口（多视图） 了解如何编写多个视图的 UWP 应用，了解非主要视图的初始化时机。当然，如果你比较极客，从 Main 函数开始写 UWP 应用，就像我在 为了理解 UWP 的启动流程，我从零开始创建了一个 UWP 程序 一文中做的一样，那么你也需要等到初始化完毕之后才能调用（至少是 SetWindow 之后了）。适配移动设备移动设备上并不是标题栏，而是状态了和虚拟按键。关于扩展视图到这些区域，可以阅读 win10 uwp 标题栏 - 林德熙。参考资料 Title bar customization - UWP app developer - Microsoft Docs" }, { "title": "理解 UWP 视图的概念，让 UWP 应用显示多个窗口（多视图）", "url": "/post/show-multiple-views-for-an-uwp-app.html", "categories": "", "tags": "uwp", "date": "2018-12-14 09:54:00 +0800", "snippet": "UWP 应用多是一个窗口完成所有业务的，事实上我也推荐使用这种单一窗口的方式。不过，总有一些特别的情况下我们需要用到不止一个窗口，那么 UWP 中如何使用多窗口呢？为什么 UWP 需要多窗口？多窗口在传统 Win32 的开发当中是司空见惯的事儿了，不过我个人非常不喜欢，因为 Windows 系统上的多窗口太多坑。以下是我以前写的关于传统多窗口开发中的一些坑（除此之外还有更多）： 关闭模态窗口后，父窗口居然跑到了其他窗口的后面 WPF 程序无法触摸操作？我们一起来找原因和解决方法！使用多窗口的原因很简单 —— 允许用户多任务处理。从这个角度来说，传统 Win32 使用“模态”多窗口的方式简直是低效的同时还带来 Bug！微软官方文档中列举了一些例子：例如一边写邮件一边参考以往的邮件；一边看正在播放的音乐一边浏览播放列表；一次性打开多份文章然后稍后一起阅读等。UWP 视图的概念在学习如何编写 UWP 多窗口之前，我们需要了解一些 UWP 视图（View）的概念。在 CoreApplication/Application、CoreWindow/Window 之间的区别 一文中，我描述了 UWP 视图的一些概念： CoreApplication 管理一个 UWP 应用中的所有视图（View），而 CoreApplication 直接管理的视图是 CoreApplicationView；也就是说，UWP 应用 CoreApplication 管理所有的应用视图 CoreApplicationView。而一个 CoreApplicationView 包含一个窗口和一个线程调度模型，即 CoreWindow 和 CoreDispatcher。 CoreWindow 就是我们所理解的窗口。为了方便使用，Windows.UI.XAML.Window 类型封装了这个 CoreWindow。CoreDispatcher 是基于消息循环的线程调度模型，正是因为有了消息循环，所以此窗口才能一直显示而不被销毁。在 为了理解 UWP 的启动流程，我从零开始创建了一个 UWP 程序 一文中，我们也能体会到 CoreApplication 和 CoreWindow 之间的关系，了解消息循环在应用中的作用。UWP 多窗口在了解到 UWP 视图的概念之后，严格意义上说，这一节的标题应该叫做 “UWP 多视图”。我画了一个思维导图来描述它们之间的关系。CoreApplication 有静态方法 CreateNewView，调用后能够创建新的 CoreApplicationView，这包含一个完整的 CoreWindow 和 CoreDispatcher。创建并显示一个新 CoreApplicationView 的代码如下：private async void OnLoaded(object sender, RoutedEventArgs e){ // 创建一个 CoreApplicationView，即新的应用视图。 var applicationView = CoreApplication.CreateNewView(); // 一个应用视图有自己的 Id，稍后我们创建应用视图的时候，需要记录这个 Id。 int newViewId = 0; // 使用新应用视图的 CoreDispatcher 线程调度模型来执行新视图中的操作。 await applicationView.Dispatcher.RunAsync(CoreDispatcherPriority.Normal, () =&amp;gt; { // 在新的应用视图中，我们将新的窗口内容设置为 ThePageInNewView 页面。 Frame frame = new Frame(); frame.Navigate(typeof(ThePageInNewView), null); Window.Current.Content = frame; Window.Current.Activate(); // 记录新应用视图的 Id，这样才能稍后切换。 newViewId = ApplicationView.GetForCurrentView().Id; }); // 使用刚刚记录的新应用视图 Id 显示新的应用视图。 var viewShown = await ApplicationViewSwitcher.TryShowAsStandaloneAsync(newViewId);}创建完后的效果如下图：管理多个 UWP 视图我们平时开发 UWP 应用的时候很少去关心 CoreApplicationView，因为默认情况下 UWP 能为我们做很多管理应用视图的工作。CoreApplication 有一个 MainView 属性，即我们一开始运行 UWP 应用时的那个应用视图。如果我们有不止一个应用视图显示出来，那么这时点击主窗口的关闭按钮将不再是关闭，而是隐藏。如果要关闭，需要调用 Application.Exit。CoreApplication 有 Views 属性储存所有的 CoreApplicationView，我们可以使用此集合来管理多个视图。使用 ApplicationViewSwitcher.SwitchAsync 并传入视图 Id 可以切换视图的显示。await ApplicationViewSwitcher.SwitchAsync(viewIdToShow);参考资料 Show multiple views for an app - UWP app developer - Microsoft Docs" }, { "title": "(2/2) 为了理解 UWP 的启动流程，我从零开始创建了一个 UWP 程序", "url": "/post/create-uwp-app-from-zero-1.html", "categories": "", "tags": "uwp, dotnet, csharp", "date": "2018-12-14 09:54:00 +0800", "snippet": "每次使用 Visual Studio 的模板创建一个 UWP 程序，我们会在项目中发现大量的项目文件、配置、应用启动流程代码和界面代码。然而这些文件在 UWP 程序中到底是如何工作起来的？我从零开始创建了一个 UWP 程序，用于探索这些文件的用途，了解 UWP 程序的启动流程。本文分为两个部分： 从零开始创建一个 UWP 项目并完成部署 从零开始编写一个 UWP 应用程序和窗口本文将从 Main 函数开始，一步步跑起来一个应用程序，显示一个窗口，并在窗口中显示一些内容。重点在了解在 UWP 中运行应用程序，并显示窗口。启动应用在上一篇文章中的末尾，我们成功启动了程序并进入了 Main 函数的断点，但实际上运行会报错。我们能看见一个窗口显示出来，随后提示进程已启动，但应用尚未运行。 The Walterlv.Demo.ZeroUwp.exe process started, but the activation request failed with error ‘The app didn’t start’.是的，我们只有一个什么都没做的 Main 函数，进程当然能够成功启动；但我们需要能够启动应用。那么 UWP 的应用是什么呢？是 CoreApplication。所以我们使用 CoreApplication 类型执行 Run 静态方法。此方法要求传入一个 IFrameworkViewSource。事实上 UWP 已经有一个 IFrameworkViewSource 的实现了，是 FrameworkViewSource。不过，我希望自己写一个，了解其原理。所以，就用 ReSharper 生成了 IFrameworkViewSource 的一个实现：using Windows.ApplicationModel.Core;namespace Walterlv.Demo.ZeroUwp{ internal sealed class WalterlvViewSource : IFrameworkViewSource { public IFrameworkView CreateView() =&amp;gt; new WalterlvFrameworkView(); }}IFrameworkViewSource 接口中只有一个方法 CreateView，返回一个新的 IFrameworkView 的实例。只是写一个 NotImplementedException 的异常，当然是跑不起来的，得返回一个真的 IFrameworkView 的实例。UWP 自带的实现为 FrameworkView，那么我也自己实现一个。这次需要实现的方法会多一些：using Windows.ApplicationModel.Core;using Windows.UI.Core;namespace Walterlv.Demo.ZeroUwp{ internal sealed class WalterlvFrameworkView : IFrameworkView { public void Initialize(CoreApplicationView applicationView) =&amp;gt; throw new System.NotImplementedException(); public void SetWindow(CoreWindow window) =&amp;gt; throw new System.NotImplementedException(); public void Load(string entryPoint) =&amp;gt; throw new System.NotImplementedException(); public void Run() =&amp;gt; throw new System.NotImplementedException(); public void Uninitialize() =&amp;gt; throw new System.NotImplementedException(); }}因此，我们需要理解这些方法的执行时机以及含义才能正确实现这些方法。庆幸的是，这些方法的含义都能在官方文档中找到（其实就是平时看到的注释）： IFrameworkView.Initialize(CoreApplicationView) IFrameworkView.Load(String) IFrameworkView.Run IFrameworkView.SetWindow(CoreWindow) IFrameworkView.Uninitialize为了方便查看，我将其整理到这些方法上作为注释。顺便的，下面这些方法刚好是按照应用生命周期的顺序被调用，也就是 Initialize-&amp;gt;SetWindow-&amp;gt;Load-&amp;gt;Run-&amp;gt;Uninitialize。/// &amp;lt;summary&amp;gt;/// 当应用启动时将执行此方法。进行必要的初始化。/// &amp;lt;/summary&amp;gt;public void Initialize(CoreApplicationView applicationView) { }/// &amp;lt;summary&amp;gt;/// 每次应用需要显示一个窗口的时候，此方法就会被调用。用于为当前应用程序显示一个新的窗口视图。/// &amp;lt;/summary&amp;gt;public void SetWindow(CoreWindow window) { }/// &amp;lt;summary&amp;gt;/// 会在 &amp;lt;see cref=&quot;Run&quot;/&amp;gt; 方法执行之前执行。如果需要使用外部资源，那么这时需要将其加载或激活。/// &amp;lt;/summary&amp;gt;public void Load(string entryPoint) { }/// &amp;lt;summary&amp;gt;/// 当此方法调用时，需要让应用内的视图（View）显示出来。/// &amp;lt;/summary&amp;gt;public void Run() { }/// &amp;lt;summary&amp;gt;/// 当应用退出时将执行此方法。如果应用启动期间使用到了外部资源，需要在此时进行释放。/// &amp;lt;/summary&amp;gt;public void Uninitialize() { }在此接口的所有方法留空地实现完以后，我们的 UWP 应用终于能跑起来了。当按下 F5 调试之后，不会再提示错误，而是依次执行这五个方法后，正常退出应用。启动窗口注意到以上所有方法都留空之后，应用程序很快就退出了。这与我们开发传统 Win32 应用时的效果是一致的 —— 是的，我们缺一个消息循环。我们需要一个不断处理的消息循环用来阻断主线程的退出，同时又能够不断响应消息。而这样的方法需要写到 Run() 方法里面。UWP 中开启一个消息循环是非常容易的，不过我们需要一个 CoreDispatcher 对象。在我们目前的接口实现中，CoreDispatcher 对象可以从 CoreWindow 中获取到。所以我们需要在 SetWindow 方法中拿到 CoreWindow 的实例，然后在 Run 中使用它开启窗口消息循环。public void SetWindow(CoreWindow window){ _window = window;}public void Run(){ _window.Activate(); _window.Dispatcher.ProcessEvents(CoreProcessEventsOption.ProcessUntilQuit);}private CoreWindow _window;▲ 开启了消息循环之后，应用不会直接退出了你可以通过阅读 理解 UWP 视图的概念，让 UWP 应用显示多个窗口（多视图） 一文来了解 UWP 应用（CoreApplication）、应用视图（CoreApplicationView）、窗口（CoreWindow/Window）、线程调度模型（CoreDispatcher）之间的关系。在窗口中显示点东西我们使用 CompositionAPI 可以在窗口中创建 Visual 并显示出来。public void SetWindow(CoreWindow window){ _window = window; var compositor = new Compositor(); var root = compositor.CreateContainerVisual(); var compositionTarget = compositor.CreateTargetForCurrentView(); compositionTarget.Root = root; var child = compositor.CreateSpriteVisual(); child.Size = new Vector2(100f, 100f); child.Brush = compositor.CreateColorBrush(Color.FromArgb(0xFF, 0x00, 0x80, 0xFF)); root.Children.InsertAtTop(child);}在窗口中做一些交互CoreWindow 除了为我们提供了消息循环之外，也可以提供交互。监听 PointerMoved 事件，我们可以做一些简单的交互。下面我用 Git 标准差异比较的方式添加了交互的代码 PointerMoved： public void SetWindow(CoreWindow window) { _window = window;+ _window.PointerMoved += OnPointerMoved; var compositor = new Compositor();- var root = compositor.CreateContainerVisual();+ _root = compositor.CreateContainerVisual(); var compositionTarget = compositor.CreateTargetForCurrentView();- compositionTarget.Root = _root;+ compositionTarget.Root = _root; var child = compositor.CreateSpriteVisual(); child.Size = new Vector2(100f, 100f); child.Brush = compositor.CreateColorBrush(Color.FromArgb(0xFF, 0x00, 0x80, 0xFF));- root.Children.InsertAtTop(child);+ _root.Children.InsertAtTop(child); }+ private void OnPointerMoved(CoreWindow sender, PointerEventArgs args)+ {+ var visual = _root.Children.First();+ var position = args.CurrentPoint.Position;+ visual.Offset = new Vector3((float) (position.X - 50f), (float) (position.Y - 50f), 0f);+ } private CoreWindow _window;+ private ContainerVisual _root;能够完成一些简单的交互。特别注意 GC如果你真的按照以上步骤写出了一个 UWP 程序并且跑起来了，你会发现过一会儿就炸了。这是因为 compositor 我们是作为变量放到方法中的，很容易就被 GC 掉。最好将它放到字段中储存起来，避免被 GC。private Compositor _compositor;总结在本文中，我们了解到 UWP 的应用程序启动中也一样需要有窗口消息循环。不过 UWP 中创建消息循环还是非常简单的。我们使用 CompositionAPI 进行了一些界面显示和简单的交互。了解到即便是如此复杂的 UWP 程序，其启动流程也没有那么复杂。不过，如果你阅读了前面一篇 (1/2) 为了理解 UWP 的启动流程，我从零开始创建了一个 UWP 程序，会发现复杂的部分都在项目文件和系统的部分。" }, { "title": ".NET/C# 使窗口永不激活（No Activate 永不获得焦点）", "url": "/post/no-activate-window.html", "categories": "", "tags": "windows, dotnet, csharp, wpf", "date": "2018-12-14 09:54:00 +0800", "snippet": "有些窗口天生就是为了辅助其它程序而使用的，典型的如“输入法窗口”。这些窗口不希望抢夺其它窗口的焦点。有 Win32 方法来解决这样的问题，WS_EX_NOACTIVATE 便是关键。具体来说，是给窗口样式中额外添加一个 WS_EX_NOACTIVATE 位。var handle = GetTheWindowHandle();int exstyle = GetWindowLong(handle, GWL_EXSTYLE);SetWindowLong(handle, GWL_EXSTYLE, exstyle | WS_EX_NOACTIVATE);当然，这里需要用到 P/Invoke 平台调用，可以阅读 使用 PInvoke.net Visual Studio Extension 辅助编写 Win32 函数签名 了解快速生成平台调用方法签名的方法。于是，我们将完整的窗口代码写完，是下面这样。注意 64 位系统中需调用 GetWindowLongPtr 和 SetWindowLongPtr，而 32 位系统中是没有这两个方法的；在任何版本的 Windows 中都是这样。当然，64 位系统会为其上运行的 32 位进程模拟 32 位系统的环境。using System;using System.Runtime.InteropServices;using System.Windows;using System.Windows.Interop;namespace Walterlv.Demo{ public partial class MainWindow : Window { public MainWindow() { InitializeComponent(); SourceInitialized += OnSourceInitialized; } private void OnSourceInitialized(object sender, EventArgs e) { var handle = new WindowInteropHelper(this).Handle; var exstyle = GetWindowLong(handle, GWL_EXSTYLE); SetWindowLong(handle, GWL_EXSTYLE, new IntPtr(exstyle.ToInt32() | WS_EX_NOACTIVATE)); } #region Native Methods private const int WS_EX_NOACTIVATE = 0x08000000; private const int GWL_EXSTYLE = -20; public static IntPtr GetWindowLong(IntPtr hWnd, int nIndex) { return Environment.Is64BitProcess ? GetWindowLong64(hWnd, nIndex) : GetWindowLong32(hWnd, nIndex); } public static IntPtr SetWindowLong(IntPtr hWnd, int nIndex, IntPtr dwNewLong) { return Environment.Is64BitProcess ? SetWindowLong64(hWnd, nIndex, dwNewLong) : SetWindowLong32(hWnd, nIndex, dwNewLong); } [DllImport(&quot;user32.dll&quot;, EntryPoint = &quot;GetWindowLong&quot;)] private static extern IntPtr GetWindowLong32(IntPtr hWnd, int nIndex); [DllImport(&quot;user32.dll&quot;, EntryPoint = &quot;GetWindowLongPtr&quot;)] private static extern IntPtr GetWindowLong64(IntPtr hWnd, int nIndex); [DllImport(&quot;user32.dll&quot;, EntryPoint = &quot;SetWindowLong&quot;)] private static extern IntPtr SetWindowLong32(IntPtr hWnd, int nIndex, IntPtr dwNewLong); [DllImport(&quot;user32.dll&quot;, EntryPoint = &quot;SetWindowLongPtr&quot;)] private static extern IntPtr SetWindowLong64(IntPtr hWnd, int nIndex, IntPtr dwNewLong); #endregion }}运行这段代码，可以发现，即时我们的窗口中文本框获得了焦点，焦点其实依然在外面的程序中。（我们的文本框依然不会响应键盘输入的。）参考资料 c# - Not take focus, but allow interaction? - Stack Overflow Extended Window Styles - Microsoft Docs GetWindowLongPtr function (Windows) SetWindowLongPtr function (Windows)" }, { "title": "使用 Microsoft.UI.Xaml 解决 UWP 控件和对老版本 Windows 10 的兼容性问题", "url": "/post/getting-started-with-microsoft-ui-xaml.html", "categories": "", "tags": "uwp, windows", "date": "2018-12-14 09:54:00 +0800", "snippet": "虽然微软宣称 Windows 10 将是最后一个 Windows 版本，但由于年代跨越实在太久远，兼容性依然是避不开的问题。Microsoft.UI.Xaml 的预览版现已推出，旨在解决 UWP UI 控件在各个不同版本 Windows 上的兼容性问题。本文将简单了解一下 Microsoft.UI.Xaml 库，然后实际看看它的效果。Windows 10 的兼容性问题在创建 UWP 应用的时候，我们可以选择目标版本和最低版本。目标版本决定了我们能使用的最新 API，最低版本决定了我们需要支持的最低版本的 Windows 10。▲ 图中目标版本为 17134，最低版本为 14393。事实上，目标版本必须是 17134，最低只能支持到 14393。然而，每一次新版本 Windows 10 的推出，都带来大量新的开发 API。可以去官方文档 Choose a UWP version - UWP app developer - Microsoft Docs 了解各个版本 Windows 10 新增的功能简介。微软在 Windows 10 16299 版本带来了 XAML 条件编译，用以在 XAML 中兼容不同版本的 Windows 10，然而这意味着必须选择 16299 作为最低 API 版本才能正常使用此功能。当然，XAML 条件编译还是带来了不少方便的特性呢，阅读 win10 uwp xaml 兼容多个版本条件编译 - 林德熙 可以了解 XAML 条件编译的使用方法，顺便收获一只猫。Windows 10 也在各个版本新增了一些控件。那么问题来了，要支持最低版本就不能使用新控件。Windows 10 又不像 iOS 那样更新率高，意味着根本不能使用新控件进行开发。Microsoft.UI.Xaml 库于是微软就推出了在 上推出了 NuGet 包 [Microsoft.UI.Xaml](https://www.nuget.org/packages/Microsoft.UI.Xaml)。使用此包，你需要将 UWP 的 目标版本设为 17134，支持的 最低版本只能到 14393，不能更低。官方对此包的描述为： This package provides backward-compatible versions of Windows UI features including UWP XAML controls, and Fluent styles and materials. It is part of the Windows UI Library.即提供各种 Windows UI 功能的向后兼容性，包括 UWP XAML 控件、Fluent 流畅设计样式和画刷。当然，不支持亚克力效果的系统版本虽然画刷能用，不崩溃，但也没有效果的。Microsoft.UI.Xaml 的上手方法安装 Microsoft.UI.Xaml 后，Visual Studio 会自动打开 readme.txt 文件提示我们用法： Thanks for installing the WinUI nuget package! Don’t forget to add this to your app.xaml: &amp;lt;Application.Resources&amp;gt; &amp;lt;XamlControlsResources xmlns=&quot;using:Microsoft.UI.Xaml.Controls&quot;/&amp;gt;&amp;lt;/Application.Resources&amp;gt; See http://aka.ms/winui for more information.即我们需要在 App.xaml 文件中添加 &amp;lt;XamlControlsResources xmlns=&quot;using:Microsoft.UI.Xaml.Controls&quot;/&amp;gt; 作为应用程序的全局资源。不过，官方文档 Getting started with the Windows UI library 中有对此更详细的描述。如果我们是新 UWP 程序，这样写是没问题的：&amp;lt;Application&amp;gt; &amp;lt;Application.Resources&amp;gt; &amp;lt;XamlControlsResources xmlns=&quot;using:Microsoft.UI.Xaml.Controls&quot;/&amp;gt; &amp;lt;/Application.Resources&amp;gt;&amp;lt;/Application&amp;gt;但如果基于原有的程序进行兼容性改造，可能原 Application 中已经有资源了，就必须换一种写法：&amp;lt;Application&amp;gt; &amp;lt;Application.Resources&amp;gt; &amp;lt;ResourceDictionary&amp;gt; &amp;lt;ResourceDictionary.MergedDictionaries&amp;gt; &amp;lt;XamlControlsResources xmlns=&quot;using:Microsoft.UI.Xaml.Controls&quot;/&amp;gt; &amp;lt;/ResourceDictionary.MergedDictionaries&amp;gt; &amp;lt;/ResourceDictionary&amp;gt; &amp;lt;/Application.Resources&amp;gt;&amp;lt;/Application&amp;gt;当然，以上这种改造在各种 XAML 上的行为都是一样的，比如我在 StackOverflow 上回答的问题 Use ResourceDictionary with other Styles in WPF 也是这样的改法，其中说明了必须这样修改的原因。不过没有结束，在需要使用到新版本 Windows 10 控件的 XAML 文件中，需要添加命名空间前缀：xmlns:controls=&quot;using:Microsoft.UI.Xaml.Controls&quot;这样才能在 XAML 中使用 Microsoft.UI.Xaml 库中的新控件：&amp;lt;Grid&amp;gt; &amp;lt;controls:NavigationView x:Name=&quot;WalterlvDemoView&quot;&amp;gt; &amp;lt;controls:NavigationView.MenuItems&amp;gt; &amp;lt;ListViewItem Content=&quot;Home&quot; /&amp;gt; &amp;lt;ListViewItem Content=&quot;Demo&quot; /&amp;gt; &amp;lt;ListViewItem Content=&quot;About&quot; /&amp;gt; &amp;lt;ListViewItem Content=&quot;https://walterlv.github.io/&quot; /&amp;gt; &amp;lt;/controls:NavigationView.MenuItems&amp;gt; &amp;lt;/controls:NavigationView&amp;gt;&amp;lt;/Grid&amp;gt;还记得本文开头那张 Visual Studio 的兼容性提示图片吗？使用了 Microsoft.UI.Xaml 库之后，不会再有提示了。这不是欺骗，是真的具备了对早期系统的兼容性。于是，一些广泛使用的 UWP 应用终于不用各种自己写控件来兼容低版本的 Windows 10 了。当然除了在 XAML 中，也可以在 C# 代码中使用库中的新 API。解决意料之外的错误一切可以那么顺利？不一定，你可能在刚刚把 &amp;lt;XamlControlsResources /&amp;gt; 加入之后，就会发现程序启动即崩溃了……然后提示： System.Runtime.InteropServices.COMException HResult=0x80004005 Message=Error HRESULT E_FAIL has been returned from a call to a COM component. Source= StackTrace: 不得不说，微软再一次把内部错误暴露了出去。实际的错误原因是 —— 目标 SDK 需要设置为 17134 —— 这是必须的！当然，这个版本号并不是跟随系统的，而是跟随 Microsoft.UI.Xaml 库的。库如果更新有新系统的控件，那么你更新库之后就需要再次更新目标 SDK 版本了。" }, { "title": "Windows 10 应用创建模糊背景窗口的三种方法", "url": "/post/create-blur-background-window.html", "categories": "", "tags": "windows, wpf, uwp, dotnet", "date": "2018-12-14 09:54:00 +0800", "snippet": "现代的操作系统中创建一张图片的高斯模糊效果非常容易，不过如果要在窗口中获得模糊支持就需要操作系统的原生支持了。iOS/Mac 和 Windows 系统都对此有支持。本文将介绍三种创建模糊背景窗口的方法。有人可能喜欢称之为毛玻璃窗口、亚克力窗口。This post is written in multiple languages. Please select yours: 中文 English 最早我是在 StackOverflow 上回答一位网友的提问时写了一份非常长的答案，后来小伙伴建议我将答案改写成博客，于是我就改了。StackOverflow 上的答案在这里：colors - WPF: How to Style my form with Transparency levels - Stack Overflow。三种创建模糊背景窗口的方法Windows 10 上创建带模糊背景的窗口有三种不同的方法，不过每一种都是既有好处又有坏处的： 调用 Win32 API —— SetWindowCompositionAttribute，使用这种方式能够获得一个背景轻微透明的窗口。当然，如果需要模拟亚克力效果或者是 iOS/Mac 上的模糊效果就 gg 了。 为窗口中的背景图片添加 WPF 自带的模糊效果 BlurEffect。这种方式你想获得多大的模糊半径就能获得多大的模糊半径，不过带来的就是更高的性能损耗。同时，还得考虑在移动窗口的时候动态地去更新背景图片并再次模糊。 使用 Fluent Design System 中的亚克力效果 —— AcrylicBrush。这绝对是 Windows 10 上获得背景模糊效果中视觉效果最好，同时又最省性能的方法了。不过，这种方法只能在 UWP 应用中使用。 SetWindowCompositionAttribute APISetWindowCompositionAttribute 并没有那么好调用，所以我为此写了一个辅助类类封装对背景模糊效果的调用。使用这个辅助类，你只需要使用一行代码就能开启背景模糊效果。可以在 XAML 代码中使用 interop:WindowBlur.IsEnabled=&quot;True&quot;：&amp;lt;Window x:Class=&quot;Walterlv.Demo.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:interop=&quot;clr-namespace:Walterlv.Demo.Interop&quot; mc:Ignorable=&quot;d&quot; Title=&quot;MainWindow&quot; Height=&quot;350&quot; Width=&quot;525&quot; interop:WindowBlur.IsEnabled=&quot;True&quot; Background=&quot;Transparent&quot;&amp;gt;&amp;lt;/Window&amp;gt;可以在 cs 代码中使用 WindowBlur.SetIsEnabled(this, true)：public class MainWindow : Window{ public MainWindow() { InitializeComponent(); WindowBlur.SetIsEnabled(this, true); }}我为 WindowBlur 类准备了一个 GitHub Gist，在这里：https://gist.github.com/walterlv/752669f389978440d344941a5fcd5b00。你只需要将代码全部复制到你的项目中即可开始使用。当然，我还写了一篇博客专门讲使用 SetWindowCompositionAttribute API 实现背景模糊效果：在 Windows 10 上为 WPF 窗口添加模糊特效（就像开始菜单和操作中心那样）。WPF BlurEffectWPF 的 UIElement 都有 Effect 属性，将其设置为 BlurEffect 即可获得控件的高斯模糊效果。&amp;lt;Window x:Class=&quot;MejirdrituTeWarqoudear.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; AllowsTransparency=&quot;True&quot; WindowStyle=&quot;None&quot; Width=&quot;540&quot; Height=&quot;360&quot;&amp;gt; &amp;lt;Grid&amp;gt; &amp;lt;Image Source=&quot;YourImageFile.jpg&quot; Stretch=&quot;Fill&quot; Margin=&quot;-60&quot;&amp;gt; &amp;lt;Image.Effect&amp;gt; &amp;lt;BlurEffect KernelType=&quot;Gaussian&quot; Radius=&quot;60&quot; /&amp;gt; &amp;lt;/Image.Effect&amp;gt; &amp;lt;/Image&amp;gt; &amp;lt;Border CornerRadius=&quot;60&quot; Margin=&quot;30&quot; Background=&quot;#7F000000&quot;&amp;gt; &amp;lt;TextBlock Foreground=&quot;White&quot; FontSize=&quot;20&quot; FontWeight=&quot;Light&quot; TextAlignment=&quot;Center&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;&amp;gt; &amp;lt;Run Text=&quot;Hello World&quot; FontSize=&quot;48&quot;/&amp;gt; &amp;lt;LineBreak/&amp;gt; &amp;lt;Run Text=&quot;walterlv.github.io&quot;/&amp;gt; &amp;lt;/TextBlock&amp;gt; &amp;lt;/Border&amp;gt; &amp;lt;/Grid&amp;gt;&amp;lt;/Window&amp;gt;特别注意：此方法有严重地性能问题。如果你的窗口是一个异形窗口，例如是具有圆角的矩形，那么你需要额外为控件设置 RectangleGeometry 来裁剪控件。&amp;lt;Window x:Class=&quot;MejirdrituTeWarqoudear.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; Width=&quot;540&quot; Height=&quot;360&quot;&amp;gt; &amp;lt;Grid&amp;gt; &amp;lt;Grid.Clip&amp;gt; &amp;lt;RectangleGeometry RadiusX=&quot;60&quot; RadiusY=&quot;60&quot; Rect=&quot;30 30 480 300&quot; /&amp;gt; &amp;lt;/Grid.Clip&amp;gt; &amp;lt;Image Source=&quot;High+Sierra.jpg&quot; Stretch=&quot;Fill&quot; Margin=&quot;-60&quot;&amp;gt; &amp;lt;Image.Effect&amp;gt; &amp;lt;BlurEffect KernelType=&quot;Gaussian&quot; Radius=&quot;60&quot; /&amp;gt; &amp;lt;/Image.Effect&amp;gt; &amp;lt;/Image&amp;gt; &amp;lt;Border Background=&quot;#7F000000&quot;&amp;gt; &amp;lt;TextBlock Foreground=&quot;White&quot; FontSize=&quot;20&quot; FontWeight=&quot;Light&quot; TextAlignment=&quot;Center&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;&amp;gt; &amp;lt;Run Text=&quot;Hello World&quot; FontSize=&quot;48&quot;/&amp;gt; &amp;lt;LineBreak/&amp;gt; &amp;lt;Run Text=&quot;walterlv.github.io&quot;/&amp;gt; &amp;lt;/TextBlock&amp;gt; &amp;lt;/Border&amp;gt; &amp;lt;/Grid&amp;gt;&amp;lt;/Window&amp;gt;如果是圆形窗口，我另外写了一篇文章来说明进行圆形裁剪：WPF 中使用附加属性，将任意 UI 元素或控件裁剪成圆形（椭圆）。UWP AcyclicBrush微软的官方文档 Acrylic material - UWP app developer - Microsoft Docs 讲解了如何使用亚克力效果。" }, { "title": "3 Ways to create a window with blurring background on Windows 10", "url": "/post/create-blur-background-window-en.html", "categories": "", "tags": "windows, wpf, uwp, dotnet", "date": "2018-12-14 09:54:00 +0800", "snippet": "This post is an answer from Stack Overflow and introduce some methods to create a window with blurring background.This post is written in multiple languages. Please select yours: 中文 English Options to blurring backgroundWe have three ways to blurring background on Windows 10 and each has its advantages and disadvantages. Call the Windows internal API SetWindowCompositionAttribute. You can get a lightly blurred transparent Window but this transparency is much less than the iOS one. Add a BlurEffect to the window background image. You can get a more similar visual effect like the iOS one with very poor performance. But in this way, the background image is fixed and cannot be updated when the window moves. Use UWP instead of WPF and use the AcrylicBrush. You can get a high-performance blur transparent window. But you should try the UWP Application development. SetWindowCompositionAttribute APICalling SetWindowCompositionAttribute API is not very easy, so I’ve written a wrapper class for easier usage. You can use my class by writing only a simple line in the XAML file or in the cs file.&amp;lt;Window x:Class=&quot;Walterlv.Demo.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:interop=&quot;clr-namespace:Walterlv.Demo.Interop&quot; mc:Ignorable=&quot;d&quot; Title=&quot;MainWindow&quot; Height=&quot;350&quot; Width=&quot;525&quot; interop:WindowBlur.IsEnabled=&quot;True&quot; Background=&quot;Transparent&quot;&amp;gt;&amp;lt;/Window&amp;gt;Or you can use it in the cs file like this:public class MainWindow : Window{ public MainWindow() { InitializeComponent(); WindowBlur.SetIsEnabled(this, true); }}Just add my wrapper class into your project. It’s a very long class so I pasted into GitHub: https://gist.github.com/walterlv/752669f389978440d344941a5fcd5b00.I also write a post for its usage, but it’s not in English: https://walterlv.github.io/post/win10/2017/10/02/wpf-transparent-blur-in-windows-10.htmlWPF BlurEffectJust set the Effect property of a WPF UIElement.&amp;lt;Window x:Class=&quot;MejirdrituTeWarqoudear.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; AllowsTransparency=&quot;True&quot; WindowStyle=&quot;None&quot; Width=&quot;540&quot; Height=&quot;360&quot;&amp;gt; &amp;lt;Grid&amp;gt; &amp;lt;Image Source=&quot;YourImageFile.jpg&quot; Stretch=&quot;Fill&quot; Margin=&quot;-60&quot;&amp;gt; &amp;lt;Image.Effect&amp;gt; &amp;lt;BlurEffect KernelType=&quot;Gaussian&quot; Radius=&quot;60&quot; /&amp;gt; &amp;lt;/Image.Effect&amp;gt; &amp;lt;/Image&amp;gt; &amp;lt;Border CornerRadius=&quot;60&quot; Margin=&quot;30&quot; Background=&quot;#7F000000&quot;&amp;gt; &amp;lt;TextBlock Foreground=&quot;White&quot; FontSize=&quot;20&quot; FontWeight=&quot;Light&quot; TextAlignment=&quot;Center&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;&amp;gt; &amp;lt;Run Text=&quot;Hello World&quot; FontSize=&quot;48&quot;/&amp;gt; &amp;lt;LineBreak/&amp;gt; &amp;lt;Run Text=&quot;walterlv.github.io&quot;/&amp;gt; &amp;lt;/TextBlock&amp;gt; &amp;lt;/Border&amp;gt; &amp;lt;/Grid&amp;gt;&amp;lt;/Window&amp;gt;Notice that it has a very poor performance.You can also add a RectangleGeometry to clip your UIElement into a rounded rectangle.&amp;lt;Window x:Class=&quot;MejirdrituTeWarqoudear.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; Width=&quot;540&quot; Height=&quot;360&quot;&amp;gt; &amp;lt;Grid&amp;gt; &amp;lt;Grid.Clip&amp;gt; &amp;lt;RectangleGeometry RadiusX=&quot;60&quot; RadiusY=&quot;60&quot; Rect=&quot;30 30 480 300&quot; /&amp;gt; &amp;lt;/Grid.Clip&amp;gt; &amp;lt;Image Source=&quot;High+Sierra.jpg&quot; Stretch=&quot;Fill&quot; Margin=&quot;-60&quot;&amp;gt; &amp;lt;Image.Effect&amp;gt; &amp;lt;BlurEffect KernelType=&quot;Gaussian&quot; Radius=&quot;60&quot; /&amp;gt; &amp;lt;/Image.Effect&amp;gt; &amp;lt;/Image&amp;gt; &amp;lt;Border Background=&quot;#7F000000&quot;&amp;gt; &amp;lt;TextBlock Foreground=&quot;White&quot; FontSize=&quot;20&quot; FontWeight=&quot;Light&quot; TextAlignment=&quot;Center&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;&amp;gt; &amp;lt;Run Text=&quot;Hello World&quot; FontSize=&quot;48&quot;/&amp;gt; &amp;lt;LineBreak/&amp;gt; &amp;lt;Run Text=&quot;walterlv.github.io&quot;/&amp;gt; &amp;lt;/TextBlock&amp;gt; &amp;lt;/Border&amp;gt; &amp;lt;/Grid&amp;gt;&amp;lt;/Window&amp;gt;UWP AcyclicBrushYou can read Microsoft’s documents Acrylic material - UWP app developer - Microsoft Docs for more details about how to write an AcylicBrush." }, { "title": "长期支持 LTS（Long-term Support）是怎样的一种支持方式", "url": "/post/what-is-long-term-support.html", "categories": "", "tags": "dotnet", "date": "2018-12-14 09:54:00 +0800", "snippet": "在 .NET Core 2.1 发布之时，微软称之为一个 LTS 版本，那么 LTS 的版本是一种怎样的版本呢？LTS这是 .NET Core 2.1 的发布博客：Announcing .NET Core 2.1 - .NET Blog；文中说： .NET Core 2.1 will be a long-term support (LTS) release. This means that it is supported for three years. We recommend that you make .NET Core 2.1 your new standard for .NET Core development.LTS 是 long-term support 的缩写，意为长期支持。这是基础库的开发者对库的使用者的一个承诺，保证某个版本的库发布之后的很长一段事件之内都得到支持。如果此版本发现一些紧急问题需要修复，那么就会在这个版本上进行更新。通常这些问题的修复都不会导致 API 变化（API 保证长期兼容），所以版本号的前两位是不变的，通常只变化第三位。微软对 .NET Core 的长期支持策略有两种支持的时长： 某个 release 版本发布之后三年； 后续替代此 release 的另一个新的 release 发布之后一年如果某个库承诺进行长期支持，那么至少数年之内使用这个库都是安全的。这段时间也足够多数开发者进行新库的准备和升级了。LTSC / LTSB对于长期支持还有其他的变种名称，当然也对应着不同的功能。例如 Windows 操作系统使用的 LTSC（Long-Term Servicing Channel）： Overview of System Center LTSC and SAC releases - Microsoft Docs Windows Server Semi-Annual Channel overview - Microsoft Docs Windows Server release information - Microsoft Docs还有已经不怎么使用的 LTSB（Long-Term Servicing Branch）： Documentation Updates for Surface and Windows 10 LTSB Compatibility – SurfaceESR当然也有机构采用 ESR 作为长期支持版本的称呼，ESR 全称为 Extended Support Release。例如 Firefox 的长期支持版本：▲ Firefox ESR Release Overview详见：Firefox Extended Support Release for Your Organization, Business, Enterprise — Mozilla。" }, { "title": "在制作跨平台的 NuGet 工具包时，如何将工具（exe/dll）的所有依赖一并放入包中", "url": "/post/include-dependencies-into-nuget-tool-package.html", "categories": "", "tags": "msbuild, nuget, visualstudio, dotnet", "date": "2018-12-14 09:54:00 +0800", "snippet": "NuGet 提供了工具类型的包支持，生成一个基于 .NET Core 的 dll 或者基于 .NET Framework 的 exe 之后，你几乎可以对项目做任何事情。但是，默认情况下，NuGet 不会将这些工具的依赖一起打包进入 NuGet 包 nupkg 文件内，这就使得功能比较复杂的跨平台 NuGet 工具包几乎是无法正常工作的。本文将介绍将这些依赖加入 NuGet 包中的方法，使得复杂的工具能够正常使用。问题你可能是在 创建一个基于命令行工具的跨平台 NuGet 工具包 的时候遇到依赖问题的，也可能是自己做到另外什么工具遇到的。典型的例子，我正在做一个基于 Roslyn 的 NuGet 工具包。于是整个 Roslyn 的大量 dll 都是我的依赖。但默认情况下，打出来的包并不包含 Roslyn 相关的 dll。探索官方关于 NuGet 的文档 并没有提及任何关于额外添加依赖文件的方法，擅长 NuGet 的大神 Nate McMaster 虽然有一篇关于加入 NuGet 依赖的博客 MSBuild tasks with dependencies，但依然没有很简单地解决。尝试找一个实际将这些依赖 Include 进来，但是不知道什么时机合适。太早了依赖文件还没有生成，太晚了 NuGet 包中即将打的文件早已确认，Include 了也没用。于是，我去阅读了 Microsoft.NET.Sdk 的源码，找到了并没有公开的内部方法来解决这个问题。关于阅读 Microsoft.NET.Sdk 源码的方式，可以参考 解读 Microsoft.NET.Sdk 的源码，你能定制各种奇怪而富有创意的编译过程 和 Reading the Source Code of Microsoft.NET.Sdk, Writing the Creative Extension of Compiling。NuGet 打包的核心在 NuGet.Build.Tasks.Pack.targets 文件，主要是这段代码（省略了大量内容，留下了看起来有点儿关系的部分）：&amp;lt;!-- 已删减大量内容，全部内容请自己阅读源码。 --&amp;gt;&amp;lt;PackTask PackItem=&quot;$(PackProjectInputFile)&quot; PackageFiles=&quot;@(_PackageFiles)&quot; PackageFilesToExclude=&quot;@(_PackageFilesToExclude)&quot; PackageTypes=&quot;$(PackageType)&quot; IsTool=&quot;$(IsTool)&quot; IncludeBuildOutput=&quot;$(IncludeBuildOutput)&quot;/&amp;gt;&amp;lt;/Target&amp;gt;PackageTypes 和 IsTool 是我放来灌水的，这两个属性决定了我们打出来的包的类型（是否是工具类型）。看起来像的是 PackageFiles 和 PackageFilesToExclude 属性，不过这两个属性用到了私有的属性 @(_PackageFiles) 和 @(_PackageFilesToExclude)。所以接下来需要搜索到底是那里在为 @(_PackageFiles) 和 @(_PackageFilesToExclude) 赋值。搜索 &amp;lt;_PackageFiles 可以找到赋值的地方就在 NuGet.Build.Tasks.Pack.targets 文件中：&amp;lt;!-- 已删减大量内容，全部内容请自己阅读源码。 --&amp;gt;&amp;lt;Target Name=&quot;_GetPackageFiles&quot; Condition=&quot;$(IncludeContentInPack) == &#39;true&#39;&quot;&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;_PackageFilesToExclude Include=&quot;@(Content)&quot; Condition=&quot;&#39;%(Content.Pack)&#39; == &#39;false&#39;&quot;/&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;!-- Include PackageFiles and Content of the project being packed --&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;_PackageFiles Include=&quot;@(Content)&quot; Condition=&quot; %(Content.Pack) != &#39;false&#39; &quot;&amp;gt; &amp;lt;BuildAction Condition = &quot;&#39;%(Content.BuildAction)&#39; == &#39;&#39;&quot;&amp;gt;Content&amp;lt;/BuildAction&amp;gt; &amp;lt;/_PackageFiles&amp;gt; &amp;lt;_PackageFiles Include=&quot;@(Compile)&quot; Condition=&quot; %(Compile.Pack) == &#39;true&#39; &quot;&amp;gt; &amp;lt;BuildAction Condition = &quot;&#39;%(Compile.BuildAction)&#39; == &#39;&#39;&quot;&amp;gt;Compile&amp;lt;/BuildAction&amp;gt; &amp;lt;/_PackageFiles&amp;gt; &amp;lt;_PackageFiles Include=&quot;@(None)&quot; Condition=&quot; %(None.Pack) == &#39;true&#39; &quot;&amp;gt; &amp;lt;BuildAction Condition = &quot;&#39;%(None.BuildAction)&#39; == &#39;&#39;&quot;&amp;gt;None&amp;lt;/BuildAction&amp;gt; &amp;lt;/_PackageFiles&amp;gt; &amp;lt;!-- 已删减大量内容，全部内容请自己阅读源码。 --&amp;gt; &amp;lt;/ItemGroup&amp;gt;&amp;lt;/Target&amp;gt;这是一个私有 Target，所以答案已经呼之欲出了。答案我们写一个 Target，将 _GetPackageFiles 设为我们的前置 Target。然后，我们就可以把输出目录中除了 NuGet 自然而然会帮我们打入 NuGet 包中的所有文件都加入到 NuGet 包中的对应目录下。具体来说，是将下面的 Target 添加到项目文件的末尾。&amp;lt;Target Name=&quot;IncludeAllDependencies&quot; BeforeTargets=&quot;_GetPackageFiles&quot;&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;None Include=&quot;$(OutputPath)*.*&quot; Exclude=&quot;$(OutputPath)$(AssemblyName).exe;$(OutputPath)$(AssemblyName).pdb&quot; Pack=&quot;True&quot; PackagePath=&quot;tools\\net47&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt;&amp;lt;/Target&amp;gt;" }, { "title": "使用 LINQ to XML，.NET 让生成 XML 文件变得和直接写 XML 一样轻松", "url": "/post/create-xml-using-linq-to-xml.html", "categories": "", "tags": "dotnet", "date": "2018-12-14 09:54:00 +0800", "snippet": "由 .NET Framework 3.5 引入，并依然在 .NET Core 中发扬光大的 LINQ to XML 让编写 XML 文件变得非常轻松。使用 XElement、XAttribute 我们能够完整构造一个 XML 出来。为了能直观地体会到优势，我写一个最简单的例子：var root = new XElement(&quot;Root&quot;, new XAttribute(&quot;Attribute&quot;, &quot;Walterlv&quot;), new XElement(&quot;Node&quot;, &quot;Content&quot;));构造出来的 XML 将是这样的：&amp;lt;Root Attribute=&quot;Walterlv&quot;&amp;gt; &amp;lt;Node&amp;gt;Content&amp;lt;/Node&amp;gt;&amp;lt;/Root&amp;gt;是不是觉得包括行的安排和缩进在内，都和 XML 一样简单？我们来看一个更复杂的例子，这是直接在编写一个 NuGet 的 nuspec 文件：var xmlns = &quot;http://schemas.microsoft.com/packaging/2012/06/nuspec.xsd&quot;;var root = new XElement(&quot;package&quot;, new XAttribute(XNamespace.Xmlns.ToString(), xmlns), new XElement(&quot;metadata&quot;, new XElement(&quot;id&quot;, &quot;MSTestEnhancer&quot;), new XElement(&quot;version&quot;, &quot;1.6.0&quot;), new XElement(&quot;authors&quot;, &quot;walterlv&quot;), new XElement(&quot;owners&quot;, &quot;walterlv&quot;), new XElement(&quot;requireLicenseAcceptance&quot;, &quot;false&quot;), new XElement(&quot;licenseUrl&quot;, &quot;https://github.com/dotnet-campus/MSTestEnhancer/blob/master/LICENSE&quot;), new XElement(&quot;projectUrl&quot;, &quot;https://dotnet-campus.github.io/mstest-enhancer&quot;), new XElement(&quot;iconUrl&quot;, &quot;https://dotnet-campus.github.io/mstest-enhancer/icon.png&quot;), new XElement(&quot;description&quot;, &quot;MSTestEnhancer helps you to write unit tests without naming any method. You can write method contract descriptions instead of writing confusing test method name when writing unit tests.&quot;), new XElement(&quot;releaseNotes&quot;, &quot;Support passing null into WithArgument method.&quot;), new XElement(&quot;copyright&quot;, &quot;Copyright (c) 2018 dotnet职业技术学院&quot;), new XElement(&quot;repository&quot;, new XAttribute(&quot;type&quot;, &quot;git&quot;), new XAttribute(&quot;url&quot;, &quot;https://github.com/dotnet-campus/MSTestEnhancer.git&quot;)), new XElement(&quot;dependencies&quot;, dependencies.Select(group =&amp;gt; new XElement(&quot;group&quot;, new XAttribute(&quot;targetFramework&quot;, group.Key), group.Value.Select(x =&amp;gt; new XElement(&quot;dependency&quot;, new XAttribute(&quot;id&quot;, x.id), new XAttribute(&quot;version&quot;, x.version), new XAttribute(&quot;exclude&quot;, x.exclude))))) ) ));var document = new XDocument(root);document.Save(@&quot;C:\\Users\\walterlv\\Desktop\\Walterlv.Demo.nuspec&quot;);其中的 dependencies 集合我写在了其他地方，这样更像是动态生成，而不是仅仅为了给一个例子。var dependencies = new Dictionary&amp;lt;string, (string id, string version, string exclude)[]&amp;gt;{ [&quot;.NETFramework4.5&quot;] = new[] { (&quot;MSTest.TestFramework&quot;, &quot;1.2.0&quot;, &quot;Build,Analyzers&quot;), (&quot;System.ValueTuple&quot;, &quot;4.4.0&quot;, &quot;Build,Analyzers&quot;), }, [&quot;.NETFramework4.7&quot;] = new[] { (&quot;MSTest.TestFramework&quot;, &quot;1.2.0&quot;, &quot;Build,Analyzers&quot;), }, [&quot;.NETStandard2.0&quot;] = new[] { (&quot;MSTest.TestFramework&quot;, &quot;1.2.0&quot;, &quot;Build,Analyzers&quot;), }};生成的 nuspec 文件非常像 NuGet 的原生 nuspec 文件。&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;package xmlns=&quot;http://schemas.microsoft.com/packaging/2012/06/nuspec.xsd&quot;&amp;gt; &amp;lt;metadata&amp;gt; &amp;lt;id&amp;gt;MSTestEnhancer&amp;lt;/id&amp;gt; &amp;lt;version&amp;gt;1.6.0&amp;lt;/version&amp;gt; &amp;lt;authors&amp;gt;walterlv&amp;lt;/authors&amp;gt; &amp;lt;owners&amp;gt;walterlv&amp;lt;/owners&amp;gt; &amp;lt;requireLicenseAcceptance&amp;gt;false&amp;lt;/requireLicenseAcceptance&amp;gt; &amp;lt;licenseUrl&amp;gt;https://github.com/easiwin/MSTestEnhancer/blob/master/LICENSE&amp;lt;/licenseUrl&amp;gt; &amp;lt;projectUrl&amp;gt;https://easiwin.github.io/mstest-enhancer&amp;lt;/projectUrl&amp;gt; &amp;lt;iconUrl&amp;gt;https://easiwin.github.io/mstest-enhancer/icon.png&amp;lt;/iconUrl&amp;gt; &amp;lt;description&amp;gt;MSTestEnhancer helps you to write unit tests without naming any method. You can write method contract descriptions instead of writing confusing test method name when writing unit tests.&amp;lt;/description&amp;gt; &amp;lt;releaseNotes&amp;gt;Support passing null into WithArgument method.&amp;lt;/releaseNotes&amp;gt; &amp;lt;copyright&amp;gt;Copyright (c) 2018 dotnet职业技术学院&amp;lt;/copyright&amp;gt; &amp;lt;repository type=&quot;git&quot; url=&quot;https://github.com/easiwin/MSTestEnhancer.git&quot; /&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;group targetFramework=&quot;.NETFramework4.5&quot;&amp;gt; &amp;lt;dependency id=&quot;MSTest.TestFramework&quot; version=&quot;1.2.0&quot; exclude=&quot;Build,Analyzers&quot; /&amp;gt; &amp;lt;dependency id=&quot;System.ValueTuple&quot; version=&quot;4.4.0&quot; exclude=&quot;Build,Analyzers&quot; /&amp;gt; &amp;lt;/group&amp;gt; &amp;lt;group targetFramework=&quot;.NETFramework4.7&quot;&amp;gt; &amp;lt;dependency id=&quot;MSTest.TestFramework&quot; version=&quot;1.2.0&quot; exclude=&quot;Build,Analyzers&quot; /&amp;gt; &amp;lt;/group&amp;gt; &amp;lt;group targetFramework=&quot;.NETStandard2.0&quot;&amp;gt; &amp;lt;dependency id=&quot;MSTest.TestFramework&quot; version=&quot;1.2.0&quot; exclude=&quot;Build,Analyzers&quot; /&amp;gt; &amp;lt;/group&amp;gt; &amp;lt;/dependencies&amp;gt; &amp;lt;/metadata&amp;gt;&amp;lt;/package&amp;gt;参考资料 LINQ to XML 与DOM (C#) - Microsoft Docs 如何：控制命名空间前缀 (C#) (LINQ to XML) - Microsoft Docs" }, { "title": "PasswordVault —— 在 UWP 应用中安全地保存密码", "url": "/post/uwp-password-vault.html", "categories": "", "tags": "uwp", "date": "2018-12-14 09:54:00 +0800", "snippet": "只要你做过自动登录，一定会遇到密码的安全问题。现在大部分的网络服务都已经支持 Token 了，有些已经支持 OAuth2.0，这意味着客户端不怎么需要关心密码的安全保存问题。但是，依然还有一些古老的服务和协议需要直接传输密码，比如邮件的 IMAP 协议。我在 ERMail 应用的开发中就遇到了这样的问题，作为一款邮件客户端，IMAP 协议下的自动登录依然要在用户的本地保存密码。无论你采用哪一种加密协议保存用户的密码，由于客户端与黑客的信息量都是相同的，所以客户端能解密出来黑客就一定能解密出来。所以，单纯地依靠应用自身是无法完成安全的密码保存的，利用操作系统、密码服务器或者其他硬件作为中转是一定需要采用的方案。后两者的成本较高，采用操作系统自带的凭据管理器是成本较低的方案。于是我找到了 PasswordVault。微软官网对 PasswordVault 有全面的介绍：PasswordVault Class (Windows.Security.Credentials) - UWP app developer - Microsoft Docs，使用起来也是非常简单的。通过 Add(PasswordCredential) 方法完成密码的保存，使用 Retrieve(String, String?wt.mc_id=MVP) 完成密码的读取。每一个 UWP 应用之间的 PasswordVault 是独立且互相不可访问的，普通用户也无法直接获取到密码；对于黑客，如果无法黑掉用户账户，也是无法解密出密码的，所以在一般使用场景下，安全性是够的。如果需要保存密码：var vault = new PasswordVault();vault.Add(new PasswordCredential(&quot;Walterlv.Demo.Uwp&quot;, &quot;walterlv&quot;, &quot;t^vxR1kuR7@7*zZh&quot;));其中，walterlv 是保存的用户名，t^vxR1kuR7@7*zZh 是保存的密码。如果需要获取此前保存的密码：var vault = new PasswordVault();var credential = vault.Retrieve(&quot;Walterlv.Demo.Uwp&quot;, &quot;walterlv&quot;);var password = credential.Password;得到的 password 即是密码字符串 t^vxR1kuR7@7*zZh。在 ERMail 中，考虑到多数代码是跨平台的，所以我使用 IPasswordManager 接口来隔离这种 UWP 平台特定的方法。于是 ERMail 的 UWP 版本的密码管理实现就像如下这么简单：using Windows.Security.Credentials;using Walterlv.ERMail.Mailing;namespace Walterlv.ERMail.Utils{ internal class PasswordManager : IPasswordManager { private const string MailVaultResourceName = &quot;Walterlv.ERMail&quot;; internal static IPasswordManager Current = new PasswordManager(); string IPasswordManager.Retrieve(string key) { var vault = new PasswordVault(); var credential = vault.Retrieve(MailVaultResourceName, key); return credential.Password; } void IPasswordManager.Add(string key, string password) { var vault = new PasswordVault(); vault.Add(new PasswordCredential(MailVaultResourceName, key, password)); } }}" }, { "title": "Windows 10 四月更新，文件夹名称也能区分大小写了", "url": "/post/case-sensitive-in-windows-file-system.html", "categories": "", "tags": "windows", "date": "2018-12-14 09:54:00 +0800", "snippet": "Linux 一向都是区分文件和文件夹大小写的。Mac OS 默认不区分文件和文件夹大小写，不过可以配置成支持。而 Windows 向来是不区分文件和文件夹大小写的，但是从 NTFS 开始却又支持区分文件夹大小写。本文将介绍 Windows 10 四月更新带来的新特性 —— 让文件夹名称也能区分大小写。问题本来文件系统是否区分大小写只是单纯风格上的差异，并没有孰优孰劣，但这可让那些跨平台的文件系统难以抉择了。典型的例子就是 Git。我曾经就遭遇过 Git 操作上的大小写敏感性问题，写了一篇博客：解决 Git 重命名时遇到的大小写不敏感的问题。由于 Windows 文件系统对大小写不敏感，所以上面的问题才变得尤其难办，竟然需要通过至少两次提交，并且丢掉单线的 Git 历史记录的方式才能真正完成任务。而单纯让 Git 在仓库中区分大小写竟然会产生两份文件（却无法在 Windows 系统中观察到）。开启方法Windows 10 四月更新终于带来了文件夹区分大小写的支持！使用管理员权限在当前文件夹启动 PowerShell：fsutil.exe file SetCaseSensitiveInfo C:\\Users\\walterlv\\GitDemo enable是的，就是上面这一段非常简单而容易理解的命令即可开启单个文件夹的名称区分大小写功能。只是单个文件夹！如果需要开启其他文件夹，需要多次执行这样的命令。而如果需要关闭对此文件夹的大小写支持，只需要将 enable 改为 disable。fsutil.exe file SetCaseSensitiveInfo C:\\Users\\walterlv\\GitDemo disable看！以上就是在 Windows 10 系统级开启了大小写敏感的我的一个 Git 仓库，这下可以让跨平台的 Git 工作起来在各个系统都一样了。注意事项以上命令的正确运行需要以下条件，缺一不可： Windows 10 四月更新（1803） 安装有 Linux 子系统，即 Windows Subsystem for Linux 所在分区为 NTFS 格式 以管理员权限运行 PowerShell如果没有安装 Linux 子系统，那么运行时会出现以下错误：错误：不支持该请求。▲ 中文版 PowerShellThe request is not supported.▲ 英文版 PowerShell这个问题在 MicrosoftDocs 的 GitHub 仓库中被提到了：fsutil setCaseSensitiveInfo · Issue #977 · MicrosoftDocs/windowsserverdocs。安装 Linux 子系统的方法可以参考微软官方文档：Install Windows Subystem for Linux (WSL) on on Windows 10。如果英文阅读有压力，可以参考毒逆天的博客：Win10 安装 Linux子系统 Ubuntu18.04 / Kali Linux 的体验。简单点，就是管理员权限 PowerShell 敲个命令：Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux或者命令都懒得敲，就是去商店下载（在商店搜索 Linux）：附fsutil file 支持的命令： ⚡ lvyi@walterlv.github.io&amp;gt; fsutil.exe file---- FILE Commands Supported ----createNew Creates a new file of a specified sizefindBySID Find a file by security identifierlayout Query all the information available about the fileoptimizeMetadata Optimize metadata for a filequeryAllocRanges Query the allocated ranges for a filequeryCaseSensitiveInfo Query the case sensitive information for a directoryqueryExtents Query the extents for a filequeryExtentsAndRefCounts Query the extents and their corresponding refcounts for a filequeryFileID Queries the file ID of the specified filequeryFileNameById Displays a random link name for the file IDqueryOptimizeMetadata Query the optimize metadata state for a filequeryValidData Queries the valid data length for a filesetCaseSensitiveInfo Set the case sensitive information for a directorysetShortName Set the short name for a filesetValidData Set the valid data length for a filesetZeroData Set the zero data for a filesetEOF Sets the end of file for an existing filesetStrictlySequential Sets ReFS SMR file as strictly sequentialfsutil 支持的命令： ⚡ lvyi@walterlv.github.io&amp;gt; fsutil.exe---- Commands Supported ----8dot3name 8dot3name managementbehavior Control file system behaviordax Dax volume managementdirty Manage volume dirty bitfile File specific commandsfsInfo File system informationhardlink Hardlink managementobjectID Object ID managementquota Quota managementrepair Self healing managementreparsePoint Reparse point managementresource Transactional Resource Manager managementsparse Sparse file controltiering Storage tiering property managementtransaction Transaction managementusn USN managementvolume Volume managementwim Transparent wim hosting management参考资料 fsutil setCaseSensitiveInfo · Issue #977 · MicrosoftDocs/windowsserverdocs windows - fsutil - The request is not supported after setCaseSensitiveInfo - Stack Overflow" }, { "title": "如何使用 MSBuild Target（Exec）中的控制台输出", "url": "/post/exec-task-of-msbuild-target.html", "categories": "", "tags": "dotnet, msbuild", "date": "2018-12-14 09:54:00 +0800", "snippet": "我曾经写过一篇文章 如何创建一个基于命令行工具的跨平台的 NuGet 工具包，通过编写一个控制台程序来参与编译过程。但是，相比于 基于 Task 的方式，可控制的因素还是太少了。有没有什么办法能够让控制台程序也能与 MSBuild Target 之间发生更多的信息交换呢？答案是有的，通过捕获控制台的输出！捕获控制台输出如果你喜爱阅读文档，那么答案已经不陌生了，在微软的官方文档 Exec Task 中就已经提及了属性 ConsoleToMSBuild。将此属性设置为 True，将能够捕获控制台输出到 MSBuild 中。（不过据说典型的程序员是不爱看文档的）那么，捕获的输出去了哪里呢？我在 如何创建一个基于 MSBuild Task 的跨平台的 NuGet 工具包 中提到了使用 Output 来将 Task 中的参数输出出来。而 Exec 也是这么做的。我们将 ConsoleOutput 输出出来即可。由于这个属性不是 ITaskItem[] 类型的，所以我们只能得到字符串属性，于是只能通过 PropertyName 来接收这样的输出。&amp;lt;Exec ConsoleToMSBuild=&quot;True&quot; Command=&quot;&amp;amp;quot;$(NuGetWalterlvToolPath)&amp;amp;quot;&quot;&amp;gt; &amp;lt;Output TaskParameter=&quot;ConsoleOutput&quot; PropertyName=&quot;OutputOfTheCommand&quot; /&amp;gt;&amp;lt;/Exec&amp;gt;PropertyGroup 转 ItemGroup如果你需要的只是一个字符串，那看完上一节就已经够了。但如果你希望得到的是一组值（例如新增了一组需要编译的文件），那么需要得到的是 ItemGroup 中的多个值，而不是 PropertyGroup 中的单个值。（如果不太明白 ItemGroup 和 PropertyGroup 之间的差别，不要紧，可以阅读 理解 C# 项目 csproj 文件格式的本质和编译流程。）MSBuild 还自带了一个 Task，名为 CreateItem，就是从一段字符串创建一组 Item。通过下面这段代码，我们能将上一节捕获到的属性转换成项的集合。&amp;lt;CreateItem Include=&quot;$(OutputOfTheCommand)&quot;&amp;gt; &amp;lt;Output TaskParameter=&quot;Include&quot; ItemName=&quot;AdditionalCompile&quot; /&amp;gt;&amp;lt;/CreateItem&amp;gt;这样，我们便能够更加完整的代码可能更具有参考意义，所以我贴在了下面：&amp;lt;Project&amp;gt; &amp;lt;Target Name=&quot;GenerateAdditionalCode&quot; BeforeTargets=&quot;CoreCompile&quot;&amp;gt; &amp;lt;Exec ConsoleToMSBuild=&quot;True&quot; Command=&quot;&amp;amp;quot;$(NuGetWalterlvToolPath)&amp;amp;quot;&quot;&amp;gt; &amp;lt;Output TaskParameter=&quot;ConsoleOutput&quot; PropertyName=&quot;OutputOfTheCommand&quot; /&amp;gt; &amp;lt;/Exec&amp;gt; &amp;lt;/Target&amp;gt; &amp;lt;Target Name=&quot;_IncludeGeneratedAdditionalCode&quot; AfterTargets=&quot;GenerateAdditionalCode&quot;&amp;gt; &amp;lt;CreateItem Include=&quot;$(OutputOfTheCommand)&quot;&amp;gt; &amp;lt;Output TaskParameter=&quot;Include&quot; ItemName=&quot;AdditionalCompile&quot; /&amp;gt; &amp;lt;/CreateItem&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;Compile Include=&quot;@(AdditionalCompile)&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;Message Text=&quot;额外添加的编译文件：@(AdditionalCompile)&quot; /&amp;gt; &amp;lt;/Target&amp;gt;&amp;lt;/Project&amp;gt;CreateItem 的转换分隔符CreateItem 从属性或字符串转到项是根据分隔符来区分的。由于使用 @(Item) 来获取项时，会得到一个用 ; 分隔的字符串，所以不难想到我们控制台输出的字符串使用 ; 分隔即能满足我们的转换需求。但事实上这是不行的！因为控制台的转换，每行是有缓冲区限制的，也就是说单行字数不能过多，否则会自动加换行符——这可能导致我们转换成的某一项或者多项中间带了换行符，从而导致错误。于是，建议直接在控制台程序中使用换行符本身作为分隔符，这样便可以去除这样的限制。因为 CreateItem 也是支持换行符分隔的。参考资料 How get exec task output with msbuild - Stack Overflow Exec Task - Visual Studio - Microsoft Docs Empty an MSBuild ItemGroup - Stack Overflow What’s New in MSBuild 15 - Visual Studio - Microsoft Docs Item Element (MSBuild) - Visual Studio - Microsoft Docs" }, { "title": "微软 Windows 系统检测网络连通性（用于显示感叹号）竟然是通过访问一个特殊网址来实现的", "url": "/post/connection-status-icon.html", "categories": "", "tags": "windows", "date": "2018-12-14 09:54:00 +0800", "snippet": "一次我走到了弱网环境中，意外地发现浏览器打开了 http://www.msftconnecttest.com/redirect 网址，随后右下角的网络图标出现了一枚“感叹号”。吹水的推断从直观看来，这个网址的连通性和网络图标上的“感叹号”有着直接的联系。那么到底有没有联系呢？于是去知乎上看看，发现了专业造轮子拉黑抢前排的轮子哥的回复。 vczh 专业造轮子，拉黑抢前排。http://gaclib.net 这个网站是windows用来测试你有没有连上网的（编辑于 2017-05-15而轮子哥是谁呢？Microsoft Office 团队的开发人员，所以对微软产品的一些技术性描述还是有些可信的（虽然吹水占了多数）。轮子哥不要怪我啊（逃不过，吹水归吹水，还是需要更多地了解下这个网址。官方的依据这个网址用于检测网络连接状态，并以图标形式展示给用户。而这个图标称之为“网络连接状态图标”（Connection Status Icon，NCSI）。自 Windows 8 开始，不同版本的 Windows 操作系统有不同的检测网络连接状态的 url，但都是通过 url 来检测的。 Windows 10.0.15063 (1703) 至 10.0.07134 (1803) http://www.msftconnecttest.com/redirect Windows 10.0.14393 (1607) http://www.msftconnecttest.com/connecttest.txt Windows 8/8.1 至 10.0.15063 (1511) http://www.msftncsi.com/ncsi.txt 而 Windows XP/Vista/7 的检测方式有些不同，但都是通过 Network Location Awareness (NLA) 方式来检测的。关于 Windows XP/Vista/7 的检测方式，可以阅读：Network Location Awareness (NLA) and how it relates to Windows Firewall Profiles - Networking Blog。局限性 如果计算机上有多张网络适配器可以工作，但只有一个探测到连通状态，那么图标上依然会有一个感叹号，即探测为“网络受限”。参考资料 开机总是有一个弹窗 http://www.msftconnecttest.com/redirect ? - 知乎 The Network Connection Status Icon - Networking Blog Network Location Awareness (NLA) and how it relates to Windows Firewall Profiles - Networking Blog The Windows Network Connection Status Icon (NCSI) - markwilson.it What must be unblocked for network icon to not say “no internet connection?” - Windows 10 - Spiceworks NLM_CONNECTIVITY enumeration (Windows) msftconnecttest.com - Microsoft Community http://www.msftconnecttest.com/redirect Appendix K: Network Connectivity Status Indicator and Resulting Internet Communication in Windows Vista - Microsoft Docs" }, { "title": "如何编写 WPF 的标记扩展 MarkupExtension，即便在 ControlTemplate/DataTemplate 中也能生效", "url": "/post/wpf-markup-extension-in-control-template.html", "categories": "", "tags": "xaml, wpf", "date": "2018-12-14 09:54:00 +0800", "snippet": "WPF 的标记扩展为 WPF 带来了强大的扩展性。利用自定义的标记扩展，我们能够为 XAML 中的属性提供各种各样种类的值，而不仅限于自带的那一些。不过有小伙伴发现在 ControlTemplate 或 DataTemplate 中编写标记扩展有时并不能正常工作，而本文将提供解决方法。本文并不会详细讲解如何编写 WPF 的标记扩展，如果你想了解相关的知识，建议阅读官网：Markup Extensions and WPF XAML - Microsoft Docs。编写简单的标记扩展一个简单的标记扩展会是像这样：using System.Windows;using System.Windows.Markup;using System.Windows.Media;namespace Walterlv.Demo{ public class RevealBorderBrushExtension : MarkupExtension { public override object ProvideValue(IServiceProvider serviceProvider) { return Brushes.White; } }}这样的标记扩展如此简单，以至于你可以在任意的 XAML 中用。只要赋值的那个属性接受 Brush 类型，就不会出错。然而……有小伙伴写了更加复杂的标记扩展，在标记扩展中还通过 serviceProvider 拿到了目标控件的一些属性。本来一直好好工作的，结果有一天这个标记扩展被用到了 ControlTemplate 上，然后就挂了……挂了……编写能在 ControlTemplate 中使用的标记扩展在 ControlTemplate 中，XAML 标记扩展也是立即执行的，这就意味着当标记扩展中的 ProvideValue 执行时，还没有根据模板创建控件呢，那创建的是什么呢？是一个名为 System.Windows.SharedDp 的对象，不明白是什么？没关系，微软把这个类设置为 internal 了，就是不想让你明白。所以，如果我们的标记扩展需要用到实际控件的一些功能（例如需要订阅事件、需要绑定、需要获取布局……），那么你就需要对 System.Windows.SharedDp 进行判断了。具体来说，是加上这样的判断：if (service.TargetObject.GetType().Name.EndsWith(&quot;SharedDp&quot;)){ return this;}更完整一点写出来，就是这样：using System;using System.ComponentModel;using System.Windows;using System.Windows.Input;using System.Windows.Markup;using System.Windows.Media;namespace Walterlv.Demo{ public class RevealBorderBrushExtension : MarkupExtension { public override object ProvideValue(IServiceProvider serviceProvider) { // 如果没有服务，则直接返回。 if (!(serviceProvider.GetService(typeof(IProvideValueTarget)) is IProvideValueTarget service)) return null; // MarkupExtension 在样式模板中，返回 this 以延迟提供值。 if (service.TargetObject.GetType().Name.EndsWith(&quot;SharedDp&quot;)) return this; // 如果不是 FrameworkElement，那么返回 this 以延迟提供值。 if (!(service.TargetObject is FrameworkElement element)) return this; // 如果是设计时，那么返回白色 if (DesignerProperties.GetIsInDesignMode(element)) return Brushes.White; var window = Window.GetWindow(element); if (window == null) return this; // 这一句是编译不通过的，我只是拿来做示范。 var brush = CreateBrush(window, element); return brush; } }}你可能会觉得这段代码有些熟悉，如果有这种感觉，说明你可能阅读过我的另一篇博客：流畅设计 Fluent Design System 中的光照效果 RevealBrush，WPF 也能模拟实现啦！。" }, { "title": "如何让 .NET Core 命令行程序接受密码的输入而不显示密码明文", "url": "/post/input-password-with-mask-in-cli.html", "categories": "", "tags": "dotnet", "date": "2018-12-14 09:54:00 +0800", "snippet": "如果是在 GUI 中要求用户输入密码，各 UI 框架基本都提供了用于输入密码的控件；在这些控件中，用户在输入密码的时候会显示掩码。然而对于控制台程序来说，并没有用于输入密码的原生方法。本文将讲述一种在控制台中输入密码，并仅显示掩码的方法。开始简单的程序让我们开始一个简单的 .NET Core 控制台程序。static void Main(string[] args){ Console.Write(&quot;用户名: &quot;); var userName = Console.ReadLine(); Console.Write(&quot;密 码: &quot;); var password = Console.ReadLine(); Console.ReadKey();}密码直接显示，暴露无遗。而且，由于我们后面持续不断的有输出，控制台不会清除掉这些输出，所以密码会一直显示到缓冲区中——这显然是不能接受的。写一个让用户输入密码并显示掩码的方法既然控制台本身并没有提供可以为密码进行掩码的方法，那么我们只能自己来写了：public static SecureString ReadPassword(string mask = &quot;*&quot;){ var password = new SecureString(); while (true) { var i = Console.ReadKey(true); if (i.Key == ConsoleKey.Enter) { Console.WriteLine(); break; } if (i.Key == ConsoleKey.Backspace) { if (password.Length &amp;gt; 0) { password.RemoveAt(password.Length - 1); Console.Write(&quot;\\b \\b&quot;); } } else { password.AppendChar(i.KeyChar); Console.Write(mask); } } password.MakeReadOnly(); return password;}方法内部接受用户的输入——如果是回车，则确认；如果是退格，则删除一个字；其他情况下输出掩码。全程使用安全的字符串 SecureString，这种字符串是没有办法直接通过托管代码获取值的。这时再输入字符串，将只能看到掩码——再也看不出来 walterlv 是不是一个逗比 了……需要注意的是，在 password 返回之前，我们调用了 SecureString.MakeReadOnly() 方法，将字符串设为只读，确保返回之后不会再被外面修改。转换密码当然，只有对安全级别比较高的库才会接受 SecureString 类型的字符串作为密码；一些简单的库只接受字符串类型的密码。那么在这些简单的库中我们如何才能得到普通的字符串呢？可以使用 Marshal 来完成：private static string ConvertToString(SecureString value){ var valuePtr = IntPtr.Zero; try { valuePtr = Marshal.SecureStringToGlobalAllocUnicode(value); return Marshal.PtrToStringUni(valuePtr); } finally { Marshal.ZeroFreeGlobalAllocUnicode(valuePtr); }}也可以间接使用 NetworkCredential 完成：private static string ConvertToString(SecureString secureString){ return new NetworkCredential(string.Empty, secureString).Password;}因为 NetworkCredential 的内部其实也是使用类似的方式获取到字符串的（详见 SecureStringHelper.CreateString - Reference Source）。internal static string CreateString(SecureString secureString){ string plainString; IntPtr bstr = IntPtr.Zero; if (secureString == null || secureString.Length == 0) return String.Empty; try { bstr = Marshal.SecureStringToBSTR(secureString); plainString = Marshal.PtrToStringBSTR(bstr); } finally { if (bstr != IntPtr.Zero) Marshal.ZeroFreeBSTR(bstr); } return plainString;}参考资料 c# - Password masking console application - Stack Overflow c# - How to convert SecureString to System.String? - Stack Overflow SecureString.MakeReadOnly Method (System.Security) - Microsoft Docs SecureStringHelper.CreateString - Reference Source" }, { "title": "如何编写基于 Microsoft.NET.Sdk 的跨平台的 MSBuild Target（附各种自带的 Task）", "url": "/post/write-msbuild-target.html", "categories": "", "tags": "visualstudio, msbuild", "date": "2018-12-14 09:54:00 +0800", "snippet": "我之前写过一篇 理解 C# 项目 csproj 文件格式的本质和编译流程，其中，Target 节点就是负责编译流程的最关键的节点。但因为篇幅限制，那篇文章不便详说。于是，我在本文说说 Target 节点。Target 的节点结构&amp;lt;Target&amp;gt; 内部几乎有着跟 &amp;lt;Project&amp;gt; 一样的节点结构，内部也可以放 PropertyGroup 和 ItemGroup，不过还能放更加厉害的 Task。按照惯例，我依然用思维导图将节点结构进行了总结：▲ 上面有绿线和蓝线区分，仅仅是因为出现了交叉，怕出现理解歧义&amp;lt;Hash&amp;gt; 和 &amp;lt;WriteCodeFragment&amp;gt; 都是 Task。我们可以看到，Task 是多种多样的，它可以占用一个 xml 节点。而本例中，WriteCodeFragment Task 就是生成代码文件，并且将生成的文件作为一项 Compile 的 Item 和 FileWrites 的 Item。在 理解 C# 项目 csproj 文件格式的本质和编译流程 中我们提到 ItemGroup 的节点，其作用由 Target 指定。所有 Compile 会在名为 CoreCompile 的 Target 中使用，而 FileWrites 在 Microsoft.NET.Sdk 的多处都生成了这样的节点，不过目前从我查看到的全部 Microsoft.NET.Sdk 中，发现内部并没有使用它。Target 执行的时机和先后顺序既然 &amp;lt;Target&amp;gt; 内部节点很大部分跟 &amp;lt;Project&amp;gt; 一样，那区别在哪里呢？&amp;lt;Project&amp;gt; 里的 &amp;lt;PropertyGroup&amp;gt; 和 &amp;lt;ItemGroup&amp;gt; 是静态的状态，如果使用 Visual Studio 打开项目，那么所有的状态将会直接在 Visual Studio 的项目文件列表和项目属性中显示；而 &amp;lt;Target&amp;gt; 内部的 &amp;lt;PropertyGroup&amp;gt; 和 &amp;lt;ItemGroup&amp;gt; 是在编译期间动态生成的，不会在 Visual Studio 中显示；不过，它为我们提供了一种在编译期间动态生成文件或属性的能力。总结起来就是——Target 是在编译期间执行的。不过，同样是编译期间，那么多个 Target，它们之间的执行时机是怎么确定的呢？一共有五个属性决定了 Target 之间的执行顺序： Project 的属性 InitialTargets 项目初始化的时候应该执行的 Target DefaultTargets 如果没有指定执行的 Target，那么这个属性将指定执行的 Target Target 的属性 DependsOnTargets 在执行此 Target 之前应该执行的另一个或多个 Target BeforeTargets 这是 MSBuild 4.0 新增的，指定应该在另一个或多个 Target 之前执行 AfterTargets 这也是 MSBuild 4.0 新增的，指定应该在另一个或多个 Target 之后执行 通过指定这些属性，我们的 Target 能够被 MSBuild 自动选择合适的顺序进行执行。例如，当我们希望自定义版本号，那么就需要赶在我们此前提到的 GenerateAssemblyInfo 之前执行。Microsoft.NET.Sdk 为我们提供的现成可用的 Task有 Microsoft.NET.Sdk 的帮助，我们可以很容易地编写自己的 Target，因为很多功能它都帮我们实现好了，我们排列组合一下就好。 Copy 复制文件 Rosyln 如何使用 MSBuild Copy 复制文件 Move 移动文件 Move Task Delete 删除文件 Message 显示一个输出信息（我在 如何创建一个基于 MSBuild Task 的跨平台的 NuGet 工具包 中利用这个进行调试） Warning 显示一个警告信息 Error 报错（这样，编译就会以错误结束） CombinePath, ConvertToAbsolutePath 拼接路径，转成绝对路径 CreateItem, CreateProperty 创建项或者属性 Csc 调用 csc.exe 编译 Csc Task MSBuild 编译一个项目 MSBuild Task Exec 执行一个外部命令（我在 如何创建一个基于命令行工具的跨平台的 NuGet 工具包 一文中利用到了这个 Task 执行命令） WriteCodeFragment 生成一段代码 WriteCodeFragment Task WriteLinesToFile 向文件中写文字 WriteLinesToFile Task提供的 Task 还有更多，如果上面不够你写出想要的功能，可以移步至官方文档翻阅：MSBuild Task Reference - Visual Studio - Microsoft Docs。使用自己写的 Task我有另外的一篇文章来介绍如何创建一个基于 MSBuild Task 的跨平台的 NuGet 工具包 - 吕毅。如果希望自己写 Ta差量编译如果你认为自己写的 Target 执行比较耗时，那么就可以使用差量编译。我另写了一篇文章专门来说 Target 的差量编译：每次都要重新编译？太慢！让跨平台的 MSBuild/dotnet build 的 Target 支持差量编译 - 吕毅。参考资料 Target Build Order - Visual Studio - Microsoft Docs MSBuild Task Reference - Visual Studio - Microsoft Docs" }, { "title": "C# 中那些可以被重载的运算符（操作符），以及使用它们的那些丧心病狂的语法糖", "url": "/post/overridable-operators-in-csharp.html", "categories": "", "tags": "csharp", "date": "2018-12-14 09:54:00 +0800", "snippet": "C# 中的运算符重载并不新鲜。然而，到底有哪些运算符可以重载，重载运算符可以用来做哪些丧心病狂的事情呢？本文收集了 C# 中所有可以重载的运算符，并且利用他们做了一些丧心病狂的语法糖。可以重载的运算符运算符的重载比想象中的更加强大。因为——重载运算符时可以随意定义运算符中操作数的数据类型和返回值的类型。是的！不只是操作数，连返回值类型也能被重载！一元运算符+, -, !, ~, ++, --, true, false通过重载这些运算符，你可以改变某种类型操作后的返回类型和返回值。不过，等等！+ 和 - 怎么会是一元运算符？不要忘了正数和负数哦！+5，-6 这些其实是在使用一元运算符，而不是单纯的整数哦。true 和 false 也能被重载？是的，重载之后，你可以改变 if(foo) 这样的判断的行为。参见：C# 很少人知道的科技。二元运算符+, -, *, /, %, &amp;amp;, |, ~, ^, &amp;lt;&amp;lt;, &amp;gt;&amp;gt;其中 ~ 运算符的重载是微软运算符重载部分的官方文档中并没有提及的。不过 Avalonia 项目利用这个不怎么常用的运算符做出了丧心病狂的绑定语法糖。参见 Avalonia/Popup.cs at master · AvaloniaUI/Avalonia。_popupRoot = new PopupRoot(DependencyResolver){ [~ContentControl.ContentProperty] = this[~ChildProperty], [~WidthProperty] = this[~WidthProperty], [~HeightProperty] = this[~HeightProperty], [~MinWidthProperty] = this[~MinWidthProperty], [~MaxWidthProperty] = this[~MaxWidthProperty], [~MinHeightProperty] = this[~MinHeightProperty], [~MaxHeightProperty] = this[~MaxHeightProperty],};必须成对重载的运算符==, !=, &amp;lt;, &amp;gt;, &amp;lt;=, &amp;gt;=其实成对重载并不是什么很大的限制，大不了都写了就行。不过，重载它们依然能写出强大的语法糖代码来。只能被间接重载的运算符索引器，显示转换或隐式转换[], (T) x前面 Avalonia 的绑定语法糖就充分利用了索引器的特点，使得能够在对象初始化器中初始化那些本没有直接定义在类型中的属性。赋值运算符+=, -=, *=, /=, %=, &amp;amp;=, |=, ^=, &amp;lt;&amp;lt;=, &amp;gt;&amp;gt;=这些运算符不可被重载。不过，其实它们都算作是原本的二元运算符与赋值操作的组合。所以，可以通过重载二元运算符来达到间接重载这些运算符。（当然，这样的方式，其赋值的作用是绝对丢不掉的）。逻辑运算符$$, || 可以阅读：[C# 重载条件逻辑运算符（&amp;amp;&amp;amp; 和   ） - walterlv](/post/overload-conditional-and-and-or-operators-in-csharp) ?:通过重载 true 和 false 一元运算符可以达到目的。??可以阅读：C# 空合并运算符（??）不可重载？其实有黑科技可以间接重载！不可被重载的运算符=, ., ?:, ??, -&amp;gt;, =&amp;gt;, as, checked, unchecked, default, delegate, is, new, sizeof, typeof如果你还发现了其他黑科技来重载那些本不可以被重载的操作符，欢迎留言探讨。参考资料 Overloadable Operators (C# Programming Guide) - Microsoft Docs" }, { "title": "如何快速编写和调试 Emit 生成 IL 的代码", "url": "/post/how-to-quickly-write-emit-code.html", "categories": "", "tags": "dotnet, csharp", "date": "2018-12-14 09:54:00 +0800", "snippet": ".NET Core/.NET Framework 的 System.Reflection.Emit 命名空间为我们提供了动态生成 IL 代码的能力。利用这项能力，我们能够在运行时生成一段代码/一个方法/一个类/一个程序集。大家都知道反射的性能很差，通过缓存反射调用的方法则能够大幅提升性能。Emit 为我们提供了这项能力，我们能够在运行时生成一段代码，替代使用反射动态调用的代码，以提升性能。我们在解决什么问题？之前我写过一篇创建委托以大幅度提高反射调用的性能的方法，不过此方法适用于预先知道方法参数和返回值类型的情况。如果我们在编译期不知道类型，那么它就行不通了。（原因？注意到那篇文章中返回的委托有类型强转吗？也就是说需要编译期确定类型，即便是泛型。）例如，我们在运行时得到一个对象，希望为这个对象的部分或全部属性赋值；此对象的类型和属性类型在编译期全部不可知（就算是泛型也没有）。 class SomeClass{ [DefaultValue(&quot;walterlv&quot;)] public string SomeProperty { get; set; }} 众所周知的反射能够完成这个目标，但它不是本文讨论的重点；因为一旦这样的方法会被数万数十万甚至更多次调用的时候，反射将造成性能灾难。既然反射不行，通过反射的创建委托也不行，那还有什么方法？ 使用表达式树（不是本文重点） 使用 Emit（本文）如果事先不能知道类型，那么只能每次通过反射去动态的调用，于是才会耗费大量的性能。如果我们能够在运行时动态地生成一段调用方法，那么这个调用方法将可以缓存下来供后续重复调用。如果我们使用 Emit，那么生成的方法与静态编写的代码是一样的，于是就能获得普通方法的性能。为了实现动态地设置未知类型未知属性的值，我决定写出如下方法： static void SetPropertyValue(object @this, object value){ ((类的类型) @this).属性名称 = (属性的类型) value;} 不用考虑编译问题了，这段代码是肯定编译不过的。方法是一个静态方法，传入两个参数——类型的实例和属性的新值；方法内部为实例中某个属性赋新值。类的类型、属性名称和属性的类型是编译期不能确定，但可以在运行时确定的；如果此生成的方法会被大量调用，那么性能优势将极其明显。快速编写 Emit为了快速编写和调试 Emit，我们需要 ReSharper 全家桶： ReSharper - 用于实时查看 IL 代码 dotPeek - 免费，用于查看我们使用 Emit 生成的代码，便于对比分析相比于原生 Visual Studio，有此工具帮助的情况下，IL 的编写速度和调试速度将得到质的提升。（当然，利用这些工具依然只是手工操作，存在瓶颈；如果你阅读完本文之后找到或编写一个新的工具，更快，欢迎与我探讨。）ReSharper 提供了 IL Viewer 窗格，从菜单依次进入 ReSharper-&amp;gt;Windows-&amp;gt;IL Viewer 可以打开。打开后立即可以看到我们当前正在编写的代码的 IL，而且还能高亮光标所在的代码块。（如果你的 IL Viewer 中没有代码或没有高亮，编译一遍项目即可。）我们要做的，就是得知 SetPropertyValue 在编译后将得到什么样的 IL 代码，这样我们才能编写出正确的 IL 生成代码来。于是编写这些辅助代码：namespace Walterlv.Demo{ class Program { static void Main(string[] args) { var instance = new TempClass(); SetPropertyValue(instance, &quot;test&quot;); } static void SetPropertyValue(object @this, object value) { ((TempClass) @this).TempProperty = (string) value; } } public class TempClass { public string TempProperty { get; set; } }}编译之后去 IL Viewer 中看 SetPropertyValue 的 IL 代码：.method private hidebysig static void SetPropertyValue( object this, object &#39;value&#39; ) cil managed { .maxstack 8 // [14 9 - 14 10] IL_0000: nop // [15 13 - 15 63] IL_0001: ldarg.0 // this IL_0002: castclass Walterlv.Demo.TempClass IL_0007: ldarg.1 // &#39;value&#39; IL_0008: castclass [System.Runtime]System.String IL_000d: callvirt instance void Walterlv.Demo.TempClass::set_TempProperty(string) IL_0012: nop // [16 9 - 16 10] IL_0013: ret } // end of method Program::SetPropertyValue将这段 IL 代码抄下来。怎么抄呢？看下面我抄的代码，你应该能够很容易看出里面一一对应的关系。public static Action&amp;lt;object, object&amp;gt; CreatePropertySetter(PropertyInfo propertyInfo){ var declaringType = propertyInfo.DeclaringType; var propertyType = propertyInfo.PropertyType; // 创建一个动态方法，参数依次为方法名、返回值类型、参数类型。 // 对应着 IL 中的 // .method private hidebysig static void // SetPropertyValue( // ) cil managed var method = new DynamicMethod(&quot;&amp;lt;set_Property&amp;gt;&quot;, typeof(void), new[] {typeof(object), typeof(object)}); var il = method.GetILGenerator(); // 定义形参。注意参数位置从 1 开始——即使现在在写静态方法。 // 对应着 IL 中的 // object this, // object &#39;value&#39; method.DefineParameter(1, ParameterAttributes.None, &quot;this&quot;); method.DefineParameter(2, ParameterAttributes.None, &quot;value&quot;); // 用 Emit 生成 IL 代码。 // 对应着 IL 中的各种操作符。 il.Emit(OpCodes.Nop); il.Emit(OpCodes.Ldarg_0); il.Emit(OpCodes.Castclass, declaringType); il.Emit(OpCodes.Ldarg_1); // 注意：下一句代码会在文章后面被修改。 il.Emit(OpCodes.Castclass, propertyType); il.Emit(OpCodes.Callvirt, propertyInfo.GetSetMethod()); il.Emit(OpCodes.Nop); il.Emit(OpCodes.Ret); // 为生成的动态方法创建调用委托，返回返回这个委托。 return (Action&amp;lt;object, object&amp;gt;) method.CreateDelegate(typeof(Action&amp;lt;object, object&amp;gt;));}现在我们用下面新的代码替换之前写在 Main 中直接赋值的代码：static void Main(string[] args){ // 测试代码。 var instance = new TempClass(); var propertyInfo = typeof(TempClass).GetProperties().First(); // 调用 Emit 核心代码。 var setValue = QuickEmit.CreatePropertySetter(propertyInfo); // 测试生成的核心代码能否正常工作。 setValue(instance, &quot;test&quot;);}直接运行，在 setValue 之后我们查看 instance 中 TempProperty 属性的值，可以发现已经成功修改了。大功告成！快速调试和修改 Emit才没有大功告成呢！试试把 TempProperty 的类型改为 int。把测试代码中传入的 &quot;test&quot; 字符串换成数字 5。运行看看：▲ 为什么会崩溃？！崩溃提示是“操作可能造成运行时的不稳定”。是什么造成了运行时的不稳定呢？难道是我们写的 IL 不对？现在开始利用 dotPeek 进行 IL 的调试。我们编写另外一个方法，用于将我们的生成的 IL 代码输出到 dll 文件。public static void OutputPropertySetter(PropertyInfo propertyInfo){ var declaringType = propertyInfo.DeclaringType; var propertyType = propertyInfo.PropertyType; // 准备好要生成的程序集的信息。 var assemblyName = new AssemblyName(&quot;Temp&quot;); var assembly = AppDomain.CurrentDomain.DefineDynamicAssembly(assemblyName, AssemblyBuilderAccess.Save); var module = assembly.DefineDynamicModule(assemblyName.Name, assemblyName.Name + &quot;.dll&quot;); var type = module.DefineType(&quot;Temp&quot;, TypeAttributes.Public); var method = type.DefineMethod(&quot;&amp;lt;set_Property&amp;gt;&quot;, MethodAttributes.Static - MethodAttributes.Public, CallingConventions.Standard, typeof(void), new[] { typeof(object), typeof(object) }); var il = method.GetILGenerator(); // 跟之前一样生成 IL 代码。 method.DefineParameter(1, ParameterAttributes.None, &quot;this&quot;); method.DefineParameter(2, ParameterAttributes.None, &quot;value&quot;); il.Emit(OpCodes.Nop); il.Emit(OpCodes.Ldarg_0); il.Emit(OpCodes.Castclass, declaringType); il.Emit(OpCodes.Ldarg_1); il.Emit(OpCodes.Castclass, propertyType); il.Emit(OpCodes.Callvirt, propertyInfo.GetSetMethod()); il.Emit(OpCodes.Nop); il.Emit(OpCodes.Ret); // 将 IL 代码输出到程序的同级目录下。 type.CreateType(); assembly.Save($&quot;{assemblyName.Name}.dll&quot;);}同样的，作为对照，我们在我们的测试程序中也修改那个参考代码。 static void SetPropertyValue(object @this, object value){ // 注意！注意！string 已经换成了 int。 ((TempClass) @this).TempProperty = (int) value;} 重新生成可以得到一个 exe，调用新写的 OutputPropertySetter 可以得到 Temp.dll。于是我们的输出目录下现在存在两个程序集：将他们都拖进 dotPeek 中，然后在顶部菜单 Windows-&amp;gt;IL Viewer 中打开 IL 显示窗格。发现什么了吗？是的！对于结构体，用的是拆箱！！！而不是强制类型转换。知道有了拆箱，于是就能知道应该怎样改了，生成 IL 的代码中 Castclass 部分应该根据条件进行判断：var castingCode = propertyInfo.PropertyType.IsValueType ? OpCodes.Unbox_Any : OpCodes.Castclass;il.Emit(castingCode, propertyType);现在运行，即可正常通过。如果你希望拥有完整的代码，可以自行将以上两句替换掉此前注释说明了 注意：下一句代码会在文章后面被修改。 的地方。更进一步 如果要 Emit 的代码中存在 if-else 这样的非顺序结构怎么办？阅读 使用 Emit 生成 IL 代码 - 吕毅 可以了解做法。 我们可以用 int 为 double 类型的属性赋值，但在本例代码中却不可行，如何解决这种隐式转换的问题？如果你尝试编写了 Emit 的代码，那么上面的问题应该难不倒你。总结 通过 Emit，我们能够在运行时动态生成 IL 代码，以解决反射动态调用方法造成的大量性能损失。 通过 ReSharper 插件，我们可以实时查看生成的 IL 代码。 我们可以将 Emit 生成的代码输出到程序集文件。 通过 dotPeek，我们可以查看程序集中类型和方法的 IL 代码。参考资料 生成方法签名与元数据 ParameterBuilder Class (System.Reflection.Emit) MethodBuilder.DefineParameter Method (Int32, ParameterAttributes, String) (System.Reflection.Emit) Defining a Parameter with Reflection Emit c# - How to set “.maxstack” with ILGenerator - Stack Overflow 生成方法体 ILGenerator.DefineLabel Method (System.Reflection.Emit) ILGenerator.MarkLabel Method (Label) (System.Reflection.Emit) c# - Emit local variable and assign a value to it - Stack Overflow C# reflection: If … else? - Stack Overflow ILGenerator.Emit Method ILGenerator.Emit Method (System.Reflection.Emit) ILGenerator.Emit Method (OpCode, String) (System.Reflection.Emit) ILGenerator.Emit Method (OpCode, MethodInfo) (System.Reflection.Emit) ILGenerator.EmitCall Method (OpCode, MethodInfo, Type[]) (System.Reflection.Emit) .net - Call and Callvirt - Stack Overflow IL 操作 OpCodes.Ldarg_0 Field (System.Reflection.Emit) OpCodes.Brfalse_S Field (System.Reflection.Emit) 输出程序集 c# - Is there a way to view the generated IL code of a DynamicMethod (in Sigil)? - Stack Overflow c# - Can I use Reflection.Emit for generating code and save generated codes in .cs files or I could use CodeDom? - Stack Overflow AssemblyBuilder.Save Method (String) (System.Reflection.Emit) 运行时错误 c# - Reflection.emit System.InvalidProgramException: Common Language Runtime detected an invalid program - Stack Overflow “Operation could destabilize the runtime.” when using IL to create a DynamicMethod · Issue #14 · jbevain/mono.reflection c# - Emit Operation could destabilize the runtime for incrementing field - Stack Overflow .NET 4.5 : Operation could destabilize the runtime (yikes!) - ElegantCode c# - Operation could destabilize the runtime? - Stack Overflow 其他 Generating and Compiling Source Code from a CodeDOM Graph - Microsoft Docs " }, { "title": "UWP 流畅设计中的光照效果（容易的 RevealBorderBrush 和不那么容易的 RevealBackgroundBrush）", "url": "/post/uwp-reveal-background-brush.html", "categories": "", "tags": "uwp, xaml", "date": "2018-12-14 09:54:00 +0800", "snippet": "在 Windows 10.0.16299 中，RevealBrush 被引入，可以实现炫酷的鼠标滑过高亮效果和点击光照。本文将告诉大家如何完整地实现这样的效果。Reveal 的效果（自带）在微软官方推荐的 XAML Controls Gallery 应用中，我们可以找到 Reveal 的实现章节。下图是应用中演示的 Reveal 效果：不过在其实现中，全都是使用的系统自带的样式，例如：&amp;lt;Button Style=&quot;{StaticResource ButtonRevealStyle}&quot; Content=&quot;Button&quot; /&amp;gt;&amp;lt;Grid HorizontalAlignment=&quot;Center&quot; Margin=&quot;5&quot; Background=&quot;{ThemeResource CustomAcrylicInAppBrush_dark}&quot; RequestedTheme=&quot;Dark&quot;&amp;gt; &amp;lt;StackPanel Orientation=&quot;Vertical&quot;&amp;gt; &amp;lt;StackPanel Orientation=&quot;Horizontal&quot;&amp;gt; &amp;lt;AppBarButton Style=&quot;{ThemeResource AppBarButtonRevealStyle}&quot; Icon=&quot;World&quot; Margin=&quot;1, 2, 0, 0&quot;/&amp;gt; &amp;lt;AppBarButton Style=&quot;{ThemeResource AppBarButtonRevealStyle}&quot; Icon=&quot;CellPhone&quot; Margin=&quot;0, 2, 1, 0&quot;/&amp;gt; &amp;lt;/StackPanel&amp;gt; &amp;lt;StackPanel Orientation=&quot;Horizontal&quot;&amp;gt; &amp;lt;AppBarButton Style=&quot;{ThemeResource AppBarButtonRevealStyle}&quot; Icon=&quot;Delete&quot; Margin=&quot;1, 2, 0, 2&quot;/&amp;gt; &amp;lt;AppBarButton Style=&quot;{ThemeResource AppBarButtonRevealStyle}&quot; Icon=&quot;Comment&quot; Margin=&quot;0, 2, 1, 2&quot;/&amp;gt; &amp;lt;/StackPanel&amp;gt; &amp;lt;/StackPanel&amp;gt;&amp;lt;/Grid&amp;gt;Reveal 的制作（自己实现）采用自带效果的控件看起来实现很容易，不过 UWP 控件的自带样式略坑，自己实现控件样式和模板是不可避免的事儿。这是定制的 ListViewItem 的模板的一部分，写了 RevealBorderBrush 和 RevealBackgroundBrush。&amp;lt;Grid x:Name=&quot;Root&quot; Width=&quot;120&quot; Height=&quot;40&quot; BorderThickness=&quot;0 1 1 0&quot;&amp;gt; &amp;lt;Grid.BorderBrush&amp;gt; &amp;lt;RevealBorderBrush /&amp;gt; &amp;lt;/Grid.BorderBrush&amp;gt; &amp;lt;Grid.Background&amp;gt; &amp;lt;RevealBackgroundBrush /&amp;gt; &amp;lt;/Grid.Background&amp;gt; &amp;lt;ContentPresenter /&amp;gt;&amp;lt;/Grid&amp;gt;运行看，发现只有边框效果，背景效果是不存在的。然而官方文档对于 RevealBackgroundBrush 的实现竟然没有提及，也是挺奇怪的。比如：Reveal highlight - UWP app developer - Microsoft Docs 和 RevealBackgroundBrush Class (Windows.UI.Xaml.Media) - UWP app developer - Microsoft Docs 。注意到 RevealBackgroundBrush 有一个附加属性 RevealBrush.State，设置到控件上用于指定采用哪一种光照效果：RevealBrush.State=&quot;Pressed&quot;。直接将其设置到控件上，发现依然是没有效果的：看来需要动态地改变，于是必须加上 VisualStateManager。&amp;lt;Grid x:Name=&quot;Root&quot; Width=&quot;120&quot; Height=&quot;40&quot; BorderThickness=&quot;0 1 1 0&quot;&amp;gt; &amp;lt;Grid.BorderBrush&amp;gt; &amp;lt;RevealBorderBrush /&amp;gt; &amp;lt;/Grid.BorderBrush&amp;gt; &amp;lt;Grid.Background&amp;gt; &amp;lt;RevealBackgroundBrush /&amp;gt; &amp;lt;/Grid.Background&amp;gt; &amp;lt;ContentPresenter /&amp;gt; &amp;lt;VisualStateManager.VisualStateGroups&amp;gt; &amp;lt;VisualStateGroup x:Name=&quot;CommonStates&quot;&amp;gt; &amp;lt;VisualState x:Name=&quot;Normal&quot; /&amp;gt; &amp;lt;VisualState x:Name=&quot;Selected&quot; /&amp;gt; &amp;lt;VisualState x:Name=&quot;PointerOver&quot;&amp;gt; &amp;lt;VisualState.Setters&amp;gt; &amp;lt;Setter Target=&quot;Root.(RevealBrush.State)&quot; Value=&quot;PointerOver&quot;/&amp;gt; &amp;lt;/VisualState.Setters&amp;gt; &amp;lt;/VisualState&amp;gt; &amp;lt;VisualState x:Name=&quot;PointerOverSelected&quot;&amp;gt; &amp;lt;VisualState.Setters&amp;gt; &amp;lt;Setter Target=&quot;Root.(RevealBrush.State)&quot; Value=&quot;PointerOver&quot;/&amp;gt; &amp;lt;/VisualState.Setters&amp;gt; &amp;lt;/VisualState&amp;gt; &amp;lt;VisualState x:Name=&quot;PointerOverPressed&quot;&amp;gt; &amp;lt;VisualState.Setters&amp;gt; &amp;lt;Setter Target=&quot;Root.(RevealBrush.State)&quot; Value=&quot;Pressed&quot;/&amp;gt; &amp;lt;/VisualState.Setters&amp;gt; &amp;lt;/VisualState&amp;gt; &amp;lt;VisualState x:Name=&quot;Pressed&quot;&amp;gt; &amp;lt;VisualState.Setters&amp;gt; &amp;lt;Setter Target=&quot;Root.(RevealBrush.State)&quot; Value=&quot;Pressed&quot;/&amp;gt; &amp;lt;/VisualState.Setters&amp;gt; &amp;lt;/VisualState&amp;gt; &amp;lt;VisualState x:Name=&quot;PressedSelected&quot;&amp;gt; &amp;lt;VisualState.Setters&amp;gt; &amp;lt;Setter Target=&quot;Root.(RevealBrush.State)&quot; Value=&quot;Pressed&quot;/&amp;gt; &amp;lt;/VisualState.Setters&amp;gt; &amp;lt;/VisualState&amp;gt; &amp;lt;/VisualStateGroup&amp;gt; &amp;lt;VisualStateGroup x:Name=&quot;DisabledStates&quot;&amp;gt; &amp;lt;VisualState x:Name=&quot;Enabled&quot;/&amp;gt; &amp;lt;VisualState x:Name=&quot;Disabled&quot;&amp;gt; &amp;lt;VisualState.Setters&amp;gt; &amp;lt;Setter Target=&quot;Root.RevealBorderThickness&quot; Value=&quot;0&quot;/&amp;gt; &amp;lt;/VisualState.Setters&amp;gt; &amp;lt;/VisualState&amp;gt; &amp;lt;/VisualStateGroup&amp;gt; &amp;lt;/VisualStateManager.VisualStateGroups&amp;gt;&amp;lt;/Grid&amp;gt;在以上这段新的代码中，我们适时在指针设备滑过的时候切换 RevealBrush.State 为 PointerOver，在按下时切换 RevealBrush.State 为 Pressed。再次运行才发现背景光照效果正常出现了。本文相关 本文所设计的源码来自我的一个个人兴趣项目，已在 GitHub 上开源：walterlv/AssembleMailing。 我写过另一篇让 WPF 实现光照效果的博客：流畅设计 Fluent Design System 中的光照效果 RevealBrush，WPF 也能模拟实现啦！" }, { "title": "使用 MSBuild 响应文件 (rsp) 来指定 dotnet build 命令行编译时的大量参数", "url": "/post/msbuild-response-files.html", "categories": "", "tags": "visualstudio, msbuild", "date": "2018-12-14 09:54:00 +0800", "snippet": "在为开源项目 dotnet-campus/MSTestEnhancer 进行持续集成编译时，需要在编译命令中传入较多的参数。这对于新接手此项目的人来说，成本还是高了一点儿。本文将介绍 MSBuild 响应文件 (MSBuild Response Files, *.rsp) 来优化命令行编译体验。我们在 msbuild 命令中加入 /? 参数可以看到它对响应文件的解释：&amp;gt; dotnet build /?# 省略了一部分输出，只保留响应文件相关的两个。@&amp;lt;file&amp;gt; 从文本文件插入命令行设置。若要指定 多个响应文件，请分别指定每个响应 文件。 自动从以下位置使用任何名为 &quot;msbuild.rsp&quot; 的 响应文件: (1) msbuild.exe 的目录 (2) 生成的第一个项目或解决方案的目录/noautoresponse 不自动包括任何 MSBuild.rsp 文件。(缩写: /noautorsp)当然，使用 dotnet msbuild 或者直接使用 msbuild.exe 都是一样的具备此功能。那么响应文件到底是什么呢？我们在 dotnet build 命令后传入的参数就可以是响应文件的内容。 响应文件以 .rsp 扩展名结尾，放在任何地方就行，只需要在 dotnet build 命令中用 @ 指定即可。 也可以用预定的文件名 Directory.Build.rsp，放在 sln 同级目录或者父级目录中。比如，在这个项目中，我直接在解决方案同级目录中新建了 Directory.Build.rsp 文件，并写入这些内容：/p:Configuration=Release/maxcpucount/p:Version=1.6.0-beta/p:AssemblyVersion=1.6.0.0这样，当执行命令 dotnet build 或 dotnet msbuild 时，将执行这些事情： 使用 Release 配置进行编译 当前计算机有多少 CPU 核，就使用多少个进程进行并行编译 NuGet 包打包版本设置为 1.6.0-beta（这将覆盖 csproj 中设置的 Version 属性） 程序集版本设置为 1.6.0。0（这将覆盖 csproj 中设置的 AssemblyVersion 属性）当然，还可以写更多的事情，但命令依旧简单——对新开发者是非常友好的。参考资料 MSBuild Response Files - Visual Studio - Microsoft Docs Default or specify msbuild properties in an external file - Stack Overflow How to use MSBuild.rsp or otherwise specify default Visual Studio MSBuild.exe command line switches - Super User" }, { "title": "Roslyn 的确定性构建", "url": "/post/deterministic-builds-in-roslyn.html", "categories": "", "tags": "visualstudio, dotnet, csharp, roslyn, msbuild", "date": "2018-12-14 09:54:00 +0800", "snippet": "注意到每次编译完之后，你的 dll 或者 exe 是不一样的吗？本来这并没有什么大不了的，但大家都知道数字和鹅厂的安全软件遍布在我们大(tiān)陆(cháo)地区的大量电脑上，它们的查杀策略是——凡是不认识的一律是病毒木马；于是每次不一样的编译很容易引起它们的警告——真不想每次都把编译后的样本提交给它们存档入库。确定性编译于是有一天意外地发现了 Roslyn 的确定性构建。方法是在 csproj 文件中加入 &amp;lt;Deterministic/&amp;gt; 标记。&amp;lt;Project&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;Deterministic&amp;gt;true&amp;lt;/Deterministic&amp;gt; &amp;lt;/PropertyGroup&amp;gt;&amp;lt;/Project&amp;gt;然后重新生成 dll 或 exe，多生成几次（每次都重新生成），会发现每次验证文件的 Hash 值都是一样的。但是，一旦我们去掉这个标记，再验证 Hash 值，就开始改变了，而且每次都不一样。不确定的编译是什么导致了没有加此标记时每次编译都不一样呢？最少有三个： MVID：当初微软在制定 CLI 标准时就说每次编译都应该在 PE 头生成新的 Id（很多工具都直接使用了 guid） PDB ID：一个跟新生成的 PDB 文件匹配的 GUID 标识符 时间戳：每次编译都要把当前时间加上当然，如果你的版本号使用了 1.0.* 这样的动态版本号，那么每次编译还会新增一个构建号。参考资料 Customize your build - Visual Studio - Microsoft Docs roslyn/Deterministic Inputs.md at master · dotnet/roslyn Deterministic Builds in C# [Umbrella] Compilers should be deterministic: same inputs generate same outputs · Issue #372 · dotnet/roslyn Deterministic builds in Roslyn" }, { "title": "（持续整理中）Visual Studio 中 C# 代码分析规则集中每一项的含义 (stylecop ruleset)", "url": "/post/meaning-of-all-kind-of-stylecop.html", "categories": "", "tags": "csharp, visualstudio", "date": "2018-12-14 09:54:00 +0800", "snippet": "因为我希望在要求很高的库中及时发现潜在的代码问题，所以我开启了 Visual Studio 的代码分析。但是在修改规则的时候发现规则的名称都是在用我懂的每一个字描述我一点都不懂的概念，于是打算一个个尝试以找出每一个代码分析的实际意义。在整理的过程当中，发现要么是名称看不懂，要么是错误提示看不懂。不过两个合在一起并配合代码实验之后，基本上都能够看懂了。于是，把已经整理的部分都分享出来。正在整理中……代码分析（Microsoft.Analyzers.ManagedCodeAnalysis）设计问题 编号 名称 含义 CA1004 泛型方法应提供类型参数 如果泛型方法的参数列表中没有用到声明的所有泛型，那么就会出现此提示（这是因为此时泛型不能被隐式推断，库使用者的学习成本会提高，详见：CA1004） CA1005 避免泛型类型的参数过多 如果写泛型的时候有超过 2 个泛型类型，就会出现此提示 CA1006 不要将泛型类型嵌套在成员签名中 如果出现类似 Func&amp;lt;Task&amp;lt;T&amp;gt; 这样的嵌套泛型出现在方法参数签名中，则会出现此提示 CA1018 用 AttributeUsageAttribute 标记特性 如果继承自一个已有的 Attribute，即便基类已经写了 AttributeUsage，此类型也应该再写一遍，以提高代码可读性和便于文档制作 CA1019 定义特性参数的访问器 自定义 Attribute 构造函数中的参数应该有一个能够访问此参数的只读属性 CA1026 不应使用默认形参 void Method(object p = null) 这样的方法不兼容 CLS，于是不被推荐 CA1033 接口方法应可由子类型调用 基类中显式实现了一个接口方法，导致子类中无法调用此接口方法 CA1040 避免使用空接口 意思就是“避免使用空接口”，这种接口就像是一个标记一样并没有什么作用，考虑使用自定义的 Attribute 来实现 CA1045 不要通过引用来传递类型 方法参数中应该尽量避免使用 ref 参数 全球化与本地化问题 编号 名称 含义 CA1305 指定 IFormatProvider 如果格式化字符串（string.Format 或者 $&quot;&quot;），应该指定区域相关的属性，，否则容易出现本地化问题 CA1307 指定 StringComparison 如果进行字符串比较或排序（EndsWith 等），应该指定区域相关的属性，否则容易出现本地化问题 CA1309 使用按顺序的 StringComparison 如果进行字符串比较或排序（EndsWith 等），若要指定非语义比较，应该指定排序规则为 StringComparison.Ordinal 或 StringComparison.OrdinalIgnoreCase 命名问题 编号 名称 含义 CA1704 标识符应正确拼写 如果命名成一些简单无意义的字符（例如 a t），那么会出现此提示 CA1725 参数名应与基方法中声明保持一致   性能问题 编号 名称 含义 CA1800 避免进行不必要的强制转换 如果多次对同一个引用进行 as，则会出现此提示，应该仅转换一次，例如使用 value is var xxx CA1801 检查未使用的参数 如果方法中有声明的参数没有使用，则会发出此警告 CA1813 避免使用未密封的特性 自定义的 Attribute 应该是 sealed 的 CA1822 将成员标记为 static 如果方法的实现中没有任何一个地方用到了 this，那么这个方法就应该标记成静态的 CA1824 用 NeutralResourcesLanguage 标记程序集 如果程序集中包含资源，那么应该用此特性标记程序集以便提升第一次查找资源时的性能；[assembly: NeutralResourcesLanguage(&quot;zh-CHS&quot;, UltimateResourceFallbackLocation.Satellite)] 表示如果当前系统处于简体中文环境，那么就去此程序集查找资源，否则就去附属程序集查找；如果资源一定在此程序集，则指定为 MainAssembly 代码质量问题这部分的代码分析来自于 Microsoft.CodeAnalysis.FxCopAnalyzers，安装此 NuGet 包后将获得更多的代码分析。 编号 名称 含义 CA2007 不应该直接 await 一个而不调用 ConfigureAwait 建议阅读 在编写异步方法时，使用 ConfigureAwait(false) 避免使用者死锁 了解这样提示的原因 参考资料 Code Analysis for Managed Code Warnings - Microsoft Docs C# Compiler Errors - Microsoft Docs" }, { "title": "生成代码，从 T 到 T1, T2, Tn —— 自动生成多个类型的泛型", "url": "/post/generate-code-of-generic-types.html", "categories": "", "tags": "csharp, dotnet, visualstudio", "date": "2018-12-14 09:54:00 +0800", "snippet": "当你想写一个泛型 &amp;lt;T&amp;gt; 的类型的时候，是否想过两个泛型参数、三个泛型参数、四个泛型参数或更多泛型参数的版本如何编写呢？是一个个编写？类小还好，类大了就杯具！事实上，在 Visual Studio 中生成代码的手段很多，本文采用最笨的方式生成，但效果也很明显——代码写得轻松写得爽！我们想要的效果我们现在有一个泛型的版本：public class Demo&amp;lt;T&amp;gt;{ public Demo(Action&amp;lt;T&amp;gt; demo) { _demo = demo ?? throw new ArgumentNullException(nameof(action)); } private Action&amp;lt;T&amp;gt; _demo; public async Task&amp;lt;T&amp;gt; DoAsync(T t) { // 做某些事情。 } // 做其他事情。}希望生成多个泛型的版本：public class Demo&amp;lt;T1, T2&amp;gt;{ public Demo(Action&amp;lt;T1, T2&amp;gt; demo) { _demo = demo ?? throw new ArgumentNullException(nameof(action)); } private Action&amp;lt;T1, T2&amp;gt; _demo; public async Task&amp;lt;(T1, T2)&amp;gt; DoAsync(T1 t1, T2 t2) { // 做某些事情。 } // 做其他事情。}注意到类型的泛型变成了多个，参数从一个变成了多个，返回值从单个值变成了元组。于是，怎么生成呢？回顾 Visual Studio 那些生成代码的方式Visual Studio 原生自带两种代码生成方式。第一种：T4 文本模板事实上 T4 模板算是 Visual Studio 最推荐的方式了，因为你只需要编写一个包含占位符的模板文件，Visual Studio 就会自动为你填充那些占位符。那么 Visual Studio 用什么填充？是的，可以在模板文件中写 C# 代码！比如官方 DEMO： &amp;lt;#@ output extension=&quot;.txt&quot; #&amp;gt; &amp;lt;#@ assembly name=&quot;System.Xml&quot; #&amp;gt; &amp;lt;# System.Xml.XmlDocument configurationData = ...; // Read a data file here. #&amp;gt; namespace Fabrikam.&amp;lt;#= configurationData.SelectSingleNode(&quot;jobName&quot;).Value #&amp;gt; { ... // More code here. } 这代码写哪儿呢？在项目上右键新建项，然后选择“运行时文本模板”。T4 模板编辑后一旦保存（Ctrl+S），代码立刻生成。有没有觉得这代码着色很恐怖？呃……根本就没有代码着色好吗！即便如此，T4 本身也是非常强悍的代码生成方式。这不是本文的重点，于是感兴趣请阅读官方文档 Code Generation and T4 Text Templates - Microsoft Docs 学习。第二种：文件属性中的自定义工具右键选择项目中的一个代码文件，然后选择“属性”，你将看到以下内容：就是这里的自定义工具。在这里填写工具的 Key，那么一旦这个文件保存，就会运行自定义工具生成代码。那么 Key 从哪里来？这货居然是从注册表拿的！也就是说，如果要在团队使用，还需要写一个注册表项！即便如此，自定义工具本身也是非常强悍的代码生成方式。这也不是本文的重点，于是感兴趣请阅读官方文档 Custom Tools - Microsoft Docs 学习。第三种：笨笨的编译生成事件这算是通常项目用得最多的方式了，因为它可以在不修改用户开发环境的情况下执行几乎任何任务。右键项目，选择属性，进入“生成事件”标签：在“预先生成事件命令行”中填入工具的名字和参数，便可以生成代码。制作生成泛型代码的工具我们新建一个控制台项目，取名为 CodeGenerator，然后把我写好的生成代码粘贴到新的类文件中。using System;using System.Linq;using static System.Environment;namespace Walterlv.BuildTools{ public class GenericTypeGenerator { private static readonly string GeneratedHeader =$@&quot;//------------------------------------------------------------------------------// &amp;lt;auto-generated&amp;gt;// 此代码由工具生成。// 运行时版本:{Environment.Version.ToString(4)}//// 对此文件的更改可能会导致不正确的行为，并且如果// 重新生成代码，这些更改将会丢失。// &amp;lt;/auto-generated&amp;gt;//------------------------------------------------------------------------------#define GENERATED_CODE&quot;; private static readonly string GeneratedFooter = $@&quot;&quot;; private readonly string _genericTemplate; private readonly string _toolName; public GenericTypeGenerator(string toolName, string genericTemplate) { _toolName = toolName ?? throw new ArgumentNullException(nameof(toolName)); _genericTemplate = genericTemplate ?? throw new ArgumentNullException(nameof(toolName)); } public string Generate(int genericCount) { var toolName = _toolName; var toolVersion = &quot;1.0&quot;; var GeneratedAttribute = $&quot;[System.CodeDom.Compiler.GeneratedCode(\\&quot;{toolName}\\&quot;, \\&quot;{toolVersion}\\&quot;)]&quot;; var content = _genericTemplate // 替换泛型。 .Replace(&quot;&amp;lt;out T&amp;gt;&quot;, FromTemplate(&quot;&amp;lt;{0}&amp;gt;&quot;, &quot;out T{n}&quot;, &quot;, &quot;, genericCount)) .Replace(&quot;Task&amp;lt;T&amp;gt;&quot;, FromTemplate(&quot;Task&amp;lt;({0})&amp;gt;&quot;, &quot;T{n}&quot;, &quot;, &quot;, genericCount)) .Replace(&quot;Func&amp;lt;T, Task&amp;gt;&quot;, FromTemplate(&quot;Func&amp;lt;{0}, Task&amp;gt;&quot;, &quot;T{n}&quot;, &quot;, &quot;, genericCount)) .Replace(&quot; T, Task&amp;gt;&quot;, FromTemplate(&quot; {0}, Task&amp;gt;&quot;, &quot;T{n}&quot;, &quot;, &quot;, genericCount)) .Replace(&quot;(T, bool&quot;, FromTemplate(&quot;({0}, bool&quot;, &quot;T{n}&quot;, &quot;, &quot;, genericCount)) .Replace(&quot;var (t, &quot;, FromTemplate(&quot;var ({0}, &quot;, &quot;t{n}&quot;, &quot;, &quot;, genericCount)) .Replace(&quot;, t)&quot;, FromTemplate(&quot;, {0})&quot;, &quot;t{n}&quot;, &quot;, &quot;, genericCount)) .Replace(&quot;return (t, &quot;, FromTemplate(&quot;return ({0}, &quot;, &quot;t{n}&quot;, &quot;, &quot;, genericCount)) .Replace(&quot;&amp;lt;T&amp;gt;&quot;, FromTemplate(&quot;&amp;lt;{0}&amp;gt;&quot;, &quot;T{n}&quot;, &quot;, &quot;, genericCount)) .Replace(&quot;(T value)&quot;, FromTemplate(&quot;(({0}) value)&quot;, &quot;T{n}&quot;, &quot;, &quot;, genericCount)) .Replace(&quot;(T t)&quot;, FromTemplate(&quot;({0})&quot;, &quot;T{n} t{n}&quot;, &quot;, &quot;, genericCount)) .Replace(&quot;(t)&quot;, FromTemplate(&quot;({0})&quot;, &quot;t{n}&quot;, &quot;, &quot;, genericCount)) .Replace(&quot;var t =&quot;, FromTemplate(&quot;var ({0}) =&quot;, &quot;t{n}&quot;, &quot;, &quot;, genericCount)) .Replace(&quot; T &quot;, FromTemplate(&quot; ({0}) &quot;, &quot;T{n}&quot;, &quot;, &quot;, genericCount)) .Replace(&quot; t;&quot;, FromTemplate(&quot; ({0});&quot;, &quot;t{n}&quot;, &quot;, &quot;, genericCount)) // 生成 [GeneratedCode]。 .Replace(&quot; public interface &quot;, $&quot; {GeneratedAttribute}{NewLine} public interface &quot;) .Replace(&quot; public class &quot;, $&quot; {GeneratedAttribute}{NewLine} public class &quot;) .Replace(&quot; public sealed class &quot;, $&quot; {GeneratedAttribute}{NewLine} public sealed class &quot;); return GeneratedHeader + NewLine + content.Trim() + NewLine + GeneratedFooter; } private static string FromTemplate(string template, string part, string separator, int count) { return string.Format(template, string.Join(separator, Enumerable.Range(1, count).Select(x =&amp;gt; part.Replace(&quot;{n}&quot;, x.ToString())))); } }}这个类中加入了非常多种常见的泛型字符串特征，当然是采用最笨的字符串替换方法。如果感兴趣优化优化，可以用正则表达式，或者使用 Roslyn 扩展直接拿语法树。于是，在 Program.cs 中调用以上代码即可完成泛型生成。我写了一个简单的版本，可以将每一个命令行参数解析为一个需要进行转换的泛型类文件。using System.IO;using System.Linq;using System.Text;using Walterlv.BuildTools;class Program{ static void Main(string[] args) { foreach (var argument in args) { GenerateGenericTypes(argument, 4); } } private static void GenerateGenericTypes(string file, int count) { // 读取原始文件并创建泛型代码生成器。 var template = File.ReadAllText(file, Encoding.UTF8); var generator = new GenericTypeGenerator(template); // 根据泛型个数生成目标文件路径和文件内容。 var format = GetIndexedFileNameFormat(file); (string targetFileName, string targetFileContent)[] contents = Enumerable.Range(2, count - 1).Select(i =&amp;gt; (string.Format(format, i), generator.Generate(i)) ).ToArray(); // 写入目标文件。 foreach (var writer in contents) { File.WriteAllText(writer.targetFileName, writer.targetFileContent); } } private static string GetIndexedFileNameFormat(string fileName) { var directory = Path.GetDirectoryName(fileName); var name = Path.GetFileNameWithoutExtension(fileName); if (name.EndsWith(&quot;1&quot;)) { name = name.Substring(0, name.Length - 1); } return Path.Combine(directory, name + &quot;{0}.cs&quot;); }}考虑到这是 Demo 级别的代码，我将生成的泛型个数直接写到了代码当中。这段代码的意思是按文件名递增生成多个泛型类。例如，有一个泛型类文件 Demo.cs，则会在同目录生成 Demo2.cs，Demo3.cs，Demo4.cs。当然，Demo.cs 命名为 Demo1.cs 结果也是一样的。在要生成代码的项目中添加“预先生成事件命令行”：&quot;$(ProjectDir)..\\CodeGenerator\\$(OutDir)net47\\CodeGenerator.exe&quot; &quot;$(ProjectDir)..\\Walterlv.Demo\\Generic\\IDemoFile.cs&quot; &quot;$(ProjectDir)..\\..\\Walterlv.Demo\\Generic\\DemoFile.cs&quot; 现在，编译此项目，即可生成多个泛型类了。彩蛋如果你仔细阅读了 GenericTypeGenerator 类的代码，你将注意到我为生成的文件加上了条件编译符“GENERATED_CODE”。这样，你便可以使用 #ifdef GENERATED_CODE 来处理部分不需要进行转换或转换有差异的代码了。这时写代码，是不是完全感受不到正在写模板呢？既有代码着色，又适用于团队其他开发者的开发环境。是的，个人认为如果带来便捷的同时注意不到工具的存在，那么这个工具便是好的。如果将传参改为自动寻找代码文件，将此工具发布到 NuGet，那么可以通过 NuGet 安装脚本将以上过程全自动化完成。参考资料 Code Generation and T4 Text Templates - Microsoft Docs Custom Tools - Microsoft Docs" }, { "title": ".NET Core 和 .NET Framework 中的 MEF2", "url": "/post/mef2-from-nuget.html", "categories": "", "tags": "visualstudio, dotnet", "date": "2018-12-14 09:54:00 +0800", "snippet": "MEF，Managed Extensibility Framework，现在已经发布了三个版本了，它们是 MEF 和 MEF2。等等！3 去哪儿了？本文将教大家完成基于 MEF2 的开发。MEF 和 MEF2其实微软发布了四个版本的 MEF： 随着 .NET Framework 4.0 发布，微软称之为 MEF 随着 .NET Framework 4.5 发布，微软让它更好用了，微软称之为 MEF2，但因为接口兼容，也直接称之为 MEF .NET 开发团队觉得 MEF 第一代性能太差，于是通过 NuGet 为移动设备发布了可移植类库，是个轻量级版本，只移植了 .NET Framework 中 MEF2 里 2 的部分；随后 .NET Core 中也加入了 MEF2，也是 .NET Framework 中 MEF2 里 2 的部分 Visual Studio 开发团队觉得 .NET Framework 里的 MEF2 性能太差，NuGet 版的 MEF2 功能太少，于是自己又写了一个，微软称之为 VS-MEF对于第一代的 MEF，我们这里就完全不说了，性能又差功能又少，没有利用价值。对于 .NET Framework 4.5 里引入的 MEF2，性能上没能改进多少，倒是使用起来功能更多。详细资料和使用方法请参考微软官方的文档： Managed Extensibility Framework (MEF) - Microsoft Docs Attributed Programming Model Overview (MEF) - Microsoft Docs而本文主要说的 MEF2 是微软后来以 NuGet 包形式发布的 MEF2；适用于 .NET Framework 4.5 及以上、.NET Core 和各种 .NET 移动平台。它的接口相比于 .NET Framework 中原生带的已经变了，中文和英文的参考资料很少，几乎都是参考微软官方发布的文档才能使用。所以本文将为大家提供其中文的使用方法指导。至于性能提升程度，我没有进行定量测试，所以直接从 IoC Container Benchmark - Performance comparison - www.palmmedia.de 一文中搬运了性能测试结果，如下：安装 MEF2.NET Framework 中自带的 MEF 在程序集 System.ComponentModel.Composition.dll 中，命名空间为 System.ComponentModel.Composition。MEF2 随 NuGet 包发布，其 NuGet 包名是 Microsoft.Composition，命名空间为 System.Composition。所以，在需要使用 MEF2 的项目中安装以上 NuGet 包即可完成安装。使用 MEF2 开发MEF 完全使用特性来管理容器中的依赖，微软称之为 Attributed Programming Model，并辅以广告——不需要配置文件的依赖注入容器。所以，使用特性来标记依赖关系就成了 MEF 的招牌依赖管理方式。使用方法我将分为两个部分来讲，最容易的是业务代码，给开发团队中所有成员使用的代码。比较难的是框架代码，给开发团队中写框架的那一部分成员。业务代码业务代码的写法其实取决于框架开发者怎么去定义框架。但是，为了方便大家理解，在这一节我将只说 MEF2 最原生的使用方法。框架那一节我才会说明如何自定义业务代码的写法。最原生的使用方法其实只有两个——[Import] 和 [Export]，其它都是变种！具体说来，标记了 Export 的类将导出给其它类使用；标记了 Import 的属性/字段/方法参数等将接收来自 Export 的那些类/属性/字段的实例。Import/Export在类型上标记 [Export] 可以让容器发现这个类型。[Export] 允许带两个参数，一个契约名称，一个契约类型。在 [Import] 的时候，相同的契约名称会被注入；与属性或字段的类型相同的契约类型会被注入。IEnumerable/Lazy如果属性或字段是集合类型，可以使用 [ImportMany] 来注入集合（如果 Export 有多个）。如果属性或字段是 Lazy&amp;lt;T&amp;gt; 类型，那么并不会立即注入，而是在访问到 Lazy&amp;lt;T&amp;gt;.Value 时才获取到实例（如果此时的创建过程由容器处理，那么第一次访问 Value 时才会创建）。框架代码框架代码也分为两个部分：一个部分是初始化，初始化后可以创建一个依赖注入容器；另一个部分是管理依赖，将使用之前初始化好的依赖注入容器进行管理。初始化的最简代码如下：var compositionHost = new ContainerConfiguration().CreateContainer();那么，得到的 compositionHost 变量将是用来管理依赖的容器，你可以将它储存在字段中用于随后管理依赖。但是，只是这么初始化将得不到任何对象。所以，我们需要额外添加配置代码，以便将一些程序集中的对象添加到容器中：var compositionHost = new ContainerConfiguration().WithAssemblies(new []{ typeof(A).Assembly, typeof(B).Assembly, typeof(C).Assembly, typeof(D).Assembly,}).CreateContainer();这样，A/B/C/D 这四个类分别所在的程序集中，直接或间接加了 [Export] 特性的类都将被此依赖容器管理。MEF2 之所以为 2，因为它除了能通过 [Export] 特性导出，还能直接在框架中发现而不必由业务开发者手动指定。这在第三方代码或者不希望被 MEF 侵入的代码中非常有用。例如，我们将所有已有的 ViewModel 导出：// 使用 ConventionBuilder 自动导出所有的 ViewModel。var convention = new ConventionBuilder();// 将所有继承自 ViewModelBase 的类导出，并共享一个实例（即注入到多个属性中的都是同一个实例）。convention.ForTypesDerivedFrom&amp;lt;ViewModelBase&amp;gt;().Export().Shared();// 使用这些配置创建依赖注入容器。var compositionHost = new ContainerConfiguration().WithAssemblies(new []{ typeof(A).Assembly, typeof(B).Assembly, typeof(C).Assembly, typeof(D).Assembly,}).WithDefaultConventions(convention).CreateContainer();;注意，以上代码中的 .Shared() 目的是让导出的 ViewModel 共享实例（同一个类型的实例只有一个）。只初始化是不行的，还需要将这些依赖注入到目标实例中才行。使用 SatisfyImports 可以将传入的对象中的所有依赖注入进去。compositionHost.SatisfyImports(targetObject);在框架设计中，对于不同模块中的类型，框架需要决定使用哪一个容器来注入，或者是否注入。所以上面这个代码会发生在使用 MEF2 框架中需要注入的任何一个部分。参考资料 MEF in .NET 4.5 - CodeProject Managed Extensibility Framework(MEF) 2 框架新特性介绍 - PetterLiu - 博客园 Is MEF or MEF2 baked into the .NET Framework? - Stack Overflow vs-mef/why.md at master · Microsoft/vs-mef mef/Home.md at master · MicrosoftArchive/mef" }, { "title": "C#/.NET 匿名函数会捕获变量，并延长对象的生命周期", "url": "/post/anonymous-function-extends-lifetime-of-variable.html", "categories": "", "tags": "csharp, dotnet", "date": "2018-12-14 09:54:00 +0800", "snippet": "小伙伴在一次垃圾回收中，发现对象并没有被回收掉，而注释掉一句代码后它便能够回收。这究竟是为什么？不关心探索过程的就直接拉到最后看结论吧！探索测试代码是这样的：private void OnLoaded(object sender, RoutedEventArgs e){ var variable = new MainPage(); var reference = new WeakReference&amp;lt;MainPage&amp;gt;(variable); variable = null; GC.Collect(); Console.WriteLine($&quot;{reference.TryGetTarget(out var target)}: {target}&quot;); DoSomething(x =&amp;gt; DoAnotherThing(x));}需要验证的是 MainPage 对象是否被回收。然而在这段代码中，MainPage 并没有被回收；然而去掉最后一行，MainPage 便可以正常回收。关键是，即便是在 Console.WriteLine 上打下断点，让代码永远不会执行到最后一句，也不会改变回收的结果。由于 DoSomething 中的委托参数恰好就是 MainPage 类型的，不禁让人觉得可能是此函数做了一些奇怪的事情。然而毕竟参数中传入的委托参数只是形参，理论上不应该影响到外部对象的回收。那么影响的只可能是变量的捕获了。于是，我们将最后一行换成别的函数别的参数：DoSomething(null);或者将整个这一句提取成新的函数：private void OnLoaded(object sender, RoutedEventArgs e){ // 省略前面的代码。 ExtractedMethod();}private void ExtractedMethod(){ DoSomething(x =&amp;gt; DoAnotherThing(x));}那么，回收就会正常进行。现在，不执行这个受争议的函数了，我们使用空的匿名函数。private void OnLoaded(object sender, RoutedEventArgs e){ var variable = new MainPage(); var reference = new WeakReference&amp;lt;MainPage&amp;gt;(variable); variable = null; GC.Collect(); Console.WriteLine($&quot;{reference.TryGetTarget(out var target)}: {target}&quot;); Dispatcher.InvokeAsync(() =&amp;gt; { });}一样会导致不回收。结论在微软官方的《C# 规范 5.0》（点此下载）的第 7.15.5.1 章节中有说到： When an outer variable is referenced by an anonymous function, the outer variable is said to have been captured by the anonymous function. Ordinarily, the lifetime of a local variable is limited to execution of the block or statement with which it is associated (§5.1.7). However, the lifetime of a captured outer variable is extended at least until the delegate or expression tree created from the anonymous function becomes eligible for garbage collection.匿名函数会捕获当前上下文的局部变量，延长对象的生命周期；直到此委托或表达式树被回收掉。也就是说，只要某个方法中存在没有被回收的匿名函数/lambda 表达式/表达式树，那么当前上下文的对象直到这些匿名函数被回收之前都不会被回收，即便已经设为了 null。参考资料 c# - .NET Do lambdas prevent garbage collection of external references used in them? - Stack Overflow C# Language Specification 5.0 C# 6.0 draft Language Specification - Microsoft Docs" }, { "title": "实现一个 WPF 版本的 ConnectedAnimation", "url": "/post/connected-animation-of-wpf.html", "categories": "", "tags": "wpf, uwp", "date": "2018-12-14 09:54:00 +0800", "snippet": "Windows 10 的创造者更新为开发者们带来了 Connected Animation 连接动画，这也是 Fluent Design System 的一部分。它的视觉引导性很强，用户能够在它的帮助下迅速定位操作的对象。不过，这是 UWP，而且还是 Windows 10 Creator’s Update 中才带来的特性，WPF 当然没有。于是，我自己写了一个“简易版本”。▲ Connected Animation 连接动画模拟 UWP 中的 APIUWP 中的连接动画能跑起来的最简单代码包含下面两个部分。准备动画 PrepareToAnimate()： ConnectedAnimationService.GetForCurrentView().PrepareToAnimate(/*string */key, /*UIElement */source); 开始动画 TryStart： var animation = ConnectedAnimationService.GetForCurrentView().GetAnimation(/*string */key);animation?.TryStart(/*UIElement */destination); 于是，我们至少需要实现这些 API： ConnectedAnimationService.GetForCurrentView(); ConnectedAnimationService.PrepareToAnimate(string key, UIElement source); ConnectedAnimationService.GetAnimation(string key); ConnectedAnimation.TryStart(UIElement destination);实现这个 API现在，我们需要写两个类才能实现上面那些方法： ConnectedAnimationService - 用来管理一个窗口内的所有连接动画 ConnectedAnimation - 用来管理和播放一个指定 Key 的连接动画ConnectedAnimationService我选用窗口作为一个 ConnectedAnimationService 的管理单元是因为我可以在一个窗口内实现这样的动画，而跨窗口的动画就非常麻烦了。所以，我试用附加属性为 Window 附加一个 ConnectedAnimationService 属性，用于在任何一个 View 所在的地方获取 ConnectedAnimationService 的实例。每次 PrepareToAnimate 时我创建一个 ConnectedAnimation 实例来管理此次的连接动画。为了方便此后根据 Key 查找 ConnectedAnimation 的实例，我使用字典存储这些实例。using System;using System.Collections.Generic;using System.Windows;using System.Windows.Media;using Walterlv.Annotations;namespace Walterlv.Demo.Media.Animation{ public class ConnectedAnimationService { private ConnectedAnimationService() { } private readonly Dictionary&amp;lt;string, ConnectedAnimation&amp;gt; _connectingAnimations = new Dictionary&amp;lt;string, ConnectedAnimation&amp;gt;(); public void PrepareToAnimate([NotNull] string key, [NotNull] UIElement source) { if (key == null) { throw new ArgumentNullException(nameof(key)); } if (source == null) { throw new ArgumentNullException(nameof(source)); } if (_connectingAnimations.TryGetValue(key, out var info)) { throw new ArgumentException(&quot;指定的 key 已经做好动画准备，不应该重复进行准备。&quot;, nameof(key)); } info = new ConnectedAnimation(key, source, OnAnimationCompleted); _connectingAnimations.Add(key, info); } private void OnAnimationCompleted(object sender, EventArgs e) { var key = ((ConnectedAnimation) sender).Key; if (_connectingAnimations.ContainsKey(key)) { _connectingAnimations.Remove(key); } } [CanBeNull] public ConnectedAnimation GetAnimation([NotNull] string key) { if (key == null) { throw new ArgumentNullException(nameof(key)); } if (_connectingAnimations.TryGetValue(key, out var info)) { return info; } return null; } private static readonly DependencyProperty AnimationServiceProperty = DependencyProperty.RegisterAttached(&quot;AnimationService&quot;, typeof(ConnectedAnimationService), typeof(ConnectedAnimationService), new PropertyMetadata(default(ConnectedAnimationService))); public static ConnectedAnimationService GetForCurrentView(Visual visual) { var window = Window.GetWindow(visual); if (window == null) { throw new ArgumentException(&quot;此 Visual 未连接到可见的视觉树中。&quot;, nameof(visual)); } var service = (ConnectedAnimationService) window.GetValue(AnimationServiceProperty); if (service == null) { service = new ConnectedAnimationService(); window.SetValue(AnimationServiceProperty, service); } return service; } }}ConnectedAnimation这是连接动画的关键实现。我创建了一个内部类 ConnectedAnimationAdorner 用于在 AdornerLayer 上承载连接动画。AdornerLayer 是 WPF 中的概念，用于在其他控件上叠加显示一些 UI，UWP 中没有这样的特性。private class ConnectedAnimationAdorner : Adorner{ private ConnectedAnimationAdorner([NotNull] UIElement adornedElement) : base(adornedElement) { Children = new VisualCollection(this); IsHitTestVisible = false; } internal VisualCollection Children { get; } protected override int VisualChildrenCount =&amp;gt; Children.Count; protected override Visual GetVisualChild(int index) =&amp;gt; Children[index]; protected override Size ArrangeOverride(Size finalSize) { foreach (var child in Children.OfType&amp;lt;UIElement&amp;gt;()) { child.Arrange(new Rect(child.DesiredSize)); } return finalSize; } internal static ConnectedAnimationAdorner FindFrom([NotNull] Visual visual) { if (Window.GetWindow(visual)?.Content is UIElement root) { var layer = AdornerLayer.GetAdornerLayer(root); if (layer != null) { var adorner = layer.GetAdorners(root)?.OfType&amp;lt;ConnectedAnimationAdorner&amp;gt;().FirstOrDefault(); if (adorner == null) { adorner = new ConnectedAnimationAdorner(root); layer.Add(adorner); } return adorner; } } throw new InvalidOperationException(&quot;指定的 Visual 尚未连接到可见的视觉树中，找不到用于承载动画的容器。&quot;); } internal static void ClearFor([NotNull] Visual visual) { if (Window.GetWindow(visual)?.Content is UIElement root) { var layer = AdornerLayer.GetAdornerLayer(root); var adorner = layer?.GetAdorners(root)?.OfType&amp;lt;ConnectedAnimationAdorner&amp;gt;().FirstOrDefault(); if (adorner != null) { layer.Remove(adorner); } } }}而 ConnectedAnimationAdorner 的作用是显示一个 ConnectedVisual。ConnectedVisual 包含一个源和一个目标，根据 Progress（进度）属性决定应该分别将源和目标显示到哪个位置，其不透明度分别是多少。private class ConnectedVisual : DrawingVisual{ public static readonly DependencyProperty ProgressProperty = DependencyProperty.Register( &quot;Progress&quot;, typeof(double), typeof(ConnectedVisual), new PropertyMetadata(0.0, OnProgressChanged), ValidateProgress); public double Progress { get =&amp;gt; (double) GetValue(ProgressProperty); set =&amp;gt; SetValue(ProgressProperty, value); } private static bool ValidateProgress(object value) =&amp;gt; value is double progress &amp;amp;&amp;amp; progress &amp;gt;= 0 &amp;amp;&amp;amp; progress &amp;lt;= 1; private static void OnProgressChanged(DependencyObject d, DependencyPropertyChangedEventArgs e) { ((ConnectedVisual) d).Render((double) e.NewValue); } public ConnectedVisual([NotNull] Visual source, [NotNull] Visual destination) { _source = source ?? throw new ArgumentNullException(nameof(source)); _destination = destination ?? throw new ArgumentNullException(nameof(destination)); _sourceBrush = new VisualBrush(source) {Stretch = Stretch.Fill}; _destinationBrush = new VisualBrush(destination) {Stretch = Stretch.Fill}; } private readonly Visual _source; private readonly Visual _destination; private readonly Brush _sourceBrush; private readonly Brush _destinationBrush; private Rect _sourceBounds; private Rect _destinationBounds; protected override void OnVisualParentChanged(DependencyObject oldParent) { if (VisualTreeHelper.GetParent(this) == null) { return; } var sourceBounds = VisualTreeHelper.GetContentBounds(_source); if (sourceBounds.IsEmpty) { sourceBounds = VisualTreeHelper.GetDescendantBounds(_source); } _sourceBounds = new Rect( _source.PointToScreen(sourceBounds.TopLeft), _source.PointToScreen(sourceBounds.BottomRight)); _sourceBounds = new Rect( PointFromScreen(_sourceBounds.TopLeft), PointFromScreen(_sourceBounds.BottomRight)); var destinationBounds = VisualTreeHelper.GetContentBounds(_destination); if (destinationBounds.IsEmpty) { destinationBounds = VisualTreeHelper.GetDescendantBounds(_destination); } _destinationBounds = new Rect( _destination.PointToScreen(destinationBounds.TopLeft), _destination.PointToScreen(destinationBounds.BottomRight)); _destinationBounds = new Rect( PointFromScreen(_destinationBounds.TopLeft), PointFromScreen(_destinationBounds.BottomRight)); } private void Render(double progress) { var bounds = new Rect( (_destinationBounds.Left - _sourceBounds.Left) * progress + _sourceBounds.Left, (_destinationBounds.Top - _sourceBounds.Top) * progress + _sourceBounds.Top, (_destinationBounds.Width - _sourceBounds.Width) * progress + _sourceBounds.Width, (_destinationBounds.Height - _sourceBounds.Height) * progress + _sourceBounds.Height); using (var dc = RenderOpen()) { dc.DrawRectangle(_sourceBrush, null, bounds); dc.PushOpacity(progress); dc.DrawRectangle(_destinationBrush, null, bounds); dc.Pop(); } }}最后，用一个 DoubleAnimation 控制 Progress 属性，来实现连接动画。完整的包含内部类的代码如下：using System;using System.Collections.Generic;using System.Linq;using System.Windows;using System.Windows.Documents;using System.Windows.Media;using System.Windows.Media.Animation;using Walterlv.Annotations;namespace Walterlv.Demo.Media.Animation{ public class ConnectedAnimation { internal ConnectedAnimation([NotNull] string key, [NotNull] UIElement source, [NotNull] EventHandler completed) { Key = key ?? throw new ArgumentNullException(nameof(key)); _source = source ?? throw new ArgumentNullException(nameof(source)); _reportCompleted = completed ?? throw new ArgumentNullException(nameof(completed)); } public string Key { get; } private readonly UIElement _source; private readonly EventHandler _reportCompleted; public bool TryStart([NotNull] UIElement destination) { return TryStart(destination, Enumerable.Empty&amp;lt;UIElement&amp;gt;()); } public bool TryStart([NotNull] UIElement destination, [NotNull] IEnumerable&amp;lt;UIElement&amp;gt; coordinatedElements) { if (destination == null) { throw new ArgumentNullException(nameof(destination)); } if (coordinatedElements == null) { throw new ArgumentNullException(nameof(coordinatedElements)); } if (Equals(_source, destination)) { return false; } // 正在播动画？动画播完废弃了？false // 准备播放连接动画。 var adorner = ConnectedAnimationAdorner.FindFrom(destination); var connectionHost = new ConnectedVisual(_source, destination); adorner.Children.Add(connectionHost); var storyboard = new Storyboard(); var animation = new DoubleAnimation(0.0, 1.0, new Duration(TimeSpan.FromSeconds(10.6))) { EasingFunction = new CubicEase {EasingMode = EasingMode.EaseInOut}, }; Storyboard.SetTarget(animation, connectionHost); Storyboard.SetTargetProperty(animation, new PropertyPath(ConnectedVisual.ProgressProperty.Name)); storyboard.Children.Add(animation); storyboard.Completed += (sender, args) =&amp;gt; { _reportCompleted(this, EventArgs.Empty); //destination.ClearValue(UIElement.VisibilityProperty); adorner.Children.Remove(connectionHost); }; //destination.Visibility = Visibility.Hidden; storyboard.Begin(); return true; } private class ConnectedVisual : DrawingVisual { public static readonly DependencyProperty ProgressProperty = DependencyProperty.Register( &quot;Progress&quot;, typeof(double), typeof(ConnectedVisual), new PropertyMetadata(0.0, OnProgressChanged), ValidateProgress); public double Progress { get =&amp;gt; (double) GetValue(ProgressProperty); set =&amp;gt; SetValue(ProgressProperty, value); } private static bool ValidateProgress(object value) =&amp;gt; value is double progress &amp;amp;&amp;amp; progress &amp;gt;= 0 &amp;amp;&amp;amp; progress &amp;lt;= 1; private static void OnProgressChanged(DependencyObject d, DependencyPropertyChangedEventArgs e) { ((ConnectedVisual) d).Render((double) e.NewValue); } public ConnectedVisual([NotNull] Visual source, [NotNull] Visual destination) { _source = source ?? throw new ArgumentNullException(nameof(source)); _destination = destination ?? throw new ArgumentNullException(nameof(destination)); _sourceBrush = new VisualBrush(source) {Stretch = Stretch.Fill}; _destinationBrush = new VisualBrush(destination) {Stretch = Stretch.Fill}; } private readonly Visual _source; private readonly Visual _destination; private readonly Brush _sourceBrush; private readonly Brush _destinationBrush; private Rect _sourceBounds; private Rect _destinationBounds; protected override void OnVisualParentChanged(DependencyObject oldParent) { if (VisualTreeHelper.GetParent(this) == null) { return; } var sourceBounds = VisualTreeHelper.GetContentBounds(_source); if (sourceBounds.IsEmpty) { sourceBounds = VisualTreeHelper.GetDescendantBounds(_source); } _sourceBounds = new Rect( _source.PointToScreen(sourceBounds.TopLeft), _source.PointToScreen(sourceBounds.BottomRight)); _sourceBounds = new Rect( PointFromScreen(_sourceBounds.TopLeft), PointFromScreen(_sourceBounds.BottomRight)); var destinationBounds = VisualTreeHelper.GetContentBounds(_destination); if (destinationBounds.IsEmpty) { destinationBounds = VisualTreeHelper.GetDescendantBounds(_destination); } _destinationBounds = new Rect( _destination.PointToScreen(destinationBounds.TopLeft), _destination.PointToScreen(destinationBounds.BottomRight)); _destinationBounds = new Rect( PointFromScreen(_destinationBounds.TopLeft), PointFromScreen(_destinationBounds.BottomRight)); } private void Render(double progress) { var bounds = new Rect( (_destinationBounds.Left - _sourceBounds.Left) * progress + _sourceBounds.Left, (_destinationBounds.Top - _sourceBounds.Top) * progress + _sourceBounds.Top, (_destinationBounds.Width - _sourceBounds.Width) * progress + _sourceBounds.Width, (_destinationBounds.Height - _sourceBounds.Height) * progress + _sourceBounds.Height); using (var dc = RenderOpen()) { dc.DrawRectangle(_sourceBrush, null, bounds); dc.PushOpacity(progress); dc.DrawRectangle(_destinationBrush, null, bounds); dc.Pop(); } } } private class ConnectedAnimationAdorner : Adorner { private ConnectedAnimationAdorner([NotNull] UIElement adornedElement) : base(adornedElement) { Children = new VisualCollection(this); IsHitTestVisible = false; } internal VisualCollection Children { get; } protected override int VisualChildrenCount =&amp;gt; Children.Count; protected override Visual GetVisualChild(int index) =&amp;gt; Children[index]; protected override Size ArrangeOverride(Size finalSize) { foreach (var child in Children.OfType&amp;lt;UIElement&amp;gt;()) { child.Arrange(new Rect(child.DesiredSize)); } return finalSize; } internal static ConnectedAnimationAdorner FindFrom([NotNull] Visual visual) { if (Window.GetWindow(visual)?.Content is UIElement root) { var layer = AdornerLayer.GetAdornerLayer(root); if (layer != null) { var adorner = layer.GetAdorners(root)?.OfType&amp;lt;ConnectedAnimationAdorner&amp;gt;().FirstOrDefault(); if (adorner == null) { adorner = new ConnectedAnimationAdorner(root); layer.Add(adorner); } return adorner; } } throw new InvalidOperationException(&quot;指定的 Visual 尚未连接到可见的视觉树中，找不到用于承载动画的容器。&quot;); } internal static void ClearFor([NotNull] Visual visual) { if (Window.GetWindow(visual)?.Content is UIElement root) { var layer = AdornerLayer.GetAdornerLayer(root); var adorner = layer?.GetAdorners(root)?.OfType&amp;lt;ConnectedAnimationAdorner&amp;gt;().FirstOrDefault(); if (adorner != null) { layer.Remove(adorner); } } } } }}调用我在一个按钮的点击事件里面尝试调用上面的代码：private int index;private void AnimationButton_Click(object sender, RoutedEventArgs e){ BeginConnectedAnimation((UIElement)sender, ConnectionDestination);}private async void BeginConnectedAnimation(UIElement source, UIElement destination){ var service = ConnectedAnimationService.GetForCurrentView(this); service.PrepareToAnimate($&quot;Test{index}&quot;, source); // 这里特意写在了同一个方法中，以示效果。事实上，只要是同一个窗口中的两个对象都可以实现。 var animation = service.GetAnimation($&quot;Test{index}&quot;); animation?.TryStart(destination); // 每次点击都使用不同的 Key。 index++;}▲ 上面的代码做的连接动画目前的局限性以及改进计划然而稍微试试不难发现，这段代码很难将控件本身隐藏起来（设置 Visibility 为 Collapsed），也就是说如果源控件和目标控件一直显示，那么动画期间就不允许隐藏（不同时显示就没有这个问题)。这样也就出不来“连接”的感觉，而是覆盖的感觉。通过修改调用方的代码，可以规避这个问题。而做法是隐藏控件本身，但对控件内部的可视元素子级进行动画。这样，动画就仅限继承自 Control 的那些元素（例如 Button，UserControl 了）。private async void BeginConnectedAnimation(UIElement source, UIElement destination){ source.Visibility = Visibility.Hidden; ConnectionDestination.Visibility = Visibility.Hidden; var animatingSource = (UIElement) VisualTreeHelper.GetChild(source, 0); var animatingDestination = (UIElement) VisualTreeHelper.GetChild(destination, 0); var service = ConnectedAnimationService.GetForCurrentView(this); service.PrepareToAnimate($&quot;Test{index}&quot;, animatingSource); var animation = service.GetAnimation($&quot;Test{index}&quot;); animation?.TryStart(animatingDestination); index++; await Task.Delay(600); source.ClearValue(VisibilityProperty); ConnectionDestination.ClearValue(VisibilityProperty);}▲ 修改后的代码做的连接动画现在，我正试图通过截图和像素着色器（Shader Effect）来实现更加通用的 ConnectedAnimation，正在努力编写中……参考资料 Connected animation - UWP app developer - Microsoft Docs UWP Connected Animations updates with Windows Creators release – Varun Shandilya 实现 Fluent Design 中的 Connected Animation - ^ _ ^ .io" }, { "title": "迫不及待地体验了一把 C#8.0 中的可空引用类型（Nullable Reference）", "url": "/post/nullable-reference-in-csharp.html", "categories": "", "tags": "csharp", "date": "2018-12-14 09:54:00 +0800", "snippet": "在我之前的一篇博客 NullReferenceException，就不应该存在！ 中，我吐槽了 C# 中 null 的弊端以及避免 null 的方法；事实上这本都是现代高级语言中极力推崇的做法。Kotlin 和 Swift 自诞生之日起引用类型就不能为空，C# 背着历史的包袱直到 8.0 才开始这么做……安装可空引用类型预览包现在 C#8.0 还没有发布，但微软已经提供了预览的扩展包，让大家体验效果并予以反馈。扩展包下载地址：2017年11月5日版本 - 最新版下载解压后直接双击 install.bat 安装即可体验（安装前退出所有 Visual Studio）。这还是预览版，还有很多已知 BUG，修复后才会发布哦！体验可空引用类型的作用现在，再写一个新类的时候，Visual Studio 会为我们提示非空引用类型未初始化，并给出建议。采纳它的建议，生成构造函数：如果我们认为这个属性可以为 null，那么就可以添加 ? 使此属性的类型变为可空引用类型。这时，如果在非 null 的地方使用此属性，则会要求判空。丢不掉的兼容性包袱由于有兼容性的包袱（至少得让你写了数月几年的项目编译通过吧），所以 C#8.0 的可空引用类型仅仅是“契约”的作用，并不能在编译级别阻止对非空引用类型的 null 赋值。而且目前为止也没有提供编译级别报错的选项。已有的程序集没有标记那些非空哪些可空，那么 C#8.0 又怎么看呢（其实应该问 Roslyn 怎么看）？它只能默认所有的类型都是非空的，于是会给你警告，就像这样：很明显，string.IsNullOrEmpty 是接受 null 值的，然而改不了现有程序集，于是这样的标记也没有用。从现在看来，我们只能把它当作 Code Contracts 的语法版本。参考资料 Nullable Reference Nullable Reference Types Preview · dotnet/csharplang Wiki What’s New In C# 7.1 And 7.2 " }, { "title": "WPF 自定义键盘焦点样式（FocusVisualStyle）", "url": "/post/customize-focus-visual-style.html", "categories": "", "tags": "wpf, uwp", "date": "2018-12-14 09:54:00 +0800", "snippet": "WPF 自带的键盘焦点样式是与传统控件样式搭配的，但 WPF 凭着其强大的自定义样式的能力，做出与传统控件样式完全不同风格的 UI 简直易如反掌。这时，其自带的键盘焦点样式（FocusVisualStyle）就非常不搭了，改改会舒服得多。比如，改成 UWP 的样式。本文将展示 WPF 自定义键盘焦点样式自定义的坑！▲ WPF 自带的键盘焦点样式▲ UWP 暗主题键盘焦点样式其实微软官方文档 Styling for Focus in Controls, and FocusVisualStyle - Microsoft Docs 有说明 FocusVisualStyle，但是——完全没有讲自定义好吗！所以，我试着写一个样式以覆盖默认的样式：&amp;lt;Style x:Key=&quot;{x:Static SystemParameters.FocusVisualStyleKey}&quot;&amp;gt; &amp;lt;Setter Property=&quot;Control.Template&quot;&amp;gt; &amp;lt;Setter.Value&amp;gt; &amp;lt;ControlTemplate&amp;gt; &amp;lt;Rectangle Margin=&quot;-3&quot; StrokeThickness=&quot;3&quot; Stroke=&quot;Gray&quot; SnapsToDevicePixels=&quot;true&quot;/&amp;gt; &amp;lt;/ControlTemplate&amp;gt; &amp;lt;/Setter.Value&amp;gt; &amp;lt;/Setter&amp;gt;&amp;lt;/Style&amp;gt;运行一看，结果完全没有效果……StackOverflow 上也有人说了这件事：xaml - How to redefine FocusVisualStyle for a WPF user control - Stack Overflow。Rohit Vats 说需要通过单独为 Button 设置才能生效并在回答中贴出了代码。然而同样的代码应用到项目中，我们会发现，我们此前定义的无 Key 样式也失效了：我的代码是这样的，试图用上此前定义的无 Key 样式，只是无效。&amp;lt;Style x:Key=&quot;{x:Static SystemParameters.FocusVisualStyleKey}&quot;&amp;gt; &amp;lt;Setter Property=&quot;Control.Template&quot;&amp;gt; &amp;lt;Setter.Value&amp;gt; &amp;lt;ControlTemplate&amp;gt; &amp;lt;Rectangle Margin=&quot;-3&quot; StrokeThickness=&quot;3&quot; Stroke=&quot;Gray&quot; SnapsToDevicePixels=&quot;true&quot;/&amp;gt; &amp;lt;/ControlTemplate&amp;gt; &amp;lt;/Setter.Value&amp;gt; &amp;lt;/Setter&amp;gt;&amp;lt;/Style&amp;gt;&amp;lt;Style TargetType=&quot;Button&quot; BasedOn=&quot;{StaticResource {x:Type Button}}&quot;&amp;gt; &amp;lt;Setter Property=&quot;FocusVisualStyle&quot; Value=&quot;{StaticResource {x:Static SystemParameters.FocusVisualStyleKey}}&quot;/&amp;gt;&amp;lt;/Style&amp;gt;那么，有没有办法能够一次定义整个应用程序生效呢？答案是——wpf - Change the FocusVisualStyle in the entire application - Stack Overflow 也承认了这一点。所以，当希望为 WPF 程序自定义 FocusVisualStyle 样式的话，建议从零开始，定义每一个最底层样式的时候设置好 FocusVisualStyle，其他样式定义的时候继承自最底层样式。参考资料 Styling for Focus in Controls, and FocusVisualStyle - Microsoft Docs xaml - How to redefine FocusVisualStyle for a WPF user control - Stack Overflow wpf - Change the FocusVisualStyle in the entire application - Stack Overflow" }, { "title": "异步任务中的重新进入（Reentrancy）", "url": "/post/reentrancy-in-async-method.html", "categories": "", "tags": "csharp, dotnet", "date": "2018-12-14 09:54:00 +0800", "snippet": "一个按钮，点击执行一个任务。我们可能直接在它的 Click 事件中写下了执行任务的代码。一般我们无需担心这样的代码会出现什么问题——但是，这样的好事情只对同步任务有效；一旦进入了异步世界，这便是无尽的 BUG！重新进入（Reentrancy）private void Button_Click(object sender, RoutedEventArgs e){ DoSomething();}private void DoSomething(){ // 同步任务。}▲ 以上，在按钮点击事件中执行同步任务上面的代码，无论我们在界面上多么疯狂地点击按钮，因为 UI 会在任务执行的过程中停止响应，所以 DoSomething 只会依次执行（还会偶尔忽略一些）。这通常不会造成什么问题，但如果 DoSomething 变成异步的 DoSomethingAsync（就像下面那样），那么情况就变得不同了。private async void Button_Click(object sender, RoutedEventArgs e){ await DoSomethingAsync();}private async Task DoSomethingAsync(){ // 异步任务。}▲ 以上，在按钮点击事件中执行异步任务由于任务执行的过程中 UI 依然是响应的，DoSomethingAsync 会因此在每一次点击的时候都进入。在异步任务结束之前重新进入此异步任务的过程，叫做重新进入（Reentrancy）。重新进入的五种方式微软在 Handling Reentrancy in Async Apps (C#) 一文中给出了重新进入的三种方式： 禁用“开始”按钮 取消和重启操作 运行多个操作并将输出排入队列 从语言描述中就能知道除了第 2 点看起来具有通用性外，其他两点只为了解决文章中面临的“输出网页列表”问题。第 1 点其思想可以重用，但第 3 点就很难抽取公共的重新进入思想。于是，我总结其前两点，再额外补充两种重新进入的方式，和不处理一起作为五种不同的处理方法。 禁用重新进入 并发 取消然后重启操作 将异步任务放入队列中依次执行 仅执行第一次和最后一次禁用重新进入禁用是最直接最简单也最彻底的重新进入问题解决办法。Button.IsEnabled = false;await DoSomethingAsync();Button.IsEnabled = true;既然重新进入可能出问题，那我们就禁止重新进入好了……并发当然，不处理也是一种方法。这意味着我们需要真的考虑 DoSomethingAsync 并发造成的影响。取消然后重启操作取消，然后重新执行一次，这也是常见的重新进入类型。浏览器或者资讯类 APP 中的刷新功能就是这种重新进入方式最常见的应用场景，用户重新执行一次刷新，可能因为前面那一次（因为网络问题或其他原因）太慢，所以重新开始。将异步任务放入队列中依次执行放入队列中是因为此异步任务的顺序是很重要的，要求每一次执行且保持顺序一致。典型的应用场景是每一次执行都需要获取或生成一组数据输出（到屏幕、文件或者其他地方）。仅执行第一次和最后一次如果用户每一次执行此异步任务都会获取当前应用程序的最新状态，然后根据最新状态执行；那么如果状态更新了，对旧状态执行多少次都是浪费的。比如保存文件的操作。第一次进入异步任务的时候会进行保存，如果保存过程没有结束又触发新的保存，则等上一次保存结束之后再执行保存操作即可。而如果第一次保存没有结束的时候又触发非常多次的保存，也只需要在第一次结束之后再保存一次即可，毕竟既然最后一次保存时的状态已经是最新状态，不需要再把之前旧的状态保存一次。参考资料 Handling Reentrancy in Async Apps (C#) - Microsoft Docs 处理异步应用中的重新进入 (C#) - Microsoft Docs" }, { "title": "将 UWP 的有效像素（Effective Pixels）引入 WPF", "url": "/post/introduce-uwp-effective-pixels-into-wpf.html", "categories": "", "tags": "wpf, uwp, xaml", "date": "2018-12-14 09:54:00 +0800", "snippet": "在很久很久以前，WPF 诞生之初，有一个神奇的单位，它的名字叫做——设备无关单位（DIP，Device Independent Unit）。微软给它描绘了一片美好的愿景——在任何显示器上显示的尺寸是相同的。What the ** is this unit!!! 神 TM 相同！！！UWP 采用有效像素（Effective Pixels）来描述尺寸，这是才是能够自圆其说的一套尺寸描述；WPF 的尺寸机制与 UWP 完全就是同一套，使用有效像素才能解释 WPF 尺寸变化上的各种特性！统一概念在继续讨论之前，我们必须统一几个概念。不能说那些意义不明确的词，尤其是“宽高”“大小”“尺寸”“更大”。试想你说一个按钮的宽高是 200，那么它的宽高到底是多少呢？一个屏幕上的按钮和另一个屏幕上的按钮哪个更大呢？在本文中，对于尺寸，我们只说三个概念： 物理尺寸（单位：厘米） 显示器像素个数（单位：个） 有效像素（即 WPF 中最常用的那个单位；在本文结束之前，这应该是一个未定义的概念）如果我们说 A 按钮比 B 按钮的物理宽度更大，那么无论它们显示在哪个显示器上，都具备相同的关系——因为我们可以拿尺子来量。如果我们说 A 按钮比 B 按钮在宽度上占用的显示器像素个数更多，我们也可以拿放大镜去屏幕上一个点一个点地数——当然，各种截图工具已经在最佳分辨率下具备数像素个数的功能了（这里一定要突出最佳分辨率）。而有效像素（Effective Pixels，本文记其为 epx）就是本文从 UWP 中引入的尺寸概念。当我们说按钮的有效像素宽度为 200 时，指的是你在 WPF 的 XAML 或 C# 代码中写下了 Width=&quot;200&quot;。接下来，当我们谈论尺寸时，只会用以上三个概念进行比较，而不会再用模糊不清的尺寸名词。从愿景看有效像素的意义有效像素单位的诞生一定是为了解决某种尺寸问题，而且是因为现有的尺寸单位无法简单地描述这一问题。而我们就要准确描述这一问题，并将得到的单位定义成“有效像素”。吐槽 DIPWPF 曾经说自己用的是“设备无关单位”（DIP），愿景是在所有显示器上显示的物理尺寸相同。比如你在代码中写了 Width=&quot;96&quot; 的按钮，那么在所有显示器上其尺寸为 1 英寸。其实简单测试就不难发现这是一个根本无法自圆其说的愿景，具体无法自圆其说的点有两个。 WPF 说自己的开发无需考虑 DPI 缩放，因为它会自己做缩放。那么当你写下 Width=&quot;96&quot; 时，到底缩放还是不缩放呢？缩放就迁就了 DPI 缩放的特性，违背了物理尺寸相同的特性；不缩放就迁就了物理尺寸相同的特性，丢失了 DPI 缩放的特性。 在非 PC 设备（手机、平板电脑、大屏幕电视）上，如果依然保持物理尺寸相同，那么 PC 上显示合适的 3cm 的按钮在手机上将占据大半个屏幕，在电视上将小得几乎看不见。怎么能让一个 UI 框架做出这么脑残的设计呢？有效像素（epx）的愿景有效像素概念的出现，就摒除了 WPF 物理尺寸相同这样荒谬而无法自圆其说的设定。但为了给有效像素设下定义，我们来看看微软到底期望这样的尺寸单位带来哪些方便吧：▲ 如果此处看不到视频，请前往 Channel 9 观看：Designing Universal Windows Platform apps。具体说来，对于手机和平板电脑（笔记本、Surface）这些近距离观看的设备，其物理尺寸可以更小；对于客厅摆放的大屏幕电视，观看距离较远，物理尺寸应该更大。相同的界面元素在不同设备上显示时，呈现出来的效果在视野角度上是相近的，这才是人眼观看比较舒适的尺寸概念的设计。▲ 图片来自于微软 UWP 设计指导文档 Introduction to Universal Windows Platform (UWP) app design (Windows apps)可以看出，有效像素的出现解决了我在 以上吐槽 中列举出无法自圆其说的第 2 点。认识到一个优秀的屏幕显示单位并不是按物理尺寸定义，而是根据不同的使用场景有所不同。第 1 点也部分得到了缓解——接受 DPI 缩放的特性，放弃承认物理尺寸相同的设定。有效像素（epx）的局限性一个好的概念除了要充分展示自己的愿景，也要看清自己的局限性。而有效像素的局限性就在于——它的愿景只是理想状态下才能有的效果，而微软本身允许硬件厂商和用户进行设置以偏离理想状态。具体是这样的： 显示器厂商为了自己的销售目标，会推出各种各样的型号——有高端的，有低端的，有主打性价比的。而性价比的主要来源就是——“噱头”——在部分参数上非常漂亮，部分参数却缩水严重。比如同样是 34 寸的 21:9 超宽屏显示器，5999 元的可以是 3440×1440 像素个数，而 3999 元的就只能是 2560×1080 像素个数。前者每英寸像素点数接近 96，而后者则低多了。Windows 操作系统上支持的最低 DPI 设置只能是 96 了，不能再低；以至于后者实际上在相同观看距离上比前者显示的界面元素的物理尺寸会大很多。这是硬件厂商的销售策略，你一个虚拟的单位还能拿它怎么样！这其实是此愿景不能实现的最主要原因了——各大显示器厂商都存在不按照最佳观看效果设置显示器参数的问题。这也是为什么我们经常能发现有些笔记本上的图标和字体大小被默认设置得小得可怜，或者超大屏幕设备上文字小得远处看不清的原因。（这里我们只谈显示器厂商在 EDID 信息中设置的最佳时序，这个时序欺骗了操作系统使之给出了不合适的显示效果；不要说用户可以改的问题，毕竟让用户改已经提高了门槛了。） 用户可以随时修改屏幕显示分辨率，修改系统或屏幕的 DPI 值。在显示分辨率与显示器实际物理分辨率不一致的情况下，用户还能设置画面的填充方式（居中或是拉伸）。我们认为，用户主动设置 DPI 是出于自己的一些目的——希望放大或缩小界面元素，而这有可能是因为原有大小对用户自己来说看起来不够舒适。（这里不想吐槽设置分辨率还不设置为居中显示的用户，那种画面模糊的感觉，怎么能承受！） 事实上，目前为止，只有一款设备真正达到了微软期望中的理想状态，那就是——Surface Studio！其它都只能算作接近，或者连接近都算不上。给有效像素下个定义结合微软对有效像素的愿景，结合实际情况，我认为“有效像素”的定义应该是这样的：在理想状态下，1 有效像素等于用户观看距离 50cm 时，观看屏幕上 1/96 英寸的物理距离所对应的视角大小。非理想状态下，1 有效像素等于显示器点对点显示像素时，1 屏幕像素乘以系统 DPI 值除以 96。WPF 和 UWP 的尺寸单位都可以用有效像素来理解，而这本身就是它们两个框架内建的单位系统。（彻底抛弃那个不能自圆其说的 DIP 吧！）有效像素的特性在以上定义之下，再研究有效像素的特性时，我们便能接受那些非理想状态下的不同行为，不再像 WPF 的 DIP 那样绝对而富有争议。按钮的大小之争当我们在代码中写下 Width=&quot;96&quot; 时，这个按钮到底多大？谈物理尺寸： 在 Surface Studio 这样的理想设备上，如果用户没有胡乱设置，它的物理宽度是 1 英寸； 在同一个显示器设备上，如果显示器的 PPI 是 96 pixels/inch，且用户使用最佳分辨率 DPI 值设置为 96，则它的物理宽度是 1 英寸 DPI 值设置为 144，则它的物理宽度是 1.5 英寸 DPI 值设置为 192，则它的物理宽度是 2 英寸 在以上情况下，如果 DPI 值固定为 96，但用户降低了分辨率 居中点对点显示，则它的物理宽度是 1 英寸 拉伸显示，则它的物理宽度大于 1 英寸 换一台显示器，PPI 值更大，则相同情况下的每一种情况都比以上物理宽度更小谈显示器像素个数： 用户使用了最佳分辨率 在 DPI 值为 96 时，显示完按钮宽度所用的屏幕像素个数为 96 DPI 值设置为 192 时，则显示完按钮宽度所用的屏幕像素个数是 192 在以上情况下，如果用户降低了分辨率 居中点对点显示，显示完按钮宽度所用的屏幕像素个数为 96 拉伸显示，显示完按钮宽度所用的屏幕像素个数大于为 96，虚拟的系统像素个数依然等于 96 接受现实看看按钮实际的大小，你会发现，影响因素真的太多太多了！当我们不再沉浸在 DIP 的理想中，不再纠结有效像素的愿景的时候，便能觉得有效像素其实为我们考虑 DPI 缩放问题做了不少努力，确实能减轻我们 UI 的开发工作量。" }, { "title": "WPF 跨应用程序域的 UI（Cross AppDomain UI）", "url": "/post/wpf-cross-domain-ui.html", "categories": "", "tags": "wpf", "date": "2018-12-14 09:54:00 +0800", "snippet": "为自己写的程序添加插件真的是一个相当常见的功能，然而如果只是简单加载程序集然后去执行程序集中的代码，会让宿主应用程序暴露在非常危险的境地！因为只要插件能够运行任何一行代码，就能将宿主应用程序修改得天翻地覆哭爹喊娘；而根本原因，就在于暴露了整个托管堆和整个 UI 树。如果将宿主和插件放到不同的应用程序域中，则可以解决此问题。本文将介绍跨应用程序域承载 UI 的方法，其中也包含跨域（Cross-Domain）调用方法。来自于托管插件框架的辅助类.NET Framework 自 3.5 以来推出了托管插件框架（MAF，Managed AddIn Framework），位于 System.AddIn 命名空间。其特性在于，将宿主和插件隔离在不同的应用程序域中，避免插件对宿主造成不良影响。此命名空间中存在 FrameworkElementAdapters 类型，在 System.Windows.Presentation 程序集中，详见 FrameworkElementAdapters.cs。虽说主要用于 MAF 插件框架，但其实只需要此类型便可以实现跨应用程序域的 UI。FrameworkElementAdapters 只有两个方法，ViewToContractAdapter 将 UI 转换成 INativeHandleContract，而 ContractToViewAdapter 将 INativeHandleContract 用一个 FrameworkElement 进行承载。public static class FrameworkElementAdapters{ [SecurityCritical] public static FrameworkElement ContractToViewAdapter(INativeHandleContract nativeHandleContract); [SecurityCritical] public static INativeHandleContract ViewToContractAdapter(FrameworkElement root);}一个极简的跨域 UI Demo首先，我们需要有一个支持跨域调用的类型，并有任意的可以用来返回 INativeHandleContract 的方法。internal sealed class DomainX : MarshalByRefObject{ public INativeHandleContract GetElement() { return FrameworkElementAdapters.ViewToContractAdapter( new Rectangle { Width = 200, Height = 100, Fill = Brushes.ForestGreen, }); }}我们需要跨域创建这个 UI 控件并得到 INativeHandleContract。var domain = AppDomain.CreateDomain(&quot;X&quot;);var instance = (DomainX)domain.CreateInstanceAndUnwrap(typeof(DomainX).Assembly.FullName, typeof(DomainX).FullName);var contract = instance.GetElement();然后，在需要承载这个跨域 UI 的地方取得这个 INativeHandleContract 的实例 contract。var element = FrameworkElementAsyncAdapters.ContractToViewAdapter(contract);// this 在这里是 MainWindow 或者 MainPage，或者其它任何能够承载 FrameworkElement 的对象。this.Content = element;以上的这两端代码都可以写在 MainWindow 的 Loaded 事件中。对 MAF 吐一下槽MAF 框架对插件和宿主程序集所在的文件夹结构有要求。这可是非常讨厌的一项特性！因为当我们希望采用 MAF 框架的时候，我们的应用程序可能已经有自己独特的一套目录了。就算我们从零开始写应用，采用 MAF 约定的方式组织 dll 也是很丑的方式（带有很重的 MAF 的影子）。它没有提供任何的配置，而且如果不按照约定放置文件夹，还会发生如下错误：参考资料 ENikS/System.AddIn: Projects related to Microsoft System.AddIn Add-In Performance: What can you expect as you cross an isolation boundary and how to make it better [Jesse Kaplan] – CLR Add-In Team Blog WPF Add-Ins Overview - Microsoft Docs Walkthrough: Creating an Extensible Application - Microsoft Docs Add-ins and Extensibility - Microsoft Docs" }, { "title": "Visual-&gt;UIElement-&gt;FrameworkElement，带来更多功能的同时也带来了更多的限制", "url": "/post/features-and-limits-on-visual-uielement-frameworkelement.html", "categories": "", "tags": "wpf, uwp, xaml", "date": "2018-12-14 09:54:00 +0800", "snippet": "在 WPF 或 UWP 中，我们平时开发所遇到的那些 UI 控件或组件，都直接或间接继承自 Framework。例如：Grid、StackPanel、Canvas、Border、Image、Button、Slider。我们总会自然而然地认为这些控件都是有大小的，它们会在合适的位置显示自己，通常不会超出去。但是，FrameworkElement 甚至是 Control 用得久了，都开始忘记 Visual、UIElement 带给我们的那些自由。阅读本文将了解我们熟知的那些功能以及限制的由来，让我们站在限制之外再来审视 WPF 的可视化树，再来看清 WPF 各种控件属性的本质。宽度和高度如果问 Width/Height 属性来自谁，只要在 WPF 和 UWP 里混了一点儿时间都会知道——FrameworkElement。随着 FrameworkElement 的宽高属性一起带来的还有 ActualWidth、ActualHeight、MinWidth、MinHeight、MaxWidth、MaxHeight。正是这些属性的存在，让我们可以直观地给元素指定尺寸——想设置多少就设置多少。然而……当你把宽或高设置得比父容器允许的最大宽高还要大的时候呢？我们会发现，控件被“切掉”了。▲ 被切掉的椭圆然而，因布局被“切掉”这一特性也是来自于 FrameworkElement！UIElement 布局时即便空间不够也不会故意去将超出边界的部分切掉，这一点从其源码就能得到证明：/// &amp;lt;summary&amp;gt;/// This method supplies an additional (to the &amp;lt;see cref=&quot;Clip&quot;/&amp;gt; property) clip geometry/// that is used to intersect Clip in case if &amp;lt;see cref=&quot;ClipToBounds&quot;/&amp;gt; property is set to &quot;true&quot;./// Typically, this is a size of layout space given to the UIElement./// &amp;lt;/summary&amp;gt;/// &amp;lt;returns&amp;gt;Geometry to use as additional clip if ClipToBounds=true&amp;lt;/returns&amp;gt;protected virtual Geometry GetLayoutClip(Size layoutSlotSize){ if(ClipToBounds) { RectangleGeometry rect = new RectangleGeometry(new Rect(RenderSize)); rect.Freeze(); return rect; } else return null;}只会在 ClipToBounds 设置为 true 的时候进行矩形切割。然而 FrameworkElement 的切掉逻辑就复杂多了，鉴于有上百行，就只贴出链接 FrameworkElement.GetLayoutClip。其处理了各种布局、变换过程中的情况。由于 FrameworkElement 的出现是为了让我们编程中像对待一个有固定尺寸的物体一样，所以也在切除上模拟了这样的空间有限的效果。如果希望不被切掉，有两种方法修正： 确保布局的时候所需尺寸不大于可用尺寸（一点也不能大于，就算是 double 精度问题导致的细微偏大都不行） MeasureOverride 返回的尺寸不大于参数传入的尺寸 ArrangeOverride 返回的尺寸不大于参数传入的尺寸 重写 GetLayoutClip 方法，并返回 null（或者写成 UIElement 那样）布局系统提及 MeasureOverride、ArrangeOverride，大家都会认为这是 WPF 布局系统给我们提供的两个可供重写的方法。然而，这两个方法其实也是 FrameworkElement 才提供的。真正布局的方法是 Measure 和 Arrange，而可供重写的方法是 MeasureCore、ArrangeCore。这两组方法均来自于 UIElement，而布局系统其实是 UIElement 引入的。那么 FrameworkElement 做了什么呢？它密封了 MeasureCore、ArrangeCore 这两个布局的重写方法，以便能够处理 Width、Height、MinWidth、MinHeight、MaxWidth、MaxHeight、Margin 这些属性对布局的影响。你觉得 Width、Height 属性是元素的最终宽高吗？我们在 宽度和高度 一节中已经说了不是，前面一段也说了不是——它们真的只是布局属性！然而，这真的很容易形成误解！WidthHeight 属性其实和 MinWidthMinHeight、MaxWidthMaxHeight 是完全一样的用途，只是在布局过程中为计算最终尺寸提供的布局限制而已。只不过 MinWidthMinHeight、MaxWidthMaxHeight 用大于和小于进行尺寸的限制，而 WidthHeight 用等于进行尺寸的限制。最终的尺寸依然是 ActualWidthActualHeight，而这个值跟 RenderSize 其实是一个意思，因为内部获取的就是 RenderSize。值得注意的是，ActualWidthActualHeight 与 RenderSize 一样，是布局结束后才会更新的，开发中需要如果修改了属性立即获取这些值其实必然是旧的，拿这些值进行计算会造成错误的尺寸数据。顺便吐槽一下：其实微软是喜欢用 Core 来作为子类重写方法的后缀的，比如 Freezable、EasingFunction 都是用 Core 后缀来处理重写。Override 后缀纯属是因为 UIElement 把这个名字用了而已。屏幕交互UIElement 中存在着布局计算，FrameworkElement 中存在着带限制的布局计算，这很容易让人以为屏幕相关的坐标计算会存在于 UIElement 或者 FrameworkElement 中。然而其实 UIElement 或者 FrameworkElement 只涉及到控件之间的坐标计算（TranslatePoint），真正涉及到屏幕坐标的转换是位于 Visual 中的，典型的是这几个： TransformToAncestor TransformToDescendant TransformToVisual PointFromScreen PointToScreen所以其实如果希望做出非常轻量级的高性能 UI，继承自 Visual 也是一个大胆的选择。当然，真正遇到瓶颈的时候，继承自 Visual 也解决不了多少问题。样式和模板FrameworkElement 开始有了样式（Style），Control 开始有了模板（Template）。而模板极大地方便了样式定制的同时，也造成了强大的性能开销，因为本来的一个 Visual 瞬间变成了几个、几十个。一般情况下这根本不会是性能瓶颈，然而当这种控件会一次性产生几十个甚至数百个（例如表格）的时候，这种瓶颈就会非常明显。总结容易出现理解偏差的几个点 Width 和 Height 属性其实只是为布局过程中的计算进行限制而已，跟 MinWidth、MinHeight、MaxWidth、MaxHeight 没有区别，并不直接决定实际尺寸。 如果发现元素布局中被切掉了，这并不是不可避免的问题；因为切掉是 FrameworkElement 为我们引入的特性，不喜欢可以随时关掉。 微软对于子类重写核心逻辑的方法喜欢使用 Core 后缀，布局中用了 Override 只是因为名字被占用了。 Visual 就可以计算与屏幕坐标之间的转换。 模板（Template）会额外产生很多个 Visual，有可能会成为性能瓶颈。参考资料 WPF Architecture - Microsoft Docs" }, { "title": "DependencyProperty.UnsetValue 的正确打开方式", "url": "/post/xaml/how-to-use-dependencyproperty-unsetvalue.html", "categories": "", "tags": "xaml", "date": "2018-12-14 09:54:00 +0800", "snippet": "无论是 WPF，还是 UWP，只要你用了绑定或者标记扩展，一定会碰到一个神奇的值——DependencyProperty.UnsetValue。UnsetValue 是什么意思？为什么会出现这个值呢？如果要让 UnsetValue 为我们所用，正确的用法又是什么呢？DependencyProperty.UnsetValue 是什么？要知道这是什么，一定要看源码：/// &amp;lt;summary&amp;gt; Standard unset value &amp;lt;/summary&amp;gt;public static readonly object UnsetValue = new NamedObject(&quot;DependencyProperty.UnsetValue&quot;);这是一个 NamedObject，而 NamedObject 又是什么呢？internal class NamedObject{ public NamedObject(string name) { if (String.IsNullOrEmpty(name)) throw new ArgumentNullException(name); _name = name; } public override string ToString() { if (_name[0] != &#39;{&#39;) _name = String.Format(CultureInfo.InvariantCulture, &quot;{{{0}}}&quot;, _name); return _name; } string _name;}好吧，其实这个类根本就没有什么用途，微软只是随便找了一个类，以便你在 Visual Studio 调试器或者你自己用代码输出值的时候能够显示一个预设好的字符串。真的只是起调试作用的啊！在 DependencyProperty.UnsetValue 的定义中，只是为了让大家调试的时候显示 DependencyProperty.UnsetValue 而已。值本身不代表任何意义，只是为了说明遇到了一个“未设置”的值。但是有人会问：null 在调试的时候也会显示 null 啊，为啥不用 null，要特别准备一个值呢？这是因为在绑定中，null 可能是一个合理的值，可能会被故意用在绑定中来达到某种目的。于是微软必须用一个大家平常开发中一定不会用到的值来表示“不合理”，于是祭出了 DependencyProperty.UnsetValue。什么情况下会出现 DependencyProperty.UnsetValue？正常情况下，只有以下两处代码会遇到 DependencyProperty.UnsetValue： 在用于绑定的转换器 IValueConverter IMultiValueConverter 的代码里面； 在 XAML 标记扩展 MarkupExtension 里面。而以上两处代码，只有在发生以下三种情况时才会遇到 DependencyProperty.UnsetValue： 绑定出现了错误，也就是说绑定从最开始的源值到目标值的若干次转换过程中任何阶段发生了错误以至于无法成功转换到目标值。虽然我们写的是一个 {Binding XXX}，但 XXX 可能由另外的绑定来提供（例如逻辑父控件的 DataContext）。一次次绑定的源值是上一个绑定的目标值，于是这样的关系组合成一个绑定提供值的链条。链条中只要有一处不能提供合理的值，就会在绑定中得到 UnsetValue。 绑定或者标记扩展写在了 ControlTemplate 或者 DataTemplate 里面，但此时并没有指定数据源。在模板应用到实际的控件之前，模板本身也会执行一次 Binding 和 MarkupExtension 的逻辑。于是如果绑定需要依赖于实际的控件，那么实际上 Binding 和 MarkupExtension 会至少执行两次，其中第一次便是模板中的那一次。此时获取依赖属性的值时拿到的便是 DependencyProperty.UnsetValue。 使用依赖项属性的 ReadLocalValue 来获取值，而不是 GetValue；但此时并没有为依赖对象设置值。如果没有设置值，那么 GetValue 会返回更低优先级的值，一般情况下是依赖项属性在注册时的默认值；但 ReadLocalValue 就是在获取显式设置的那个值，如果没设，就只能是 DependencyProperty.UnsetValue 了。我们应该如何正确使用 DependencyProperty.UnsetValue？微软官方对于 DependencyProperty.UnsetValue 的介绍，专门的文档中只有一个说法，就是用来表示“不合理”的值，却并没有说明什么情况下为合理，什么情况下为不合理。但好在微软将一些推荐写法散落在了多个不同的文章中。这里整理在一起，以便为大家对 DependencyProperty.UnsetValue 的正确使用提供指导。 在注册依赖项属性的时候，不要使用 DependencyProperty.UnsetValue 作为默认值。这个值本意其实并不是在说“未设置”，而是代表“不合理”。默认值必须是“合理地”才行。微软官方文档 Custom dependency properties 对此的解释是，如果默认值设置为 UnsetValue，则会在大家使用其值的时候产生混淆，并不能区分到底是依赖属性（的绑定系统）提供值的时候出错了还是因为只是默认没设置。 微软推荐在写绑定的转换器的时候，如果转换有错误，不应该抛出异常，而是应该返回一个 DependencyProperty.UnsetValue，以便阻止绑定中继续传递值。不过我认为错误应该更及时地被发现才能避免错误的继续蔓延，所以建议在 DEBUG 下依然抛出异常，而在发布的版本里返回 UnsetValue。微软的推荐出自于 Data binding in depth，在 How to: Convert Bound Data 中给出了这种推荐的示例代码。 如果需要在 CoerceValueCallback 回调中验证值的合理性，当值不合理的时候，返回 DependencyProperty.UnsetValue。这将告诉依赖属性系统阻止这次值的更改。参考资料 Data binding in depth - UWP app developer - Microsoft Docs How to: Convert Bound Data - Microsoft Docs Custom dependency properties - UWP app developer - Microsoft Docs Dependency Property Callbacks and Validation - Microsoft Docs c# - Why do I get a DependencyProperty.UnsetValue when converting a value in a MultiBinding? - Stack Overflow DependencyProperty.UnsetValue Field (System.Windows) UnsetValue" }, { "title": "用 AppContext 解决类库的更新兼容问题", "url": "/post/dotnet/2017/09/30/app-context.html", "categories": "", "tags": "dotnet", "date": "2018-12-14 09:54:00 +0800", "snippet": "还记得微软在 Mitigation: Pointer-based Touch and Stylus Support 中告诉大家如何在 .NET Framework 4.7 中迁移 WPF 的触控到基于 Pointer 消息？记得关键的 &amp;lt;AppContextSwitchOverrides value=&quot;Switch.System.Windows.Input.Stylus.EnablePointerSupport=true&quot;/&amp;gt; 这一句吗？有没有好奇为何这一句话能用来控制微软基础类库中某一块功能的行为呢？阅读本文将了解微软为开发者提供的一套类库更新的兼容性解决方案——AppContext。这是微软自 .NET Framework 4.6 开始为开发者们提供的方案。比如你打算为你的类库增加了一个功能——指定一个文件夹名称用于存放文件。你写出了这样的代码：// 1.0 版本的类库public static class StorageSomeInfo{ public static void SetDirectoryName(string directoryName) { _directory = directoryName ?? throw new ArgumentNullException(nameof(directoryName)); // 其他逻辑。 }}故事背景你将类库发布到 NuGet 上，一切运行安好。直到有一天，某人给 directoryName 传入了空字符串。结果你的文件全部都不再存到指定的文件夹下，而是存到了根目录……这跟你的预期不符啊！然而，类库发布了这么久，这么多人都下载安装使用了，要是随随便便把代码改成这样，搞不好一大堆小伙伴将面临着崩溃……（谁知道他们有没有依赖于你的 BUG 编程呢？搞不好他们绞尽脑汁发现这样还可以存到根目录呢于是就开开心心地用了呢！）// 2.0 版本的类库public static class StorageSomeInfo{ public static void SetDirectoryName(string directoryName) { if (string.IsNullOrWhitespace(directoryName)) throw new ArgumentException(nameof(directoryName)); // 其他逻辑。 }}[Obsolete] 是一个好方案，他能够指导开发者一步步迁移他们对 API 的使用。不过： 如果调用的代码太多了，迁移起来就是个痛苦的差事儿。 难得取了个好名字，要知道取名字可是编程中最难的事儿之一啊！ 更多的开发者们其实根本没意识到你写出了这个坑，于是凭什么让他们升级 API？！使用 AppContext这时候祭出——AppContext！将你的 2.0 代码改成这样：// 2.0 版本的类库public static class StorageSomeInfo{ public static void SetDirectoryName(string directoryName) { if (AppContext.TryGetSwitch(&quot;Switch.StorageSomeInfo.UseLegacyDirectoryName&quot;, out var flag) &amp;amp;&amp;amp; flag == true) // 跑以前的代码 else // 跑新的代码 // 其他逻辑。 }}那么开发者们更新你的类库时，就有可以挽回的方案了： 如果开发者们没有遇到什么问题，那么恭喜你那位开发者很幸运没有踩到你的坑，你平滑迁移过去了！ 如果开发者们遇到了根目录问题，那么你的更新日志中的指导说明将起作用。你可以在更新日志中写下说明： 建议开发者们修改此方法的调用，避免写出错误的代码； 如果开发者们很难改动这样的代码，可以要求开发者在 app.config 文件中添加以下代码以使用“遗弃的”逻辑。 &amp;lt;configuration&amp;gt; &amp;lt;runtime&amp;gt; &amp;lt;AppContextSwitchOverrides value=&quot;Switch.StorageSomeInfo.UseLegacyDirectoryName=true&quot; /&amp;gt; &amp;lt;/runtime&amp;gt; &amp;lt;/configuration&amp;gt; 更多 AppContext 的信息开发者们如果有多个开关需要开启或关闭，则使用分号分隔多个开关：&amp;lt;AppContextSwitchOverrides value=&quot;switchName1=value1;switchName2=value2&quot; /&amp;gt; 开发者们如果不想写配置文件，也可以直接在程序中调用：AppContext.SetSwitch(string, bool);当然，甚至可以直接动用注册表：HKLM\\SOFTWARE\\Microsoft\\.NETFramework\\AppContext 作为 Key，字符串作为 Value。依然是分号分割的键值对作为注册表项的值来存。如果采用注册表方案，将影响这台计算机上运行的所有程序。这三种方式的优先级是： 代码中直接调用的优先级最高； 在 app.config 中指定的优先级其次； 在注册表中指定的优先级最低。一点坑在从 .NET Framework 4.6 升级到 4.7 后，注册表的方式貌似失效了。参考：FIX: AppContext switch overrides are not applied to applications that run on the .NET Framework 4.7" }, { "title": "为 Visual Studio 使用通配符批量添加项目文件", "url": "/post/vs/2017/09/26/wildcards-in-vs-projects.html", "categories": "", "tags": "visualstudio, msbuild", "date": "2018-12-14 09:54:00 +0800", "snippet": "通常大家都不会关心 Visual Studio 的项目文件里是如何记录这个项目所包含的所有文件的，因为各位开发者们早已经习惯于右键添加文件或者拖拽文件进项目了。但如果你在某一个文件夹中放了大量的文件（尤其是图片等资源文件），那么这时会卡很久才能拖进去，拖完之后如果还要批量修改生成操作，那真的是痛不欲生。但是，Visual Studio 提供的项目文件（*.csproj）其实是支持通配符的。比如，我们通常的项目文件的片段是这样的：&amp;lt;ItemGroup&amp;gt; &amp;lt;Content Include=&quot;Properties\\Default.rd.xml&quot; /&amp;gt; &amp;lt;Content Include=&quot;Assets\\LockScreenLogo.scale-200.png&quot; /&amp;gt; &amp;lt;Content Include=&quot;Assets\\SplashScreen.scale-200.png&quot; /&amp;gt; &amp;lt;Content Include=&quot;Assets\\Square150x150Logo.scale-200.png&quot; /&amp;gt; &amp;lt;Content Include=&quot;Assets\\Square44x44Logo.scale-200.png&quot; /&amp;gt; &amp;lt;Content Include=&quot;Assets\\Square44x44Logo.targetsize-24_altform-unplated.png&quot; /&amp;gt; &amp;lt;Content Include=&quot;Assets\\StoreLogo.png&quot; /&amp;gt; &amp;lt;Content Include=&quot;Assets\\Wide310x150Logo.scale-200.png&quot; /&amp;gt;&amp;lt;/ItemGroup&amp;gt;但是，改成这样的话，以后新添加的 *.png 文件也会加入：&amp;lt;ItemGroup&amp;gt; &amp;lt;Content Include=&quot;Properties\\Default.rd.xml&quot; /&amp;gt; &amp;lt;Content Include=&quot;Assets\\*.png&quot; /&amp;gt;&amp;lt;/ItemGroup&amp;gt;而且，如果你想改生成方式，也很简单：&amp;lt;ItemGroup&amp;gt; &amp;lt;None Include=&quot;Properties\\Default.rd.xml&quot; /&amp;gt; &amp;lt;None Include=&quot;Assets\\*.png&quot; /&amp;gt;&amp;lt;/ItemGroup&amp;gt;但是，小心有坑，因为如果你的目录下是多个文件夹嵌套的话，需要用两个星号来表示可能出现多层文件夹：&amp;lt;ItemGroup&amp;gt; &amp;lt;Content Include=&quot;Properties\\Default.rd.xml&quot; /&amp;gt; &amp;lt;Content Include=&quot;Assets\\*.png&quot; /&amp;gt; &amp;lt;Content Include=&quot;Assets\\**\\*.png&quot; /&amp;gt;&amp;lt;/ItemGroup&amp;gt;参考资料 How to: Select the Files to Build - Microsoft Docs" }, { "title": "深入了解 WPF Dispatcher 的工作原理（Invoke/InvokeAsync 部分）", "url": "/post/dotnet/2017/09/26/dispatcher-invoke-async.html", "categories": "", "tags": "dotnet", "date": "2018-12-14 09:54:00 +0800", "snippet": "深耕 WPF 开发的各位程序员大大们一定避不开使用 Dispatcher。跨线程访问 UI 当然免不了用到它，将某个任务延迟到当前任务之后执行也会用到它。Dispatcher.Invoke、Dispatcher.BeginInvoke 是过去大家经常使用的方法，而 .NET Framework 4.5 中微软为我们带来了 Dispatcher.InvokeAsync 方法，它和前面两个有何不同？阅读本文将更深入地了解 Dispatcher 的工作机制。本文是深入了解 WPF Dispatcher 的工作原理系列文章的一部分： Invoke/InvokeAsync 部分（本文） PushFrame 部分回顾老旧的 BeginInvoke，看看新的 InvokeAsync微软自 .NET Framework 3.0 为我们引入了 Dispatcher 之后，BeginInvoke 方法就已存在。不过，看这名字的 Begin 前缀，有没有一种年代感？没错！这是微软在 .NET Framework 1.1 时代就推出的 Begin/End 异步编程模型（APM，Asynchronous Programming Model）。虽说 Dispatcher.BeginInvoke 并不完全按照 APM 模型来实现（毕竟没有对应的 End，也没有返回 IAsyncResult），但这个类型毕竟也是做线程相关的事情，而且这个方法的签名明显还带着那个年代的影子。不止名字上带着 Begin 表示异步的执行，而且参数列表中还存在着 Delegate 和 object 这样古老的类型。要知道，现代化的方法可是 Action/Func 加泛型啊！大家应该还对 .NET Framework 4.5 带给我们的重磅更新——async/await 异步模式感到兴奋，因为它让我们的异步代码变得跟同步代码一样写了。这是微软新推荐的异步编程模式，叫做 TAP（Task-based Asynchronous Pattern）。既然异步编程模式都换了，同为线程服务的 Dispatcher.BeginInvoke 怎能不改呢？于是，微软真的改了，就是从 .NET Framework 4.5 版本开始。它叫做——Dispatcher.InvokeAsync。BeginInvoke 和 InvokeAsync 有什么不同？这个还真得扒开微软的源码看一看呢！[Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]public DispatcherOperation BeginInvoke(DispatcherPriority priority, Delegate method);[Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]public DispatcherOperation BeginInvoke(DispatcherPriority priority, Delegate method, object arg);[Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]public DispatcherOperation BeginInvoke(DispatcherPriority priority, Delegate method, object arg, params object[] args);public DispatcherOperation BeginInvoke(Delegate method, params object[] args);public DispatcherOperation BeginInvoke(Delegate method, DispatcherPriority priority, params object[] args);一共五个重载，前面三个都被微软做了标记，让你在智能感知列表中看不见。（这里吐槽一下 ReSharper，明明微软已经不让显示了嘛，干嘛还把人家显示出来……）后面两个暂时还看得见，但那又如何？！根本没啥区别好吗！！！为什么会像上面那样吐槽，是因为我发现这五个不同的重载里面其实都调用了同一个内部方法：[SecuritySafeCritical]private DispatcherOperation LegacyBeginInvokeImpl(DispatcherPriority priority, Delegate method, object args, int numArgs){ ValidatePriority(priority, &quot;priority&quot;); if(method == null) { throw new ArgumentNullException(&quot;method&quot;); } DispatcherOperation operation = new DispatcherOperation(this, method, priority, args, numArgs); InvokeAsyncImpl(operation, CancellationToken.None); return operation;}这里让我忍不住吐槽的是两点： Legacy 是个什么鬼！词典上说这是“遗产，老化的”意思啊！很明显这是近乎被微软遗弃的代码啊！ 既然这五个重载都用了被遗弃的方法，为什么只有前面三个看不见，后面两个看得见啊！还有，微软你干嘛不标记为 [Obsolete] 呢！好，吐槽结束。我们再来看看 InvokeAsync 方法。public DispatcherOperation InvokeAsync(Action callback);public DispatcherOperation InvokeAsync(Action callback, DispatcherPriority priority);[SecuritySafeCritical]public DispatcherOperation InvokeAsync(Action callback, DispatcherPriority priority, CancellationToken cancellationToken);public DispatcherOperation&amp;lt;TResult&amp;gt; InvokeAsync&amp;lt;TResult&amp;gt;(Func&amp;lt;TResult&amp;gt; callback);public DispatcherOperation&amp;lt;TResult&amp;gt; InvokeAsync&amp;lt;TResult&amp;gt;(Func&amp;lt;TResult&amp;gt; callback, DispatcherPriority priority);[SecuritySafeCritical]public DispatcherOperation&amp;lt;TResult&amp;gt; InvokeAsync&amp;lt;TResult&amp;gt;(Func&amp;lt;TResult&amp;gt; callback, DispatcherPriority priority, CancellationToken cancellationToken);看吧，这才像微软新的 TAP 异步模式的代码啊。不带 CancellationToken 的四个重载会汇聚到带 CancellationToken 的两个重载中，这两个重载代码除了泛型返回值以外几乎一模一样。所以我们拿第三个当研究对象看看：[SecuritySafeCritical]public DispatcherOperation InvokeAsync(Action callback, DispatcherPriority priority, CancellationToken cancellationToken){ if(callback == null) { throw new ArgumentNullException(&quot;callback&quot;); } ValidatePriority(priority, &quot;priority&quot;); DispatcherOperation operation = new DispatcherOperation(this, priority, callback); InvokeAsyncImpl(operation, cancellationToken); return operation;}你发现了什么？这与那个被遗弃的 LegacyBeginInvokeImpl 长得非常像。不，就是一模一样！你总不能说参数名称不同也要算吧……甚至……返回值类型也是一样的。既然这样，我们总算是明白微软到底在做些什么了。其实微软在 .NET Framework 4.5 中已经把 BeginInvoke 的实现改造成了 TAP 异步模式，但方法名字和老旧的参数列表却始终是微软的一块心病，于是痛下决心新增了 6 个更加现代的方法免得产生兼容性问题。不过由于里面的实现一模一样，并没有额外带来什么 BUG，所以微软也不好意思标记为 [Obsolete] 已过时了。既然两个方法一样，后文我也就没必要两个都说了，一切以新款的 InvokeAsync 为主。InvokeAsync 的实现原理前面一节几乎告诉我们，InvokeAsync 的关键就在 InvokeAsyncImpl 方法中。 用一个 DispatcerOperation 把我们传入的 Action/Func 包装起来。这样，我们传入的任务和优先级将在一起处理。 将 DispatcherOperation 加入到一个 PriorityQueue&amp;lt;DispatcherOperation&amp;gt; 类型的队列中。这个队列内部实现是一个 SortedList，于是每次入队之后，出队的时候一定是按照优先级出队的。 调用 RequestProcessing，直至最后向某个隐藏窗口发送了一条消息。 那个隐藏窗口接收到了这条消息，然后从 PriorityQueue&amp;lt;DispatcherOperation&amp;gt; 队列中取出一条任务执行（真实情况复杂一点，后面会谈到）。上面第 3 点的消息是这样发的：UnsafeNativeMethods.TryPostMessage(new HandleRef(this, _window.Value.Handle), _msgProcessQueue, IntPtr.Zero, IntPtr.Zero);等等，这句代码里面的 _window 是哪儿来的？为什么凭空出现了一个可以用来发送消息的窗口？于是，在 Dispatcher 构造函数中发现了这个窗口。这并不是我们平时所熟知的那个 Window 类，而是一个用于发送和接收 Dispatcher 调度器调度任务消息的 Win32 隐藏窗口。不信它是一个窗口？请进入 MessageOnlyHwndWrapper 类看，它的基类 HwndWrapper 中直接使用了方法 UnsafeNativeMethods.CreateWindowEx 创建了这个窗口，然后拿到了它的句柄 Handle。既然会向窗口发消息，自然而然可以 Hook 它的消息处理函数，就像下面这样：// Create the message-only window we use to receive messages// that tell us to process the queue.MessageOnlyHwndWrapper window = new MessageOnlyHwndWrapper();_window = new SecurityCriticalData&amp;lt;MessageOnlyHwndWrapper&amp;gt;( window );_hook = new HwndWrapperHook(WndProcHook);_window.Value.AddHook(_hook);而这里处理的消息类型只有三种： 关掉这个隐藏窗口； 处理 Dispatcher 调度的任务（这个消息是在 Dispatcher 的静态构造函数中注册的）； 定时器。前面两个不难理解，但是为什么这里与定时器有关？！继续调查，我们发现微软在 Dispatcher 中把所有不同种类的优先级分成了三个大类： 前台优先级（对应 DispatcherPriority.Loaded 到 DispatcherPriority.Send，也就是数字 6~10） 后台优先级（对应 DispatcherPriority.Background 到 DispatcherPriority.Input，也就是数字 4~5） 空闲优先级（对应 DispatcherPriority.SystemIdle 到 DispatcherPriority.ApplicationIdle，也就是数字 1~3）在这里微软又开始逗我们玩了……因为在他的处理中，后面两个是完全相同的！所以严格意义上只分了两种——前台优先级和非前台优先级。而区分他们的一个分界点就是——用户的输入。如果有用户的输入发生，那么会开启一个定时器，在定时器时间到达之前，所有的后台优先级任务都不会去执行。但前台优先级任务不受用户输入的影响。在这样的设定下，用户的输入不会随随便便被饿死，WPF 程序也就不会从输入层面开始卡顿了。研究到这里，似乎 InvokeAsync 的执行原理差不多都清楚了。但是不要忘了这可是 TAP 异步模式的一项实践啊，这方法是要支持 await 并附带返回值的。但这里就没有更多底层的内容了。我们注意到 InvokeAsync 的返回值是 DispatcherOperation 类型的，而这就是 InvokeAsync 方法中我们前面看到的代码中直接 new 出来的。DispatcherOperation 中有一个 Invoke 方法，这是无返回值的，但是它执行完后会置 Task 的 Result 值。另外 DispatcherOperation 实现了 GetAwaiter 方法，于是就可以使用 await。对于如何自己实现一个可以 await 的类，我可能会专门写一篇文章，但如果你现在就希望了解，可以阅读：How to write a custom awaiter – Lucian’s VBlog。而被我们遗弃的 BeginInvoke，由于内部调用了同一个函数，所以实现原理是完全一样的。而且，这么古老的函数也允许 await。Invoke 的实现原理也许你会觉得奇怪。我们连“异步”的 InvokeAsync 的实现原理都了解了，同步的 Invoke 还有何难！如果你这么认为，你一定忽略了一个很重要的问题——死锁！如果是另一个线程调用到此线程的 Invoke，那么同步等待一下当然不会有问题。但是如果调用线程就是此线程本身呢？如果依然采用“同步等待”的方式，那么 UI 线程就会因为 Invoke 的调用而阻塞，然而 Invoke 中传入的 Action 是插入到 UI 线程执行的，如果 UI 线程正在等待 Invoke，还怎么插入得进去？！所以，它一定有另外一套实现方式！而微软为这套实现方式做了两条路径： 如果是 10 的最高优先级，则直接调用 Invoke 里传入的任务； 如果是其他，则调用 DispatcherOperation 的 Wait 方法进行等待。等等，这不还是 Wait 吗！然而进去 Wait 方法查看，你会发现，根本不是！public DispatcherOperationStatus Wait(TimeSpan timeout){ // 省略一些前面的代码。 // We are the dispatching thread for this operation, so // we can&#39;t block. We will push a frame instead. DispatcherOperationFrame frame = new DispatcherOperationFrame(this, timeout); Dispatcher.PushFrame(frame); // 省略一些后面的代码。 return _status;}它用了 Dispatcher.PushFrame。这样保证了在不阻塞线程的情况下进行“等待”。至于如何做到“不阻塞地等待”，请参阅本系列的第二篇文章 深入了解 WPF Dispatcher 的工作原理（PushFrame 部分）。总结 进入了 .NET Framework 4.5 及以上的开发者们，建议使用 InvokeAsync 代替 BeginInvoke； Dispatcher 通过创建一个隐藏的消息窗口来让一个个 Invoke 到此线程的任务按照优先级执行； Invoke 使用 PushFrame 做到了不阻塞 UI 线程的等待。参考资料 异步编程模型 Asynchronous Programming Model (APM) - Microsoft Docs Asynchronous Design Pattern Overview Interop with Other Asynchronous Patterns and Types - Microsoft Docs Task-based Asynchronous Pattern (TAP) - Microsoft Docs InvokeAsync Dispatcher.cs WPF 消息机制 WPF的消息机制（二）- WPF内部的5个窗口之隐藏消息窗口 - 葡萄城控件技术团队博客 - CSDN博客 Awaiter How to write a custom awaiter – Lucian’s VBlog " }, { "title": "git 如何更可靠地解决冲突？", "url": "/post/resolve-git-conflicts.html", "categories": "", "tags": "git, visualstudio", "date": "2018-12-09 19:45:25 +0800", "snippet": "使用 git 合并代码时出现冲突是很常见的，不过如何解冲突才能更加可靠呢？不漏掉别人的修改，也同时让自己的修改完全保留。本文将介绍利用各种工具更可靠地解决冲突。使用 Visual Studio如果你使用 Visual Studio，那么当合并两个分支出现冲突的时候，Visual Studio 的 Team Explorer 会显示当前冲突的所有文件。▲ 图 1当你点击其中一个文件的 Merge 按钮的时候，会显示这个文件的合并界面。▲ 图 2可以看到，上图中两边的差异非常大。左边的代码进行了某项不为人知的修改，而右边的这些代码都被删除了。如果采用左边，则右边删除移走的代码就会留存，形成两份相似的代码；如果采用右边，那么左边在另一个分支的修改就会丢失。这时，可以 和基准进行比较 来查看两个分支相对于同样的基准提交的差异来手动解决冲突。点击合并页面顶部工具栏中的选择比较源按钮，可以切换比较代码的双方。你可以比较“源”和“目标”，这也是默认的比较。你还可以选择比较“源”和“基准”、“目标”和“基准”。这样，你可以分别查看两边代码相比于同一个基准提交的修改。对于左边的修改，通过查看“源”与“基准”的不同，得知左边其实值修改了一行。那么这时，我们把这一行重新补充到右边删除移走的代码里面（被移到了另一个文件中，需要补充到那个文件中对应的地方），那么两边的修改才真正时等价合并了。你可以在下图看到这两个不同选项的理解。" }, { "title": "使用 ReSharper，输入即遵循 StyleCop 的代码格式化规范", "url": "/post/write-code-with-stylecop-using-resharper.html", "categories": "", "tags": "visualstudio, csharp, dotnet", "date": "2018-12-01 12:36:27 +0800", "snippet": "StyleCop 可以帮助强制执行代码格式化规范，ReSharper 可以帮助你更高效地编写代码。把两者结合起来，你便能高效地编写符合团队强制格式化规范的代码来。本文就介绍如何使用 ReSharper 来高效地遵循 StyleCop 的代码格式化规范。安装插件 StyleCop by JetBrainsStyleCop by JetBrains 插件的开发名称是 StyleCop.ReSharper，所以你也可以通过搜索 StyleCop.ReSharper 得到同样的插件。▲ StyleCop by JetBrains 的图标先安装 StyleCop by JetBrains 插件。注意这是 ReSharper 的插件，而不是 Visual Studio 的插件。你需要到 ReSharper 的 Extension Manager 中去下载。▲ 前往 ReSharper 的 Extension Manager在 ReSharper 自己的插件管理页面，搜索并安装 StyleCop by JetBrains 插件：▲ 搜索并安装 StyleCop by JetBrains当你点击了窗口下面的那个“Install”按钮后，ReSharper 会弹出一个等待窗口一次性安装完毕。你需要等待，等待的时间取决于网速。安装完之后，重启 Visual Studio 就会生效。如果你稍后见到了本节上面的图标，那么那实际上就是 StyleCop by JetBrains 插件的一部分。修改 StyleCop by JetBrains 的规则现在打开一个以前写的项目，你可能会发现大量的代码都已被波浪线入侵 😭 。▲ 代码已被波浪线入侵，代码源自我的另一篇博客：如何实现一个可以用 await 异步等待的 Awaiter。如果你现在编写新的代码，你会发现新的代码已经开始使用 StyleCop 建议的规则了。不过，可能这个规则并不是你希望的规则，正如这张图所描述的那样： The documentation text within the param tag does not contain any whitespace between words, indicating that it most likely does not follow a proper grammatical structure required for documentation text. [StyleCp Rule: SA1630]翻译过来：param 标记中的文档文本不包含任何单词之间的空格，表示它很可能不遵循文档文本所需的正确语法结构。[StyleCp规则：SA1630]。很明显，这一条 StyleCop 规则连中文都没有考虑过，中文文本怎么可能包含单词之间的空格呢 😂 。所以，很明显我们需要定制我们自己的 StyleCop 规则。在 ReSharper 的设置中找到 Code Inspection -&amp;gt; Inspection Serverity -&amp;gt; C# -&amp;gt; StyleCop。展开之后你就能看到 StyleCop by JetBrains 的规则定制了。▲ 定制规则在这里，按照你的团队约定，将一项项的值设置为： 不遵守 提示 建议 警告 错误不通用的 StyleCop by JetBrains 规则实际上使用此插件生成的 StyleCop 规则并不是 StyleCop 的通用配置，而是生成了一个 DotSettings 的 ReSharper 配置。如果需要使用到通用配置，请阅读 在 Visual Studio 中使用 StyleCop 来约束团队代码规范。参考资料 StyleCop code style settings and inspections - .NET Tools Blog.NET Tools Blog ReSharper Gallery - StyleCop by JetBrains" }, { "title": "用 dotTrace 进行性能分析时，各种不同性能分析选项的含义和用途", "url": "/post/dottrace-profiler-options.html", "categories": "", "tags": "dotnet", "date": "2018-11-28 16:25:46 +0800", "snippet": "对 .NET 程序进行性能分析，dotTrace 能应对绝大多数的场景。在开启一个进程进行性能分析之前，我们会看到一些性能分析选项（Profiler Options）。本文将介绍这几个选项的含义，并用实际的例子来说明其用途。dotTrace 的性能分析选项你可以前往 Download dotTrace: .NET Performance Profiler by JetBrains 下载 dotTrace。本文要说的就是下图右边的那四个选项，在启动一个进程进行性能分析之前可以看得见的。▲ dotTrace 启动进程进行性能分析的界面有四个选项： Sampling Tracing Line-by-Line TimelineSampling 采样界面中的描述为： Accurate measurement of call time. Optimal for most use cases.使用此选项进行启动进程后，会准确测量不同方法的执行时间，但不会统计方法的调用次数。这适用于大多数场景。尤其是如果你还没有对你的程序进行过任何性能分析的情况下，先使用这个选项进行一个初步分析大致确定性能问题是很方便的。Tracing 追踪界面中的描述为： Accurate measurement of calls number. Optimal for analyzing algorithm complexity.会准确地测量调用次数。但在此选项下，时间的测量将由于性能分析的开销过大而可能不准确。如果你使用 Sampling 分析方式得不到你想要的性能分析数据的时候，你可能用得到此选项。例如，当你分析算法复杂度，需要明确知道方法的调用次数，而不需要知道方法的准确执行时间的时候。Line-by-line 逐行界面中只写了一句根本无法理解的话： Advanced use cases only.仅仅说了这是高级使用场景，名没有说什么样的场景。这个选项下，分析器会测量每行代码。由于性能分析的开销过于巨大，调用时间的测量也是不准确的。如果要降低此选项下的开销，你可以使用过滤器仅分析特定的方法。关于使用过滤器，可以阅读官方文档 Profiler Options - Help - dotTrace。当你已经通过其他方法得知性能问题出现在哪个具体的方法时你可能需要用到这个选项，这会分析此方法的每一行代码。Timeline 时间线界面中的描述为： Measurement of temporal performance data. Optimal for most use cases including analysis of multi-threaded applications.收集有关线程状态、应用程序事件和其他多线程数据的时态数据。此方法基于 Windows 的事件跟踪器（ETW）。推荐用于大多数情况，尤其是分析多线程应用程序的时候。你可以用这个选项来确定 UI 卡顿或不响应的原因，可以分析过多的 GC（垃圾回收），可以分析不均匀的工作负载分配、IO 不足或者其他各种异常。由于需要用到 Windows 的事件跟踪器（ETW），所以你可能遭遇 ETW 相关的问题。具体可以阅读 用 dotTrace 进行性能分析时，Timeline 打不开？无法启动进程？也许你需要先开启系统性能计数器的访问权限。参考资料 Profiler Options - Help - dotTrace" }, { "title": "Win2D 中的游戏循环：CanvasAnimatedControl", "url": "/post/game-loop-of-win2d-canvas-animated-control.html", "categories": "", "tags": "dotnet, win2d, uwp", "date": "2018-11-28 16:25:46 +0800", "snippet": "Win2D 是 DirectX 的一个高层封装，提供了极大 DirectX 性能的同时，又具有很好用的 API 设计。用 Win2D 除了能做出高性能的视觉效果之外，还可以轻而易举地搭建一个游戏循环出来。使用 Win2D 的游戏循环，你可以直接做出一个简单的游戏出来。使用 Win2D 做出来的游戏我在 GitHub 上开源了我正在做的一个基于 Win2D 的小游戏 —— GravityMaze，可以翻译为重力迷宫。本意是使用手机的重力感应器借助于自然重力的方式玩这款游戏，不过考虑到 Windows 10 Mobile 的手机太少，用户数量太少，其实我还是直接展示 UWP 桌面版好了。使用方向键可以控制桌面的倾斜角度，以便间接控制小球的运动方向。当然，我自己是有一部 Lumia 950XL 的，你可以在 使用 Windows 10 中的加速度计（Accelerometer，重力传感器） 一文中看到它的身影。▲ 重力迷宫这张图的红色背景是我自己拍摄的，所以绝不可能存在版权问题。准备工作要使用 Win2D 进行简单的游戏开发，你需要先配置好一些 UWP 的开发环境，并且在你的项目中安装 Win2D.uwp 的 NuGet 包。阅读 win10 uwp win2d 入门 看这一篇就够了 - 林德熙 了解如何在你的项目中安装 Win2D，并且了解 Win2D 基本的知识。Win2D 中的画布控件Win2D 中的画布有 CanvasControl、CanvasVirtualControl 和 CanvasAnimatedControl。 CanvasControl 用于进行一次性绘制，或者那些不常更新的画面内容。例如进行软件的 UI 绘制，或者软件中所得图形的绘制。 CanvasVirtualControl 适用于在一个很大的画面中，只显示一个小部分的情况。例如显示大地图的一部分，或者显示大量超界的笔迹内容。 CanvasAnimatedControl 适用于显示频繁更新的画面。典型的例子就是游戏。CanvasAnimatedControl我们使用 CanvasAnimatedControl 来做游戏循环，因为这是 Win2D 这几个控件中最适合做游戏循环的控件了。要在你的项目中使用 CanvasAnimatedControl，你需要在 XAML 中添加 using:Microsoft.Graphics.Canvas.UI.Xaml：&amp;lt;Page x:Class=&quot;Walterlv.GravityMaze.Pages.GamePage&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:xaml=&quot;using:Microsoft.Graphics.Canvas.UI.Xaml&quot;&amp;gt; &amp;lt;xaml:CanvasAnimatedControl Update=&quot;OnUpdate&quot; Draw=&quot;OnDraw&quot; /&amp;gt;&amp;lt;/Page&amp;gt;然后，我们订阅 CanvasAnimatedControl 的两个事件： Update 用于更新游戏中的数据，更新参考的是游戏时间线。 Draw 用于绘制游戏的内容。 这是游戏循环最必要的两个事件了，其他虽然也是需要的，但也可以不写。private MazeGame _game; private void OnUpdate(ICanvasAnimatedControl sender, CanvasAnimatedUpdateEventArgs e){ // 根据时间线更新游戏数据。 _game.Update(e.Timing);}private void OnDraw(ICanvasAnimatedControl sender, CanvasAnimatedDrawEventArgs e){ // 绘制游戏画面。 using (var ds = e.DrawingSession) { _game.Draw(ds); }}CanvasAnimatedControl 在游戏中的使用你在我的 GamePage 中其实看不到对 Update 和 Draw 事件的实际使用，因为我把它们都封装到了 MazeGame 中了。有些信息需要注意： Update 和 Draw 运行于相同的线程，但都不是主线程；所以你不可以从这里去获取主线程中的 UI 资源。 正常情况下 Update 调用一次之后，Draw 就会调用一次；但如果当前运行缓慢，那么多次 Update 调用之后才会调用一次 Draw。 如果 UWP 窗口最小化了，那么只会调用 Update 方法，而不会调用 Draw 方法。▲ 线程在 GravityMaze 重力迷宫中，主要是 Player 也就是你在上面动图中看到的那个小球需要在 Update 中更新数据，其他其实只需要画就好了。Update 中我需要计算速度、加速度以及进行碰撞检测。private void OnUpdate(ICanvasAnimatedControl sender, CanvasAnimatedUpdateEventArgs e){ var seconds = timing.ElapsedTime.TotalSeconds; // 1. 根据重力感应器或者键盘计算这一帧桌面的倾斜角度。 // 2. 计算这一倾角带来的加速度。 // 3. 计算是否跌入黑洞。 // 4. 将加速度叠加阻力。 // 5. 计算此速度和加速度下的位置。 // 6. 进行边缘检测和碰撞检测。}而在 Draw 中，只绘制了那个球：private void OnDraw(ICanvasAnimatedControl sender, CanvasAnimatedDrawEventArgs e){ // 绘制游戏画面。 using (var ds = e.DrawingSession) { ds.FillEllipse(_xPosition, _yPosition, _radius, _radius, Colors.Gray); }}事实上你在上面动图看到的球并不是一个毫无生机的灰球，而是一个具有特效的半透明塑料弹球。你可以阅读 使用 Win2D 绘制带图片纹理的圆（或椭圆） 了解如何绘制这样的塑料弹球。CanvasAnimatedControl 中 CreateResources 事件CanvasAnimatedControl 中还有 CreateResources 事件，对更复杂的游戏循环有所帮助。当需要创建资源的时候会引发此事件。第一次使用的时候就需要创建资源；除此之外，如果设备丢失，也需要创建资源。阅读 Win2D 官方文章系列翻译 - 处理设备丢失 - void² - 博客园 了解更多关于设备丢失的内容。private CanvasBitmap _boardMaterial;private async void OnCreateResources(CanvasAnimatedControl sender, CanvasCreateResourcesEventArgs e){ // 其中，GameCanvas 是 XAML 中 CanvasAnimatedControl 的名称。 _boardMaterial = await CanvasBitmap.LoadAsync(GameCanvas, new Uri(&quot;{ms-appx:///Assets/Game/Boards/table.jpg}&quot;));}这里的 _boardMaterial 就是你在上面动图中看到的后面那张红色背景。这样，便可以在需要的时候创建资源。不过，这时你需要在 Draw 中先判空再绘制。private void OnDraw(ICanvasAnimatedControl sender, CanvasAnimatedDrawEventArgs e){ using (var ds = e.DrawingSession) { // 其中，FullBounds 是 Rect 类型，我在 Page 的 SizeChanged 中给它赋的值。 if (_boardMaterial != null) { ds.DrawImage(_boardMaterial, FullBounds); } else { ds.FillRectangle(FullBounds, Colors.White); } }}你也可以使用事件参数 CanvasCreateResourcesEventArgs 来追踪这个异步加载任务，这样能够在绘制之前确保资源被加载完毕。private async void OnCreateResources(CanvasAnimatedControl sender, CanvasCreateResourcesEventArgs e){ e.TrackAsyncAction(CreateResourcesAsync().AsAsyncAction()); async Task CreateResourcesAsync() { _boardMaterial = await CanvasBitmap.LoadAsync(GameCanvas, new Uri(&quot;{ms-appx:///Assets/Game/Boards/table.jpg}&quot;)); }}参考资料 win10 uwp win2d 入门 看这一篇就够了 - 林德熙 win10 uwp win2d CanvasVirtualControl 与 CanvasAnimatedControl - 林德熙 win10 uwp 萤火虫效果 - 林德熙" }, { "title": "使用 Win2D 绘制带图片纹理的圆（或椭圆）", "url": "/post/draw-bitmap-ellipse-using-win2d.html", "categories": "", "tags": "dotnet, win2d, uwp", "date": "2018-11-28 16:25:46 +0800", "snippet": "使用 Win2D 绘制图片和绘制椭圆都非常容易，可是如何使用 Win2D 绘制图片纹理的椭圆呢？重力迷宫小球▲ 重力迷宫你可以看到这个小球就像一个透明塑料小球一样，纹理会跟随背景而动。这显然不是 Win2D 中的游戏循环：CanvasAnimatedControl 一文中我用 DrawEllipse 画的那个灰色小球。Win2D 实现我们会使用到 Win2D 中的多种特效： MorphologyEffect 用于将背景那些红色的洞洞转换成较虚的形态，以便球看起来不是扁平的。 不是必要的，只是为了好看而已。 CropEffect 将背景区域裁剪成一个较小的区域。 不是必要的。 AlphaMaskEffect 使用透明度蒙版使得图片只露出椭圆部分。 这是绘制椭圆必要的特效。 ShadowEffect 做一个小球的阴影。 不是必要的。 要画出图片纹理的椭圆，只需要这么一点代码即可：using (var list = new CanvasCommandList(creator)){ using (var s = list.CreateDrawingSession()) { s.FillEllipse(_xPosition, _yPosition, _radius, _radius, Colors.Black); } var mask = new AlphaMaskEffect { Source = bitmap, AlphaMask = list, }; ds.DrawImage(mask);}▲ 带图片纹理的椭圆现在，如果你希望获得本文一开始获得的那种奇妙的效果，可以添加更多的特效：var bitmap = _game.Material.bitmap;var morphology = new MorphologyEffect{ Source = bitmap, Mode = MorphologyEffectMode.Dilate, Width = 40, Height = 40,};var crop = new CropEffect{ Source = morphology, SourceRectangle = new Rect( _xPosition - _radius, _yPosition - _radius, _radius + _radius, _radius + _radius),};using (var list = new CanvasCommandList(creator)){ using (var s = list.CreateDrawingSession()) { s.FillEllipse(_xPosition, _yPosition, _radius, _radius, Colors.Black); } var mask = new AlphaMaskEffect { Source = crop, AlphaMask = list, }; var shadow = new ShadowEffect { Source = mask, BlurAmount = 4, ShadowColor = Color.FromArgb(0x40, 0x00, 0x00, 0x00), }; ds.DrawImage(shadow); ds.DrawImage(mask);}关于 CanvasCommandList上面的例子中，我们是用到了 CanvasCommandList。它可以帮助我们将绘制命令先绘制到一个缓存的上下文中，以便被其他绘制上下文进行统一的处理。阅读林德熙的博客了解更多 CanvasCommandList 的资料：win2d CanvasCommandList 使用方法 - 林德熙。" }, { "title": "如何在单元测试中使用 Dispatcher.Invoke/InvokeAsync？", "url": "/post/run-dispatcher-in-unit-test.html", "categories": "", "tags": "wpf, unittest", "date": "2018-11-27 13:10:18 +0800", "snippet": "对于部分涉及到 WPF UI 的部分，单元测试一般都难以进行。但是，如果只是使用到其中的 UI 线程调度，那就稍微容易一些。不过为了找到这个方法我做了很多天的尝试。本文将提供一种在单元测试中运行 Dispatcher 的方法，以便能够在单元测试中测试到 Invoke/InvokeAsync 是否按要求执行。我第一个想到的是在当前函数中执行 Dispatcher.Run，但是 Run 之后就阻塞了，我还怎么测试呢？于是我又想到我上个月写的辅助方法 UIDispatcher.RunNewAsync()，在后台创建一个运行起来的 Dispatcher。参见我博客 如何实现一个可以用 await 异步等待的 Awaiter - walterlv 中 UIDispatcher 的实现。这方法确实可行，可以 await。然而单元测试中只有一个单元测试可以通过，无论什么测试，只有第一个 Run 起来的可以通过，其它的全部无法完成（已知运行中，无法退出单元测试）。最后，在 c# - Using the WPF Dispatcher in unit tests - Stack Overflow 发现其实可以先 Invoke 再 Run，这样，即便是当前的单元测试线程也是可以正常完成的。private void RunInDispatcher(Action action){ var dispatcher = Dispatcher.CurrentDispatcher; var frame = new DispatcherFrame(); dispatcher.InvokeAsync(() =&amp;gt; action(dispatcher)); dispatcher.InvokeAsync(() =&amp;gt; frame.Continue = false, DispatcherPriority.Background); Dispatcher.PushFrame(frame);}这个方法借鉴了此前我和我朋友研究过的 WPF DoEvents（虽然已被弃用）： 深入了解 WPF Dispatcher 的工作原理（PushFrame 部分） - walterlv wpf DoEvents - 林德熙于是，单元测试可以这样做：[TestMethod]public void TestSomething_SomethingHappened(){ RunInDispatcher(async dispatcher =&amp;gt; { // 做一些事情。 // 然后…… dispatcher.InvokeAsync(action); // 然后干些啥…… // 然后等待 Measure/Arrange。 await Dispatcher.Yield(); // 然后再验证值。 Assert.AreEqual(a, b); });}Yield 的意思可以参见我的另一篇博客 出让执行权：Task.Yield, Dispathcer.Yield - walterlv。以上。参考资料 c# - Using the WPF Dispatcher in unit tests - Stack Overflow" }, { "title": "技术、产品、交流、思考 - 微软技术暨生态大会 2018", "url": "/post/tech-summit-2018.html", "categories": "", "tags": "miscellaneous", "date": "2018-11-27 13:08:55 +0800", "snippet": "微软技术暨生态大会 2018（Microsoft Tech Summit 2018）已于 2018 年 10 月 25-27 日在上海世博中心召开。本文记录我们参会后的一些知识和思考。路2018 年 10 月 23 日中午，我和林德熙踏上了前往上海的旅程。这是德熙第一次进行如此长途的旅行，之前几乎一直待在家里。微软技术暨生态大会是从 10 月 25 日到 10 月 27 日，而 10 月 24 日是微软合作伙伴会议。我们当初在制定行程时，并没有意识到微软合作伙伴会议与微软技术暨生态大会是分开的，所以我们其实多准备了一天的行程。不过这也正好可以有额外充足的时间了解世博中心和微软合作伙伴展示的产品。我们是乘坐高铁往返的，平均单程 8 个小时。这是非常久的时间，除了高铁噪声之外很安静。我们可以做非常多的阅读、思考、交流、准备。当然，我还利用这样的时间修改分会场课程的课件，然后预演，为课程 预编译框架 - 开发高性能应用 做准备。产品产品展厅自 24 日起就开始展示。合作商覆盖微软推广的各个方向 —— 云、人工智能、DevOps 开发者套件、现代化的工作模式……作为开发者，由于这部分的合作涉及到较多商务上的沟通，所以我们并没有进行深入的交流。吃现场为所有的参会人员准备了午餐盒饭，在 微软粉丝之夜：IT之家读者捕捉铺路集团董事长玄隐 - 微软,粉丝之夜,技术暨生态大会 - IT之家 中你能找到 MVP 保哥和 MVP 林德熙的午餐图片。只有我一个人觉得这份午餐的分量很足还能吃剩吗？为什么大家都说吃不饱？额外的，在粉丝之夜有简餐，是一些西餐甜点，都是凉的。由于我来之前的几天闹肚子，所以虽然饿但只吃了一点点。而林德熙也饿，吃了很多，结果第二天开始闹肚子😂。所以我们竟然四个晚上都光顾了附近外卖的一家粥铺。技术Visual Studio 协同开发第一天整天都不像是一个技术交流，不过这一切在 26 号起有了变化。由于我早上去分会场进行 27 号分会场课程彩排，所以错过了一开始的主会场内容。据小伙伴林德熙的描述，第一个是令人振奋的是 Visual Studio 的协作功能。在现场演示中，工程师通过分享一个 Visual Studio 的协同编辑链接，另一位工程师可以协同编写前者的代码。在此过程中，编写和调试都和在另一台电脑上无异。这无疑是团队进行开发协作的一项重大功能！结对编程在软件工程中不止是共同完成某项功能，减少 Bug，更能让不同的开发者之间互相学习对方的技术、开发手法以及以及高效习惯。而 Visual Studio 的协同开发功能无疑让结对编程的成本突然间减小了许多。当然，不止是协同编辑，还能协同调试。不止在 Visual Studio 中能够使用，在 Visual Studio Code 中也一样可以使用。AppCenter 在一处管理你所有的应用发布接下来是开源与跨平台相关的技术演讲。在介绍 Xamarin 的时候，提到了 Xamarin.Forms。如果使用 Xamarin 的原生控件开发方式，那么开发者需要了解各个平台的界面布局规则。在有了 Xamarin.Forms 的情况下，开发者可以无需了解各个平台的布局即可开发出适用于各个平台的应用。当然，这其实引入了一个 UI 间接层，在 UI 的实现中绕了一下，可能不适用于开发稍微复杂一点的应用。当然这些都是以前就有的内容了。令人兴奋的是，随着 Xamarin，也推出了 AppCenter 服务！你再也不需要针对每一个应用市场走不同的发布流程了，你可以在只在 AppCenter 中完成 App Store 以及 Google Play 或者其他市场的发布流程。.NET Core 3 与桌面应用今年五月的 Microsoft Build 大会上就已经发布了重磅消息 .NET Core 3 将为桌面应用带来支持。不过主会场上与 .NET Core 3 相关的演示依然令人兴奋。演讲者使用 .NET Framework 版本的应用进行磁盘文件扫描，得出所有文件目录的百分比占用的时候用时 7109 毫秒。而相同的代码使用 .NET Core 3 编译，进行同样的操作，耗时是 1763 毫秒！不止如此，.NET Core 3 还提供了一种编译方式，将所有的第三方依赖通通发布成一个 exe，这样，你能直接带走一个什么依赖都不需要的单个 exe 文件进行分发；相比于此前 .NET Core 3 发布时一大堆第三方依赖包，或者 .NET Framework 时需要的 .NET Framework 环境依赖来说，简直是方便！思考方式大会带来的不止是产品和商务的碰撞，不止是技术和推广和交流，更有思考方式上的改变。 No problems can be solved from the same level of consciousness that created it.在“万物重构”分会场课程中，韦青老师将云比喻成电，将公有云比喻成电网，将私有云比喻成发电机。曾经在电网不那么稳定，是不是会停电的日子里，可能每家大院都会有一台发电机，为自家大院供电。不过共有电网因为雄厚的实力，其发展速度是非常快的，无论从稳定性、速度、可用性还有安全性上都好的太多，私有发电机渐渐会失去其作用。私有云就像发电机一样，是公有云发展过程中的中间方案。技术是一种赋能，其应用不止是在技术本身。例如电，早期对电的用途就在于发挥它的能源和光属性；很容易地就用电来驱动点灯。可能早期怎么都不能想到可以使用电来做现代计算机这样如此复杂和精密的任务。云，如此，不止用来存储和计算。这是一种赋能，是一种再创造。大佬Edi Wanghttps://edi.wang/ Edi Wang 是我们第一个遇到的大佬，一直活跃于 Windows 应用开发 UWP 方向。当然后面也在做 Asp.NET Core。Edi Wang 是个 100% 资深的软粉，所有的产品都是用微软的。歌单中还有“软狗之歌”……文轩https://www.ithome.com/ ▲ 图片来自 IT 之家 微软粉丝之夜：IT之家读者捕捉铺路集团董事长玄隐 - 微软,粉丝之夜,技术暨生态大会，蓝衣是玄隐，皮卡丘是文轩文轩的实名是白天宝，是 IT 之家的编辑。擅长写深度文章而不是资讯，做微软产品评测。在青岛 IT 之家，快讯一天需要三十篇，而深度文章则不需要那么多。文轩对对质量的要求很高。不止是自己的文章，还有形象，还有周围的环境以及给大家的体验。出发之前理了一个奇妙的发型，于是买了一只耳朵会动的皮卡丘帽子。在 MVP 之夜之前，将酒吧背景音乐换成微软在各大会场曾经播放过的音乐；将酒吧中所有的显示器图案换成 Microsoft Logo；将酒吧灯光换成与 Microsoft Logo 搭配的主题蓝色，并搭配一些让人舒适的暖色。他仔细校准每一个灯光，显示器中的显示效果，以求达到最佳的微软酒吧氛围。IT 之家的读者更多的是粉丝群体，学生很多。如果文章内容过于偏技术，那么不会有多少读者。所以可能一些非技术性或半技术性文章可以在 IT 之家发布和推广呢！梁桐铭微信公众号：角落的白板报梁桐铭是一位 90 后，频繁活跃于 .NET 社区和成都 .NET 线下。他和张善友一起不断尽自己的努力改善国内的 .NET 生态环境。在课程《打造开源的 .NET Core 微服务解决方案》课程中，他介绍了 52ABP.com 微服务框架，可以用在你的 Web 应用上。红薯红薯是开源中国创始人，码云创始人。拥抱开源，专治 GitHub 在中国的各种水土不服。码云为个人开发者提供免费的 git 仓库服务，为企业开发者提供付费的私有仓库服务。企业可以通过签署合同的方式来保证企业私有仓库的安全。期望码云能够与开发工具有更多的集成，或者可以提供 API，让社区来帮助完成这样的集成。吴波http://blog.vichamp.com/ 吴波是 PowerShell 方向的 MVP，在福建。对 .NET Framework 和 .NET Core 的迁移也是很感兴趣的。他推荐我们可以尝试使用 Turbo Studio 对 .NET Framework 环境进行虚拟化，这样应用在部署之后可以不需要系统中安装的 .NET Framework 环境。他告诉我们，一般企业会非常支持这种对外的技术交流的，因为对公司来说： 可以提高团队对外的技术影响力； 可以为团队塑造一个有应诉待查的 Leader，这样在团队中进行一些决策时大家更能够信服，容易推动一些技术方案的执行； 可以吸引技术人才，了解前沿技术。项斌http://www.cnblogs.com/BeanHsiang/ 在 MVP 展台一直循环播放的视频中，有一段是校宝在线的。正好我们发现项斌就职于校宝在线。更多阅读：鬼才项斌，用人工智能推动教育服务创新邵猛https://www.cnblogs.com/shaomeng/ 深圳来画科技的 UWP 版本开发者，在技术和商务上都是领导者。水歌水歌的名字是石垚（yáo），做 FCC 培训内容。FCC 全称 Free Code Campus。FCC 为学员免费提供各种语言的学习资料，可以在线从零开始学习编程语言。他为此提供一些课程内容。领英在没有与 FCC 有过任何沟通的情况下，把 FCC 认证作为大学认证同级别对待。张善友微信公众号：dotNET跨平台▲ 张善友（右）和梁桐铭（左）张善友的名气已经不需要介绍了……Dinohttp://www.cnblogs.com/dino623/default.html Windows 应用圈微软主推的 Windows 桌面应用的开发框架是 UWP / WPF / Windows Forms，随后是原生 Win32 API。Windows 桌面应用的开发者在国内是真的少，传说中的后 PC 时代。27 号上午我的课程预编译框架，开发高性能应用还有很多人参加。虽然说主要适用于桌面应用，不过在思想上也能用于其他 .NET 领域（当然开源社区的小伙伴如果能多多支持也能都支持的）。而邵猛下午的课程利用 Windows 新特性开发出更好的手绘视频应用听众就寥寥无几了。虽说那个时间已经有不少参会者走了，不过这与国内目前的 UWP（或者说推广到 Windows 桌面应用）生态不无关系。Windows 应用 UI 框架的未来发展方向虽然微软会持续发力，但 UWP 在未来很长一段时间之内可能只会成为小众，除非找到下一个爆发点。这真的得益于微软在 Windows 应用分发平台上的各种失误（比如各种商店无法下载……）。在微软推广 UWP 的过程中，WPF 一直作为 UWP 的上一个遗落的版本而存在着，只会处于维护状态。微软会为其添加安全更新、添加 .NET Core 迁移相关的支持，而不会再在性能或者一些低概率的 Bug 上耗费太多精力。WPF 会在此状态下持续很长一段时间，因为微软必须考虑到自家内部产品中也存在大量基于 .NET Framework 的 WPF 和 Windows Forms 应用，比如 Visual Studio。在未来一两年内，WPF 和 Windows Forms 最大的变化要属其 .NET Core 化了，估计 Visual Studio 这种重磅的应用可能面临着两种不同的进化路线： 向 .NET Core 方向迁移。 如果这种事情发生，那么至少 WPF 会在未来一个较短的数年之内获得不那么少的维护支持。至少必须确保 Visual Studio 这种大级别的 WPF 应用能够顺利完成迁移而不会产生大量明显的 Bug。 向跨平台方向迁移。 这几乎相当于对 Visual Studio 的界面代码进行一次彻头彻尾的重构。不过考虑到插件的兼容性，也许未来一段时间之内这种跨平台迁移会采用混合界面框架。 Visual Studio 几乎不会往 UWP 的方向发展。未来的 Windows UI 框架选择从对微软内部工具的迁移策略可以对我们的技术栈变化带来一些可能发展方向的思考。首先，如果是 WPF / Windows Forms，那么向 .NET Core 的迁移几乎成了一个 100% 要做的事情。无论未来 WPF / Windows Forms 产品要向哪个方向发展，只要不是整个团队的开发人员换掉，整个技术栈换掉，.NET Core 迁移都是必然的一步。这一步不止能带来大量的性能提升，还能让应用不再与操作系统产生大量的耦合，减少 .NET Framework 部署到操作系统中产生的一堆环境问题。那么可以采用的 UI 框架是什么呢？ Xamarin 方向 UWP 方向 混合 UI 框架方向对于希望团队充分进行技术复用，那么几乎可以考虑迁移到以上 UI 框架，否则可以考虑其他 UI 框架。当然我更推荐使用混合 UI 框架，这样利于未来 UI 框架的演进，并充分利用到新 UI 框架带来的 Windows 新特性支持和高性能。▲ 再见 Tech Summit 2018回家的时候，高铁上。再次进入了夜色……" }, { "title": "只有你能 new 出来！.NET 隐藏构造函数的 n 种方法（Builder Pattern / 构造器模式）", "url": "/post/hide-your-constructor.html", "categories": "", "tags": "dotnet, csharp", "date": "2018-11-27 13:08:55 +0800", "snippet": "如果你给类写了一个公有构造函数，那么这个类就能被其他开发者 new 出来。如果你不想让他们 new 出来，把构造函数 private 就好了呀。然而还有更多奇怪的方式来隐藏你类的构造方法。为什么要隐藏构造函数？有些类型，只有组件的设计者才知道如何正确创建其类型的实例，多数开发者都无法正确将其创建出来。典型的如 string：绝大多数开发者都不能正确创建出 string 的实例，但通过写一个字符串由编译器去创建，或者使用 StringBuilder 来构造则不容易出错。再或者，我们只希望开发者使用到某个抽象的实例，而不是具体的类型，那么这个时候开发者也需要有方法能够拿到抽象接口的实例。我们可能会使用工厂或者某些其他的方法让开发者在不知道具体类型的时候获取到抽象类型的实例。这正是构造器模式的典型应用场景。在维基百科中对它适用性的描述为： 在以下情况使用生成器模式： 当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时； 当构造过程必须允许被构造的对象有不同的表示时。 详见：生成器模式 - 维基百科，自由的百科全书接下来，我们使用一些奇怪的方式来创建对象的实例，完完全全把构造函数隐藏起来。隐式转换和显式转换典型的像 long a = 1;，bool? b = true 这都是语法级别的隐式转换。这真的只是语法级别的隐式转换，实际上这两个都是编译器原生支持，编译时即已转换为真实的类型了。[System.Runtime.Versioning.NonVersionable]public static implicit operator Nullable&amp;lt;T&amp;gt;(T value){ return new Nullable&amp;lt;T&amp;gt;(value);}[System.Runtime.Versioning.NonVersionable]public static explicit operator T(Nullable&amp;lt;T&amp;gt; value){ return value.Value;}于是我们可以考虑写一个神奇的类，其创建是通过隐式转换来实现的：Fantastic fantastic = &quot;walterlv&quot;;Console.WriteLine(fantastic);以上代码的输出是 walterlv is fantastic。namespace Walterlv.Demo.Patterns{ public class Fantastic { private readonly string _value; private Fantastic(string value) =&amp;gt; _value = value; public static implicit operator Fantastic(string value) =&amp;gt; new Fantastic(value); public override string ToString() =&amp;gt; $&quot;{_value ?? &quot;null&quot;} is fantastic.&quot;; }}而使用显式转换，我们还可以写出更奇怪的代码来。比如下面这个，我们的实例是通过强制转换一个 null 来实现的：Fantastic fantastic = (IFantastic) null;Console.WriteLine(fantastic);以上代码的输出是 ` is fantastic` 字符串。呃……前面有个空格。namespace Walterlv.Demo.Patterns{ public class Fantastic { private readonly IFantastic _value; private Fantastic(IFantastic value) =&amp;gt; _value = value; public static implicit operator Fantastic(IFantastic value) =&amp;gt; new Fantastic(value); public override string ToString() =&amp;gt; $&quot;{_value} is fantastic.&quot;; } public class IFantastic { }}那个 IFantastic 必须得是一个类，而不能是接口，因为隐式转换不能从接口转，也不能转到接口。▲ 不能定义从接口进行的隐式转换运算符重载使用运算符重载，也可以让类型实例的构造隐藏起来。比如下面的 Scope 类型，从字符串创建，然后通过与不同的字符串进行位或运算来得到其他的 Scope 的实例。Scope scope = &quot;A&quot;;var full = scope | &quot;B&quot; | &quot;C&quot;;Console.WriteLine(full);当然这段代码也少不了隐式转换的作用。以上 Scope 类型的实现在 github 上开源，其表示 OAuth 2.0 中的 Scope。ERMail/Scope.cs关于运算符重载的更多内容，可以参考我的另外两篇文章： C# 中那些可以被重载的操作符，以及使用它们的那些丧心病狂的语法糖 - walterlv C# 空合并操作符（??）不可重载？其实有黑科技可以间接重载！ - walterlv" }, { "title": "都是用 DllImport？有没有考虑过自己写一个 extern 方法？", "url": "/post/write-your-own-extern-method.html", "categories": "", "tags": "dotnet, csharp, roslyn, msbuild", "date": "2018-11-27 13:08:55 +0800", "snippet": "你做 .NET 开发的时候，一定用过 DllImport 这个特性吧，这货是用于 P/Invoke (Platform Invoke, 平台调用) 的。这种 DllImport 标记的方法都带有一个 extern 关键字。那么有没有可能我们自己写一个自己的 extern 方法呢？答案是可以的。本文就写一个这样的例子。DllImport日常我们的平台调用代码是这样的：class Walterlv{ [STAThread] static void Main(string[] args) { var hwnd = FindWindow(null, &quot;那个窗口的标题栏文字&quot;); // 此部分代码省略。 } [DllImport(&quot;user32.dll&quot;, CharSet = CharSet.Unicode)] public static extern IntPtr FindWindow(string lpClassName, string lpWindowName);}你看不到 FindWindow 的实现。自定义的 extern那我们能否自己实现一个这样的 extern 的方法呢？写一写，还真是能写得出来的。▲ 外部方法需要 Attribute 的提示只不过如果你装了 ReSharper，会给出一个提示，告诉你外部方法应该写一个 Attribute 在上面（虽然实际上编译没什么问题）。那么我们就真的写一个 Attribute 在上面吧。class Walterlv{ internal void Run() { Foo(); } [WalterlvHiddenMethod] private static extern void Foo();}[AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)]internal sealed class WalterlvHiddenMethodAttribute : Attribute{}如果你好奇如果没写 Attribute 会怎样，那我可以告诉你 —— 你写不写都一样，都是不能运行起来的。▲ 方法没有实现让自定义的 extern 工作起来如果无法运行，那么我们写 extern 是完全没有意义的。于是我们怎么能让这个“外部的”函数工作起来呢？—— 事实上就是工作不起来。不过，我们能够控制编译过程，能够在编译期间为其添加一个实现。这里，我们需要用到 MSBuild/Roslyn 相关的知识： Roslyn 通过 Target 修改编译的文件 - 林德熙当你读完上面那篇文章，你就明白我想干啥了。没错，在编译期间将其替换成一个拥有实现的函数。现在，我们将我们的几个类放到不同的文件中。▲ 我们的项目文件// Program.csclass Walterlv{ [STAThread] static void Main(string[] args) { Demo.Foo(); }}// Demo.csclass Demo{ [WalterlvHiddenMethod] internal static extern void Foo();}// WalterlvHiddenMethodAttribute.csusing System;[AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)]internal sealed class WalterlvHiddenMethodAttribute : Attribute{}No！我们还有一个隐藏文件 Demo.implemented.cs。▲ 隐藏的文件// Demo.implemented.csusing System;class Demo{ internal static void Foo() { Console.WriteLine(&quot;我就是一个外部方法。&quot;); }}这个文件我是通过在 csproj 中将其 remove 掉使得在解决方案中看不见。&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;OutputType&amp;gt;Exe&amp;lt;/OutputType&amp;gt; &amp;lt;TargetFramework&amp;gt;net472&amp;lt;/TargetFramework&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;Compile Remove=&quot;Demo.implemented.cs&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt;&amp;lt;/Project&amp;gt;然后，我们按照上文博客中所说的方式，添加一个 Target，在编译时替换这个文件：&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;OutputType&amp;gt;Exe&amp;lt;/OutputType&amp;gt; &amp;lt;TargetFramework&amp;gt;net472&amp;lt;/TargetFramework&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;Compile Remove=&quot;Demo.implemented.cs&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;Target Name=&quot;WalterlvReplaceMethod&quot; BeforeTargets=&quot;BeforeBuild&quot;&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;Compile Remove=&quot;Demo.cs&quot; Visible=&quot;false&quot; /&amp;gt; &amp;lt;Compile Include=&quot;Demo.implemented.cs&quot; Visible=&quot;false&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;/Target&amp;gt;&amp;lt;/Project&amp;gt;现在，运行即会发现可以运行。▲ 可以运行总结 extern 是 C# 的一个语法而已，谁都可以用，但最终编译时的 C# 文件必须都有实现。 我们可以在编译时修改编译的文件来为这些未实现的方法添加实现。原理看完上面的方法，是不是觉得写一个把实现藏起来的 extern 方法很简单？但如果你认为 DllImport 也是这么做的那就不对了。还记得我们一开始写的 FindWindow 方法吗？我们查看其编译后的 IL 代码，可以发现其外部调用已经写到了 IL 里面了，并且其实现使用了 pinvokeimpl 关键字。也就是说，具体的调用是 JIT 编译器去做的事儿。.method public hidebysig static pinvokeimpl ( &quot;user32.dll&quot; unicode winapi )native int FindWindow( string lpClassName, string lpWindowName ) cil managed preservesig { // Can&#39;t find a body} // end of method Walterlv::FindWindow至于实际执行时的执行细节，可以阅读 c# - How does DllImport really work? - Stack Overflow 了解更多。如果去看看我们写的 Foo 的 IL，就完全不一样了：.method assembly hidebysig static void Foo() cil managed { .custom instance void WalterlvHiddenMethodAttribute::.ctor() = (01 00 00 00 ) .maxstack 8 IL_0000: nop IL_0001: ldstr &quot;我就是一个外部方法。&quot; IL_0006: call void [mscorlib]System.Console::WriteLine(string) IL_000b: nop IL_000c: ret } // end of method Demo::Foo这其实就是我们在 Demo.implement.cs 中写的那个函数的实现。这是当然，毕竟我们编译时偷偷把这个函数换成了那个隐藏的文件实现了。关于如何迅速查看 C# 代码对应的 IL，可以阅读我的另一篇博客：如何快速编写和调试 Emit 生成 IL 的代码。参考资料 c# - How does DllImport really work? - Stack Overflow" }, { "title": "深入了解 WPF Dispatcher 的工作原理（PushFrame 部分）", "url": "/post/dotnet/2017/09/26/dispatcher-push-frame.html", "categories": "", "tags": "dotnet", "date": "2018-11-27 13:08:55 +0800", "snippet": "在上一篇文章 深入了解 WPF Dispatcher 的工作原理（Invoke/InvokeAsync 部分） 中我们发现 Dispatcher.Invoke 方法内部是靠 Dispatcher.PushFrame 来确保“不阻塞地等待”的。然而它是怎么做到“不阻塞地等待”的呢？阅读本文将更深入地了解 Dispatcher 的工作机制。本文是深入了解 WPF Dispatcher 的工作原理系列文章的一部分： Invoke/InvokeAsync 部分 PushFrame 部分（本文）Dispatcher.PushFrame 是什么？如果说上一篇文章 深入了解 WPF Dispatcher 的工作原理（Invoke/InvokeAsync 部分） 中的 Invoke 算是偏冷门的写法，那 ShowDialog 总该写过吧？有没有好奇过为什么写 ShowDialog 的地方可以等新开的窗口返回之后继续执行呢？var w = new FooWindow();w.ShowDialog();Debug.WriteLine(w.Bar);看来我们这次有必要再扒开 Dispatcher.PushFrame 的源码看一看了。不过在看之前，我们先看一看 Windows Forms 里面 DoEvents 的实现，这将有助于增加我们对源码的理解。DoEventsWindows Forms 里面的 DoEvents 允许你在执行耗时 UI 操作的过程中插入一段 UI 的渲染过程，使得你的界面看起来并没有停止响应。[SecurityPermissionAttribute(SecurityAction.Demand, Flags = SecurityPermissionFlag.UnmanagedCode)]public void DoEvents(){ DispatcherFrame frame = new DispatcherFrame(); Dispatcher.CurrentDispatcher.BeginInvoke(DispatcherPriority.Background, new DispatcherOperationCallback(ExitFrame), frame); Dispatcher.PushFrame(frame);}public object ExitFrame(object f){ ((DispatcherFrame)f).Continue = false; return null;}首先我们需要拿出本文一开始的结论——调用 Dispatcher.PushFrame 可以在不阻塞 UI 线程的情况下等待。在此基础之上，我们仔细分析此源码的原理，发现是这样的： 添加了一个 Background（4） 优先级的 DispatcherOperation，执行的操作就是调用 ExitFrame 方法。（如果不明白这句话，请回过头再看看 Invoke/InvokeAsync 这部分 。） 调用 Dispatcher.PushFrame 以便在不阻塞 UI 线程的情况下等待。 由于用户输入的优先级是 Input（5），UI 响应的优先级是 Loaded（6），渲染的优先级是 Render（7），每一个都比 Background（4）高，于是只要有任何 UI 上的任务，都会先执行，直到没有任务时才会执行 ExiteFrame 方法。（如果不知道为什么，依然请回过头再看看 Invoke/InvokeAsync 这部分 。） 当 ExitFrame 被执行时，它会设置 DispatcherFrame.Continue 为 false。为了让 DoEvents 实现它的目标，它必须能够在中间插入了 UI 和渲染逻辑之后继续执行后续代码才行。于是，我们可以大胆猜想，设置 DispatcherFrame.Continue 为 false 的目标是让 Dispatcher.PushFrame(frame); 这一句的等待结束，这样才能继续后面代码的执行。好了，现在我们知道了一个不阻塞等待的开关： 调用 Dispatcher.PushFrame(frame); 来不阻塞地等待； 设置 frame.Continue = false 来结束等待，继续执行代码。知道了这些，再扒 Dispatcher.PushFrame 代码会显得容易许多。PushFrame 的源码这真是一项神奇的技术。以至于这一次我需要毫无删减地贴出全部源码：[SecurityCritical, SecurityTreatAsSafe ]private void PushFrameImpl(DispatcherFrame frame){ SynchronizationContext oldSyncContext = null; SynchronizationContext newSyncContext = null; MSG msg = new MSG(); _frameDepth++; try { // Change the CLR SynchronizationContext to be compatable with our Dispatcher. oldSyncContext = SynchronizationContext.Current; newSyncContext = new DispatcherSynchronizationContext(this); SynchronizationContext.SetSynchronizationContext(newSyncContext); try { while(frame.Continue) { if (!GetMessage(ref msg, IntPtr.Zero, 0, 0)) break; TranslateAndDispatchMessage(ref msg); } // If this was the last frame to exit after a quit, we // can now dispose the dispatcher. if(_frameDepth == 1) { if(_hasShutdownStarted) { ShutdownImpl(); } } } finally { // Restore the old SynchronizationContext. SynchronizationContext.SetSynchronizationContext(oldSyncContext); } } finally { _frameDepth--; if(_frameDepth == 0) { // We have exited all frames. _exitAllFrames = false; } }}这里有两个点值得我们研究： _frameDepth 字段。 while 循环部分。我们先看看 _frameDepth 字段。每调用一次 PushFrame 就需要传入一个 DispatcherFrame，在一次 PushFrame 期间再调用 PushFrame 则会导致 _frameDepth 字段增 1。于是，一个个的 DispatcherFrame 就这样一层层嵌套起来。再看看 while 循环。while(frame.Continue){ if (!GetMessage(ref msg, IntPtr.Zero, 0, 0)) break; TranslateAndDispatchMessage(ref msg);}还记得 DoEvents 节里我们说到的开关吗？就是这里的 frame.Continue。看到这段代码是不是很明确了？如果设置为 false，则退出循环，于是 PushFrame 方法返回，同时 _frameDepth 字段减 1。在一个个的 frame.Continue 都设置为 false 以至于后，程序将从 Main 函数退出。如果 frame.Continue 一直保持为 true 呢？那就进入了“死循环”。可是这里我们需要保持清醒，因为“死循环”意味着阻塞，意味着无法在中间插入其它的 UI 代码。所以要么是 GetMessage 让我们能继续处理窗口消息，要么是 TranslateAndDispatchMessage 让我们能继续处理窗口消息。（至于为什么只要能处理消息就够了，我们上一篇说到过，Dispatcher 任务队列的处理就是利用了 Windows 的消息机制。）然而，这两个方法内部都调用到了非托管代码，很难通过阅读代码了解到它处理消息的原理。但是通过 .NET Framework 源码调试技术我发现 TranslateAndDispatchMessage 方法似乎并没有被调用到，GetMessage 始终在执行。我们有理由相信用于实现非阻塞等待的关键在 GetMessage 方法内部。.NET Framework 源码调试技术请参阅：调试 ms 源代码 - 林德熙。于是去 GetMessage 方法内，找到了 UnsafeNativeMethods.ITfMessagePump 类型的变量 messagePump。这是 Windows 消息循环中的重要概念。看到这里，似乎需要更了解消息循环才能明白实现非阻塞等待的关键。不过我们可以再次通过调试 .NET Framework 的源码来了解消息循环在其中做的重要事情。调试源码以研究 PushFrame 不阻塞等待的原理为了开始调试，我为主窗口添加了触摸按下的事件处理函数：private void OnStylusDown(object sender, StylusDownEventArgs e){ Dispatcher.Invoke(() =&amp;gt; { Console.WriteLine(); new MainWindow().ShowDialog(); }, DispatcherPriority.Background);}其中 Dispatcher.Invoke 和 ShowDialog 都是为了执行 PushFrame 而写的代码。Console.WriteLine() 只是为了让我打上一个用于观察的断点。运行程序，在每一次触摸主窗口的时候，我们都会命中一次断点。观察 Visual Studio 的调用堆栈子窗口，我们会发现每触摸一次命中断点时调用堆栈中会多一次 PushFrame，继续执行，由于 ShowDialog 又会多一次 PushFrame。于是，我们每触摸一次，调用堆栈中会多出两个 PushFrame。每次 PushFrame 之后，都会经历一次托管到本机和本机到托管的转换，随后是消息处理。我们的触摸消息就是从消息处理中调用而来。于是可以肯定，每一次 PushFrame 都将开启一个新的消息循环，由非托管代码开启。当 ShowDialog 出来的窗口关掉，或者 Invoke 执行完毕，或者其它会导致 PushFrame 退出循环的代码执行时，就会退出一次 PushFrame 带来的消息循环。于是，在上一次消息处理中被 while 阻塞的代码得以继续执行。一层层退出，直到最后 Main 函数退出时，程序结束。上图使用的是我在 GitHub 上的一款专门研究 WPF 触摸原理的测试项目：https://github.com/walterlv/ManipulationDemo。至此，PushFrame 能够做到不阻塞 UI 线程的情况下继续响应消息的原理得以清晰地梳理出来。如果希望更详细地了解 WPF 中的 Dispatcher 对消息循环的处理，可以参考：详解WPF线程模型和Dispatcher - 踏雪无痕 - CSDN博客。结论 每一次 PushFrame 都会开启一个新的消息循环，记录 _frameDepth 加 1； 在新的消息循环中，会处理各种各样的 Windows 消息，其中有的以事件的形式转发，有的是执行加入到 PriorityQueue&amp;lt;DispatcherOperation&amp;gt; 队列中的任务； 在显式地退出 PushFrame 时，新开启的消息循环将退出，并继续此前 PushFrame 处的代码执行； 当所有的 PushFrame 都退出后，程序结束。 PushFrame 的 while 循环是真的阻塞着主线程，但循环内部会处理消息循环，以至于能够不断地处理新的消息，看起来就像没有阻塞一样。（这与我们平时随便写代码阻塞主线程导致无法处理消息还是有区别的。）PushFrame 的已知缺陷PushFrame 使用通过开启一个新的消息循环使得 UI 线程能够在新的消息循环中处理消息，以便 UI “不卡”，同时使得调用 PushFrame 的代码能够 “阻塞”。这种实现方式也带来了一些问题： 调用代码被虽然被阻塞，但又不像常规线程阻塞一样 —— 它会发生 “意料之外” 的重入问题，即单个线程也会遇到并发问题。 关于重入，可以阅读：异步任务中的重新进入（Reentrancy） PushFrame 使用 Windows 消息循环机制，而多重消息循环机制可能出现其他 Bug，例如： 当你在用鼠标拖拽窗口调整位置或大小的时候，如果触发了一次 PushFrame，那么此窗口会卡住 c# - PushFrame locks up WPF window when user is moving window - Stack Overflow 参考资料 PushFrame/DispatcherFrame Dispatcher.cs c# - WPF DispatcherFrame magic - how and why this works? - Stack Overflow c# - For what is PushFrame needed? - Stack Overflow multithreading - WPF - Dispatcher PushFrame() - Stack Overflow DispatcherFrame Class (System.Windows.Threading) DispatcherFrame. Look in-Depth - CodeProject Windows 消息循环 Message loop in Microsoft Windows - Wikipedia c# - Understanding the Dispatcher Queue - Stack Overflow 详解WPF线程模型和Dispatcher - 踏雪无痕 - CSDN博客 调试 .NET Framework 源码 调试 ms 源代码 - 林德熙 已知缺陷 c# - PushFrame locks up WPF window when user is moving window - Stack Overflow " }, { "title": "用 dotTrace 进行性能分析时，Timeline 打不开？无法启动进程？也许你需要先开启系统性能计数器的访问权限", "url": "/post/dottrace-timeline-not-working.html", "categories": "", "tags": "dotnet, windows", "date": "2018-11-12 16:46:37 +0800", "snippet": "对 .NET 程序使用 dotTrace 进行性能分析时，你也可能遭遇到 dotTrace 的 Bug。我就遇到了性能分析选项 Timeline 打不开进程的情况。dotTrace 的性能分析选项dotTrace 启动性能分析的选项有四个，你可以阅读 用 dotTrace 进行性能分析时，各种不同性能分析选项的含义和用途 了解不同选项的含义和用途，以便对你的性能分析提供更多的帮助和更有价值的分析数据。Timeline 打不开？可是，当我真的使用这个选项的时候，却发现根本无法完成性能分析。具体来说，是在出现了性能分析的指示窗口后，被分析程序的界面迟迟没有出现。随后在半分钟到数分钟后，分析器自动退出，没有得到任何性能分析数据。▲ 启动 ETW（事件跟踪器）▲ 启动性能分析器▲ 性能分析指示窗口最后那个指示窗口就这样过一会儿变成以下窗口，提示 “Waiting for a managed application to start…”，然后消失。▲ 等待启动解决方法在这四个选项中，只有 Timeline 和 Line-by-line 是打不开的，Sampling 打得开。于是可以从他们之间的差异着手分析。在 用 dotTrace 进行性能分析时，各种不同性能分析选项的含义和用途 一文中，我们可以得知，只有 Timeline 用到了 ETW，而这个是一个系统功能。也许是系统功能无法访问呢？毕竟这种事情还是非常常见的。于是果然在 Timeline is not working 找到了解决方法 —— 你需要开启你所在的用户组对 Performance Monitor 的访问权限。现在开始解决：启动“计算机管理”在你的 Windows 10 搜索（或者小娜）中搜索 “计算机管理”，英文用户搜索 “Computer Management”。然后启动它。▲ 搜索并启动计算机管理配置性能监视器用户组在计算机管理中，找到 “计算机管理 -&amp;gt; 系统工具 -&amp;gt; 本地用户和组 -&amp;gt; 组”，点开后在中间的列表中找到 “Performance Monitor Users”。对于英文的系统，对应的路径为 “Computer Management -&amp;gt; System Tools -&amp;gt; Local Users and Groups -&amp;gt; Groups”，然后一样找到 “Performance Monitor Users”。▲ 找到 Performance Monitor Users为了照顾中文用户，我找小伙伴帮忙截了一张中文的图：▲ 中文版的设置路径添加自己作为用户组的成员双击 Performance Monitor Users，按照以下的步骤将自己添加到用户组中。▲ 将自己添加到用户组中感谢 林德熙 再次帮我截到一张中文版的图片：▲ 中文版的添加你已经完成了你已经修复了问题，建议注销并重新登录 Windows，当然也可以考虑重启。重启后再次尝试使用 Timeline 选项启动进程进行性能分析应该可以正常。参考资料 Timeline is not working: issue solution for different Windows versions – .NET Tools Support - JetBrains Can’t start ETW collector. – .NET Tools Support - JetBrains" }, { "title": "了解 .NET/C# 程序集的加载时机，以便优化程序启动性能", "url": "/post/when-assemblies-are-loaded.html", "categories": "", "tags": "dotnet, csharp", "date": "2018-11-11 19:06:51 +0800", "snippet": "林德熙在 C# 程序集数量对软件启动性能的影响 一文中说到程序集数量对程序启动性能的影响。在那篇文章中，我们得出结论，想同类数量的情况下，程序集的数量越多，程序启动越慢。额外的，不同的代码编写方式对程序集的加载性能也有影响。本文将介绍 .NET 中程序集的加载时机，了解这个时机能够对启动期间程序集的加载性能带来帮助。程序集加载方式对性能的影响为了直观地说明程序集加载方式对性能的影响，我们先来看一段代码：using System;using System.Threading.Tasks;namespace Walterlv.Demo{ public static class Program { [STAThread] private static int Main(string[] args) { var logger = new StartupLogger(); var startupManagerTask = Task.Run(() =&amp;gt; { var startup = new StartupManager(logger).ConfigAssemblies( new Foo(), new Bar(), new Xxx(), new Yyy(), new Zzz(), new Www()); startup.Run(); return startup; }); var app = new App(startupManagerTask); app.InitializeComponent(); app.Run(); return 0; } }}在这段代码中，Foo、Bar、Xxx、Yyy、Zzz、Www 分别在不同的程序集中，我们姑且认为程序集名称是 FooAssembly、BarAssembly、XxxAssembly、YyyAssembly、ZzzAssembly、WwwAssembly。现在，我们统计 Main 函数开始第一句话到 Run 函数开始执行时的时间： 统计 Milestone Time 第一次 ——————————– ——-: 第一次 Main Method Start 107 第一次 Run 344 第二次 Main Method Start 106 第二次 Run 276 第三次 Main Method Start 89 第三次 Run 224 在三次统计中，我们可以看到三次平均时长 180 ms。如果观察没一句执行时的 Module，可以看到 Main 函数开始时，这些程序集都未加载，而 Run 函数执行时，这些程序集都已加载。事实上，如果你把断点放在 Task.Run 中 lambda 表达式的第一个括号处，你会发现那一句时这些程序集就已经加载了，不用等到后面代码的执行。作为对比，我需要放上没有程序集加载时候的数据（具体来说，就是去掉所有 new 那些类的代码）： 统计 Milestone Time 第一次 ——————————– ——-: 第一次 Main Method Start 43 第一次 Run 75 第二次 Main Method Start 27 第二次 Run 35 第三次 Main Method Start 28 第三次 Run 40 这可以证明，以上时间大部分来源于程序集的加载，而不是其他什么代码。现在，我们稍稍修改一下程序集，让 new Foo() 改为使用 lambda 表达式来创建： using System; using System.Threading.Tasks; namespace Walterlv.Demo { public static class Program { [STAThread] private static int Main(string[] args) { var logger = new StartupLogger(); var startupManagerTask = Task.Run(() =&amp;gt; { var startup = new StartupManager(logger).ConfigAssemblies(-- new Foo(),-- new Bar(),-- new Xxx(),-- new Yyy(),-- new Zzz(),-- new Www());++ () =&amp;gt; new Foo(),++ () =&amp;gt; new Bar(),++ () =&amp;gt; new Xxx(),++ () =&amp;gt; new Yyy(),++ () =&amp;gt; new Zzz(),++ () =&amp;gt; new Www()); startup.Run(); return startup; }); var app = new App(startupManagerTask); app.InitializeComponent(); app.Run(); return 0; } } }这时，直到 Run 函数执行时，那些程序集都还没有加载。由于我在 Run 函数中真正使用到了那些对象，所以其实 Run 中是需要写代码来加载那些程序集的（也是自动）。如果我们依次加载这些程序集，那么时间如下： Milestone Time Main Method Start 38 Run 739 如果我们使用 Parallel 并行加载这些程序集，那么时间如下： Milestone Time Main Method Start 31 Run 493 可以看到，程序集加载时间有明显增加。实际上我们完成的任务是一样的，但是程序集加载时间显著增加，这显然不是我们期望的结果。在上例中，第一个不到 200 ms 的加载时间，来源于我们直接写下了 new 不同程序集中的类型。后面长一些的时间，则因为我们的 Main 函数中没有直接构造类型，而是写成了 lambda 表达式。来源于在 Run 中调用那些 lambda 表达式从而间接加载了类型。为了更直观，我把 Run 方法中的关键代码贴出来：// assemblies 是直接 new 出来的参数传进来的。_assembliesToBeManaged.AddRange(assemblies);// assemblies 是写的 lambda 表达式参数传进来的。_assembliesToBeManaged.AddRange(assemblies.Select(x =&amp;gt; x()));上面的版本，这些程序集的加载时间是 180 ms，而下面的版本，则达到惊人的 701 ms！程序集的加载时机于是我们可以了解到程序集的加载时机。 在一个方法被 JIT 加载的时候，里面用到的类型所在的程序集就会被加载到应用程序域中。当加载完后，此方法才被执行。 加载程序集时，只会加载方法中会直接使用到的类型，如果是 lambda 内的类型，则会在此 lambda 被调用的时候才会执行（其实这本质上和方法被调用之前的加载是一个时机）。并且，我们能够得出性能优化建议： 如果可行，最好让 CLR 自动管理程序集的加载，而且一次性能加载所有程序集的话就一次性加载，而不要尝试自己去分开加载这些程序集，那会使得能够并行的加载程序集的时间变得串行，浪费启动性能。" }, { "title": "出让执行权：Task.Yield, Dispatcher.Yield", "url": "/post/yield-in-task-dispatcher.html", "categories": "", "tags": "dotnet, csharp, wpf, uwp", "date": "2018-10-29 13:03:35 +0800", "snippet": "Yield 这个词很有意思，叫做“屈服”“放弃”“让步”，字面意义上是让出当前任务的执行权，转而让其他任务可以插入执行。Task、Dispatcher、Thread 都有 Yield() 方法，看起来都可以让出当前任务的执行权。如果在阅读中发现对本文涉及到的一些概念不太明白，可以阅读： 深入了解 WPF Dispatcher 的工作原理（Invoke/InvokeAsync 部分） 深入了解 WPF Dispatcher 的工作原理（PushFrame 部分）Dispatcher.Yield如果一个方法的实现比较耗时，为了不影响 UI 的响应，你会选择用什么方法呢？我之前介绍过的 Invoke 和 InvokeAsync 可以解决，将后续耗时的任务分割成一个个小的片段以低于用户输入和渲染的优先级执行。Dispatcher.Yield 也可以，其行为更加类似于 Dispatcher.InvokeAsync（即采用 Dispatcher 调度的方式，事实上后面会说到其实就是调用了 InvokeAsync），而非 Dispatcher.Invoke（即采用 PushFrame 新开消息循环的方式）。使用时需要 await：foreach(var item in collection){ DoWorkWhichWillTakeHalfASecond(); await Dispatcher.Yield();}这样，这个 foreach 将在每遍历到一个集合项的时候中断一次，让 UI 能够响应用户的交互输入和渲染。Yield 方法可以传入一个优先级参数，指示继续执行后续任务的优先级。默认是 DispatcherPriority.Background，低于用户输入 DispatcherPriority.Input、 UI 逻辑 DispatcherPriority.Loaded 和渲染 DispatcherPriority.Render。Dispatcher.Yield 是如何做到出让执行权的呢？查看源码，发现 DispatcherYield 的返回值是 DispatcherPriorityAwaiter，而它的 OnCompleted 方法是这样的：public void OnCompleted(Action continuation){ if(_dispatcher == null) throw new InvalidOperationException(SR.Get(SRID.DispatcherPriorityAwaiterInvalid)); _dispatcher.InvokeAsync(continuation, _priority);}所以，其实真的就是 InvokeAsync。如果希望了解为何是 OnCompleted 方法，可以阅读 【C#】【多线程】【05-使用C#6.0】08-自定义awaitable类型 - L.M。需要注意Dispatcher.Yield 是 Dispatcher 类型的静态方法，而不是像 InvokeAsync 一样是实例方法。不过 C# 有一个神奇的特性——静态方法和实例方法可以在同一上下文中调用，而不用担心产生歧义。例如：using System.Windows.Threading;class Demo : DispatcherObject{ void Test() { // 调用静态方法 Yield。 await Dispatcher.Yield(); // 调用实例方法 InvokeAsync。 await Dispatcher.InvokeAsync(() =&amp;gt; { }); }}注意需要引用命名空间 System.Windows.Threading。Task.Yield拿前面 Dispatcher.Yield 的例子，我们换成 Task.Yield：foreach(var item in collection){ DoWorkWhichWillTakeHalfASecond(); await Task.Yield();}效果与 Dispatcher.Yield(DispatcherPriority.Normal) 是一样的。因为 Task 调度回到线程上下文靠的是 SynchronizationContext，WPF UI 线程的 SynchronizationContext 被设置为了 DispatcherSynchronizationContext，使用 Dispatcher 调度；而 DispatcherSynchronizationContext 构造时传入的优先级默认是 Normal，WPF 并没有特殊传入一个别的值，所以 WPF UI 线程上使用 Task.Yield() 出让执行权后，恢复时使用的是 Normal 优先级，相当于 Dispatcher.Yield(DispatcherPriority.Normal)。希望了解 Dispatcher 和 SynchronizationContext 的区别可以阅读 c# - Difference between Synchronization Context and Dispatcher - Stack Overflow。DispatcherSynchronizationContext 执行 await 后续任务的上下文代码：/// &amp;lt;summary&amp;gt;/// Asynchronously invoke the callback in the SynchronizationContext./// &amp;lt;/summary&amp;gt;public override void Post(SendOrPostCallback d, Object state){ // Call BeginInvoke with the cached priority. Note that BeginInvoke // preserves the behavior of passing exceptions to // Dispatcher.UnhandledException unlike InvokeAsync. This is // desireable because there is no way to await the call to Post, so // exceptions are hard to observe. _dispatcher.BeginInvoke(_priority, d, state);}既然是 Normal 优先级，那么在 UI 线程上的效果自然不如 Dispatcher.Yield。但是，Task.Yield 适用于任何线程，因为 SynchronizationContext 本身是与 Dispatcher 无关的，适用于任何线程。这样，于如果一个 Task 内部的任务太耗时，用 Task.Yield 则可以做到将此任务分成很多个片段执行。如果觉得 Task.Yield() 的用途难以理解，可以参考 dudu 的博客 终于明白了 C# 中 Task.Yield 的用途 - dudu - 博客园。参考资料 c# - Task.Yield - real usages? - Stack Overflow Task.Yield Method (System.Threading.Tasks) c# - Difference between Synchronization Context and Dispatcher - Stack Overflow" }, { "title": "课程 预编译框架，开发高性能应用 - 微软技术暨生态大会 2018", "url": "/post/dotnet-build-and-roslyn-course-in-tech-summit-2018.html", "categories": "", "tags": "dotnet, csharp, msbuild, roslyn, visualstudio, nuget", "date": "2018-10-19 13:24:10 +0800", "snippet": "微软技术暨生态大会（Tech Summit），2018 年在上海世博中心召开。这是最后一次的 Tech Summit 了；明年开始，中国大陆地区就要和其他国家和地区一样，进行全球 Ignite Tour 了。我也有幸成为分会场讲师团队的一员，课程是《预编译框架 - 开发高性能应用》。内容就是我博客中与 MSBuild / Roslyn / dotnet / NuGet 相关的内容；我们将利用这些知识打造一个高性能客户端应用。进入 微软技术暨生态大会 官网可以了解更多内容。如果你和我一样对微软技术富有热情，那么也欢迎你 买票 一起去上海。关于课程《预编译框架 - 开发高性能应用》时间：2018 年 10 月 27 日 11:00-11:45代号：DEV306难度：L300利用 Roslyn 在编译期间提前完成收集和修改所需的各种信息，我们能将 .NET 的反射耗时降低到近乎为 0！当前大多数的框架都离不开反射的支持，但是 .NET 的反射很伤性能，而不用反射又很难支撑大型应用；基于 Roslyn 的预编译框架旨在解决这些性能问题。本次讲题能学到什么？ 体验预编译框架的强大性能 理解 dotnet build 的编译过程 使用 Roslyn 分析和修改项目源代码 如何开发自己的预编译框架 制作源代码引用 NuGet 包（而不是 dll 引用 NuGet 包）其实此课程的计划课程内容有 2.5 小时，毕竟博客都有好几十篇了呢。算上跟我一起研究这项技术的 林德熙的与 Roslyn 相关的博客，那就更多了，而且还在持续增加中。不过实际分会场课程中内容众多，留给每个讲师的时间只有 45 分钟，必须减少和压缩课程内容。于是，实际课程会以入门为主，进阶内容将作为资料线下学习。注意：即便是“入门”，难度也依然是 L300（难度范围为 L100-L400），所以你必须拥有一定的 .NET 开发知识和一些应用开发经验才会理解课程内容。如果你的经验更偏客户端应用开发，那么更能体会本课程内容的目的。额外的，彩排在 26 号 9:40-10:00。课程大纲课程大纲是为 2 小时的课程而设计的。所以实际上我只会讲大部分内容，以下所有动手实验和演示的地方都会略过，代之以提前运行和编写的结果。实际课程中会略过的部分以斜体表示。 引入 一批性能数据 收集：反射 VS 配置文件 VS 预编译 调用：直接调用 VS 最快反射 VS 预编译 程序集个数：1 个 VS …… 概览 目录 了解源码包 SourceYard 和预编译框架 SourceFusion 学会编写编译期代码以提升应用性能 预编译框架的原理 多个 API 的展示 源码包 编译期类 类模板 扩展 教学 目标：学会使用编译期代码代替反射以提升应用的执行性能 教学目录 理解 dotnet build 的编译过程 理解 csproj 文件格式 理解编译过程 理解 NuGet 打包原理 动手实验：SourceYard 源码包简化版 编译期间执行一个 exe 程序 在 exe 程序中接收参数并干预编译结果 学习使用 Roslyn 分析源代码 语法可视化窗格 分析 C# 语法树 在编译期间执行代码 动手实验：SourceFusion 预编译框架简化版 在编译期间收集程序集中具有特定标记的所有类型 生成代码以快速访问这些类型的特定方法 回顾 回顾 dotnet build 的编译过程和 Roslyn 分析源码 SourceYard 和 SourceFusion 的开源仓库，欢迎加入 关于讲师 —— 吕毅你可以进入 微软技术暨生态大会 - 大会日程 页面，然后点击 “演讲嘉宾”。在这里，你可以看到主题演讲、分会场课程以及动手实验室的各位讲师，可以去了解每一位讲师以及他们的课程。当然，你也可以看到我。欢迎你的加入最后，欢迎你一起参加微软技术暨生态大会，我们一起去与微软大咖，各位微软 MVP，社区技术牛人交流技术。 购票 微软粉丝之夜报名（目前名额已满）课程课件使用 希沃白板 5 制作，这是一款专门针对教学场景设计的互动课件工具。相关链接由于相关文章太多，所以重新整理到以下新的文章中： 从零开始学习 dotnet 编译过程和 Roslyn 源码分析 - 吕毅更多课程 Microsoft Tech Summit 2018 课程简述：利用 Windows 新特性开发出更好的手绘视频应用 - shaomeng - 博客园 时间：2018 年 10 月 27 日 17:00-17:45 讲师：邵猛 代号：NUE204 " }, { "title": "WPF 中的 NameScope", "url": "/post/namescope-of-wpf.html", "categories": "", "tags": "dotnet, wpf", "date": "2018-10-16 21:01:20 +0800", "snippet": "我们在 WPF 中使用绑定时可以使用 ElementName=Foo 这样的写法，并且还能够真的在运行时找到这个名称对应的对象，是因为 WPF 中提供了名称范围概念。实现 INameScope 接口可以定义一个名称范围。无论你使用 Name 属性还是使用 x:Name 特性都可以在一个名称范围内指定某个元素的名称。绑定时就在此名称范围内查找，于是可以找到你需要的对象。本文将介绍 WPF 中 NameScope 的查找规则。（额外的，资源 / 资源字典的查找方式与 NameScope 的方式是一样的，所以本文分析过程同样使用与资源的查找。）INameScopeWPF 的 INameScope 接口只用来管理一个范围之内的名称。它包含下面三个方法：public interface INameScope{ object FindName(string name); void RegisterName(string name, object scopedElement); void UnregisterName(string name);}它的主要实现是 NameScope，包含了更多功能；而上面的接口是其本质功能。不过，NameScope 的实现带来了一个重要的依赖项属性 —— NameScope。下面是此属性的代码（经过简化）：public static readonly DependencyProperty NameScopeProperty = DependencyProperty.RegisterAttached(&quot;NameScope&quot;, typeof(INameScope), typeof(NameScope));public static void SetNameScope(DependencyObject dependencyObject, INameScope value){ if (dependencyObject == null) throw new ArgumentNullException(nameof(dependencyObject)); dependencyObject.SetValue(NameScopeProperty, value);}public static INameScope GetNameScope(DependencyObject dependencyObject){ if (dependencyObject == null) throw new ArgumentNullException(nameof(dependencyObject)); return ((INameScope)dependencyObject.GetValue(NameScopeProperty));}同样实现了此接口的还有 TemplateNameScope，此 NameScope 会被 FrameworkTemplate / FrameworkElementFactory / BamlRecordReader 设置到以上依赖属性中。于是我们可以在模板范围内找到某个特定名称对应的元素。除此之外，NameScope 的设置由 XAML 解析器在 WPF 项目编译的时候自动生成。NameScope 的名称注册规则如果你没有在代码中显式去调用 RegisterName 这样的方法，那么 NameScope 的创建以及名称的注册都由 XAML 解析器来完成。XAML 解析器（BamlRecordReader）注册名字的时候并没有去爬可视化树什么的，只是单纯在解析 XAML 的时候去调用代码注册这个名字而已。注册由一个 Stack 来完成，NameScopeStack。设想以下这个例子（来自于 .NET Framework 代码中的注释）：&amp;lt;Window x:Name=&quot;myWindow&quot;&amp;gt; ... &amp;lt;Style x:Name=&quot;myStyle&quot;&amp;gt; ... &amp;lt;SolidColorBrush x:Name=&quot;myBrush&quot;&amp;gt; &amp;lt;/SolidColorBrush&amp;gt; &amp;lt;/Style&amp;gt;&amp;lt;/Window&amp;gt;每当 XAML 解析器解析一层的时候，就会给 NameScopeStack 入栈，于是 Window 首先创建 NameScope 入栈。随后解析到 Style 时又加一个 NameScope 入栈，其他元素解析时不会创建 NameScope（包括 XAML 中的顶层元素 UserControl 等）。这时，myWindow 会被注册到 Window 一层的 NameScope 中，myStyle 也会注册到 Window 一层的 NameScope 中；而 myBrush 则会注册到 Style 那一层的 NameScope 中。 Window 的 NameScope myWindow myStyle Style 的 NameScope myBrush NameScope 的名称查找规则在本文一开始贴出 NameScope 依赖项属性的时候，你应该注意到这只是一个普通的属性，并没有使用到什么可以用可视化树继承这样的高级元数据。事实上也不应该有这样的高级元数据，因为 NameScope 的抽象级别低于可视化树或者逻辑树。但是，实际上 NameScope 的查找却是依赖于逻辑树的 —— 这是 FrameworkElement 的功能：internal static INameScope FindScope(DependencyObject d, out DependencyObject scopeOwner){ while (d != null) { INameScope nameScope = NameScope.NameScopeFromObject(d); if (nameScope != null) { scopeOwner = d; return nameScope; } DependencyObject parent = LogicalTreeHelper.GetParent(d); d = (parent != null) ? parent : Helper.FindMentor(d.InheritanceContext); } scopeOwner = null; return null;}非常明显，FindScope 是期望使用逻辑树来查找名称范围的。不过值得注意的是，当一个元素没有逻辑父级的时候，会试图使用 Helper.FindMentor 来查找另一个对象。那这是什么方法，又试图寻找什么对象呢？Mentor 是名词，意为 “导师，指导”。于是我们需要阅读以下 Helper.FindMentor 方法的实现来了解其意图：提示：以下注释中的 FE 代表 FrameworkElement，而 FCE 代表 FrameworkContentElement。/// &amp;lt;summary&amp;gt;/// This method finds the mentor by looking up the InheritanceContext/// links starting from the given node until it finds an FE/FCE. This/// mentor will be used to do a FindResource call while evaluating this/// expression./// &amp;lt;/summary&amp;gt;/// &amp;lt;remarks&amp;gt;/// This method is invoked by the ResourceReferenceExpression/// and BindingExpression/// &amp;lt;/remarks&amp;gt;internal static DependencyObject FindMentor(DependencyObject d){ // Find the nearest FE/FCE InheritanceContext while (d != null) { FrameworkElement fe; FrameworkContentElement fce; Helper.DowncastToFEorFCE(d, out fe, out fce, false); if (fe != null) { return fe; } else if (fce != null) { return fce; } else { d = d.InheritanceContext; } } return null;}具体来说，是不断查找 InheritanceContext，如果找到了 FrameworkElement 或者 FrameworkContentElement，那么就返回这个 FE 或者 FCE；如果到最终也没有找到，则返回 null。这是个 virtual 属性，基类 DependencyObject 中只返回 null，而子类重写它时，返回父级。Freezable, FrameworkElement, FrameworkContentElement 等重写了这个属性。对于 FrameworkElement，重写时只是单纯的返回了一个内部管理的字段而已：internal override DependencyObject InheritanceContext{ get { return InheritanceContextField.GetValue(this); }}此字段在调用 DependencyObject.AddInheritanceContext 的时候会赋值。而对于可视化树或逻辑树的建立，此方法不会被调用，所以此属性并不会对可视化树或逻辑树有影响。但是，Freezable, InputBinding, Visual3D, GridViewColumn, ViewBase, CollectionViewSource, ResourceDictionary, TriggerAction, TriggerBase 等会在属性赋值的时候调用此方法。于是我们能够在以上这些属性的设置中找到名称。特别说明，只有那些重写了 InheritanceContext 的类型才会在查找名称的时候找得到 NameScope；只有以上这些调用了 DependencyObject.AddInheritanceContext 方法的属性才会在赋值是能够找得到 NameScope。所以，我另一篇文章中所说的 ContextMenu 是找不到对应的 NameScope 的。WPF 的 ElementName 在 ContextMenu 中无法绑定成功？试试使用 x:Reference！。此文中 ContextMenu 找到的 NameScope 是 null。" }, { "title": "将 UWP 中 CommandBar 的展开方向改为向下展开", "url": "/post/force-the-commandbar-to-open-down.html", "categories": "", "tags": "uwp", "date": "2018-10-16 16:57:39 +0800", "snippet": "在 UWP 中使用 CommandBar 来迅速添加一组功能按钮是非常迅速的，是 UWP 中推荐的交互方案之一。也许你能见到 CommandBar 按你所需向下展开，不过可能更多数情况会看到 CommandBar 的展开方向是向上的。本文将解释 CommandBar 的展开方向逻辑，并且提供多种方法来解决它展开方向的问题。为什么我们需要更改 CommandBar 的展开方向？&amp;lt;CommandBar Background=&quot;#40000000&quot; ClosedDisplayMode=&quot;Compact&quot;&amp;gt; &amp;lt;AppBarButton Icon=&quot;Add&quot; Label=&quot;添加&quot; ToolTipService.ToolTip=&quot;添加一个 RSS 订阅&quot; /&amp;gt; &amp;lt;AppBarButton Icon=&quot;Bullets&quot; Label=&quot;编辑&quot; ToolTipService.ToolTip=&quot;进入编辑状态&quot; /&amp;gt;&amp;lt;/CommandBar&amp;gt;看下图的例子，我们有一个在顶部的 CommandBar，但是它展开的时候方向是向上的，以至于挡住了顶部的标题栏。▲ CommandBar 在不合适的方向展开理论上标题栏是挡不住的。不过，由于流畅设计（Fluent Design）的存在，越来越多的应用开始使用自定义的标题栏，以获得浑然天成的流畅设计效果。而上图就是其中的一个例子。我们当然希望在顶部的 CommandBar 其展开方向是向下，所以我们需要找到一些方法。将 CommandBar 改为向下展开的几种方法首先定一个基调：CommandBar 的默认展开方向就是向上，无论你使用哪种方式，本质上都没有解决其展开方向的问题。所以以下方法都有可能在你的使用场景下失效，除了大杀器 —— 重写 Template。方法一：使用 Page.TopAppBar 属性&amp;lt;Page x:Class=&quot;Walterlv.Rssman.MainPage&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; Background=&quot;{ThemeResource ApplicationPageBackgroundThemeBrush}&quot;&amp;gt; &amp;lt;Page.TopAppBar&amp;gt; &amp;lt;CommandBar Background=&quot;#40000000&quot; ClosedDisplayMode=&quot;Compact&quot;&amp;gt; &amp;lt;AppBarButton Icon=&quot;Add&quot; Label=&quot;添加&quot; ToolTipService.ToolTip=&quot;添加一个 RSS 订阅&quot; /&amp;gt; &amp;lt;AppBarButton Icon=&quot;Bullets&quot; Label=&quot;编辑&quot; ToolTipService.ToolTip=&quot;进入编辑状态&quot; /&amp;gt; &amp;lt;/CommandBar&amp;gt; &amp;lt;/Page.TopAppBar&amp;gt; &amp;lt;Grid&amp;gt; &amp;lt;/Grid&amp;gt;&amp;lt;/Page&amp;gt;如果你并没有做一些奇怪的样式，是一个 Demo 或者是刚开始做的应用，那么此方法应该对你有效。▲ Page.TopAppBar 中的 CommandBar看！现在 CommandBar 向下展开了。这就是我们的解决方案之一。不过，觉得怪怪的是不是？因为我自定义了标题栏，当然不能让标题栏挡住我的控件啊！千万不要尝试将你的 Page 设置一个 Margin 让他下移，因为：▲ 无论你设置到哪个 Page 中，无论 Margin 设为多少，就算是给 Frame 外面的 Grid 设置 Margin，通通都是无效的！Page.TopAppBar 在应用窗口级别的。正如官网中所描述的那样： Command bars can be placed at the top of the app window, at the bottom of the app window, and inline.方法二：更改布局，使得顶部空间不足以展开 CommandBarCommandBar 的 ClosedDisplayMode 设为 Compact 时，折叠状态高度 48，展开状态高度 60；在设为 Minimal 时，折叠状态高度 24，展开状态依然是 60。▲ 各种模式下的展开和折叠高度鉴于 CommandBar 仅在空间不足时才会从向上展开变为向下展开，所以我们可以利用顶部空间的距离差来完成方向的修改。对于 Compact 模式，我们仅能在上方预留不足 12 的尺寸，而对于 Minimal 模式，我们则有不大于 36 的尺寸可以预留。在我们一开始的例子中，我们需要留出标题栏的高度，而标题栏高度为 32，所以使用 Minimal 模式时，我们的展开方向自然因为顶部空间不足而向下展开。另外，12 像素除了留白以外也没什么作用，所以实质上 Compact 模式并不能通过这种方式解决展开方向的问题。▲ 在使用 Minimal 的关闭模式时，可以向下展开如果你设置的 SecondaryCommand 比较长，那么展开的时候也会占用较多的控件，于是也可以强制 CommandBar 向下展开。方法三：设置 DefaultLabelPosition 避开展开方向的问题如果不容易改展开方向，那么不让 CommandBar 面临展开方向的问题也是一个不错的解决方案 —— 为 CommandBar 设置 DefaultLabelPosition 便是这样的方案。将 DefaultLabelPosition 属性设置为 Right 或者 Collapsed 而不是 Bottom，那么 CommandBar 便不再需要展开这些按钮了，因为即便展开也不会显示更多的信息了，除了那个根本不会影响高度的更多项。▲ 设置为 Collapsed 或者 Right 的 DefaultLabelPosition方法四：修改 CommandBar 的模板不得不说这真是一个令人难受的方法，因为定义 CommandBar 模板和样式的代码行数有 1400 行左右。但这也是目前依然使用 CommandBar 控件时最好的方案了。▲ 编辑控件模板的副本现在，使用 Visual Studio 设计器来帮助我们获得 CommandBar 的完整默认样式定义，就像上图那样。于是，我们可以阅读其代码并修改展开方向了。代码很长，为了能够迅速理解其结构，我将其最关键的大纲部分贴到下面：&amp;lt;ControlTemplate x:Key=&quot;CommandBarTemplate1&quot;&amp;gt; &amp;lt;Grid&amp;gt; &amp;lt;VisualStateManager.VisualStateGroups&amp;gt; &amp;lt;VisualStateGroup x:Name=&quot;DisplayModeStates&quot;&amp;gt; &amp;lt;VisualStateGroup.Transitions&amp;gt; &amp;lt;VisualState From=&quot;CompactClosed&quot; To=&quot;CompactOpenUp&quot; /&amp;gt; &amp;lt;VisualState From=&quot;CompactOpenUp&quot; To=&quot;CompactClosed&quot; /&amp;gt; &amp;lt;VisualState From=&quot;CompactClosed&quot; To=&quot;CompactOpenDown&quot; /&amp;gt; &amp;lt;VisualState From=&quot;CompactOpenDown&quot; To=&quot;CompactClosed&quot; /&amp;gt; &amp;lt;VisualState From=&quot;MinimalClosed&quot; To=&quot;MinimalOpenUp&quot; /&amp;gt; &amp;lt;VisualState From=&quot;MinimalOpenUp&quot; To=&quot;MinimalClosed&quot; /&amp;gt; &amp;lt;VisualState From=&quot;MinimalClosed&quot; To=&quot;MinimalOpenDown&quot; /&amp;gt; &amp;lt;VisualState From=&quot;MinimalOpenDown&quot; To=&quot;MinimalClosed&quot; /&amp;gt; &amp;lt;VisualState From=&quot;HiddenClosed&quot; To=&quot;HiddenOpenUp&quot; /&amp;gt; &amp;lt;VisualState From=&quot;HiddenOpenUp&quot; To=&quot;HiddenClosed&quot; /&amp;gt; &amp;lt;VisualState From=&quot;HiddenClosed&quot; To=&quot;HiddenOpenDown&quot; /&amp;gt; &amp;lt;VisualState From=&quot;HiddenOpenDown&quot; To=&quot;HiddenClosed&quot; /&amp;gt; &amp;lt;/VisualStateGroup.Transitions&amp;gt; &amp;lt;VisualState x:Name=&quot;CompactClosed&quot; /&amp;gt; &amp;lt;VisualState x:Name=&quot;CompactOpenUp&quot; /&amp;gt; &amp;lt;VisualState x:Name=&quot;CompactOpenDown&quot; /&amp;gt; &amp;lt;VisualState x:Name=&quot;MinimalClosed&quot; /&amp;gt; &amp;lt;VisualState x:Name=&quot;MinimalOpenUp&quot; /&amp;gt; &amp;lt;VisualState x:Name=&quot;MinimalOpenDown&quot; /&amp;gt; &amp;lt;VisualState x:Name=&quot;HiddenClosed&quot; /&amp;gt; &amp;lt;VisualState x:Name=&quot;HiddenOpenUp&quot; /&amp;gt; &amp;lt;VisualState x:Name=&quot;HiddenOpenDown&quot; /&amp;gt; &amp;lt;/VisualStateGroup&amp;gt; &amp;lt;/VisualStateManager.VisualStateGroups&amp;gt; &amp;lt;/Grid&amp;gt;&amp;lt;/ControlTemplate&amp;gt;可以看到，对于每一种 ClosedDisplayMode，都有三种状态与之对应 —— Closed、Up 和 Down。当然，Up 就是向上展开时的状态，Down 就是向下展开时的状态。而 Closed、Up 和 Down 之间的状态切换有四种 —— Closed 到 Up、Up 到 Closed、Closed 到 Down 以及 Down 到 Closed。于是，我们要获得任何时候都向下展开的能力，我们便需要将所有的 Up 状态修改成 Down 的状态。现在，我们将 将 &amp;lt;VisualState From=&quot;CompactClosed&quot; To=&quot;CompactOpenDown&quot; /&amp;gt; 的代码复制到 &amp;lt;VisualState From=&quot;CompactClosed&quot; To=&quot;CompactOpenUp&quot; /&amp;gt; 中，&amp;lt;VisualState From=&quot;CompactOpenDown&quot; To=&quot;CompactClosed&quot; /&amp;gt; 内部的代码复制到 &amp;lt;VisualState From=&quot;CompactOpenUp&quot; To=&quot;CompactClosed&quot; /&amp;gt; 中，将 &amp;lt;VisualState x:Name=&quot;CompactOpenDown&quot; /&amp;gt; 内的代码复制到 &amp;lt;VisualState x:Name=&quot;CompactOpenUp&quot; /&amp;gt; 中。也就是说，我们将所有 CompactClosed 和 CompactDown 的状态复制到了 CompactClosed 和 CompactUp 的状态中。这样，即便 CommandBar 判定为向上展开，实际上的动画和交互也都是向下展开的了。以下是这样修改后的效果。▲ 使用样式更改的展开方向究竟应该如何修改 CommandBar 的展开方向在多数情况下，我想我们并没有特别强烈的需求一定要让 CommandBar 在顶部依然有空间的情况下展开方向向下。如果有，那通常也是中大型项目，这时 CommandBar 样式和模板所占用的那 1400 行左右的代码也就不显得多了。但对于小型个人项目而言，可以考虑修改应用程序的外观设计来规避这么长的代码。例如让 CommandBar 始终显示或隐藏文字，或者让 CommandBar 默认为 Minimal 的状态。如果你对其他控件有小型样式的修改需求，可以阅读我的另一篇文章：UWP 轻量级样式定义（Lightweight Styling）。" }, { "title": "各个 C# 版本的主要特性、发布日期和发布方式（C# 1.0 - 7.3）", "url": "/post/csharp-version-histories.html", "categories": "", "tags": "visualstudio, csharp, dotnet", "date": "2018-10-15 15:00:20 +0800", "snippet": "本文收集各个 C# 版本的主要特性、发布日期和发布方式。C# 8.0 尚在预览版本C# 7.3 2018 年 5 月 随 Visual Studio 2017 v15.7 发布C# 7.2 2017 年 11 月 随 Visual Studio 2017 v15.5 发布C# 7.1 2017 年 8 月 随 Visual Studio 2017 v15.3 发布C# 7.0 2017 年 3 月 随 Visual Studio 2017 和 .NET Framework 4.7 发布C# 6.0 2015 年 7 月 随 Visual Studio 2015 和 .NET Framework 4.6 发布C# 5.0 2012 年 8 月 随 Visual Studio 2012 和 .NET Framework 4.5 发布C# 4.0 2010 年 4 月 随 Visual Studio 2010 和 .NET Framework 4.0 发布C# 3.0 2007 年 11 月 随 Visual Studio 2008 和 .NET Framework 3.5 发布C# 2.0 2005 年 11 月 随 Visual Studio 2005 和 .NET Framework 3.0 发布C# 1.2 2003 年 4 月 随 Visual Studio 2003 和 .NET Framework 1.1 发布C# 1.0 2002 年 1 月 随 Visual Studio 2002 和 .NET Framework 1.0 发布参考资料 .net - What are the correct version numbers for C#? - Stack Overflow" }, { "title": "WPF 的 ElementName 在 ContextMenu 中无法绑定成功？试试使用 x:Reference！", "url": "/post/fix-wpf-binding-issues-in-context-menu.html", "categories": "", "tags": "wpf, dotnet", "date": "2018-10-14 12:25:19 +0800", "snippet": "在 Binding 中使用 ElementName 司空见惯，没见它出过什么事儿。不过当你预见 ContextMenu，或者类似 Grid.Row / Grid.Column 这样的属性中设置的时候，ElementName 就不那么管用了。本文将解决这个问题。以下代码是可以正常工作的&amp;lt;Window x:Class=&quot;Walterlv.Demo.BindingContext.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; x:Name=&quot;WalterlvWindow&quot; Title=&quot;Walterlv Binding Demo&quot; Height=&quot;450&quot; Width=&quot;800&quot;&amp;gt; &amp;lt;Grid Background=&quot;LightGray&quot; Margin=&quot;1 1 1 0&quot; MinHeight=&quot;40&quot;&amp;gt; &amp;lt;TextBlock&amp;gt; &amp;lt;Run Text=&quot;{Binding Mode=OneWay}&quot; FontSize=&quot;20&quot; /&amp;gt; &amp;lt;LineBreak /&amp;gt; &amp;lt;Run Text=&quot;{Binding ElementName=WalterlvWindow, Path=DemoText, Mode=OneWay}&quot; /&amp;gt; &amp;lt;/TextBlock&amp;gt; &amp;lt;/Grid&amp;gt;&amp;lt;/Window&amp;gt;在代码中，我们为一段文字中的一个部分绑定了主窗口的的一个属性，于是我们使用 ElementName 来指定绑定源为 WalterlvWindow。▲ 使用普通的 ElementName 绑定以下代码就无法正常工作了保持以上代码不变，我们现在新增一个 ContextMenu，然后在 ContextMenu 中使用一模一样的绑定表达式：&amp;lt;Window x:Class=&quot;Walterlv.Demo.BindingContext.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; x:Name=&quot;WalterlvWindow&quot; Title=&quot;Walterlv Binding Demo&quot; Height=&quot;450&quot; Width=&quot;800&quot;&amp;gt; &amp;lt;Grid Background=&quot;LightGray&quot; Margin=&quot;1 1 1 0&quot; MinHeight=&quot;40&quot;&amp;gt; &amp;lt;Grid.ContextMenu&amp;gt; &amp;lt;ContextMenu&amp;gt; &amp;lt;MenuItem Header=&quot;{Binding ElementName=WalterlvWindow, Path=DemoText, Mode=OneWay}&quot; /&amp;gt; &amp;lt;/ContextMenu&amp;gt; &amp;lt;/Grid.ContextMenu&amp;gt; &amp;lt;TextBlock&amp;gt; &amp;lt;Run Text=&quot;{Binding Mode=OneWay}&quot; FontSize=&quot;20&quot; /&amp;gt; &amp;lt;LineBreak /&amp;gt; &amp;lt;Run Text=&quot;{Binding ElementName=WalterlvWindow, Path=DemoText, Mode=OneWay}&quot; /&amp;gt; &amp;lt;/TextBlock&amp;gt; &amp;lt;/Grid&amp;gt;&amp;lt;/Window&amp;gt;注意，MenuItem 的 Header 属性设置为和 Run 的 Text 属性一模一样的绑定字符串。不过运行之后的截图显示，右键菜单中并没有如预期般出现绑定的字符串。使用 x:Reference 代替 ElementName 能够解决以上绑定失败的原因，是 Grid.ContextMenu 属性中赋值的 ContextMenu 不在可视化树中，而 ContextMenu 又不是一个默认建立 ScopeName 的控件，此时既没有自己指定 NameScope，有没有通过可视化树寻找上层设置的 NameScope，所以在绑定上下文中是找不到 WalterlvWindow 的。如果调用去查找，得到的是 null。详见：WPF 中的 NameScope。类似的情况也发生在设置非可视化树或逻辑树的属性时，典型的比如在 Grid.Row 或 Grid.Column 属性上绑定时，ElementName 也是失效的。此时最适合的情况是直接使用 x:Reference。 &amp;lt;Window x:Class=&quot;Walterlv.Demo.BindingContext.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; x:Name=&quot;WalterlvWindow&quot; Title=&quot;Walterlv Binding Demo&quot; Height=&quot;450&quot; Width=&quot;800&quot;&amp;gt; &amp;lt;Grid Background=&quot;LightGray&quot; Margin=&quot;1 1 1 0&quot; MinHeight=&quot;40&quot;&amp;gt; &amp;lt;Grid.ContextMenu&amp;gt; &amp;lt;ContextMenu&amp;gt;- &amp;lt;MenuItem Header=&quot;{Binding ElementName=WalterlvWindow, Path=DemoText, Mode=OneWay}&quot; /&amp;gt;+ &amp;lt;MenuItem Header=&quot;{Binding Source={x:Reference WalterlvWindow}, Path=DemoText, Mode=OneWay}&quot; /&amp;gt; &amp;lt;/ContextMenu&amp;gt; &amp;lt;/Grid.ContextMenu&amp;gt; &amp;lt;TextBlock&amp;gt; &amp;lt;Run Text=&quot;{Binding Mode=OneWay}&quot; FontSize=&quot;20&quot; /&amp;gt; &amp;lt;LineBreak /&amp;gt; &amp;lt;Run Text=&quot;{Binding ElementName=WalterlvWindow, Path=DemoText, Mode=OneWay}&quot; /&amp;gt; &amp;lt;/TextBlock&amp;gt; &amp;lt;/Grid&amp;gt; &amp;lt;/Window&amp;gt;不过，这是个假象，因为此代码运行时会抛出异常： XamlObjectWriterException: Cannot call MarkupExtension.ProvideValue because of a cyclical dependency. Properties inside a MarkupExtension cannot reference objects that reference the result of the MarkupExtension. The affected MarkupExtensions are:‘System.Windows.Data.Binding’ Line number ‘8’ and line position ‘27’.因为给 MenuItem 的 Header 属性绑定赋值的时候，创建绑定表达式用到了 WalterlvWindow，但此时 WalterlvWindow 尚在构建（因为里面的 ContextMenu 是窗口的一部分），于是出现了循环依赖。而这是不允许的。为了解决循环依赖问题，我们可以考虑将 x:Reference 放到资源中。因为资源是按需创建的，所以这不会造成循环依赖。那么总得有一个对象来承载我们的绑定源。拿控件的 Tag 属性也许是一个方案，不过专门为此建立一个绑定代理类也许是一个更符合语义的方法： &amp;lt;Window x:Class=&quot;Walterlv.Demo.BindingContext.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;+ xmlns:local=&quot;clr-namespace:Walterlv.Demo.BindingContext&quot; x:Name=&quot;WalterlvWindow&quot; Title=&quot;Walterlv Binding Demo&quot; Height=&quot;450&quot; Width=&quot;800&quot;&amp;gt;+ &amp;lt;Window.Resources&amp;gt;+ &amp;lt;local:BindingProxy x:Key=&quot;WalterlvBindingProxy&quot; Data=&quot;{x:Reference WalterlvWindow}&quot; /&amp;gt;+ &amp;lt;/Window.Resources&amp;gt; &amp;lt;Grid Background=&quot;LightGray&quot; Margin=&quot;1 1 1 0&quot; MinHeight=&quot;40&quot;&amp;gt; &amp;lt;Grid.ContextMenu&amp;gt; &amp;lt;ContextMenu&amp;gt;- &amp;lt;MenuItem Header=&quot;{Binding Source={x:Reference WalterlvWindow}, Path=DemoText, Mode=OneWay}&quot; /&amp;gt;+ &amp;lt;MenuItem Header=&quot;{Binding Source={StaticResource WalterlvBindingProxy}, Path=Data.DemoText, Mode=OneWay}&quot; /&amp;gt; &amp;lt;/ContextMenu&amp;gt; &amp;lt;/Grid.ContextMenu&amp;gt; &amp;lt;TextBlock&amp;gt; &amp;lt;Run Text=&quot;{Binding Mode=OneWay}&quot; FontSize=&quot;20&quot; /&amp;gt; &amp;lt;LineBreak /&amp;gt; &amp;lt;Run Text=&quot;{Binding ElementName=WalterlvWindow, Path=DemoText, Mode=OneWay}&quot; /&amp;gt; &amp;lt;/TextBlock&amp;gt; &amp;lt;/Grid&amp;gt; &amp;lt;/Window&amp;gt;至于 BindingProxy，非常简单：public sealed class BindingProxy : Freezable{ public static readonly DependencyProperty DataProperty = DependencyProperty.Register( &quot;Data&quot;, typeof(object), typeof(BindingProxy), new PropertyMetadata(default(object))); public object Data { get =&amp;gt; (object) GetValue(DataProperty); set =&amp;gt; SetValue(DataProperty, value); } protected override Freezable CreateInstanceCore() =&amp;gt; new BindingProxy(); public override string ToString() =&amp;gt; Data is FrameworkElement fe ? $&quot;BindingProxy: {fe.Name}&quot; : $&quot;Binding Proxy: {Data?.GetType().FullName}&quot;;}现在运行，右键菜单已经正常完成了绑定。▲ 右键菜单已经正常完成了绑定参考资料 c# - WPF databinding error in Tag property - Stack Overflow" }, { "title": "分析现有 WPF / Windows Forms 程序能否顺利迁移到 .NET Core 3.0（使用 .NET Core 3.0 Desktop API Analyzer ）", "url": "/post/net-core-desktop-api-analyzer.html", "categories": "", "tags": "dotnet, wpf", "date": "2018-10-05 06:40:51 +0800", "snippet": "今年五月的 Build 大会上，微软说 .NET Core 3.0 将带来 WPF / Windows Forms 这些桌面应用的支持。当然，是通过 Windows 兼容包（Windows Compatibility Pack）实现的。为了提前检查你的程序是否能在未来跑在 .NET Core 3.0 上，微软在 2018年8月8日 推出了 .NET Core 3.0 Desktop API Analyzer，帮助你提前检查你的程序能有多容易迁移到 .NET Core 3.0本文将介绍其使用方法，并介绍 API 的逐步迁移方法。.NET Core 3.0 Desktop API Analyzer你可以前往 GitHub 查看 .NET Core 3.0 Desktop API Analyzer 项目： Microsoft/dotnet-apiport-ui去 release 标签下即可下载。当然，目前仅发布一个版本，你也可以点击以下链接直接下载： PortabilityAnalyzer.zip下载完后解压到任意目录即可运行。分析一个 WPF 程序第一个想到的，是分析目前已在商店发布的基于 .NET Framework 4.7 的 WPF 程序 标识符命名工具 - Whitman。▲ 分析 WPF 程序其实这个目录下只有一点点程序集，所以分析起来很快的。▲ Whitman 的目录结构选好后，点击 Analyze，在 Analyzing… 提示等待之后，即可在它指定的临时目录中找到分析结果文件：Report saved in: C:\\Users\\walterlv\\AppData\\Local\\Temp\\PortabilityReport.xlsx竟然是一个 Excel 表格！▲ Excel 表格表示的结果可以看到，我的 Whitman 对 .NET Core 3.0 的 API 是 100% 兼容的。将来迁移的时候可以不需要修改代码。分析更复杂的程序我试着分析一个更庞大的 WPF 软件目录后，发现还是有一些 API 是不兼容的。▲ 有一些 API 不兼容▲ 有一些程序集兼容性很低这份 Excel 表格中还包含了具体哪些 API 是不兼容的，并为部分使用提供了建议：▲ 查看不兼容的 API所以，我们只需要查找对对应 API（第一列）的使用，然后通过其他技术手段将其替换成别的方法来写即可解决这样的兼容性问题。着手解决兼容性问题比如我们拿出其中一行： Target type Target member Header for assembly name entries .NET Core Recommended changes T:System.Runtime.Remoting.Messaging.MethodCallMessageWrapper T:System.Runtime.Remoting.Messaging.MethodCallMessageWrapper Walterlv.Placeholder Not supported Remove usage. 我们通过在 Walterlv.Placeholder（这只是个占位程序集，实际名称已隐去）中全解决方案中搜索 MethodCallMessageWrapper 可以找到此 API 的所有使用。public override IMessage Invoke(IMessage msg){ var caller = new MethodCallMessageWrapper((IMethodCallMessage) msg); // 省略其他代码。}此方法在此处上下文的目的是实现 AOP 代理，即为了实现切面编程，允许在实体类的每个方法执行之前注入一些代码。既然此处基于 .NET Framework MethodCallMessageWrapper 的 AOP 已不可用，那么我们需要寻找到 .NET Core 中 AOP 的替代品。例如 .NET Core 官方推荐的是： dotnetcore/AspectCore-Framework: AspectCore is an AOP-based cross platform framework for .NET Standard.于是，我们几乎需要改造此类型，使其对 .NET Framework 中 MethodCallMessageWrapper 的使用替换成对 AspectCore-Framework 的依赖。这是一项繁重的工作，不过还是要做的。迁移到 .NET Core 有很多好处，不是吗？一些错误额外的，在其他一些程序的分析中，我遇到了一些错误。通过混淆的比较，我认为此错误可能源于程序集的混淆：Unable to analyze.Details:Detecting assembly references [Failed]Cannot locate assembly information for System.Object. Microsoft assemblies found are:Cannot locate assembly information for System.Object. Microsoft assemblies found are:Cannot locate assembly information for System.Object. Microsoft assemblies found are:Cannot locate assembly information for System.Object. Microsoft assemblies found are:Cannot locate assembly information for System.Object. Microsoft assemblies found are:Cannot locate assembly information for System.Object. Microsoft assemblies found are:Cannot locate assembly information for System.Object. Microsoft assemblies found are:Cannot locate assembly information for System.Object. Microsoft assemblies found are:如果你想了解更多混淆相关的资料，可以阅读我的另一篇博客：.NET 中各种混淆（Obfuscation）的含义、原理、实际效果和不同级别的差异（使用 SmartAssembly）。未来的迁移.NET Core 并不会原生提供 WPF / Windows Forms 这些桌面应用的支持，而是通过 Windows 兼容包（Windows Compatibility Pack）实现。你可以阅读微软官方博客了解：Announcing the Windows Compatibility Pack for .NET Core - .NET Blog迁移到 .NET Core 并不会为这些程序带来跨平台特性，只是能够充分利用到 .NET Core 带来的诸多好处而已。比如更高的性能，更方便的部署，及时的更新。当然还有 MIT 开源，我们能够和社区一起修复 Bug。关于 .NET Framework 迁移到 .NET Core 的好处，以及 .NET Framework 未来的支持情况，可以阅读微软的另一篇博客了解：Update on .NET Core 3.0 and .NET Framework 4.8 - .NET Blog" }, { "title": "使用并解析 OPML 格式的订阅列表来转移自己的 RSS 订阅（解析篇）", "url": "/post/deserialize-opml-using-dotnet.html", "categories": "", "tags": "dotnet, csharp, uwp", "date": "2018-09-23 20:01:15 +0800", "snippet": "OPML 全称是 Outline Processor Markup Language ，即 大纲处理标记语言。目前流行于收集博客的 RSS 源，便于用户转移自己的订阅项目。本文将介绍这个古老的格式，并提供一个 .NET 上的简易解析器。本文是两个部分的第二篇，前者是理解 OPML 格式，此篇是解析此格式： 概念篇 解析篇（本文）OPML 格式在解析之前，最好先理解此格式的的元素组成和元素属性，所以如果你没有阅读 概念篇，请先前往阅读。创建适用于 RSS 的简易 OPML 模型我们先为模型创建基类 OpmlModel。为了方便在客户端应用中使用，可以使其继承自 INotifyPropertyChanged。namespace Walterlv.Rssman.Models{ public abstract class OpmlModel : NotificationObject { public void Deserialize(XElement element) { OnDeserializing(element); } protected abstract void OnDeserializing(XElement element); }}namespace Walterlv.Rssman.Models{ public abstract class NotificationObject : INotifyPropertyChanged { public event PropertyChangedEventHandler PropertyChanged; [NotifyPropertyChangedInvocator] protected void SetValue&amp;lt;T&amp;gt;(ref T field, T value, [CallerMemberName] string propertyName = null) { if (Equals(field, value)) return; field = value; PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName)); } [NotifyPropertyChangedInvocator] protected void NotifyPropertyChanged([CallerMemberName] string propertyName = null) { PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName)); } }}拿出我们关心的 outline 的属性来解析，于是有：namespace Walterlv.Rssman.Models{ [DebuggerDisplay(&quot;RssOutline {Text,nq}, {XmlUrl,nq}, Count={Children.Count,nq}&quot;)] public sealed class RssOutline : OpmlModel { private string _text; private OutlineType _type; private string _xmlUrl; private string _htmlUrl; public string Text { get =&amp;gt; _text; set =&amp;gt; SetValue(ref _text, value); } public OutlineType Type { get =&amp;gt; _type; set =&amp;gt; SetValue(ref _type, value); } public string XmlUrl { get =&amp;gt; _xmlUrl; set =&amp;gt; SetValue(ref _xmlUrl, value); } public string HtmlUrl { get =&amp;gt; _htmlUrl; set =&amp;gt; SetValue(ref _htmlUrl, value); } public bool HasChildren =&amp;gt; Children.Any(); public ObservableCollection&amp;lt;RssOutline&amp;gt; Children { get; } = new ObservableCollection&amp;lt;RssOutline&amp;gt;(); protected override void OnDeserializing(XElement element) { // 等待编写解析代码。 } }}还有表示 OPML 文档的模型：namespace Walterlv.Rssman.Models{ [DebuggerDisplay(&quot;RssOpml {Title,nq}, Count={Children.Count,nq}&quot;)] public sealed class RssOpml : OpmlModel { private string _title; public string Title { get =&amp;gt; _title; set =&amp;gt; SetValue(ref _title, value); } public ObservableCollection&amp;lt;RssOutline&amp;gt; Children { get; } = new ObservableCollection&amp;lt;RssOutline&amp;gt;(); protected override void OnDeserializing(XElement element) { // 等待编写解析代码。 } }}从 OPML 文档中解析出模型在以上的模型代码中，我为基类留有 OnDeserializing 方法以供反序列化。为了尽可能简化此博客的代码，参数我直接使用了 XElement 类型，以便在方法中使用 XPath 语法来解析。（当然，如果你是做库或者进行大型可维护项目的开发，这里就需要一些抽象了。）现在，我们写一个新的静态类型 Opml 来解析 OPML 文档：namespace Walterlv.Rssman.Services{ public static class Opml { public static async Task&amp;lt;RssOpml&amp;gt; ParseAsync(Stream stream) { var document = await XDocument.LoadAsync(stream, LoadOptions.None, CancellationToken.None); var root = document.XPathSelectElement(&quot;opml&quot;); var opml = new RssOpml(); opml.Deserialize(root); return opml; } }}于是，再补全模型 RssOpml 和 RssOutline 的反序列化部分：// RssOpml.csprotected override void OnDeserializing(XElement element){ var title = element.XPathSelectElement(&quot;head/title&quot;); Title = title?.Value; var outlines = element.XPathSelectElements(&quot;body/outline&quot;); Children.Clear(); foreach (var value in outlines) { var outline = new RssOutline(); outline.Deserialize(value); Children.Add(outline); }}// RssOutline.csprotected override void OnDeserializing(XElement element){ var text = element.Attribute(&quot;text&quot;); Text = text?.Value; var type = element.Attribute(&quot;type&quot;); if (type != null &amp;amp;&amp;amp; Enum.TryParse(type.Value, out OutlineType outlineType)) { Type = outlineType; } var xmlUrl = element.Attribute(&quot;xmlUrl&quot;); XmlUrl = xmlUrl?.Value; var htmlUrl = element.Attribute(&quot;htmlUrl&quot;); HtmlUrl = htmlUrl?.Value; var outlines = element.XPathSelectElements(&quot;outline&quot;); Children.Clear(); foreach (var value in outlines) { var outline = new RssOutline(); outline.Deserialize(value); Children.Add(outline); }}注意，以上两个方法请分别填充到 RssOpml.cs 和 RssOutline.cs 的 OnDeserializing 方法中。这里，所有的 XML 解析均使用的是 XPath 语法，关于 XPath 语法，可以阅读 XML 的 XPath 语法 - walterlv，关于如何使用 XPath 在 .NET 中读写 XML 文件，可以阅读 .NET 使用 XPath 来读写 XML 文件 - walterlv。使用此 OPML 模型当你把这些类都准备好，那么你就可以使用简单的几句话来完成 OPML 文档的解析了。在 UWP 应用中，可以通过 StorageFile 来打开一个文件流：var folder = Package.Current.InstalledLocation;using (var stream = await folder.OpenStreamForReadAsync(&quot;sample-opml.xml&quot;)){ var opml = await Opml.ParseAsync(stream); // 使用此 OPML 文档}在 .NET Framework 传统应用中，可以使用 File.Read 来打开一个文件流。由于我们本文中创建的模型均实现了 INotifyPropertyChanged 接口，所以你甚至可以直接将 Opml.ParseAsync 的返回结果应用于绑定。" }, { "title": "Git 更安全的强制推送，--force-with-lease", "url": "/post/safe-push-using-force-with-lease.html", "categories": "", "tags": "git", "date": "2018-09-23 12:33:38 +0800", "snippet": "由于 git rebase 命令的存在，强制将提交推送到远端仓库似乎也有些必要。不过都知道 git push --force 是不安全的，这让 git rebase 命令显得有些鸡肋。本文将推荐 --force-with-lease 参数，让我们可以更安全地进行强制推送。--force-with-lease 参数自 Git 的 1.8.5 版本开始提供，只在解决 git push --force 命令造成的安全问题。那么 git push --force 命令有什么安全问题？--force 会使用本地分支的提交覆盖远端推送分支的提交。也就是说，如果其他人在相同的分支推送了新的提交，你的这一举动将“删除”他的那些提交！就算在强制推送之前先 fetch 并且 merge 或 rebase 了也是不安全的，因为这些操作到推送之间依然存在时间差，别人的提交可能发生在这个时间差之内。如果你对这样的危险没有什么直观的感觉，可以看看这则新闻： 还在用 Git 的 -f 参数强推仓库，你这是在作死！ 因代码不规范，码农枪击4名同事，一人情况危急▲ git push -f 致使枪杀--force-with-lease 将解决这种安全问题使用了 --force-with-lease 参数之后，上面那种安全问题就没有那么危险了。使用此参数推送，如果远端有其他人推送了新的提交，那么推送将被拒绝，这种拒绝和没有加 --force 参数时的拒绝是一样的。 walterlv$ git push --force-with-leaseTo https://github.com/walterlv/walterlv.github.io.git ! [rejected] master -&amp;gt; master (fetch first)error: failed to push some refs to &#39;https://github.com/walterlv/walterlv.github.io.git&#39; 请特别注意——如果你 fetch 之后在本地的 origin 相关分支上已经看到了别人的提交，依然进行强制推送，你还是会覆盖别人的提交。也就是说，--force-with-lease 解决的是本地仓库不够新时，依然覆盖了远端新仓库的问题，如果你执意想要覆盖远端提交，只需要先 fetch 再推送，它也不会拒绝的。在使用 git push --force-with-lease 命令被拒绝时，你需要 fetch 仓库，然后确认其他人是否对此分支有新的修改，如果没有，你才可以继续强制推送。 walterlv$ git fetchremote: Counting objects: 46, done.remote: Compressing objects: 100% (29/29), done.remote: Total 46 (delta 21), reused 40 (delta 15), pack-reused 0Unpacking objects: 100% (46/46), done.From https://github.com/walterlv/walterlv.github.io e75edf0..217a49d master -&amp;gt; origin/master 在 fetch 完毕之后，请一定检查此分支是否已经被其他人修改，如果有新的提交，你应该进行一次 merge 或者 rebase。 walterlv$ git rebaseFirst, rewinding head to replay your work on top of it...Applying: Add post &quot;safe push using force with lease&quot;. 此后，再次进行推送或强制推送即可。 walterlv$ git push --force-with-leaseCounting objects: 4, done.Delta compression using up to 8 threads.Compressing objects: 100% (4/4), done.Writing objects: 100% (4/4), 363 bytes | 363.00 KiB/s, done.Total 4 (delta 3), reused 0 (delta 0)remote: Resolving deltas: 100% (3/3), completed with 3 local objects.To https://github.com/walterlv/walterlv.github.io.git 219a6d5..dff94a5 master -&amp;gt; master 额外的问题：为什么推送到远端的提交还依然要用 rebase？Git 官方文档对 rebase 有如下描述：▲ 如果你想吐槽那段中文翻译，我只想说——那是 Git 的官方中文文档既然已经推送的提交不应该再进行 rebase，那本不应该会遇到本文提到的问题。但是——GitHub 的工作流或者 GitLab 的工作流中，都有一种行为是 rebase 自己的分支到 origin/master 上，以保证 master 分支上的提交是纯粹的干净的。也就是说，本意是禁止对合并到 master 或 develop 分支上的提交进行 rebase；但对于自己的 temp 分支或者 feature 分支，因为提交还没有合并到主干中，随时删除掉或者将历史进行美化也不会造成太大的问题。▲ 这是 GitLab 上的设置，可以要求提交者必须进行 rebase 才允许合并参考资料 Git - git-push Documentation How do I properly force a Git push? - Stack Overflow Force-with-lease: an alternative to force push - Weiqing –force considered harmful; understanding git’s –force-with-lease - Atlassian Developers" }, { "title": "再也不用克隆多个仓库啦！git worktree 一个 git 仓库可以连接多个工作目录", "url": "/post/git-worktree.html", "categories": "", "tags": "git", "date": "2018-09-17 18:45:12 +0800", "snippet": "我在 feature 分支开发得多些，但总时不时被高优先级的 BUG 打断需要临时去 develop 分一个分支出来解 BUG。git 2.6 以上开始提供了 worktree 功能，可以解决这样的问题。阅读本文将了解使用 git worktree 高效进行并行开发的方法。git worktree 从一个仓库中可以创建多个工作目录，方便多开编辑器并行开发。快速上手git worktree add -b &amp;lt;新分支名&amp;gt; &amp;lt;新路径&amp;gt; &amp;lt;从此分支创建&amp;gt;例如，你正在某个 feature 分支开发，希望从 master 分出一个分支来解决某个紧急的 BUG：git worktree add -b t/walterlv/bugfix-100 ../Demo.bugfix master这样，原本的仓库文件夹的同级目录下会出现一个 Demo.bugfix 文件夹（当然名字随便取）。这个仓库里只有一个 .git 文件用来记录这是主仓库的一个工作目录。自此，这两个工作目录在工作上看起来就像两个独立的仓库一样，都可以运行各种命令，包括切换分支。另外，你也可以不使用 -b，以便直接使用现有的分支，而不创建新的分支：git worktree add &amp;lt;新路径&amp;gt; &amp;lt;从此分支创建&amp;gt;例如，你正在某个 feature 分支开发，希望回到 master 分支解决某个紧急的 BUG：git worktree add ../Demo.bugfix master相比于克隆多个仓库，使用这种方法创建的多个目录，有诸多好处： 只有一个仓库会占用版本库的空间，其它只占用工作目录的空间，对大型项目而言非常节省空间。 因为所有工作目录共享一个仓库，所以一个更新意味着整个更新（A 目录里对分支做的改动，B 目录里切到此分支也是改动后的；避免到时候找不到某个未推送的改动改到了哪个仓库）注意事项使用 git worktree 创建的多个目录，不能有任何两个目录在同一个分支下——原因应该不言自明。如果要删除其中一个工作目录，直接删除文件夹即可。随后使用命令清除多余的已经被删的工作目录：git worktree prune" }, { "title": ".NET 命令行参数包含应用程序路径吗？", "url": "/post/when-will-the-command-line-args-contain-the-executable-path.html", "categories": "", "tags": "dotnet, csharp", "date": "2018-09-13 11:24:33 +0800", "snippet": "如果你关注过命令行参数，也许发现有时你会在命令行参数的第一个参数中中看到应用程序的路径，有时又不会。那么什么情况下有路径呢？其实是否有路径只是取决于获取命令行参数的时候用的是什么方法。而这是 Windows 操作系统的机制，与具体的运行环境无关。测试程序考虑下面这样的测试程序：using System;using System.Globalization;namespace Walterlv.Demo.CommandLines{ class Program { static void Main(string[] args) { Console.WriteLine($&quot;参数总数：{args.Length}&quot;); OutputArgsInfo(args); Console.WriteLine($&quot;按任意键继续……&quot;); Console.ReadKey(); } private static void OutputArgsInfo(string[] args) { var digitCount = (args.Length - 1).ToString(CultureInfo.InvariantCulture).Length; for (var i = 0; i &amp;lt; args.Length; i++) { Console.WriteLine($&quot;[{i.ToString().PadLeft(digitCount, &#39; &#39;)}] {args[i]}&quot;); } } }}当我们向命令行中传入参数的时候，我们可以得到所有的命令行。▲ Main 函数中的命令行参数这种行为与具体的 .NET SDK 无关。看我们的项目文件，可以发现，无论是老旧的 .NET Framework 4.5 还是新的 .NET Framework 4.7.2 还是更加主流的 .NET Core 2.1，命令行参数中都是没有应用程序路径的。&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;OutputType&amp;gt;Exe&amp;lt;/OutputType&amp;gt; &amp;lt;TargetFrameworks&amp;gt;net45;net472;netcoreapp2.1&amp;lt;/TargetFrameworks&amp;gt; &amp;lt;/PropertyGroup&amp;gt;&amp;lt;/Project&amp;gt;那为什么有时候会看到应用程序路径呢？解释在《Windows 核心编程》一书中有说到： 可以获得一个指向进程的完整命令行的指针，方法是调用 GetCommandLine 函数： PTSTR GetCommandLine(); 该函数返回一个指向包含完整命令行的缓存的指针，该命令行包括执行文件的完整路径名。也就是说，调用 GetCommandLine 函数时，我们将得到包含执行文件的完整路径名的命令行参数。这个方法对应到 .NET 中，是 System.Environment.GetCommandLineArgs()。于是修改我们刚刚的函数，加上 Environment.GetCommandLineArgs() 的调用：using System;using System.Globalization;namespace Walterlv.Demo.CommandLines{ class Program { static void Main(string[] args) { Console.WriteLine($&quot;Main 函数参数列表中参数总数：{args.Length}&quot;); OutputArgsInfo(args); args = Environment.GetCommandLineArgs(); Console.WriteLine($&quot;GetCommandLineArgs 参数总数：{args.Length}&quot;); OutputArgsInfo(args); Console.WriteLine($&quot;按任意键继续……&quot;); Console.ReadKey(); } private static void OutputArgsInfo(string[] args) { var digitCount = (args.Length - 1).ToString(CultureInfo.InvariantCulture).Length; for (var i = 0; i &amp;lt; args.Length; i++) { Console.WriteLine($&quot;[{i.ToString().PadLeft(digitCount, &#39; &#39;)}] {args[i]}&quot;); } } }}现在，我们能看到参数列表中多了应用程序的完整路径：▲ GetCommandLineArgs 中的命令行参数事实上这样的差异不止在 .NET 中有体现，整个 Windows 上的程序都是这样的特性。这在《Windows 核心编程》一书中是有说明的。总结 Main 函数的参数中不包含应用程序执行路径； System.Environment.GetCommandLineArgs() 得到的命令行参数中包含应用程序的执行路径； Windows 上的所有程序其命令行参数的行为表现都是如此，这不是 .NET 的专属特性。" }, { "title": "WPF 同一窗口内的多线程 UI（VisualTarget）", "url": "/post/multi-thread-ui-using-visualtarget-in-wpf.html", "categories": "", "tags": "wpf, dotnet, csharp", "date": "2018-09-05 13:47:01 +0800", "snippet": "WPF 的 UI 逻辑只在同一个线程中，这是学习 WPF 开发中大家几乎都会学习到的经验。如果希望做不同线程的 UI，大家也会想到使用另一个窗口来实现，让每个窗口拥有自己的 UI 线程。然而，就不能让同一个窗口内部使用多个 UI 线程吗？阅读本文将收获一份对 VisualTarget 的解读以及一份我封装好的跨线程 UI 控件 DispatcherContainer.cs。WPF 同一个窗口中跨线程访问 UI 有多种方法： 使用 VisualTarget (本文) 使用 SetParent 嵌入另一个窗口前者使用的是 WPF 原生方式，做出来的跨线程 UI 可以和原来的 UI 相互重叠遮挡。后者使用的是 Win32 的方式，实际效果非常类似 WindowsFormsHost，新线程中的 UI 在原来的所有 WPF 控件上面遮挡。另外，后者不止可以是跨线程，还可以跨进程。几个必备的组件微软给 VisualTarget 提供的注释是： 提供跨线程边界将一个可视化树连接到另一个可视化树的功能。注释中说 VisualTarget 就是用来连接可视化树（VisualTree）的，而且可以跨线程边界。也就是说，这是一个专门用来使同一个窗口内部包含多个不同 UI 线程的类型。所以，我们的目标是使用 VisualTarget 显示跨线程边界的 UI。VisualTarget 本身继承自 CompositionTarget，而不是 Visual；其本身并不是可视化树的一部分。但是它的构造函数中可以传入一个 HostVisual 对象，这个对象是一个 Visual，如果将此 HostVisual 放入原 UI 线程的可视化树上，那么 VisualTarget 就与主 UI 线程连接起来了。另外一半，VisualTarget 需要连接另一个异步线程的可视化树。然而，VisualTarget 提供了 RootVisual 属性，直接给此属性赋一个后台 UI 控件作为其值，即连接了另一个 UI 线程的可视化树。总结起来，其实我们只需要 new 一个 VisualTarget 的新实例，构造函数传入一个 UI 线程的可视化树中的 HostVisual 实例，RootVisual 属性设置为另一个 UI 线程中的控件，即可完成跨线程可视化树的连接。事实上经过尝试，我们真的只需要这样做就可以让另一个线程上的 UI 呈现到当前的窗口上，同一个窗口。读者可以自行编写测试代码验证这一点，我并不打算在这里贴上试验代码，因为后面会给出完整可用的全部代码。完善基本功能虽说 VisualTarget 的基本使用已经可以显示一个跨线程的 UI 了，但是其实功能还是欠缺的。一个典型的情况是，后台线程的这部分 UI 没有连接到 PresentationSource；而 Visual.PointFromScreen、Visual.PointFromScreen 这样的方法明确需要连接到 PresentationSource 才行。参见这里：In WPF, under what circumstances does Visual.PointFromScreen throw InvalidOperationException? - Stack Overflow。可是，应该如何将 RootVisual 连接到 PresentationSource 呢？我从 Microsoft.DwayneNeed 项目中找到了方法。这是源码地址：Microsoft.DwayneNeed - Home。做法是重写属性和方法：public override Visual RootVisual{ get =&amp;gt; _visualTarget.RootVisual; set { // 此处省略大量代码。 }}protected override CompositionTarget GetCompositionTargetCore(){ return _visualTarget;}Microsoft.DwayneNeed 中有 VisualTargetPresentationSource 的完整代码，我自己只为这个类添加了 IDisposable 接口，用于 Dispose 掉 VisualTarget 的实例。我需要这么做是因为我即将提供可修改后台 UI 线程控件的方法。让方法变得好用为了让整个多线程 UI 线程的使用行云流水，我准备写一个 DispatcherContainer 类来优化多线程 UI 的使用体验。期望的使用方法是给这个控件的实例设置 Child 属性，这个 Child 是后台线程创建的 UI。然后一切线程同步相关的工作全部交给此类来完成。在我整理后，使用此控件只需如此简单：&amp;lt;Grid Background=&quot;#FFEEEEEE&quot;&amp;gt; &amp;lt;local:DispatcherContainer x:Name=&quot;Host&quot;/&amp;gt;&amp;lt;/Grid&amp;gt;await Host.SetChildAsync&amp;lt;MyUserControl&amp;gt;();其中，MyUserControl 是控件的类型，可以是你写的某个 XAML 用户控件，也可以是其他任何控件类型。用这个方法创建的控件，直接就是后台 UI 线程的。当然，如果你需要自己控制初始化逻辑，可以使用委托创建控件。await Host.SetChildAsync(() =&amp;gt;{ var box = new TextBox { Text = &quot;吕毅 - walterlv&quot;, Margin = new Thickness(16), }; return box;});下图即是用以上代码创建的后台线程文本框。甚至，你已经有线程的后台 UI 控件了，或者你希望自己来创建后台的 UI 控件，则可以这样：// 创建一个后台线程的 Dispatcher。// 其中，UIDispatcher 是我自己封装的方法，在 GitHub 上以 MIT 协议开源。// https://github.com/walterlv/sharing-demo/blob/master/src/Walterlv.Demo.WPF/Utils/Threading/UIDispatcher.csvar dispatcher = await UIDispatcher.RunNewAsync(&quot;walterlv&#39;s testing thread&quot;);// 使用这个后台线程的 Dispatcher 创建一个自己的用户控件。var control = await dispatcher.InvokeAsync(() =&amp;gt; new MyUserControl());// 将这个用户控件放入封装好的 DispatcherContainer 中。// DispatcherContainer 是我自己封装的方法，在 GitHub 上以 MIT 协议开源。// https://github.com/walterlv/sharing-demo/blob/master/src/Walterlv.Demo.WPF/Utils/Threading/DispatcherContainer.csawait Host.SetChildAsync(control);注意到我们自己创建的控件已经运行在后台线程中了：完整的代码以下所有代码均可点击进入 GitHub 查看。核心的代码包含两个类： VisualTargetPresentationSource 这是实现异步 UI 的关键核心，用于连接两个跨线程边界的可视化树，并同时提供连接到 PresentationSource 的功能。（由于我对 PresentationSource 的了解有限，此类绝大多数代码都直接来源于 Microsoft.DwayneNeed - Home。） DispatcherContainer 当使用我封装好的多线程 UI 方案时（其实就是把这几个类自己带走啦），这个类才是大家编程开发中主要面向的 API 类啊！其他辅助型代码： UIDispatcher 这并不是重点，此类型只是为了方便地创建后台 Dispatcher。 DispatcherAsyncOperation 此类型只是为了让 UIDispatcher 中的方法更好写一些。 AwaiterInterfaces 这是一组可有可无的接口；给 DispatcherAsyncOperation 继承的接口，但是不继承也没事，一样能跑。这些辅助型代码的含义可以查看我的另一篇博客：如何实现一个可以用 await 异步等待的 Awaiter - walterlv。参考资料 WPF Round Table Part 2: Multi UI Threaded Control - //InterKnowlogy/ Blogs Multithreaded UI: HostVisual – Presentation Source Microsoft.DwayneNeed - Home" }, { "title": ".NET/C# 推荐一个我设计的缓存类型（适合缓存反射等耗性能的操作，附用法）", "url": "/post/design-a-cache-pool.html", "categories": "", "tags": "dotnet, csharp", "date": "2018-09-02 15:59:05 +0800", "snippet": "这里我想说的是类型“实例”的缓存，适用于那些实例或者值计算很耗时的操作。典型的场景如反射获取 Attribute。适用本文推荐的方法适用于相同的输入可以获得相同的输出，但是这个输入到输出的过程非常耗时。大家都知道反射是很耗时的，尤其是获取 Attribute 和反射调用实例的方法。而从一个反射的成员中得到其 Attribute 是唯一的输入对应唯一的输出。思路既然唯一的输入对应唯一的输出，那么我们可以通过一个字典来储存我们已经转换过的输出。// 其中 TSource 表示输入的类型，TCache 表示输出的类型。Dictionary&amp;lt;TSource, TCache&amp;gt; _cacheDictionary = new Dictionary&amp;lt;TSource, TCache&amp;gt;();然后我们把已经计算过输出的输入存入到这个字典中。这样，当我们试图重新计算相同输入的输出的时候，便可以直接从字典中取得所需的输出的值。为了通用一点，我设计一个类型 CachePool&amp;lt;TSource, TCache&amp;gt;：namespace Walterlv{ public sealed class CachePool&amp;lt;TSource, TCache&amp;gt; { Dictionary&amp;lt;TSource, TCache&amp;gt; _cacheDictionary = new Dictionary&amp;lt;TSource, TCache&amp;gt;(); private TCache GetOrCacheValue(TSource source) { // 从这里计算新值或者从字典中获取已经计算的值。 } }}这个计算过程是唯一确定的，所以我们可以从构造函数中传入并储存下来。public CachePool([NotNull] Func&amp;lt;TSource, TCache&amp;gt; conversion){ _convert = conversion ?? throw new ArgumentNullException(nameof(conversion));}private readonly Func&amp;lt;TSource, TCache&amp;gt; _convert;于是我们的缓存类已经近乎完成。为了线程安全，我加了锁；但考虑到部分情况下性能更重要，所以我把锁设为了可选项。代码代码我放到了 gist.github.com，walterlv/CachePool.cs。你可以直接点击以上链接查看。为了不影响本文的阅读，我把实际的代码放到了最后。用法高性能创建对象比如你认为反射创建对象是一个耗时的操作，那么可以将构造函数的调用创建成一个委托，然后把这个委托缓存下来。这样，下次创建相同对象的时候就不需要反射调用构造函数了，而是直接调用委托拿到对象的新实例。private static readonly CachePool&amp;lt;Type, Func&amp;lt;object&amp;gt;&amp;gt; ConstructorCache = new CachePool&amp;lt;Type, Func&amp;lt;object&amp;gt;&amp;gt;(x =&amp;gt; Expression.Lambda&amp;lt;Func&amp;lt;object&amp;gt;&amp;gt;(Expression.New(x)).Compile());高性能为属性赋值我在 如何快速编写和调试 Emit 生成 IL 的代码 一文中创建了可以为属性赋值的委托，你也可以使用此方法将委托缓存下来，以便每次给相同类型的相同属性赋值时能有不那么差的性能。高性能“反射”调用函数调用函数所得的结果可是不一样的，所以直接缓存函数结果是不靠谱的，不过我们依然可以将反射调用缓存为委托的调用。我在 .NET Core/Framework 创建委托以大幅度提高反射调用的性能 一文中有介绍。附代码" }, { "title": ".NET/C# 使用反射调用含 ref 或 out 参数的方法", "url": "/post/handle-ref-or-out-arguments-using-reflection.html", "categories": "", "tags": "dotnet, csharp", "date": "2018-09-02 14:59:00 +0800", "snippet": "使用反射，我们可以很容易地在运行时调用一些编译时无法确定的属性、方法等。然而，如果方法的参数中包含 ref 或 out 关键字的时候，又该怎么调用呢？本文将介绍如何反射调用含 ref 或 out 关键字的方法。比如我们有这样的类型：public class Walterlv{ public string Get(string key) { }}那么反射的时候可以使用：var walterlv = new Walterlv();var value = (string) typeof(Walterlv).GetMethod(&quot;Get&quot;).Invoke(walterlv, new object[] { &quot;key&quot; });然而现在我们的函数是这样的，带一个 out 关键字的参数：public class Walterlv{ public bool TryGet(string key, out string value) { }}事实上，无论是什么样的方法，在反射式调用的都是同一个方法，即 Invoke。对于 out 和 ref 关键字的方法来说，会更新传入的数组，也就是 Invoke 最后传入的那个参数。所以其实我们只需要保存那个数组的实例，在调用完毕之后便能重新取出被修改的参数了。var walterlv = new Walterlv();var args = new object[] { &quot;key&quot;, null };var value = (string) typeof(Walterlv).GetMethod(&quot;Get&quot;).Invoke(walterlv, args);// 在这里可以从 args 里面取出被 ref 或者 out 修改的参数。参考资料 out, ref and InvokeMember !!! - CodeProject c# - How to pass a parameter as a reference with MethodInfo.Invoke - Stack Overflow" }, { "title": ".NET/C# 使用反射注册事件", "url": "/post/add-event-handler-using-reflection.html", "categories": "", "tags": "dotnet, csharp", "date": "2018-09-01 20:31:24 +0800", "snippet": "使用反射，我们可以很容易地在运行时调用一些编译时无法确定的属性、方法等。那么如何注册事件呢？本文将介绍如何使用反射注册事件。不使用反射例如，我们希望反射的类型是这样的：public class Walterlv{ public event EventHandler BlogPublished;}那么只需要使用如下代码即可完成事件的注册：var walterlv = new Walterlv();walterlv += Walterlv_BlogPublished;public void Walterlv_BlogPublished(object sender, EventHandler handler){}使用反射而如果使用反射，则是：var walterlv = new Walterlv();var eventInfo = typeof(Walterlv).GetEvent(nameof(BlogPublished));var handler = new EventHandler(Walterlv_BlogPublished);eventInfo.AddEventHandler(walterlv, handler);当然，实际使用的时候，如果能访问到 Walterlv 类型，当然也不会去用到反射，所以通常情况是这样的：public void AddHandler&amp;lt;T&amp;gt;(T instance, string eventName, EventHandler handler){ var eventInfo = instance.GetType().GetEvent(eventName); eventInfo.AddEventHandler(instance, handler);}安全地使用反射虽然以上方式使用了反射成功注册了事件，但实际上我们的参数中传入了一个特定类型的委托 EventHandler。实际上事件的委托种类非常多。在委托中，即便签名完全相同，也不是同一个委托类型。如果传入的参数类型改为 EventHandler&amp;lt;EventArgs&amp;gt;，或者 BlogPublished 事件的类型改为 EventHandler&amp;lt;EventHandler&amp;gt;，虽然实际上这两个委托的签名是兼容的，但其委托类型不同，依然是不能互相转换的。你会在运行时遇到一下异常：▲ 委托无法转换所以我们必须有一些更安全的方式来注册事件。正常情况下，我们转换一个签名兼容的委托是使用构造函数：public EventHandler ConvertDelegate(EventHandler&amp;lt;EventArgs&amp;gt; handler){ return new EventHandler(handler);}那么在反射中，我们需要使用 Delegate.CreateDelegate 创建指定类型的委托。public void AddHandler&amp;lt;T&amp;gt;(T instance, string eventName){ var eventInfo = instance.GetType().GetEvent(eventName); var methodInfo = GetType().GetMethod(nameof(Walterlv_BlogPublished)); var @delegate = Delegate.CreateDelegate(eventInfo.EventHandlerType, this, methodInfo); eventInfo.AddEventHandler(instance, @delegate);}public void Walterlv_BlogPublished(object sender, EventHandler handler){}这里，Delegate.CreateDelegate 的作用就是执行委托类型的转换。我在 .NET Core/Framework 创建委托以大幅度提高反射调用的性能 中也提到过这个方法。参考资料 c# - AddEventHandler using reflection - Stack Overflow" }, { "title": ".NET/C# 判断某个类是否是泛型类型或泛型接口的子类型", "url": "/post/is-subclass-of-raw-generic-or-implemented-raw-generic.html", "categories": "", "tags": "dotnet, csharp", "date": "2018-09-01 16:28:05 +0800", "snippet": ".NET 中提供了很多判断某个类型或实例是某个类的子类或某个接口的实现类的方法，然而这事情一旦牵扯到泛型就没那么省心了。本文将提供判断泛型接口实现或泛型类型子类的方法。.NET 中没有自带的方法对于实例，.NET 中提供了这些方法来判断：if (instance is Foo || instance is IFoo){}对于类型，.NET 中提供了这些方法来判断：if (typeof(Foo).IsAssignableFrom(type) || typeof(IFoo).IsAssignableFrom(type)){}或者，如果不用判断接口，只判断类型的话：if (type.IsSubClassOf(typeof(Foo))){}对于 typeof 关键字，不止可以写 typeof(Foo)，还可以写 typeof(Foo&amp;lt;&amp;gt;)。这可以得到泛型版本的 Foo&amp;lt;T&amp;gt; 的类型。不过，如果你试图拿这个泛型版本的 typeof(Foo&amp;lt;&amp;gt;) 执行上述所有判断，你会发现所有的 if 条件都会是 false。我们需要自己编写方法typeof(Foo&amp;lt;&amp;gt;) 和 typeof(Foo&amp;lt;SomeClass&amp;gt;) 之间的关系就是 GetGenericTypeDefinition 函数带来的关系。所以我们可以充分利用这一点完成泛型类型的判断。比如，我们要判断接口：public static bool HasImplementedRawGeneric(this Type type, Type generic){ // 遍历类型实现的所有接口，判断是否存在某个接口是泛型，且是参数中指定的原始泛型的实例。 return type.GetInterfaces().Any(x =&amp;gt; generic == (x.IsGenericType ? x.GetGenericTypeDefinition() : x));}而如果需要判断类型，那么就需要遍历此类的基类了：public static bool IsSubClassOfRawGeneric([NotNull] this Type type, [NotNull] Type generic){ if (type == null) throw new ArgumentNullException(nameof(type)); if (generic == null) throw new ArgumentNullException(nameof(generic)); while (type != null &amp;amp;&amp;amp; type != typeof(object)) { isTheRawGenericType = IsTheRawGenericType(type); if (isTheRawGenericType) return true; type = type.BaseType; } return false; bool IsTheRawGenericType(Type test) =&amp;gt; generic == (test.IsGenericType ? test.GetGenericTypeDefinition() : test);}于是，我们可以把这两个方法合成一个，用于实现类似 IsAssignableFrom 的效果，不过这回将支持原始接口（也就是 typeof(Foo&amp;lt;&amp;gt;)）。/// &amp;lt;summary&amp;gt;/// 判断指定的类型 &amp;lt;paramref name=&quot;type&quot;/&amp;gt; 是否是指定泛型类型的子类型，或实现了指定泛型接口。/// &amp;lt;/summary&amp;gt;/// &amp;lt;param name=&quot;type&quot;&amp;gt;需要测试的类型。&amp;lt;/param&amp;gt;/// &amp;lt;param name=&quot;generic&quot;&amp;gt;泛型接口类型，传入 typeof(IXxx&amp;amp;lt;&amp;amp;gt;)&amp;lt;/param&amp;gt;/// &amp;lt;returns&amp;gt;如果是泛型接口的子类型，则返回 true，否则返回 false。&amp;lt;/returns&amp;gt;public static bool HasImplementedRawGeneric([NotNull] this Type type, [NotNull] Type generic){ if (type == null) throw new ArgumentNullException(nameof(type)); if (generic == null) throw new ArgumentNullException(nameof(generic)); // 测试接口。 var isTheRawGenericType = type.GetInterfaces().Any(IsTheRawGenericType); if (isTheRawGenericType) return true; // 测试类型。 while (type != null &amp;amp;&amp;amp; type != typeof(object)) { isTheRawGenericType = IsTheRawGenericType(type); if (isTheRawGenericType) return true; type = type.BaseType; } // 没有找到任何匹配的接口或类型。 return false; // 测试某个类型是否是指定的原始接口。 bool IsTheRawGenericType(Type test) =&amp;gt; generic == (test.IsGenericType ? test.GetGenericTypeDefinition() : test);}" }, { "title": "Win32 程序在启动时激活前一个启动程序的窗口", "url": "/post/show-previous-process-instance-window-when-startup.html", "categories": "", "tags": "windows, wpf", "date": "2018-09-01 08:15:17 +0800", "snippet": "UWP 程序天生单实例。当然，新 API （10.0.17134）开始也提供了多实例功能。不过，传统 Win32 程序可就要自己来控制单实例了。本文介绍简单的几个 Win32 方法调用，使 Win32 程序也支持单实例。激活之前进程的窗口我们可以通过进程名称找到此前已经启动过的进程实例，如果发现，就激活它的窗口。[STAThread]static void Main(string[] args){ var current = Process.GetCurrentProcess(); var process = Process.GetProcessesByName(current.ProcessName).FirstOrDefault(x =&amp;gt; x.Id != current.Id); if (process != null) { var hwnd = process.MainWindowHandle; ShowWindow(hwnd, 9); return; } // 启动自己的主窗口，此部分代码省略。}[DllImport(&quot;user32.dll&quot;)]private static extern int ShowWindow(IntPtr hwnd, uint nCmdShow);你一定觉得那个 9 很奇怪，它是多个不同的 nCmdShow 的值： 0 Hide 1 Minimized 2 Maximized 9 Restore另外，找到的窗口此时可能并不处于激活状态。例如在 Windows 10 中，此窗口可能在其他桌面上。那么我们需要添加额外的代码将其显示出来。在前面的 ShowWindow 之后，再调用一下 SetForegroundWindow 即可将其激活到最前面来。如果在其他桌面，则会切换到对应的桌面。[DllImport(&quot;USER32.DLL&quot;)]public static extern bool SetForegroundWindow(IntPtr hWnd);var hwnd = process.MainWindowHandle;ShowWindow(hwnd, 9);SetForegroundWindow(hwnd);找到并激活窗口以上方法适用于普通的主窗口。然而当窗口并不是进程的主窗口，或者 ShowInTaskBar 设为了 false 的时候就不生效了（此时窗口句柄会改变）。于是，我们需要改用其他的方式来查找窗口。[STAThread]static void Main(string[] args){ var hwnd = FindWindow(null, &quot;那个窗口的标题栏文字&quot;); if (hwnd != IntPtr.Zero) { ShowWindow(hwnd, 9); return; } // 启动自己的主窗口，此部分代码省略。}[DllImport(&quot;user32.dll&quot;, CharSet = CharSet.Unicode)]public static extern IntPtr FindWindow(string lpClassName, string lpWindowName);参考资料 Controlling Window State Of Other Applications using C# c# - How to show/hide an application with Visible and ShowInTaskBar as false - Stack Overflow ShowWindowAsync function (Windows) How do I maximize/minimize applications programmatically in C#?" }, { "title": "Windows 无法删除文件夹 —— 访问被拒绝 / 因为目录不是空的", "url": "/post/delete-directory-that-is-not-empty.html", "categories": "", "tags": "windows", "date": "2018-09-01 08:14:59 +0800", "snippet": "在日常使用 Windows 10 时，有时会遇到删除很普通的文件夹时提示“访问被拒绝”，以管理员权限重试后依然提示没有权限。如果使用命令行删除，则会提示“无法删除文件夹 XXX，目录不是空的。”。本文将介绍其原因并提供解决方案。删除文件夹遭到拒绝有时我们在删除一个很普通的文件夹时，会提示需要提升权限才能删除。▲ 需要提升权限其实按照经验，这种问题与权限并没有什么关系。尤其是以上这种 NuGet 缓存目录下的文件夹，和权限更是扯不上关系。所以其实点了“继续”也并没有什么左右，依然是没完没了的错误。▲ 需要访问权限如果我 一层层进入到文件夹的里面，然后 先删除文件，再一层层 退出来删掉文件夹，那么这个文件夹就能被正常删除掉。这至少能说明，并没有文件或文件夹处于被占用的状态！！！所以这个时候我考虑使用命令行删除：▲ 使用命令行删除命令行删除时，给了一个错误提示： rd : Directory C:\\Users\\lvyi.nuget\\packages\\walterlv.package.demo\\12.0.27-alpha\\src\\Demo_\\MagicalDemo_\\Magical_ cannot be removedbecause it is not empty.意思是说，命令行在删除其中一个子文件夹的时候出错，原因是：“目录不是空的。”如果继续翻看下面的错误提示，发现这是一个按文件夹递归的提示。解决方案在网上搜索“目录不是空的”能得到不少结果，而且提供了不少解决方案： windows - Batch - Getting “The directory is not empty” on rmdir command - Stack Overflow powershell - Cannot remove item. The directory is not empty - Stack Overflow 还有更多……然而，无论敲入什么样的命令，都没有用。这时我抱着试一试的心态去搜索框（小娜）中搜索“资源监视器”或直接输入 resmon 命令打开资源监视器。在“关联的句柄”中我输入了无法删除的文件夹名称，才终于找到了根本原因：▲ 资源监视器结束掉可能用到了这个版本 NuGet 包的 Visual Studio 后，文件夹可以被正常删除掉了。▲ 因为删除太快，好不容易抓到的一张图所以什么“需要管理员权限”啊，什么“目录不是空的”，都是假的！！！真正的原因还是文件夹被占用。" }, { "title": "在操作系统重启后恢复应用程序的工作状态", "url": "/post/application-restart-manager.html", "categories": "", "tags": "csharp, windows", "date": "2018-09-01 08:13:21 +0800", "snippet": "Windows 10 创意者更新之后，默认开启了重启后恢复应用程序状态的功能。这是自 Vista 以来就提供的功能——Restart Manager。应用程序实现这一功能只需要调用 RegisterApplicationRestart 即可。传入两个参数： 重启后使用的命令行参数（例如当前正在打开的文件，以及正在阅读或编辑的位置） 决定是否进行重启的限制标记（任何时候都能重启还是在某些条件下关掉重启功能）我封装了以下这个函数的调用并将其放到 GitHub 上：sharing-demo/ApplicationRestartManager.cs at master · walterlv/sharing-demo。调用代码如下：if (ApplicationRestartManager.IsRestartManagerSupported){ ApplicationRestartManager.RegisterApplicationRestart( currentOpeningFile, ApplicationRestartFlags.None);}附：封装的 ApplicationRestartManager：using System;using System.Diagnostics.Contracts;using System.Runtime.InteropServices;using System.Windows;using Jetbrains.Annotations;namespace Walterlv.Win32{ /// &amp;lt;summary&amp;gt; /// 为应用程序提供重启后恢复状态的功能。 /// &amp;lt;/summary&amp;gt; public class ApplicationRestartManager { /// &amp;lt;summary&amp;gt; /// 获取一个值，该值指示当前操作系统环境是否支持 Restart Manager 功能。 /// Restart Manager 是 Windows Vista 新增的功能。在 Windows 10 秋季创意者更新之后，默认开启了 EWX_RESTARTAPPS。 /// &amp;lt;/summary&amp;gt; public static bool IsSupported =&amp;gt; IsSupportedLazy.Value; /// &amp;lt;summary&amp;gt; /// 向操作系统的 Restart Manager 注册应用终止后的重启方式。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;pwsCommandLine&quot;&amp;gt; /// 应用程序的重启时应该使用的参数，允许为 null，表示不带参数。 /// 请注意：如果命令行参数中的某一个参数包含空格，请加上引号。 /// &amp;lt;/param&amp;gt; /// &amp;lt;param name=&quot;dwFlags&quot;&amp;gt;为应用程序的重启行为添加限制，默认没有限制。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public static bool RegisterApplicationRestart( [CanBeNull] string pwsCommandLine, ApplicationRestartFlags dwFlags = ApplicationRestartFlags.None) { return 0 == RegisterApplicationRestart(pwsCommandLine, (int) dwFlags); } /// &amp;lt;summary&amp;gt; /// Windows Vista 及以上才开启 Restart Manager。 /// &amp;lt;/summary&amp;gt; [ContractPublicPropertyName(nameof(IsSupported))] private static readonly Lazy&amp;lt;bool&amp;gt; IsSupportedLazy = new Lazy&amp;lt;bool&amp;gt;(() =&amp;gt; Environment.OSVersion.Version &amp;gt;= new Version(6, 0)); /// &amp;lt;summary&amp;gt; /// Registers the active instance of an application for restart. /// See also: [RegisterApplicationRestart function (Windows)](https://msdn.microsoft.com/en-us/library/windows/desktop/aa373347) /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;pwzCommandline&quot;&amp;gt; /// A pointer to a Unicode string that specifies the command-line arguments for the application when it is restarted. The maximum size of the command line that you can specify is RESTART_MAX_CMD_LINE characters. Do not include the name of the executable in the command line; this function adds it for you. /// If this parameter is NULL or an empty string, the previously registered command line is removed. If the argument contains spaces, use quotes around the argument. /// &amp;lt;/param&amp;gt; /// &amp;lt;param name=&quot;dwFlags&quot;&amp;gt; /// This parameter can be 0 or one or more of the following values: /// - 1: Do not restart the process if it terminates due to an unhandled exception. /// - 2: Do not restart the process if it terminates due to the application not responding. /// - 4: Do not restart the process if it terminates due to the installation of an update. /// - 8: Do not restart the process if the computer is restarted as the result of an update. /// &amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt; /// This function returns S_OK on success or one of the following error codes. /// - E_FAIL: Internal error. /// - E_INVALIDARG: The specified command line is too long. /// &amp;lt;/returns&amp;gt; [DllImport(&quot;kernel32.dll&quot;, CharSet = CharSet.Auto)] private static extern uint RegisterApplicationRestart(string pwzCommandline, int dwFlags); } /// &amp;lt;summary&amp;gt; /// 表示重启时的限制标记。 /// &amp;lt;/summary&amp;gt; [Flags] public enum ApplicationRestartFlags { /// &amp;lt;summary&amp;gt; /// 没有重启限制。如果仅指定 &amp;lt;see cref=&quot;None&quot;/&amp;gt;，那么操作系统在可以重启应用程序的时候都会重启应用。 /// &amp;lt;/summary&amp;gt; None = 0, /// &amp;lt;summary&amp;gt; /// 指定此时不重启：因未处理的异常而导致进程停止工作。 /// &amp;lt;/summary&amp;gt; RestartNoCrash = 1, /// &amp;lt;summary&amp;gt; /// 指定此时不重启：因应用程序无响应而导致进程停止工作。 /// &amp;lt;/summary&amp;gt; RestartNoHang = 2, /// &amp;lt;summary&amp;gt; /// 指定此时不重启：因应用安装更新导致进程关闭。 /// &amp;lt;/summary&amp;gt; RestartNoPatch = 4, /// &amp;lt;summary&amp;gt; /// 指定此时不重启：因操作系统安装更新后重启导致进程关闭。 /// &amp;lt;/summary&amp;gt; RestartNoReboot = 8 }}参考资料 为何win10 1709（秋季创意更新） 重启会自动恢复一些程序为重启以前的工作状态？ - 蒋晟的回答 - 知乎 RegisterApplicationRestart function (Windows) pinvoke.net: RegisterApplicationRestart (kernel32) Restart Manager Support For Windows Application - CodeProject c# - Restart a crashed program with RegisterApplicationRestart without user prompt - Stack Overflow Vista Application Crash Recovery in C# - CodeProject c# - Restart a crashed program with RegisterApplicationRestart without user prompt - Stack Overflow" }, { "title": "为带有多种语言的 Jekyll 博客添加多语言选择", "url": "/post/multi-language-in-jekyll-blog.html", "categories": "", "tags": "site, web, html, css", "date": "2018-09-01 08:13:02 +0800", "snippet": "我有几篇博客是用多种语言编写的，一开始我是在每篇博客中添加其他语言的链接，但多语言博客多了之后就成了复制粘贴了。是时候做一个通用的布局来实现多语言博客了！本文将为大家提供一个我编写好的多语言博客选择器（MIT License）。先来看看效果。现在，请选择一个阅读语言： English русский 繁體中文 简体中文 日本語 ไทย 不要惊讶：其实这里的每一种语言都指向了你正在阅读的简体中文😜。编写一个简单的语言选择器html 里可以用 &amp;lt;select&amp;gt; 来做选择器。当然，本文只是用 &amp;lt;select&amp;gt; 当作例子，你也可以做成表格型的、链接型的或者其他更多更炫酷的样子。&amp;lt;select&amp;gt; 的最简例子（可以直接写到 markdown 里）： &amp;lt;select&amp;gt; &amp;lt;option value=&quot;/post/multi-language-in-jekyll-blog.html&quot;&amp;gt;English&amp;lt;/option&amp;gt; &amp;lt;option value=&quot;/post/multi-language-in-jekyll-blog.html&quot;&amp;gt;中文&amp;lt;/option&amp;gt;&amp;lt;/select&amp;gt; 来看看效果： English 中文然而，我们希望在点击的时候自动跳转到对应的链接。于是，我们为 select 的 onchange 事件添加处理函数： &amp;lt;select onchange=&quot;self.location.href=options[selectedIndex].value&quot;&amp;gt; &amp;lt;option value=&quot;/post/multi-language-in-jekyll-blog.html&quot;&amp;gt;English&amp;lt;/option&amp;gt; &amp;lt;option value=&quot;/post/multi-language-in-jekyll-blog.html&quot;&amp;gt;中文&amp;lt;/option&amp;gt;&amp;lt;/select&amp;gt; 再试试选择一下： English 中文这就可以生效了。引入页面配置元数据毕竟博客有多篇，终归要引入配置的。现在我们为这篇文章配置两种语言。（考虑到更通用的情况，我将一种语言定义为一种 version。） version: current: 简体中文versions: - English: /post/multi-language-in-jekyll-blog.html - 中文: /post/multi-language-in-jekyll-blog.html 这个配置是要放到博客 markdown 的元数据头里的。制作布局文件为了更加通用，我在 _include 文件夹中新建了 post-version-selector.html 的布局文件，然后在每一个需要引入语言选择器的地方加上 {% include post-version-selector.html %}。（比如本文一开始的那个语言选择器就是通过在那个地方加上了这句话生成的。）现在，我们把之前写的 select 搬到 post-version-selector.html 文件中，并引入页面中配置好的各语言路径。{%- comment -%} MIT Licensed {%- endcomment -%}{%- if page.versions -%} &amp;lt;select onchange=&quot;self.location.href=options[selectedIndex].value&quot;&amp;gt; {%- for version_hash in page.versions -%} {%- for version in version_hash -%} {%- assign key = version[0] -%} {%- assign value = version[1] -%} {%- if page.version.current == key -%} &amp;lt;option value=&quot;{{ site.baseurl }}{{ page.url }}&quot; selected=&quot;selected&quot;&amp;gt;{{ key }}&amp;lt;/option&amp;gt; {%- else -%} &amp;lt;option value=&quot;{{ value }}&quot;&amp;gt;{{ key }}&amp;lt;/option&amp;gt; {%- endif -%} {%- endfor -%} {%- endfor -%} &amp;lt;/select&amp;gt;{%- endif -%}统一解释一下： 这里使用的 liquid 语言标记中都添加了短线 -，即 {%- if condition -%}{%- endif -%}，这是为了将 liquid 语言占用的空行移除掉。 不同于原生的 html，在 markdown 中的 html 是受到空行影响的，如果 &amp;lt;select&amp;gt; 的各个 &amp;lt;option&amp;gt; 之间有空行，那么整个 select 会被 markdown 解析器活生生拆掉。 liquid 中如果要遍历 key-value 值，需要使用 for 来取出其中的 key 和 value。 就是 {%- for version in version_hash -%} 这一行，虽然有个 for，但其实只会执行一次。 参考资料 jekyll - Iterate over hashes in liquid templates - Stack Overflow How can I set the default value for an HTML &amp;lt;select&amp;gt; element? - Stack Overflow 超详细的HTML &amp;lt;select&amp;gt; 标签用法及技巧介绍_w3cschool Whitespace control – Liquid template language" }, { "title": "屏幕上那个灰色带有数字的框是什么？看着好难受！", "url": "/post/where-is-the-gray-candidate-window-come-from.html", "categories": "", "tags": "dotnet, csharp", "date": "2018-09-01 08:12:39 +0800", "snippet": "为什么屏幕上出现了一个灰框，里面有黑色数字，而且还不消失？强迫症难以忍受啊！▲ 就是这个置于所有窗口最顶层，怎么也去不掉的灰色数字框强迫症晚期请直接前往最后一节把它消灭好了，非强迫症晚期的我们一起来探究下它到底是什么。使用 Spy++想探究一个界面属于哪个进程，当然少不了 Spy++。现在，我们去 Visual Studio 中找到并打开 Spy++。于是，我们会看到一个丑的不得了的 Spy++ 的界面：紧接着，我们点击查找窗口（ ）按钮开始查找窗口：我们发现，当我们将那个瞄准靶心指向灰色小窗口上时，这个窗口的句柄和其他信息已经显示。于是，点击“确定”来查看这个窗口的信息。▲ 居然是 Visual Studio 的某个名为 CandidateWindow 的子窗口猜测和搜索现在我们得到了这些线索： 这是 Visual Studio 的窗口 这个窗口的类名叫做 CandidateWindow 这一定是 Visual Studio 的 BUG，可以被我们疯狂吐槽现在我们有了搜索关键字：Gray Box，Candidate Window，Visual Studio。搜索果然能发现有人遇到了这个问题（特别吐槽没有中文的，于是才有了本文）。有用的搜索资料见本文最后的 参考资料。解决问题从搜索的结果中，我们可以得知，这是 Visual Studio 用来在 CodeLens 上显示辅助提示的指示窗口。解决方法便是在代码编辑窗口中长按 Alt 键重新打开辅助指示窗口，然后松开 Alt 键关掉这些窗口。试一试长按 Alt 键，果然出现了一模一样的窗口：松开 Alt 后，之前一直不消失的灰色数字窗口终于消失，世界顿时清静了。Alt 指示窗口是什么？其实这是 Windows 提供的一项功能，用于在仅有键盘的设备上能够操作各种菜单。下图是在资源管理器中长按 Alt 出来的键盘按键提示，按下键盘对应的键可以进入对应的功能。参考资料 Grey box with number sticks at top left corner of screen - Developer Community number in upper-left corner of screen - Developer Community Visual Studio leaving numbers in tooltips on desktop - Developer Community visual studio 2012 puts a small number in the top left corner of my screen - Stack Overflow" }, { "title": "（C#）if (this == null)？你在逗我，this 怎么可能为 null！用 IL 编译和反编译看穿一切", "url": "/post/this-could-be-null.html", "categories": "", "tags": "dotnet, msil", "date": "2018-09-01 08:12:18 +0800", "snippet": "if (this == null) Console.WriteLine(&quot;this is null&quot;); 这句话一写，大家一定觉得荒谬，然而 if 内代码的执行却是可能的！本文讲介绍到底发生了什么。制造一个 this 可以为 null 的程序请看代码，这是我们的库函数：namespace Walterlv.Demo{ public class Foo { public void Test() { if (this == null) Console.WriteLine(&quot;this is null&quot;); else Console.WriteLine(&quot;this is not null&quot;); } }}外面是这样调用的：namespace Walterlv.Demo{ public class Program { private static void Main() { Foo p = null; p.Test(); } }}这代码写出来，当然毫不犹豫地说——这会发生 NullReferenceException！然而……现在我们改一改 Program 的 IL：将关注重点放在图中红框标注的部分，那是调用 p.Test 的地方。现在，我们将它从 callvirt 修改成 call。第一步：反编译 exe 成 IL： # ildasm 在 C:\\Program Files (x86)\\Microsoft SDKs\\Windows\\v10.0A\\bin\\NETFX 4.7.1 Tools\\x64 路径下ildasm /out=D:\\Desktop\\wdemo.il D:\\Desktop\\Walterlv.Demo\\wdemo\\bin\\Debug\\wdemo.exe 第二步：修改 IL，将 callvirt 修改成 call IL_0004: call instance void Walterlv.Demo.Foo::Test() 第三步：重新编译 IL 成 exe # ilasm 在 C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319 路径下lvyi&amp;gt; ilasm /out:D:\\Desktop\\wdemo.exe D:\\Desktop\\wdemo.ilMicrosoft (R) .NET Framework IL Assembler. Version 4.7.2556.0Copyright (c) Microsoft Corporation. All rights reserved.Assembling &#39;D:\\Desktop\\wdemo.il&#39; to EXE --&amp;gt; &#39;D:\\Desktop\\wdemo.exe&#39;Source file is ANSIAssembled method Walterlv.Demo.Program::MainAssembled method Walterlv.Demo.Program::.ctorAssembled method Walterlv.Demo.Foo::TestAssembled method Walterlv.Demo.Foo::.ctorCreating PE fileEmitting classes:Class 1: Walterlv.Demo.ProgramClass 2: Walterlv.Demo.FooEmitting fields and methods:GlobalClass 1 Methods: 2;Class 2 Methods: 2;Resolving local member refs: 1 -&amp;gt; 1 defs, 0 refs, 0 unresolvedEmitting events and properties:GlobalClass 1Class 2Resolving local member refs: 0 -&amp;gt; 0 defs, 0 refs, 0 unresolvedWriting PE fileOperation completed successfully 结果，现在再执行程序时，输出是 this is null：为什么此时 this 是 null从名字上看，call 是为了调用非虚方法、静态方法或者基类方法的；而 callvirt 是为了调用虚方法的。前者在编译时就将确认调用了某个类的某个方法，而后者将在运行时动态决定应该调用哪个。然而，当 IL 试图调用某个变量实例的一个方法时，由于不确定这个变量到底是不是实际的类型（还是基类型），所以都采用 callvirt 进行调用。call 在编译时就已确定调用，所以也没有加入 null 的判断；callvirt 却需要，因为通常都是实例使用。于是，此次便出现了 null.Test() 这样诡异的调用。一些建议和总结虽然我们制造出了一个 this 可能为 null 的情况，即便库和调用方是分开开发的，但实际开发中其实并不需要考虑这样的问题。参考资料 Easy way to modify IL code – I know the answer (it’s 42) .net - Call and Callvirt - Stack Overflow Observing a null this value" }, { "title": "使用 GitVersion 在编译或持续构建时自动使用语义版本号（Semantic Versioning）", "url": "/post/automatically-semantic-versioning-using-git-version-task.html", "categories": "", "tags": "visualstudio, nuget, csharp, dotnet", "date": "2018-09-01 08:11:50 +0800", "snippet": "我们在之前谈过 语义版本号（Semantic Versioning），在项目中应用语义版本号能够帮助库的开发者在发布包时表明更多的语义信息。这是趋势，从微软的博客 Versioning NuGet packages in a continuous delivery world 三部曲中可以看出，从 NuGet 4.3.0 以及 Visual Studio 2017 15.3 以上版本开始支持语义版本号 2.0 也能看出。本文将从持续集成的角度来说语义版本号，告诉大家如何自动生成包含语义的版本号，并在发布库时采用。This post is written in multiple languages. Please select yours: 中文 English 安装 GitVersionTask微软工程师在博客 Versioning NuGet packages in a continuous delivery world: part 3 – Microsoft DevOps Blog 中推荐的语义版本号生成工具是 GitVersion。从实际寻找来看，这似乎也是唯一一个能够让 NuGet 包支持语义版本号的工具。去 NuGet.org 上为我们的库项目安装 GitVersionTask 即可开始我们的语义版本号。请特别注意： 目前只有 GitVersionTask 4.0 以上的版本（目前都是 beta）才支持 .NET Core 那样新格式的 csproj。 目前即便是最新测试版的 GitVersionTask 也不支持使用基于 .NET Core 的 dotnet build 编译，原因和解决方案我已经提交给 GitTools 团队了（详见：dotnet build command always fails with GitVersionTask 4.0.0-beta · Issue #1399 · GitTools/GitVersion），临时方案是使用 .NET Framework 版本的 msbuild。配置 GitVersion特别吐槽一下 GitVersion 的官方文档，把功能堆积得很多很强大，却忽视了面向新手的入门教程。GitVersion 的配置文件名为 GitVersion.yml，要求放到仓库的根目录下。官方文档对于配置文件的解释非常抽象，看完也不知道值应该写成什么样，也不知道每个值代表什么意义。于是我基本上是通过阅读它的源码来了解配置文件的实际含义的。经过一番折腾，我把配置文件改成了下面这样。next-version: 1.0mode: ContinuousDeliveryincrement: Inherittag-prefix: &#39;[vV]&#39;source-branches: [&#39;master&#39;, &#39;develop&#39;, &#39;hotfix&#39;]ignore: sha: [] commits-before: 2018-01-01T00:00:00branches: master: regex: master$ mode: ContinuousDelivery tag: &#39;&#39; increment: Patch prevent-increment-of-merged-branch-version: true track-merge-target: false tracks-release-branches: false is-release-branch: true release: regex: r(elease$|(eleases)?[-/]) mode: ContinuousDelivery tag: beta increment: Patch prevent-increment-of-merged-branch-version: true track-merge-target: false tracks-release-branches: false is-release-branch: true feature: regex: f(eatures)?[-/] mode: ContinuousDeployment tag: alpha increment: Minor prevent-increment-of-merged-branch-version: false track-merge-target: false tracks-release-branches: false is-release-branch: false▲ 别看这配置文件写得这么长，但其实官方的默认配置文件更长！好了不开玩笑了，这配置文件分两部分来看：1. branches 之前；2. branches 之后。写在 branches 之前的为全局配置，写在 branches 之后的是按分支分类的配置；它们的配置键值其实都是一样的。分支里的配置优先级高于全局配置。也就是说，如果编译打包的分支名能被 regex 正则表达式匹配上，那么就使用匹配的分支配置，否则使用全局配置。举例，假设我们现在的版本库是这样的：分支名称匹配 regex那么当我们在 release 分支的 f 提交上编译，使用的配置将是 release 分支的配置。由于我将 release 分支的正则表达式写成了 r(elease$|(eleases)?[-/])（注意，我们不需要加行首标记 ^，因为 GitVersionTask 里会为我们在最前面加一个），所以类似这样的分支名也是使用 release 分支的配置： r/1.2.0 releases/1.2.0 release但是，这样的分支名将采用默认的全局配置（因为不符合正则表达式）： r releases以上配置中我只列举了三组分支，但其实在 一个成功的 Git 分支流模型 中，还有 hotfix develop 这样更多的分支。如果你的项目足够大，建议自己参考其他分支写出这两个分支的配置出来。预发布标签 tag我们的 release 配置中，会为版本号加一个 beta 预发布标签，所以可能打出 2.0.0-beta 这样的包出来，或者 2.0.0-beta+3。但在全局配置下，默认打出的包会加一个以分支名命名的预发布标签；像这样 2.0.0-r（在 r 分支），或者 2.0.0-temp-walterlv-custombranch（在 temp/walterlv/custombranch 分支）。继续看以上的配置，在 f/blog 或 features/new 分支上将采用 alpha 预发布标签。我们在 master 分支的配置上版本号递增规则 incrementincrement 这一项的可选值有 Major、Minor、Patch、None 和 Inherit 五种。 Major 如果此前在 Git 仓库此分支前有一个 1.2.0 的 Tag，那么现在将打出 2.0.0 的包来（无论此分支当前距离那个 Tag 有多少个提交，都只加 1） Minor 如果此前在 Git 仓库此分支前有一个 1.2.0 的 Tag，那么现在将打出 1.3.0 的包来（无论此分支当前距离那个 Tag 有多少个提交，都只加 1） Patch 如果此前在 Git 仓库此分支前有一个 1.2.0 的 Tag，那么现在将打出 1.2.1 的包来（无论此分支当前距离那个 Tag 有多少个提交，都只加 1） None 如果此前在 Git 仓库此分支前有一个 1.2.0 的 Tag，那么现在将打出 1.2.0 的包来 Inherit 如果此分支上没有发现能够确认版本号的线索（例如一个 Tag），那么将自动寻找此分支的来源分支，继承来源分支的版本号递增规则。注意我在全局配置中加了一个 source-branches 配置，用于指定如果要自动寻找来源分支，请去这个集合中指定的分支名称里找。下图是 release 分支上打包的版本号。版本号递增的方式 modemode 可选的值有三种： continuous-delivery 持续交付，临近产品发布时使用，详细信息可阅读Continous delivery - GitVersion continuous-deployment 持续部署，日常使用，详细信息可阅读Continuous deployment - GitVersion Mainline 传统的（官方文档没有说明，代码中没有注释，但阅读代码发现其策略是从上一个 Tag 递增版本号）语义版本号使用教程在了解了以上的配置之后，使用 GitVersionTask 才不会显得版本号的规则诡异。我们从简单的使用开始，逐步向难演进。学习规则为：单个 master 分支 -&amp;gt; Git 分支流与预发布版本单个 master 分支如果我们只在 master 上开发，那么上手就非常容易了。如果我们刚开始接触 GitVersionTask，那么我们在上一个发布包的提交上新建一个标签（Tag），命名为 v1.2.0，那么此标签之后的版本号打包将自动变为 1.2.1。Git 提交每次增多，那么构建号将加 1。下图中的版本号是 1.2.1+3。（注意：加号是语义版本号 2.0 的新特性，重申需要 NuGet 4.3.0 以及 Visual Studio 2017 15.3 以上版本。）Git 分支流与预发布版本当使用 Git 分支流时，版本号的递增方式其实与前面配置章节和单个 master 章节讲的时一致的。如下图。但是，我们需要学习如何充分利用这样的分支流，以便让语义版本号充分发挥它的作用。假设：我们最近发布了 1.1.0 正式版。 如果我们正在为库添加新功能，则新建一个 feature 分支，一直开发，直到认为开发完毕（功能实现完成，单元测试全绿） 如果此时有打包需求临时内测，则直接在 feature 分支打包，这样能打出 1.2.0-alpha 的包（后面的 + 取决于相对于此前发布多了多少个提交） 如果内测差不多了，则合并到 develop 分支确认这个内侧包 如果准备发布这个功能了，那么从 develop 分到 release 分支 这时如果有打包需求，则应该在打包之前新建一个标签（Tag）v1.2-beta，这样能打出 1.2 的 beta 包（而不是 1.1 的） 如果在此 beta 的基础上出现持续打包，那么需要持续新建标签（因为自动新建的标签只会增加一次 Patch 号） 如果确认可正式发布，则 release 合并到 master，新建 v1.2 标签参考资料 Versioning NuGet packages in a continuous delivery world: part 1 – Microsoft DevOps Blog Versioning NuGet packages in a continuous delivery world: part 2 – Microsoft DevOps Blog Versioning NuGet packages in a continuous delivery world: part 3 – Microsoft DevOps Blog C#/.NET - How to generate and increase package version automatically especially via CI? - Stack Overflow GitTools/GitVersion: Easy Semantic Versioning (http://semver.org) for projects using Git GitVersion Gitversion Task for VS2017-style csproj · Issue #1349 · GitTools/GitVersion Change Assembly Version - Jenkins - Jenkins Wiki Not working in .NET Core v2.0 project · Issue #15 · jeffkl/RoslynCodeTaskFactory NuGet Gallery - RoslynCodeTaskFactory 1.2.1 dotnet build command always fails with GitVersionTask 4.0.0-beta · Issue #1399 · GitTools/GitVersion .NET Core MSBuild cannot load tasks built against MSBuild 4.0 · Issue #2111 · Microsoft/msbuild Should the SDK include Microsoft.Build.Utilities.v4.0? · Issue #1870 · dotnet/sdk" }, { "title": "Automatically increase the semantic version using GitVersion", "url": "/post/automatically-semantic-versioning-using-git-version-task.en.html", "categories": "", "tags": "visualstudio, nuget, csharp, dotnet", "date": "2018-09-01 08:11:36 +0800", "snippet": "I wrote another post talking about Semantic Versioning before (but it is not in English). Introducing the semantic version to a project can give library users more semantic information when library developers publishing packages. From the Microsoft blog Versioning NuGet packages in a continuous delivery world we could find that semantic versioning is the trend.This article will refer to the semantic versioning from the perspective of continuous integration, telling you how to automatically generate a version that contains semantic, and use it when publishing the library.This post is written in multiple languages. Please select yours: 中文 English Install the GitVersionTaskA Microsoft engineer recommend a semantic versioning tools named GitVersion on his blog Versioning NuGet packages in a continuous delivery world: part 3 – Microsoft DevOps Blog. I tried to find more tools but unfortunately the GitVersion seems to be the only one that can add semantic version to a nuget package.Go to NuGet.org to install GitVersionTask for our library project and then we will start our semantic versioning.Attention: Only GitVersionTask 4.0 or later (currently beta) supports new csproj format which is introduced from .NET Core. Currently even the latest beta version of GitVersionTask does not support the .NET Core-based compilation - dotnet build. I’ve submitted an issue to the GitTools team to explain the reason and the solution. (see: dotnet build command always fails with GitVersionTask 4.0.0-beta · Issue #1399 · GitTools/GitVersion) The temporary fallback is to use a full .NET Framework version - msbuild.GitVersion ConfigurationGitVersion official documentation is not easy to read. I cannot find even detailed meaning of each configuration keys and values. But I read it’s source code, and these are the meanings below.next-version: 1.0mode: ContinuousDeliveryincrement: Inherittag-prefix: &#39;[vV]&#39;source-branches: [&#39;master&#39;, &#39;develop&#39;, &#39;hotfix&#39;]ignore: sha: [] commits-before: 2018-01-01T00:00:00branches: master: regex: master$ mode: ContinuousDelivery tag: &#39;&#39; increment: Patch prevent-increment-of-merged-branch-version: true track-merge-target: false tracks-release-branches: false is-release-branch: true release: regex: r(elease$|(eleases)?[-/]) mode: ContinuousDelivery tag: beta increment: Patch prevent-increment-of-merged-branch-version: true track-merge-target: false tracks-release-branches: false is-release-branch: true feature: regex: f(eatures)?[-/] mode: ContinuousDeployment tag: alpha increment: Minor prevent-increment-of-merged-branch-version: false track-merge-target: false tracks-release-branches: false is-release-branch: false▲ It’s long, but the official one is longer.// TODO: Translation is interrupted and I’ll translate below later.好了不开玩笑了，这配置文件分两部分来看：1. branches 之前；2. branches 之后。写在 branches 之前的为全局配置，写在 branches 之后的是按分支分类的配置；它们的配置键值其实都是一样的。分支里的配置优先级高于全局配置。也就是说，如果编译打包的分支名能被 regex 正则表达式匹配上，那么就使用匹配的分支配置，否则使用全局配置。举例，假设我们现在的版本库是这样的：分支名称匹配 regex那么当我们在 release 分支的 f 提交上编译，使用的配置将是 release 分支的配置。由于我将 release 分支的正则表达式写成了 r(elease$|(eleases)?[-/])（注意，我们不需要加行首标记 ^，因为 GitVersionTask 里会为我们在最前面加一个），所以类似这样的分支名也是使用 release 分支的配置： r/1.2.0 releases/1.2.0 release但是，这样的分支名将采用默认的全局配置（因为不符合正则表达式）： r releases以上配置中我只列举了三组分支，但其实在 一个成功的 Git 分支流模型 中，还有 hotfix develop 这样更多的分支。如果你的项目足够大，建议自己参考其他分支写出这两个分支的配置出来。预发布标签 tag我们的 release 配置中，会为版本号加一个 beta 预发布标签，所以可能打出 2.0.0-beta 这样的包出来，或者 2.0.0-beta+3。但在全局配置下，默认打出的包会加一个以分支名命名的预发布标签；像这样 2.0.0-r（在 r 分支），或者 2.0.0-temp-walterlv-custombranch（在 temp/walterlv/custombranch 分支）。继续看以上的配置，在 f/blog 或 features/new 分支上将采用 alpha 预发布标签。我们在 master 分支的配置上版本号递增规则 incrementincrement 这一项的可选值有 Major、Minor、Patch、None 和 Inherit 五种。 Major 如果此前在 Git 仓库此分支前有一个 1.2.0 的 Tag，那么现在将打出 2.0.0 的包来（无论此分支当前距离那个 Tag 有多少个提交，都只加 1） Minor 如果此前在 Git 仓库此分支前有一个 1.2.0 的 Tag，那么现在将打出 1.3.0 的包来（无论此分支当前距离那个 Tag 有多少个提交，都只加 1） Patch 如果此前在 Git 仓库此分支前有一个 1.2.0 的 Tag，那么现在将打出 1.2.1 的包来（无论此分支当前距离那个 Tag 有多少个提交，都只加 1） None 如果此前在 Git 仓库此分支前有一个 1.2.0 的 Tag，那么现在将打出 1.2.0 的包来 Inherit 如果此分支上没有发现能够确认版本号的线索（例如一个 Tag），那么将自动寻找此分支的来源分支，继承来源分支的版本号递增规则。注意我在全局配置中加了一个 source-branches 配置，用于指定如果要自动寻找来源分支，请去这个集合中指定的分支名称里找。下图是 release 分支上打包的版本号。版本号递增的方式 modemode 可选的值有三种： continuous-delivery 持续交付，临近产品发布时使用，详细信息可阅读Continous delivery - GitVersion continuous-deployment 持续部署，日常使用，详细信息可阅读Continuous deployment - GitVersion Mainline 传统的（官方文档没有说明，代码中没有注释，但阅读代码发现其策略是从上一个 Tag 递增版本号）语义版本号使用教程在了解了以上的配置之后，使用 GitVersionTask 才不会显得版本号的规则诡异。我们从简单的使用开始，逐步向难演进。学习规则为：单个 master 分支 -&amp;gt; Git 分支流与预发布版本单个 master 分支如果我们只在 master 上开发，那么上手就非常容易了。如果我们刚开始接触 GitVersionTask，那么我们在上一个发布包的提交上新建一个标签（Tag），命名为 v1.2.0，那么此标签之后的版本号打包将自动变为 1.2.1。Git 提交每次增多，那么构建号将加 1。下图中的版本号是 1.2.1+3。（注意：加号是语义版本号 2.0 的新特性，重申需要 NuGet 4.3.0 以及 Visual Studio 2017 15.3 以上版本。）Git 分支流与预发布版本当使用 Git 分支流时，版本号的递增方式其实与前面配置章节和单个 master 章节讲的时一致的。如下图。但是，我们需要学习如何充分利用这样的分支流，以便让语义版本号充分发挥它的作用。假设：我们最近发布了 1.1.0 正式版。 如果我们正在为库添加新功能，则新建一个 feature 分支，一直开发，直到认为开发完毕（功能实现完成，单元测试全绿） 如果此时有打包需求临时内测，则直接在 feature 分支打包，这样能打出 1.2.0-alpha 的包（后面的 + 取决于相对于此前发布多了多少个提交） 如果内测差不多了，则合并到 develop 分支确认这个内侧包 如果准备发布这个功能了，那么从 develop 分到 release 分支 这时如果有打包需求，则应该在打包之前新建一个标签（Tag）v1.2-beta，这样能打出 1.2 的 beta 包（而不是 1.1 的） 如果在此 beta 的基础上出现持续打包，那么需要持续新建标签（因为自动新建的标签只会增加一次 Patch 号） 如果确认可正式发布，则 release 合并到 master，新建 v1.2 标签References Versioning NuGet packages in a continuous delivery world: part 1 – Microsoft DevOps Blog Versioning NuGet packages in a continuous delivery world: part 2 – Microsoft DevOps Blog Versioning NuGet packages in a continuous delivery world: part 3 – Microsoft DevOps Blog C#/.NET - How to generate and increase package version automatically especially via CI? - Stack Overflow GitTools/GitVersion: Easy Semantic Versioning (http://semver.org) for projects using Git GitVersion Gitversion Task for VS2017-style csproj · Issue #1349 · GitTools/GitVersion Change Assembly Version - Jenkins - Jenkins Wiki Not working in .NET Core v2.0 project · Issue #15 · jeffkl/RoslynCodeTaskFactory NuGet Gallery - RoslynCodeTaskFactory 1.2.1 dotnet build command always fails with GitVersionTask 4.0.0-beta · Issue #1399 · GitTools/GitVersion .NET Core MSBuild cannot load tasks built against MSBuild 4.0 · Issue #2111 · Microsoft/msbuild Should the SDK include Microsoft.Build.Utilities.v4.0? · Issue #1870 · dotnet/sdk" }, { "title": "使用 Emit 生成 IL 代码", "url": "/post/generate-il-using-emit.html", "categories": "", "tags": "dotnet, csharp", "date": "2018-09-01 08:11:23 +0800", "snippet": ".NET Core/.NET Framework 的 System.Reflection.Emit 命名空间为我们提供了动态生成 IL 代码的能力。利用这项能力，我们能够在运行时生成一段代码/一个方法/一个类/一个程序集。本文将介绍使用 Emit 生成 IL 代码的方法，以及在此过程中可能遇到的各种问题。在编写以下代码时如果遇到一些意料之外的错误，希望调试生成的 IL 代码，可以尝试阅读 如何快速编写和调试 Emit 生成 IL 的代码 了解如何调试和解决。用 Emit 生成 IL 代码时，很多我们写 C# 时不会注意到的问题现在都需要开始留意。在阅读本文之前，希望统一一个平时可能不太留意的英文： 形参：parameter 实参：argument如果不了解它们之间的区别，请自行搜索。定义方法签名在 IL 中，方法名称可以使用比 C# 更多的字符，例如“&amp;lt;”和“&amp;gt;”，这也是 C# 编译闭包时喜欢使用的字符。目前我还没有找到 IL 中哪些字符可以作为标识符名称，但从混淆工具来看，是比 C# 多得多的。如果你试图生成实例方法，那么实例本身 this 将成为第一个参数，不过并不需要额外将它定义到参数列表中。当然，如果是静态方法，我们能够自己指定一个 this 参数，不过没有实际的意义。var method = new DynamicMethod(&quot;&amp;lt;MethodName&amp;gt;&quot;, typeof(void), new[] { typeof(object), typeof(object) });method.DefineParameter(1, ParameterAttributes.None, &quot;this&quot;);method.DefineParameter(2, ParameterAttributes.None, &quot;value&quot;);如果不声明形参，那么生成的 IL 代码的函数将无法被正常调用（提示可能造成运行时的不稳定）。声明和初始化局部变量平时写 C# 的时候，可能一个方法里面没有定义任何一个局部变量，但 IL 可不一定这么认为。例如：int a = 0;if (value.GetType() == typeof(string)){}else{}实际上，在 IL 中，除了 Int32 类型的 a 之外，还会额外定义一个 bool 类型的局部变量 V_1。在 value.GetType() == typeof(string) 执行完后，其值将存入 V_1。所以，如果需要编写 Emit 生成代码的代码，需要注意这些隐式产生的局部变量，它们需要和普通变量一样被初始化。Emit 代码为：// 这就声明了两个局部变量。il.DeclareLocal(typeof(int));il.DeclareLocal(typeof(bool));定义标签如果代码中存在非线性结构，例如 if-else，那么 IL 就需要知道跳转的地址。那么如何能够知道跳转到哪个地址呢？——使用标签。对 if-else 来说，if 操作需要知道 else 的起始地址；对于 if 内部的结尾来说，需要知道整个 if-else 结束之后的第一个操作的地址。var startOfElse = il.DefineLabel();var endOfWholeIfElse = il.DefineLabel();il.Emit(OpCodes.Nop);// 其他生成代码。// 如果 if 条件不满足，跳转到 startOfElse。il.Emit(OpCodes.Brfalse_S, startOfElse);// 其他生成代码。// 在 if 结束之后，跳转到 endOfWholeIfElse 地址。il.Emit(OpCodes.Br_S, endOfWholeIfElse);// 其他生成代码。// 假设这里到了 else 的开头了，于是将 startOfElse 进行标记。标记完紧跟着写 else 部分的代码。il.MarkLabel(startOfElse);il.Emit(OpCodes.Nop);// 其他生成代码。// 假设这里整个 if-else 结束了，于是将 endOfWholeIfElse 进行标记。il.MarkLabel(endOfWholeIfElse);参考资料 生成方法签名与元数据 ParameterBuilder Class (System.Reflection.Emit) MethodBuilder.DefineParameter Method (Int32, ParameterAttributes, String) (System.Reflection.Emit) Defining a Parameter with Reflection Emit c# - How to set “.maxstack” with ILGenerator - Stack Overflow 生成方法体 ILGenerator.DefineLabel Method (System.Reflection.Emit) ILGenerator.MarkLabel Method (Label) (System.Reflection.Emit) c# - Emit local variable and assign a value to it - Stack Overflow C# reflection: If … else? - Stack Overflow " }, { "title": "让你编写的控件库在 XAML 中有一个统一的漂亮的命名空间（xmlns）和命名空间前缀", "url": "/post/define-xmlns-of-for-xaml.html", "categories": "", "tags": "dotnet, xaml, wpf", "date": "2018-09-01 08:04:53 +0800", "snippet": "在 WPF XAML 中使用自己定义的控件时，想必大家都能在 XAML 中编写出这个控件的命名空间了。然而——我写不出来，除非借助 ReSharper。如果控件能够有一个漂亮的命名空间和命名空间前缀呢？——好吧，还是写不出来，不过，至少漂亮些。本文将指导你自定义在 XAML 中使用的命名空间。达到什么样的效果？&amp;lt;UserControl x:Class=&quot;HuyaHearhira.UserControl1&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:w=&quot;http://walterlv.github.io/demo&quot; &amp;lt;Grid&amp;gt; &amp;lt;w:DemoPage /&amp;gt; &amp;lt;/Grid&amp;gt;&amp;lt;/UserControl&amp;gt;注意到 DemoPage 所在的命名空间了吗？是 http://walterlv.github.io/demo 哦。而且，命名空间前缀是 w。这是不是比下面这种看得清爽多了呢？&amp;lt;UserControl x:Class=&quot;HuyaHearhira.UserControl1&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:newCsprojDemo=&quot;clr-namespace:Walterlv.NewCsprojDemo;assembly=Walterlv.NewCsprojDemo&quot;&amp;gt; &amp;lt;Grid&amp;gt; &amp;lt;newCsprojDemo:DemoPage /&amp;gt; &amp;lt;/Grid&amp;gt;&amp;lt;/UserControl&amp;gt;当然，好处不止是更清爽，还有更多，总结起来是这三个： 利于 API 的升级 例如你写了一个库提供了一些可以在 XAML 中使用的控件，但是后来随着功能的强大你把程序集拆分成了多个。这时，如果没有这样的命名空间定义，那就意味着使用你的库的大量开发者需要手工修改 XAML 中的命名空间前缀定义。而使用了这样的命名空间定义的方法后，开发者只需要重新编译一遍即可。 简化命名空间前缀 如果你的库有多个命名空间下都提供控件，那么可以使用命名空间定义将这些 C#/.NET 命名空间都映射到同一个 url 下，使得 XAML 中的命名空间声明可以更少。 更加清晰的命名空间声明 可以通过将命名空间前缀定义得更加清晰，更有效地利用每一个字符，而不是一些结构化的 clr-namespace 和 assembly。这是怎么做到的呢？在 System.Windows.Markup 命名空间下，有两个程序集级别的 Attribute，分别是 XmlnsDefinition 和 XmlnsPrefix。XmlnsDefinition 定义某个 C# 命名空间和一段命名空间字符串是等意的，XmlnsPrefix 定义此命名空间的默认前缀（只是默认而已）。using System.Windows.Markup;[assembly: XmlnsDefinition(&quot;http://walterlv.github.io/demo&quot;, &quot;Walterlv.NewCsprojDemo&quot;)][assembly: XmlnsPrefix(&quot;http://walterlv.github.io/demo&quot;, &quot;w&quot;)]于是，利用这两个 Attribute 能够达到本文一开始的奇妙的效果。如果你用工具（例如 ReSharper）自动生成命名空间前缀时，才会使用这样默认的命名空间前缀，否则，你随便填。还有什么更高级的玩法吗？也许你注意到 WPF 有一些一开始就帮你生成好的命名空间前缀，例如这些：&amp;lt;UserControl xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot;&amp;gt;&amp;lt;/UserControl&amp;gt;如果我们也把命名空间定义到这里会如何呢？[assembly: XmlnsDefinition(&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;, &quot;Walterlv.NewCsprojDemo&quot;)]哇，我们竟然可以不用带前缀啦！&amp;lt;UserControl x:Class=&quot;HuyaHearhira.UserControl1&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;&amp;gt; &amp;lt;Grid&amp;gt; &amp;lt;DemoPage /&amp;gt; &amp;lt;/Grid&amp;gt;&amp;lt;/UserControl&amp;gt;这在项目内为一些几乎侵染全部代码的标记扩展是很棒的一波语法糖。例如——自己实现的本地化标记扩展。一些限制值得注意的是，XAML 命名空间的定义只会在外部程序集生效。这是说，如果你在 A 程序集中定义了命名空间，那么只有引用了 A 程序集的 B 或者 C 才可以使用到新定义的命名空间；A 程序集自身是没有办法使用此命名空间的。参考资料 wpf - How to make XmlnsDefinition work on the local assembly? - Stack Overflow XmlnsDefinition doesn’t work in the same assembly" }, { "title": "如何在 .NET 库的代码中判断当前程序运行在 Debug 下还是 Release 下", "url": "/post/check-running-in-debug-or-release-in-a-library.html", "categories": "", "tags": "dotnet", "date": "2018-09-01 08:00:29 +0800", "snippet": "我们经常会使用条件编译符 #if DEBUG 在 Debug 下执行某些特殊代码。但是一旦我们把代码打包成 dll，然后发布给其他小伙伴使用的时候，这样的判断就失效了，因为发布的库是 Release 配置的；那些 #if DEBUG 的代码根本都不会编译进库中。然而总有时候希望在库中也能得知程序是 Debug 还是 Release，以便库发布之后也能在 Debug 下多做一些检查。那么有办法得知使用此库的程序是 Debug 配置还是 Release 配置下编译的呢？本文将介绍一个比较靠谱的方法（适用于 .NET Standard）。先上代码using System;using System.Diagnostics;using System.Linq;using System.Reflection;namespace Walterlv.ComponentModel{ /// &amp;lt;summary&amp;gt; /// 包含在运行时判断编译器编译配置中调试信息相关的属性。 /// &amp;lt;/summary&amp;gt; public static class DebuggingProperties { /// &amp;lt;summary&amp;gt; /// 检查当前正在运行的主程序是否是在 Debug 配置下编译生成的。 /// &amp;lt;/summary&amp;gt; public static bool IsDebug { get { if (_isDebugMode == null) { var assembly = Assembly.GetEntryAssembly(); if (assembly == null) { // 由于调用 GetFrames 的 StackTrace 实例没有跳过任何帧，所以 GetFrames() 一定不为 null。 assembly = new StackTrace().GetFrames().Last().GetMethod().Module.Assembly; } var debuggableAttribute = assembly.GetCustomAttribute&amp;lt;DebuggableAttribute&amp;gt;(); _isDebugMode = debuggableAttribute.DebuggingFlags .HasFlag(DebuggableAttribute.DebuggingModes.EnableEditAndContinue); } return _isDebugMode.Value; } } private static bool? _isDebugMode; }}再解释原理发现特性所有 .NET 开发者都应该知道我们编译程序时有 Debug 配置和 Release 配置，具体来说是项目文件中一个名为 &amp;lt;Configuration&amp;gt; 的节点记录的字符串。使用 Debug 编译后的程序和 Release 相比有哪些可以检测到的不同呢？我反编译了我的一个程序集。.NET Core 程序集，Debug 编译：[assembly: AssemblyVersion(&quot;1.0.0.0&quot;)][assembly: CompilationRelaxations(8)][assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)][assembly: Debuggable(DebuggableAttribute.DebuggingModes.Default | DebuggableAttribute.DebuggingModes.DisableOptimizations | DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints | DebuggableAttribute.DebuggingModes.EnableEditAndContinue)][assembly: AssemblyCompany(&quot;Walterlv.Demo&quot;)][assembly: AssemblyConfiguration(&quot;Debug&quot;)][assembly: AssemblyFileVersion(&quot;1.0.0.0&quot;)][assembly: AssemblyInformationalVersion(&quot;1.0.0&quot;)][assembly: AssemblyProduct(&quot;Walterlv.Demo&quot;)][assembly: AssemblyTitle(&quot;Walterlv.Demo&quot;)].NET Core 程序集，Release 编译：[assembly: AssemblyVersion(&quot;1.0.0.0&quot;)][assembly: CompilationRelaxations(8)][assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)][assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)][assembly: AssemblyCompany(&quot;Walterlv.Demo&quot;)][assembly: AssemblyConfiguration(&quot;Release&quot;)][assembly: AssemblyFileVersion(&quot;1.0.0.0&quot;)][assembly: AssemblyInformationalVersion(&quot;1.0.0&quot;)][assembly: AssemblyProduct(&quot;Walterlv.Demo&quot;)][assembly: AssemblyTitle(&quot;Walterlv.Demo&quot;)]发现一个很棒的特性 AssemblyConfiguration，直接写明了当前是 Debug 还是 Release 编译的。你以为这就完成了？我们再来看看 .NET Framework 下面的情况。.NET Framework 程序集，Debug 编译：[assembly: AssemblyVersion(&quot;1.0.0.0&quot;)][assembly: CompilationRelaxations(8)][assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)][assembly: Debuggable(DebuggableAttribute.DebuggingModes.Default | DebuggableAttribute.DebuggingModes.DisableOptimizations | DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints | DebuggableAttribute.DebuggingModes.EnableEditAndContinue)][assembly: AssemblyTitle(&quot;Walterlv.Demo&quot;)][assembly: AssemblyDescription(&quot;&quot;)][assembly: AssemblyConfiguration(&quot;&quot;)][assembly: AssemblyCompany(&quot;&quot;)][assembly: AssemblyProduct(&quot;Walterlv.Demo&quot;)][assembly: AssemblyCopyright(&quot;Copyright © walterlv 2018&quot;)][assembly: AssemblyTrademark(&quot;&quot;)][assembly: ComVisible(false)][assembly: AssemblyFileVersion(&quot;1.0.0.0&quot;)][assembly: TargetFramework(&quot;.NETFramework,Version=v4.7&quot;, FrameworkDisplayName = &quot;.NET Framework 4.7&quot;)].NET Framework 程序集，Release 编译：[assembly: AssemblyVersion(&quot;1.0.0.0&quot;)][assembly: CompilationRelaxations(8)][assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)][assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)][assembly: AssemblyTitle(&quot;Walterlv.Demo&quot;)][assembly: AssemblyDescription(&quot;&quot;)][assembly: AssemblyConfiguration(&quot;&quot;)][assembly: AssemblyCompany(&quot;&quot;)][assembly: AssemblyProduct(&quot;Walterlv.Demo&quot;)][assembly: AssemblyCopyright(&quot;Copyright © walterlv 2018&quot;)][assembly: AssemblyFileVersion(&quot;1.0.0.0&quot;)][assembly: TargetFramework(&quot;.NETFramework,Version=v4.7&quot;, FrameworkDisplayName = &quot;.NET Framework 4.7&quot;)]已经没有 AssemblyConfiguration 特性可以用了。不过我们额外发现一个比较间接的特性可用 Debuggable，至少两者都是有的，可以写出兼容的代码。DebuggableAttribute.DebuggingModes 有多个值： None 自 .NET Framework 2.0 开始，JIT 跟踪信息始终会生成，所以这个属性已经没用了。如果指定为这个值，会直接按 Default 处理。 Default 允许 JIT 编译器进行优化。 DisableOptimizations 禁止编译器对输出程序集进行优化，因为优化可能导致调试过程非常困难。 IgnoreSymbolStoreSequencePoints EnableEditAndContinue 允许在进入断点的情况下编辑代码并继续执行。 通常在 Debug 下编译时，使用的值是 EnableEditAndContinue。寻找程序集以上发现的程序集特性是需要找到一个程序集的，那么应该使用哪一个程序集呢？通常我们调试的时候是运行一个入口程序的，所以可以考虑使用 Assembly.GetEntryAssembly() 来获取入口程序集。然而微软官网对此方法有一个描述： The assembly that is the process executable in the default application domain, or the first executable that was executed by AppDomain.ExecuteAssembly. Can return null when called from unmanaged code.也就是说如果入口程序集是非托管程序集，那么这个可能返回 null。这可能发生在单元测试中、性能测试中或者其他非托管程序调用托管代码的情况；虽然不是主要场景，却很常见。所以，我们依然需要处理返回 null 的情况。那么如何才能找到我们需要的入口程序集呢？考虑托管代码的调用栈中的第一个函数可能是最接近使用者调试的程序集的，所以我们可以采取查找栈底的方式：var assembly = new StackTrace().GetFrames().Last().GetMethod().Module.Assembly;StackTrace.GetFrames() 方法可能返回 null，但那仅对于一个任意的 StackTrace。在我们的使用场景中是取整个托管调用栈的，由于这个方法本身就是托管代码，所以栈中至少存在一个帧；也就是说此方法在我们的场景中是不可能返回 null 的。所以代码静态检查工具如果提示需要处理 null，其实是多余的担心。性能另外，一个编译好的程序集是不可能在运行时再去修改 Debug 和 Release 配置的，所以第一次获取完毕后就可以缓存下来以便后续使用。参考资料 Assembly.GetEntryAssembly Method (System.Reflection) c# - I need an alternative to Assembly.GetEntryAssembly() that never returns null - Stack Overflow StackTrace.GetFrames" }, { "title": "如何精准地用打印机在贺卡或邀请函上打字", "url": "/post/print-to-fill-words-in-card.html", "categories": "", "tags": "office", "date": "2018-08-26 15:35:47 +0800", "snippet": "当你有一堆带有空位的贺卡或邀请函，你是准备手写呢，还是准备打字呢？你的旁边恰巧有一位书法漂亮的 MM 那自不必说，然而如果字都像我这样写得丑，那还是选择打字好了。然而，贺卡或邀请函不同于白纸，通常都是已经打印好有内容的。那么如何打印以便让所有文字的内容都对应到贺卡或邀请函的正确空位上，还是有些难度的。本文将教你如何在毫米级别将文字精准地打印到贺卡或邀请函上。准备：工具 你的贺卡或邀请函（为了描述方便，后面都称作邀请函，需要至少一张用来试验） 一个带有 Microsoft Word 或其他文档编辑软件的 PC 一把具有 1 ms 精度的尺子 一个打印机（那种不会将纸卷起来的类型） 一张 A4 纸 一支笔第一步：准备打印机和纸张取一张 A4 纸，将邀请函放置于 A4 纸的任意一角。无需关心到底是哪一个角，因为不同打印机打印的方向并不相同，我们马上会进行实验判断到底应该放到哪一角。▲ 对齐邀请函用尺子将邀请函在 A4 纸上的轮廓勾勒出来：▲ 勾勒轮廓然后取下邀请函，将其放入打印机中：▲ 放入打印机第二步：制作 Word 文档在 Microsoft Word 中新建一个文档，需要进行一些设置： 纸张大小：A4 纸张方向：横向 文档边距：0（注意这里的上下左右四个方向都要设置为 0）为了能够更精准地控制打印文字地位置，我们还需要在 Word 中做一些标尺设置： 文件 → 选项 → 高级 标尺单位设为“厘米” 取消勾选“使用字符单位” （重要！不然“厘米”单位依然不会生效的） 视图 勾选标尺 接下来，我们就不会再在 Word 文档中直接打字了，而是全部使用文本框。使用标尺，我们可以大致估算出邀请函占用下面这么多的空间：▲ 估算邀请函占用的空间于是我们在邀请函的文本中间放置一个文本框和随意的内容：▲ 随意的文本框现在打印测试效果：▲ 打印看效果很不幸，打印出来与我们预期的方向是反着的。我们之前并没有使用真实的邀请函测试，而是勾勒出了轮廓 —— 这就是为了测试打印机的打印方向二准备的！第三步：调整打印方向如果你上一步得到的方向是对着的，那么这整个第三步都是可以忽略的。现在，我们要么调整文档方向，要么调整打印机纸张方向。为了之后对齐文字的直观，我们当然应该选择调整打印机的纸张方向。于是，请重新将刚刚的打印纸放回打印机，但是我们预期的邀请函的方向就变化了：▲ 预期的邀请函方向发生了变化也就是说，我们的 Word 文档中文字应该从右上角区域移至左下角区域：▲ Word 中的编辑区域也应相应改变于是，我们的准备工作就算结束了。以后对于同款打印机，你可以不用再尝试了，直接使用这一次的调试结果： 记住这次邀请函在纸张中的位置和方向 记住这次 Word 文档中邀请函的位置精确对齐邀请函中的占位符现在，准备好你的尺子，把邀请函放到打印纸上，你需要初步量出每个占位符的位置，以便在 Word 文档中相应的位置插入文本框。▲ 测量出每一个占位符的位置在测量的过程中，不断对应到 Word 文档的相应位置。（注意到我们一开始打开了 Word 文档的厘米标注吗？就是为了与物理尺寸对齐。）▲ 在 Word 文档中创建文本框现在，将用来试验的邀请函放入打印机中，我们即将直接在邀请函中进行试验。▲ 将试验邀请函放入打印机通常，第一次打印出来的效果不尽如人意，即便你测量得非常精确可能都会如此：▲ 不尽如人意的打印效果不过不要紧，你只需要测量实际打印位置（大小）和实际所需位置之间的差异，得知你的每一个文本框需要分别向上下左右移动多少毫米，然后在 Word 文档中将文本框移动那么长的距离。 一个小技巧：你可以尝试找出按一次方向键对应移动多少毫米，这样可以迅速找到精确的移动毫米数。（比如我实际尝试在 100% 缩放比下，3 次方向键移动 1 毫米。不断在刚刚已经打印过的邀请函上打印试错，直至所有文本框都得到满意的位置：▲ 所有的文本框都到达满意的位置打印最终邀请函由于你所有的文本框已对齐，所以即便你再拿一个全新的邀请函放入打印机打印，也依然能得到精确对齐的打印版邀请函。所以你只需要填入最终信息打印即可。▲ 最终打印的邀请函邮件合并然而，你既然希望打印，邀请函肯定不止发送给一个人。人数较少则无所谓，你可以每打印一张改一下名字。然而人数一旦多起来，这种方案肯定让你吐血！Word 中有“邮件合并”功能，你可以在 Word 中插入“域”，然后导入 Excel 名单为每一个人生成专属的邀请函。关于“邮件合并”功能，你可以阅读：使用 Excel 电子表格进行邮件合并 - Word。" }, { "title": "通过解读 WPF 触摸源码，分析 WPF 插拔设备触摸失效的问题（问题篇）", "url": "/post/wpf-touch-fails-when-tablet-device-changed.html", "categories": "", "tags": "wpf, windows", "date": "2018-08-19 19:09:56 +0800", "snippet": "在 .NET Framework 4.7 以前，WPF 程序的触摸处理是基于操作系统组件但又自成一套的，这其实也为其各种各样的触摸失效问题埋下了伏笔。再加上它出现得比较早，触摸失效问题也变得更加难以解决。即便是 .NET Framework 4.7 以后也需要开发者手动开启 Pointer 消息，并且存在兼容性问题。本文将通过解读 WPF 触摸部分的源码，分析 WPF 插拔设备触摸失效的问题。随后，会给微软报这个 Bug。This post is written in multiple languages. Please select yours: 中文 English 所谓“触摸失效”，指的是无论你如何使用手指或触摸笔在触摸屏上书写、交互，程序都没有任何反应。而使用鼠标操作则能正常使用。 本文所述的“触摸失效问题”我在 WPF 程序无法触摸操作 一文中有所提及，但本文偏向于分析其内部发生的原因。 本文与 林德熙 的 WPF 插拔触摸设备触摸失效 所述的是同一个问题。那篇文章会更多的偏向于源码解读，而本文更多地偏向于分析触摸失效的过程。 WPF 程序插拔设备导致触摸失效问题无论你写的 WPF 程序多么简单，哪怕只有一个最简单的窗口带着一个可以交互的按钮，本文所述的触摸失效问题你都可能遇到。具体需要的条件为： 运行 任意的 WPF 程序 插拔带有触摸的 HID 设备（可以是物理插拔，也可以是驱动或软件层面的插拔）以上虽说是必要条件，但如果要提高触摸失效的复现概率，需要制造一个较高的 CPU 占用： 当前系统中有 较高的 CPU 占用率可能还有一些尚不确定的条件： 是否对 .NET Framework 的版本有要求？ 是否对 Windows 操作系统的版本有要求？将以上所有条件组合起来，对于触摸失效的问题描述为： 当运行任意的 WPF 程序时，如果此时操作系统有较高的 CPU 占用，并且此时存在带有触摸的 HID 设备插拔，那么此 WPF 程序可能出现“触摸失效”问题，即此后此程序再也无法触摸操作了。 如果此时系统中同时运行了多个 WPF 程序，多个 WPF 程序可能都会在此时出现触摸失效问题。触摸失效原因初步分析WPF 从收集设备触摸到大多数开发者所熟知的 Stylus 和 Mouse 事件需要两个不同的线程完成。 主线程，负责进行 Windows 消息循环 StylusInput 线程，负责从 WPF 非托管代码和 COM 组件中获得触摸信息主线程中的 Windows 消息循环处理这些消息： LBUTTONDOWN, LBUTTONUP DEVICECHANGE, TABLETADDED, TABLETREMOVEDStylus Input 线程主要由 PenThreadWorker 类创建，在线程循环中使用 GetPenEvent 和 GetPenEventMultiple 这两个函数来获取整个触摸设备中的触摸事件，并将触摸的原始信息向 WPF 的其他触摸处理模块传递。传递的其中一个模块是 WorkerOperationGetTabletsInfo 类，其的 OnDoWork 方法中会通过 COM 组件获取触摸设备个数。而导致触摸失效的错误代码就发生在以上 Stylus Input 线程的处理中。 PenThreadWorker 的 GetPenEventMultiple 方法传入的 _handles 为空数组，这会导致进行无限的等待。 WorkerOperationGetTabletsInfo 的 OnDoWork 因为 COM 组件错误出现 COMException 或因为线程安全问题出现 ArgumentException；此时方法内部会 catch 然后返回空数组，这使得即时存在触摸设备也会因此而识别为不存在。为了方便理解以上的两个 Bug，可以看看我简化后的 .NET Framework 源码：// PenThreadWorker.ThreadProcwhile(这里是两层循环，简化成一个以便理解){ // 以下的 break 都只退出一层循环而已。 if (this._handles.Length == 1) { if (!GetPenEvent(this._handles[0], 其他参数)) { break; } } else if (!GetPenEventMultiple(this._handles, 其他参数)) { break; } // 后续逻辑。}// WorkerOperationGetTabletsInfo.OnDoWorktry{ _tabletDeviceInfo = PenThreadWorker.GetTabletInfoHelper(pimcTablet);}catch(COMException){ _tabletDevicesInfo = new TabletDeviceInfo[0];}catch(ArgumentException){ _tabletDevicesInfo = new TabletDeviceInfo[0];}// 其他异常。以上的问题分析中，ArgumentException 异常几乎可以肯定是线程安全问题所致；COMException 不能确定；而 GetPenEventMultiple 中的参数 handles 实际上是用来进行非托管和托管代码线程同步用的 ResetEvent 集合，所以实际上也是线程同步问题导致的死锁。同时联系以上必要复现步骤中，如果当前存在高 CPU 占用则可以大大提高复现概率；我们几乎可以推断，此问题是 WPF 对触摸的处理存在线程安全的隐患所致。此触摸失效问题的解决方法在推断出初步原因后，根本的解决方法其实只剩下两个了： 修复 WPF 的 Bug 由于我们无法编译 .NET Framework 的源码，所以几乎只能由微软来修复这个 Bug，即需要新版本的 WPF 来解决这个线程安全隐患 当然，此问题的修复可以跟随 .NET Framework 更新，也可以跟随即将推出的 .NET Core 3 进行更新。 更新 Windows（传说中的补丁） 新的 Windows 提供给 WPF 的 COM 组件可能也需要修复线程安全或其他与触摸硬件相关的问题 比较彻底的方案是以上两者都需要修复，但都 只能由微软来完成。那我们非微软开发者可以做些什么呢？ 降低 CPU 占用率 虽然这不由我们控制，不过我们如果能降低一些意料之外的高 CPU 占用，则可以大幅降低 WPF 触摸失效问题出现的概率。 然而作为用户又可以做些什么呢？ 重新插拔触摸设备（如果你的触摸框是通过 USB 连接可以手工插拔的话）触摸失效问题的分析过程以上结论的得出，离不开对 .NET Framework 源码的解读和调试。由于 WPF 的触摸原理涉及到较多类型和源码，需要大量篇幅描述，所以不在本文中说明。阅读以下文章可以更加深入地了解这个触摸失效的问题： WPF 插拔触摸设备触摸失效 - lindexi 通过解读 WPF 触摸源码，分析 WPF 插拔设备触摸失效的问题（分析篇） - walterlv本文所有的 .NET Framework 源码均由 dnSpy 反编译得出，分析过程也基本是借助 dnSpy 的无 pdb 调试特性进行。关于 dnSpy 的更多使用，可以阅读： 断点调试 Windows 源代码 - lindexi 神器如 dnSpy，无需源码也能修改 .NET 程序 - walterlv" }, { "title": "为修改了链接地址的博客进行重定向", "url": "/post/redirect-for-blog-links.html", "categories": "", "tags": "site", "date": "2018-08-19 19:09:39 +0800", "snippet": "不同于笔记，博客除了给自己带来知识的积累之外，还将知识和思想分享给了互联网上的同道中人。于是，当我不得不修改博客地址的时候，就不得不考虑地址修改的兼容问题。博客自发布的那一刻开始，就随时可能被各种奇怪的机构收录： 搜索引擎（喜欢被收录，这样就有更多的人能够获益） 授权的转载站点（虽然目前还没有） 各种泛滥的去除了原作者信息的盗版（比如这里 在Windows10系统上为WPF窗口添加模糊特效） 被其它内容引用（喜欢被引用，说明这份知识是有用的）分享和开放的互联网行为一般会在引用或收录的时候加上原文链接，于是我的链接一旦发布，便不建议再更改。可是，链接有问题啊！那就重定向！我使用 Jekyll 博客，于是，我在根目录建立了一个 redirect 文件夹，专门存放链接的重定向。里面的内容只有两个： 存放原址 重定向到目标地址的脚本代码如下：---permalink: /post/wpf-add-on-ui.html---&amp;lt;script&amp;gt; window.location.href=&quot;/post/wpf-cross-domain-ui.html&quot;;&amp;lt;/script&amp;gt;可以在这个链接中尝试重定向：https://walterlv.github.io/post/wpf-add-on-ui.html附那些盗版▲ 某掐头去尾的盗版网站▲ 盗版▲ 被翻译了的盗版▲ 被翻译了的盗版" }, { "title": ".NET 中 GetProcess 相关方法的性能", "url": "/post/performance-of-get-process.html", "categories": "", "tags": "dotnet, windows", "date": "2018-08-19 15:04:19 +0800", "snippet": ".NET 的 Process 类中提供了查找进程的若干方法，其中部分方法还比较消耗性能。如果你试图优化查找进程相关方法的性能，可能本文分享的一些耗时数据可以作为参考。性能比较Process 类中提供了四种查询进程的方法： GetProcesses 获取当前计算机或远程计算机上运行的所有进程。 GetProcessById 获取当前计算机或远程计算机上 pid 为 指定值的进程。 GetProcessesByName 根据进程的名字查找当前计算机或远程计算机上的进程。 GetCurrentProcess 获取当前进程的 Process 实例。 先给出我的实测数据（100 次执行耗时）： Process.GetProcesses() 00:00:00.7254688 Process.GetProcessById(id) 00:00:01.3660640（实际数值取决于当前进程数） Process.GetProcessesByName(&quot;Walterlv.Demo&quot;) 00:00:00.5604279 Process.GetCurrentProcess() 00:00:00.0000546 结果显示获取所有进程实例的 GetProcesses 方法速度竟然比获取单个进程实例的 GetProcessById 还要快得多！额外地，根据名称查找进程比前两者都快，获取当前进程实例的方法快得不是一个数量级。这些速度差异源于哪里我们先看看最慢的方法 GetProcessIds，它的最本质的实现在 ProcessManager 类中：// ProcessManagerpublic static int[] GetProcessIds() { int[] processIds = new int[256]; int size; for (;;) { if (!NativeMethods.EnumProcesses(processIds, processIds.Length * 4, out size)) throw new Win32Exception(); if (size == processIds.Length * 4) { processIds = new int[processIds.Length * 2]; continue; } break; } int[] ids = new int[size / 4]; Array.Copy(processIds, ids, ids.Length); return ids;}先创建一个 256 长度的数组，然后使用本机函数枚举进程列表填充这个数组。如果实际所需的数组大小与传入的数组大小相等，说明数组用完了，有可能进程数比 256 个多。所以，将数组长度扩大为两倍，随后再试一次。直到发现申请的数组长度足够存下进程数为止。这里用到了本机方法 EnumProcesses 来枚举进程。传入的 size 要乘以 4 是因为传入的是字节数，一个 int 是 4 个字节。// NativeMethods[DllImport(&quot;psapi.dll&quot;, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]public static extern bool EnumProcesses(int[] processIds, int size, out int needed);所以我们可以得知，如果当前计算机中的进程数小于 256 个，那么枚举进程方法仅需执行一次；而如果大于或等于 256 个，则枚举进程的方法需要执行两次或更多次，这是性能很差的一个重要原因。另外，GetProcesses 方法就要复杂得多，其核心调用的是 ProcessManager.GetProcessInfos 方法。方法很长，但其大体思路是获取当前计算机上的线程列表，然后将线程所在的进程储存到哈希表中（相当于去重），随后返回此哈希表的数组副本。// ProcessManagerstatic ProcessInfo[] GetProcessInfos(IntPtr dataPtr, Predicate&amp;lt;int&amp;gt; processIdFilter) { // 60 is a reasonable number for processes on a normal machine. Hashtable processInfos = new Hashtable(60); long totalOffset = 0; while(true) { IntPtr currentPtr = (IntPtr)((long)dataPtr + totalOffset); SystemProcessInformation pi = new SystemProcessInformation(); Marshal.PtrToStructure(currentPtr, pi); // Process ID shouldn&#39;t overflow. OS API GetCurrentProcessID returns DWORD. int processInfoProcessId = pi.UniqueProcessId.ToInt32(); if (processIdFilter == null || processIdFilter(processInfoProcessId)) { // get information for a process ProcessInfo processInfo = new ProcessInfo(); processInfo.processId = processInfoProcessId; processInfo.handleCount = (int)pi.HandleCount; processInfo.sessionId = (int)pi.SessionId; processInfo.poolPagedBytes = (long)pi.QuotaPagedPoolUsage;; processInfo.poolNonpagedBytes = (long)pi.QuotaNonPagedPoolUsage; processInfo.virtualBytes = (long)pi.VirtualSize; processInfo.virtualBytesPeak = (long)pi.PeakVirtualSize; processInfo.workingSetPeak = (long)pi.PeakWorkingSetSize; processInfo.workingSet = (long)pi.WorkingSetSize; processInfo.pageFileBytesPeak = (long)pi.PeakPagefileUsage; processInfo.pageFileBytes = (long)pi.PagefileUsage; processInfo.privateBytes = (long)pi.PrivatePageCount; processInfo.basePriority = pi.BasePriority; if( pi.NamePtr == IntPtr.Zero) { if( processInfo.processId == NtProcessManager.SystemProcessID) { processInfo.processName = &quot;System&quot;; } else if( processInfo.processId == NtProcessManager.IdleProcessID) { processInfo.processName = &quot;Idle&quot;; } else { // for normal process without name, using the process ID. processInfo.processName = processInfo.processId.ToString(CultureInfo.InvariantCulture); } } else { string processName = GetProcessShortName(Marshal.PtrToStringUni(pi.NamePtr, pi.NameLength/sizeof(char))); // // On old operating system (NT4 and windows 2000), the process name might be truncated to 15 // characters. For example, aspnet_admin.exe will show up in performance counter as aspnet_admin.ex. // Process class try to return a nicer name. We used to get the main module name for a process and // use that as the process name. However normal user doesn&#39;t have access to module information, // so normal user will see an exception when we try to get a truncated process name. // if (ProcessManager.IsOSOlderThanXP &amp;amp;&amp;amp; (processName.Length == 15)) { if (processName.EndsWith(&quot;.&quot;, StringComparison.OrdinalIgnoreCase)) { processName = processName.Substring(0, 14); } else if (processName.EndsWith(&quot;.e&quot;, StringComparison.OrdinalIgnoreCase)) { processName = processName.Substring(0, 13); } else if (processName.EndsWith(&quot;.ex&quot;, StringComparison.OrdinalIgnoreCase)) { processName = processName.Substring(0, 12); } } processInfo.processName = processName; } // get the threads for current process processInfos[processInfo.processId] = processInfo; currentPtr = (IntPtr)((long)currentPtr + Marshal.SizeOf(pi)); int i = 0; while( i &amp;lt; pi.NumberOfThreads) { SystemThreadInformation ti = new SystemThreadInformation(); Marshal.PtrToStructure(currentPtr, ti); ThreadInfo threadInfo = new ThreadInfo(); threadInfo.processId = (int)ti.UniqueProcess; threadInfo.threadId = (int)ti.UniqueThread; threadInfo.basePriority = ti.BasePriority; threadInfo.currentPriority = ti.Priority; threadInfo.startAddress = ti.StartAddress; threadInfo.threadState = (ThreadState)ti.ThreadState; threadInfo.threadWaitReason = NtProcessManager.GetThreadWaitReason((int)ti.WaitReason); processInfo.threadInfoList.Add(threadInfo); currentPtr = (IntPtr)((long)currentPtr + Marshal.SizeOf(ti)); i++; } } if (pi.NextEntryOffset == 0) { break; } totalOffset += pi.NextEntryOffset; } ProcessInfo[] temp = new ProcessInfo[processInfos.Values.Count]; processInfos.Values.CopyTo(temp, 0); return temp;}GetProcessesByName 方法就比较奇怪了，因为其本质上就是调用了 Process.GetProcesses 方法，并在其后额外执行了一些代码。理论上不应该出现耗时更短的情况。事实上，在测试中，我将 GetProcesses 和 GetProcessesByName 方法的执行调换顺序也能得到稳定一致的结果，都是 GetProcessesByName 更快。public static Process[] GetProcessesByName(string processName, string machineName) { if (processName == null) processName = String.Empty; Process[] procs = GetProcesses(machineName); ArrayList list = new ArrayList(); for(int i = 0; i &amp;lt; procs.Length; i++) { if( String.Equals(processName, procs[i].ProcessName, StringComparison.OrdinalIgnoreCase)) { list.Add( procs[i]); } else { procs[i].Dispose(); } } Process[] temp = new Process[list.Count]; list.CopyTo(temp, 0); return temp;}至于 GetCurrentProcess 方法能够这么快，很好理解，毕竟是自己进程，有什么拿不到的呢？其内部调用的是本机方法：[DllImport(&quot;kernel32.dll&quot;, CharSet=System.Runtime.InteropServices.CharSet.Auto)]public static extern int GetCurrentProcessId();另外，有个有意思的现象： Windows的PID为什么是4的倍数 - 开源中国社区 WINDOWS进程或线程号为什么是4的倍数 - GUO Xingwang - 博客园" }, { "title": "WPF Applications Stop Responding to Touches after Adding or Removing Tablet Devices", "url": "/post/wpf-touch-fails-when-tablet-device-changed-en.html", "categories": "", "tags": "wpf, windows", "date": "2018-08-15 15:42:00 +0800", "snippet": "WPF framework handles touch devices and events mostly using its own code and COM components instead of using the windows message loop. Unfortunately, there may be some bugs in the WPF touch handling codes. So we sometimes suffer from the WPF touch failures. This changes after Microsoft introducing .NET Framework 4.7, but the developers have to switch on the Pointer message manually with some compliant issues.In this article, I’ll post some codes of WPF to present its potential bugs of touch failure.This post is written in multiple languages. Please select yours: 中文 English The touch failure issueEven if you write a very simple WPF application which contains only a button, you’ll be suffering from the touch failure issue.What you need is: Run any WPF application Keep plugging and unplugging a USB HID tablet deviceThe actions above helps reproduce touch failure with a small probability. But if you want a larger probability, you should: Make a high CPU usageProbably there may be other conditions such as the .NET Framework version and the Windows version but I’m not sure.When you put them together, you’ll get a full touch failure issue description. Run any WPF application with a high CPU usage, and then keep plugging and unplugging a USB HID tablet device, you’ll get the WPF application which stops responding to touches. If multiple WPF applications are running at the same time, most of them will lose touch.Preliminary analysis of the touch failureWPF use two different threads to collect touch information from tablet devices and convert them to the Stylus and Mouse event that most of us are familiar to. The Main thread of WPF. WPF use windows message loop on this thread to handle mouse message and device change message. The Stylus Input thread. WPF run the unmanaged code and call COM component to collect device information and touch information.The WPF stylus code uses the windows message loop to handle these messages: LBUTTONDOWN, LBUTTONUP DEVICECHANGE, TABLETADDED, TABLETREMOVEDThe Stylus Input thread is created by the PenThreadWorker class. The PenThreadWorker call GetPenEvent and GetPenEventMultiple in the thread loop to fetch the whole touch events of tablet devices and then it will pass the raw touch data to other touch modules to translate them into regular Stylus/Touch/Mouse events. One of the touch modules is the WorkerOperationGetTabletsInfo class which contains an OnDoWork method to fetch tablet device count through COM components.The touch failure comes from the code of the Stylus Input thread. An empty _handles array is passed into the GetPenEventMultiple method of PenThreadWorker and this action may cause infinite waiting. A COMException or ArgumentException may happen when the OnDoWork of WorkerOperationGetTabletsInfo is running. This method will catch the exceptions and returns an empty array which will cause the WPF application get empty tablet devices by mistake even if there are tablet devices in actual.I’ve simplified the core .NET Framework code of the stylus handling above. You may understand what I mean more clearly by reading these codes:// PenThreadWorker.ThreadProcwhile(There are two loops in real){ // The `break` below only exit one loop, not two. if (this._handles.Length == 1) { if (!GetPenEvent(this._handles[0], otherArgs)) { break; } } else if (!GetPenEventMultiple(this._handles, otherArgs)) { break; } // Other logics.}// WorkerOperationGetTabletsInfo.OnDoWorktry{ _tabletDeviceInfo = PenThreadWorker.GetTabletInfoHelper(pimcTablet);}catch(COMException){ _tabletDevicesInfo = new TabletDeviceInfo[0];}catch(ArgumentException){ _tabletDevicesInfo = new TabletDeviceInfo[0];}// Other exception handling.I can definitely sure that the ArgumentException is the result of the thread-safety issue but I’m not sure whether COMException is the same. The handles argument is the handles of ResetEvents which are used for the thread syncing between managed code and unmanaged code. So the infinite waiting of GetPenEventMultiple is actually a deadlock which is also a thread-safety issue.Remember that we can make a high CPU usage to increase the probability of reproduction, we can infer that the touch failure issue is caused by the thread-safety issue of WPF stylus handling.The solutions to the touch failureAfter inferring the preliminary reason, there are only two fundamental solutions left for us: Fix the bug of WPF Only Microsoft can fix this kind of bugs because we cannot rebuild WPF all by our selves. Of course, this kind of patch can be introduced in .NET Framework, or be introduced in the WPF on .NET Core 3. Fix the bug of Windows The COM components provided for WPF may need an update to fix the thread-safety issue or other tablet devices issues. A more thorough solution is that both of them need to be fixed, but both can only be done by Microsoft.So what can we non-Microsoft developers do? Reduce CPU usage Although this is not controlled by us, if we can reduce some unexpected high CPU usage, we can greatly reduce the probability of WPF touch failure. But what can I do if I’m only a normal user? Re-plug the touch device (if your touch frame can be manually plugged in via USB connection)The details analysis for the touch failureThe above conclusions come from the reading and debugging of the .NET Framework source code.Since WPF touch details involve more types and source code which requires a lot of descriptions, so it is not explained in this article. Read the following article to get a deeper understanding of the touch failure (all of the links are under translating): WPF 插拔触摸设备触摸失效 - lindexi 通过解读 WPF 触摸源码，分析 WPF 插拔设备触摸失效的问题（分析篇） - walterlvAll of the .NET Framework source code in this article is decompiled by dnSpy, and the analysis process is basically based on the dnSpy’s no-PDB debugging feature." }, { "title": "WPF 绘制对齐像素的清晰显示的线条", "url": "/post/draw-aligned-lines-using-guidelineset.html", "categories": "", "tags": "wpf", "date": "2018-08-13 20:47:08 +0800", "snippet": "此前有小伙伴询问我为何他 1 像素的线条显示发虚，然后我告诉他是“像素对齐”的问题，然而他设置了各种对齐像素的属性依旧没有作用。于是我对此进行了一系列试验，对 WPF 像素对齐的各种方法进行了一次总结。此后在 StackOverflow 中，我回答了 graphics - WPF DrawingContext seems ignore SnapToDevicePixels - Stack Overflow 问题。阅读本文，我们将了解解决 WPF 像素对齐的四种方法以及其各自的适用范围和副作用。为什么要做像素对齐看线条！这是 3 像素的线条：然而论其原因，就是因为我们屏幕太渣~哦~不，是因为绘制的线条没有与屏幕像素对齐，具体来说是视觉对象（Visual）的位置不在整数像素上或尺寸不是整数像素。而与此同时屏幕的点距又太大以至于我们看出来绘制的线条和屏幕像素之间的差异。然而为什么 WPF 不默认为我们对齐像素呢？这是因为要对齐像素必定带来尺寸上的偏差；这是绘制尺寸精度和最终呈现效果之间的平衡。在 MacBook、Surface Pro 这些高档显示屏上，根本不用管这样的平衡问题；但在渣渣显示器上，微软把这种平衡的控制交给了应用的开发者。处理像素对齐的四种方法方法一：布局取整 UseLayoutRounding实际效果是：根本就不起作用！事实上我们从 .NET Framework 源码可以得知，UseLayoutRounding 实际只处理 UI 元素对自己子级控件的布局取整。一旦整棵布局树种有任何一个不是整数（或者 DPI 相乘后不是整数），那么就依然没有解决问题。方法二：对齐设备像素 SnapsToDevicePixels这是一个会沿着逻辑树继承的属性，只要最顶层设置了这个属性，里面的元素都会具备此特性。不过，他只处理矩形的渲染，也就是说，只对 Border Rectangle 这些类型的元素生效，其他的包括自己写的元素基本都是不管用的。它有一个好处，是像素对齐的情况下同时能够保证显示不足或超过 1 像素时，也能带一点儿透明或者超过一点像素。方法三：使用 DrawingContext 绘制并配合 GuidelineSet如果自己处理绘制，则可以在 OnRender 方法中使用 DrawingContext 来绘制各种各样的形状。DrawingContext 有方法 PushGuidelineSet，而 PushGuidelineSet 就是用来处理对齐的。以下是四种不同方式的对齐效果对比，其中上面一半是直接对齐（即绘制过程是紧贴着的），下面一半则是多个部分带上一点偏移（即并不是紧贴）：▲ 看不清的可以考虑方法看于是要想像素对齐，必须： 布局或绘制时，UI 元素之间一点偏移或空隙都不能有，一点都不行 SnapsToDevicePixels 和 GuidelineSet 在实际对齐中有效，而 UseLayoutRounding 就是在逗你GuidelineSet 的使用可以参考我在 StackOverflow 上的回答：graphics - WPF DrawingContext seems ignore SnapToDevicePixels - Stack Overflow。以下是我编写的用于辅助绘制对齐线条的扩展方法：public static class SnapDrawingExtensions{ public static void DrawSnappedLinesBetweenPoints(this DrawingContext dc, Pen pen, double lineThickness, params Point[] points) { var guidelineSet = new GuidelineSet(); foreach (var point in points) { guidelineSet.GuidelinesX.Add(point.X); guidelineSet.GuidelinesY.Add(point.Y); } var half = lineThickness / 2; points = points.Select(p =&amp;gt; new Point(p.X + half, p.Y + half)).ToArray(); dc.PushGuidelineSet(guidelineSet); for (var i = 0; i &amp;lt; points.Length - 1; i = i + 2) { dc.DrawLine(pen, points[i], points[i + 1]); } dc.Pop(); }}注意添加到 GuidelineSet 的尺寸不需要是整数，也不需要计算对齐屏幕的位置，只需要随便指定一个值即可，但相邻的绘制元素的值需要在 double 级别完全相同，多一点少一点都不行。另外还需要特别注意的是：如果你绘制矩形，那么 GuidelineSet 构造函数参数传入的是横坐标和纵坐标，不要把宽度和高度传进去了。在 OnRender 中调用它绘制：protected override void OnRender(DrawingContext dc){ // Draw four horizontal lines and one vertical line. // Notice that even the point X or Y is not an integer, the line is still snapped to device. dc.DrawSnappedLinesBetweenPoints(_pen, LineThickness, new Point(0, 0), new Point(320, 0), new Point(0, 40), new Point(320, 40), new Point(0, 80.5), new Point(320, 80.5), new Point(0, 119.7777), new Point(320, 119.7777), new Point(0, 0), new Point(0, 120));}方法四：RenderOptions.EdgeMode这是纯渲染级别的附加属性，对所有 UI 元素有效。这个属性很神奇，一旦设置，元素就再也不会出现模糊的边缘了，一定是硬像素边缘。不足半像素的全部删掉，超过半像素的变为 1 个像素。以为它可以解决问题？——Too young, too simple.你希望能够绘制 1 像素的线条，实际上它会让你有时看得见 1 像素线条，有时看的是 2 像素线条，有时居然完全看不见！！！如果你都作用对象上还有其它视觉对象，它们也会一并变成了“硬边缘”，是可以看得见一个个像素的边缘。各种方法适用范围总结 如果画粗线条粗边框，那么 RenderOptions.EdgeMode 最适合了，因为设置起来最方便，可以设置到所有的 UI 元素上。由于边框很粗，所以多一个少一个像素用户也注意不到。 如果是画细边框，那么使用 Border 配合 SnapsToDevicePixels 可以解决，无论是 0.8 像素还是 1.0 像素，1.2 像素，都能在准确地显示其粗细的基础之上还保证像素对齐。 如果图形比较复杂，比如绘制表格或者其它各种交叉了线条的图形，那么使用 DrawingContext 绘制，并设置 GuidelineSet 对齐。 如果窗口非常简单，既没有缩放，UI 元素也不多，可以考虑使用 UseLayoutRounding 碰碰运气，万一界面简单到只需要整数对齐就够了呢？ 特别说明，上面四种方法不足与应对所有的像素对齐情况，如果还是没办法对齐……节哀把……我们一起找偏方……" }, { "title": "C#/.NET 序列化和反序列化 YAML 元数据", "url": "/post/serialize-and-deserialize-yaml.html", "categories": "", "tags": "dotnet, csharp", "date": "2018-08-13 05:47:27 +0800", "snippet": "我希望能够对我博客中的所有 YAML 元数据进行格式化和自动生成，于是我需要进行一些 YAML 解析和写入的操作。.NET 并没有原生提供对 YAML 的序列化和反序列化。虽然 YAML 文件的解析并不难，不过如果不是处于特别的理由（比如性能），使用现有的库解析 YAML 是比较好的选择。本文推荐使用 YamlDotNet 序列化和反序列化 YAML。YAML 元数据作为示例，我拿出我在去年写的一篇博客的元数据进行分析：layout: posttitle: &quot;利用 TypeConverter，转换字符串和各种类型只需写一个函数&quot;date_published: 2017-01-17 18:13:00 +0800date: 2018-04-23 07:31:32 +0800tags: dotnetpermalink: /dotnet/2017/01/17/convert-using-type-converter.htmlkeywords: dotnet typeconverterdescription: 使用 TypeConverter 实现字符串转各种类型。注意，实际上元数据是包含开始标签和结束标签的。yaml 元数据以 --- 包裹，toml 元数据以 +++ 包裹。由于从 Markdown 中解析出 YAML 元数据不是本文的重点，所以我放到最后一起说明。定义 .NET 类型我们需要先定义 .NET 类型，以便 YamlDotNet 进行序列化和反序列化。public sealed class YamlFrontMeta{ [YamlMember(Alias = &quot;title&quot;, ApplyNamingConventions = false)] public string Title { get; set; } [YamlMember(Alias = &quot;date&quot;, ApplyNamingConventions = false)] public string Date { get; set; } [YamlMember(Alias = &quot;date_published&quot;, ApplyNamingConventions = false)] public string PublishDate { get; set; } [YamlMember(Alias = &quot;layout&quot;, ApplyNamingConventions = false)] public string Layout { get; set; } [YamlMember(Alias = &quot;permalink&quot;, ApplyNamingConventions = false)] public string PermanentUrl { get; set; } [YamlMember(Alias = &quot;categories&quot;, ApplyNamingConventions = false)] public string Categories { get; set; } [YamlMember(Alias = &quot;tags&quot;, ApplyNamingConventions = false)] public string Tags { get; set; } [YamlMember(Alias = &quot;keywords&quot;, ApplyNamingConventions = false)] public string Keywords { get; set; } [YamlMember(Alias = &quot;description&quot;, ApplyNamingConventions = false)] public string Description { get; set; } [YamlMember(Alias = &quot;versions&quot;, ApplyNamingConventions = false)] public List&amp;lt;VersionsInfo&amp;gt; Versions { get; set; } [YamlMember(Alias = &quot;published&quot;, ApplyNamingConventions = false)] public bool IsPublished { get; set; } = true; [YamlMember(Alias = &quot;sitemap&quot;, ApplyNamingConventions = false)] public bool IsInSiteMap { get; set; } = true;}.NET 类型中的属性必须是 YAML 文件中属性的超集。以上 ApplyNamingConventions 属性的默认值是 true，这为了解决一些命名约束上的问题，详见：YamlMember Alias isn’t applied when using the CamelCaseNamingConvention · Issue #228 · aaubry/YamlDotNet。另外，如果 YAML 属性中包含数组，则需要将属性的类型设置为集合类型。title: &quot;Good Framework Rely on Good Api —— Six API Design Principles&quot;date_published: 2018-06-30 19:09:53 +0800date: 2018-08-12 16:04:26 +0800tags: dotnet frameworkversions: - 中文: /post/framework-api-design.html - English: #public sealed class VersionInfo{ [YamlMember(Alias = &quot;current&quot;, ApplyNamingConventions = false)] public string Current { get; set; }}public sealed class VersionsInfo{ [YamlMember(Alias = &quot;中文&quot;, ApplyNamingConventions = false)] public string Chinese { get; set; } [YamlMember(Alias = &quot;English&quot;, ApplyNamingConventions = false)] public string English { get; set; }}序列化与反序列化使用 Deserializer 类型可以反序列化一个 YAML 元数据。var deserializer = new Deserializer();var matter = deserializer.Deserialize&amp;lt;YamlFrontMeta&amp;gt;(yamlText);使用 Serializer 类型可以序列化一个 YAML 元数据到字符串。这样，就能更新博客的 YAML 元数据部分了。var serializer = new Serializer();var yamlText = serializer.Serialize(matter);" }, { "title": "C#/.NET 读取或修改文件的创建时间和修改时间", "url": "/post/read-write-file-date-attributes.html", "categories": "", "tags": "windows, dotnet, csharp", "date": "2018-08-12 19:44:24 +0800", "snippet": "手工在博客中添加 Front Matter 文件头可是个相当费事儿的做法，这种事情就应该自动完成。.NET 中提供了非常方便的修改文件创建时间的方法，使用这种方法，能够帮助自动完成一部分文件头的编写或者更新。相关类型.NET 中提供了两个不同的设置创建和修改时间的入口： File 静态类 FileInfo 类▲ File 静态类的方法▲ FileInfo 类的方法很明显，使用 FileInfo 类可以使用属性直接获取和赋值，用法上会比 File 方便，不过需要一个 FileInfo 的实例。修改时间我期待能够读取文件的创建和修改时间来获知博客文章的发布和修改时间。不过在此之前，我需要先根据 Markdown 文件元数据更新文件时间。private void FixFileDate(FileInfo file, DateTimeOffset createdTime, DateTimeOffset modifiedTime){ // 更改文件的创建时间。 file.CreationTimeUtc = createdTime.UtcDateTime; // 更改文件的更新时间。 file.LastWriteTimeUtc = modifiedTime.UtcDateTime; // 更改文件最近一次访问的时间。 file.LastAccessTimeUtc = DateTimeOffset.Now.UtcDateTime;}至于如何获取 Markdown 文件元数据中的时间，可以使用 YamlDotNet（当然，需要自己提取 YAML 元数据头）。读取时间当此后需要使用文件的创建时间来更新 YAML 元数据时，只需要读取这几个属性即可。UpdateMetaTime(file, file.CreationTimeUtc, file.LastWriteTimeUtc);void UpdateMetaTime(FileInfo file, DateTimeOffset publishDate, DateTimeOffset date){ var publishDateString = date.ToLocalTime().ToString(&quot;yyyy-MM-dd HH:mm:ss zz&quot;); var dateString = date.ToLocalTime().ToString(&quot;yyyy-MM-dd HH:mm:ss zz&quot;); // 省略更新 YAML 元数据。}关于 UTC 时间也许你注意到以上我使用的时间类型都是 DateTimeOffset 而不是 DateTime，这是因为 DateTimeOffset 中记录了时区信息，不至于在使用的过程中丢掉时区信息，出现重复时间转换，发生时间错误。" }, { "title": "Good Framework Rely on Good Api —— Six API Design Principles", "url": "/post/framework-api-design-en.html", "categories": "", "tags": "dotnet, framework", "date": "2018-08-12 16:04:26 +0800", "snippet": "We have S.O.L.I.D principles of object-oriented programming, and we also have Software design patterns to solve general, reusable solution to a commonly occurring problem. But we don’t have public-accepted API design principles or patterns for us to develop better APIs.But we still have many API designing experiences to conclude some design principals. This post concludes them.This post is written in multiple languages. Please select yours: 中文 English The API design principles in this post mostly come from Practical API Design written by Jaroslav Tulach who is the NetBeans founder. I’ve read the whole book but find that most knowledge is his recommendations and are scattered to be in order. So I collect the core API design recommendations into six design principles. Maybe this post will help you to evaluate your Framework and API design quality and help you to write good APIs that gives the user better experience.What is API?API is the short of Application programming interface. Wikipedia has a definition for it, but it’s a bit hard to understand. See this link to view the definition: Application programming interface - Wikipedia.We can simply treat class, interface, Property, Field, Method, and the configuration file or the protocol provided by the library as APIs.API design principlesEven if you don’t learn anything nor read any books about API design, if you have programmed a few times long, you’ll feel that some APIs are easier to use and others are not. This means that every programmer has more or less API usage experience.So the principals concluded in this post will help us design better API for our library users.Easier to understandSome users want to use a new API and find that they must learn some new knowledge about it to write correct code. The more the user should learn new knowledge the harder the API to understand.We can follow these tips to help us design easier-to-understand APIs: Don’t introduce new concept if not necessary. Prevent the user to use it incorrectly. Make the user cannot write incorrect code. It means you can make the code uncompilable when the user uses it incorrectly. If you find that is hard to make the wrong code uncompilable, you can throw exceptions to warn the user and provide tips for him/her to fix it. You’d better make wrong code ugly at the same time. e.g. Make the IDE display underlines in the wrong code. If you can only warn the user in your documentation, you may tried less. It’s recommended to try more to do the things above. Moq in .NET foundation is a very good practice for Prevent the user to use it incorrectly. You can install and try it in Moq in nuget.org.Easier to findMost of us use IDE to develop and maybe some of us use code editor such as Visual Studio Code, Sublime, Atom, Notepad++ or Vim. Whatever you use to write code, they all have IntelliSense which can help you know more context APIs and write correct API usage code.If we can find some new API and use it correctly via IntelliSense, we can say that the API is easier to find.How do we find the APIs via IntelliSense? When we implement a method which we don’t know anything about its parameters, we can get right values we want from the arguments via the IntelliSense. When we call a method which we don’t know anything about its parameters, we can fetch and create what it needs via the IntelliSense. When we call a method whose return value type is unfamiliar for us, we can use the return value correctly via the IntelliSense.There is a picture below I draw to describe APIs easier or harder to find.▲ The connection lines indicates that we can know the APIs through the method parameters and the returning value.Related APIs are more similarIf the similar functions have similar APIs, the API users cost very less to learn the correct usage of the new API.You may remember the Select method of LINQ. And when you use LINQ to XML to read/write XML files, you’ll find Select method, too. Their usage experiences are very similar so that you can easily know how to use Select in LINQ to XML if you know the LINQ.Simple task have simple implementationIf you only design your APIs in the recommendation of the three principles above, your classes may be too large so that they may violate the Single Responsibility Principle of S.O.L.I.D. So there is another principle to prevent this being happen. That is, a simple task should have a simple implementation.InkCanvas of UWP is a good practice of this principal. You can use an InkCanvas To accept inks by writing only a simple line:&amp;lt;InkCanvas x:Name=&quot;inkCanvas&quot; /&amp;gt;You can write more advanced functions by writing more customization code, but all of them are not necessary: // The code below is from https://docs.microsoft.com/en-us/windows/uwp/design/input/pen-and-stylus-interactions// Set supported inking device types.inkCanvas.InkPresenter.InputDeviceTypes = Windows.UI.Core.CoreInputDeviceTypes.Mouse | Windows.UI.Core.CoreInputDeviceTypes.Pen;// Set initial ink stroke attributes.InkDrawingAttributes drawingAttributes = new InkDrawingAttributes();drawingAttributes.Color = Windows.UI.Colors.Black;drawingAttributes.IgnorePressure = false;drawingAttributes.FitToCurve = true;inkCanvas.InkPresenter.UpdateDefaultDrawingAttributes(drawingAttributes); Easier to test and to be testedBetter API helps the API user easier to test his/her API usage methods.If you provide an API with a static method such as Config.Get(&quot;SomeKey&quot;) to retrieve configuration values, the API user will find it hard to write unit test method because he/she cannot create fake configuration.Easier to keep compatibility even if upgrading frequentlyBetter APIs cost less for the users to upgrade their library versions and bring less burden for the API developers to make library compatible.There are three kind of compatibility: Binary compatibility When upgrading the library, the users can run their projects without a recompile. Code compatibility When upgrading the library, the users can recompile their project without any code modification. Behavior compatibility When upgrading the library, the users’ applications run the same as before. We can follow these tips to help us design better-future-compatibility APIs: Don’t release your APIs ahead of your whole solution. If you are trying to release an API for the future usage, I recommend you not to do this. Because you don’t know the future needs, the APIs have a very high probability to be changed with a heavy compatibility burden. Reserve enough extension points. If an API which will have more chance to change in the future has fewer extension points, the API will change more frequently. But if you reserve some designed extension points, future change will be in the control. Give tips for the users to migrate legacy APIs. If an API is obsolete, you’d better not to delete it immediately. It’s recommended to mark it obsolete and tell the users how to migrate to the new APIs. Framework designThe framework can be understood as a set of APIs developed for the complete solution of a certain kind of problems.Avalonia is a cross-platform UI framework and it uses ReactiveUI which is a reactive UI framework to develop MVVM pattern UI.Hope you’ll design better APIs by reading the six API design principals.References Practical API Design by Jaroslav Tulach (The NetBeans founder)" }, { "title": "WPF/UWP 的 Grid 布局竟然有 Bug，还不止一个！了解 Grid 中那些未定义的布局规则", "url": "/post/the-bugs-of-grid.html", "categories": "", "tags": "wpf, uwp, xaml", "date": "2018-08-12 16:04:15 +0800", "snippet": "只要你用 XAML 写代码，我敢打赌你一定用各种方式使(nuè)用(dài)过 Grid。不知你有没有在此过程中看到过 Grid 那些匪夷所思的布局结果呢？本文将带你来看看 Grid 布局中的 Bug。This post is written in multiple languages. Please select yours: 中文 English 无限空间下的比例先上一段代码，直接复制到你的试验项目中运行：&amp;lt;Canvas&amp;gt; &amp;lt;Grid Height=&quot;100&quot;&amp;gt; &amp;lt;Grid.ColumnDefinitions&amp;gt; &amp;lt;ColumnDefinition Width=&quot;100&quot; /&amp;gt; &amp;lt;ColumnDefinition Width=&quot;*&quot; /&amp;gt; &amp;lt;ColumnDefinition Width=&quot;2*&quot; /&amp;gt; &amp;lt;/Grid.ColumnDefinitions&amp;gt; &amp;lt;Border Grid.Column=&quot;0&quot; Background=&quot;CornflowerBlue&quot; Width=&quot;150&quot; /&amp;gt; &amp;lt;Border Grid.Column=&quot;1&quot; Background=&quot;Tomato&quot; Width=&quot;150&quot; /&amp;gt; &amp;lt;Border Grid.Column=&quot;2&quot; Background=&quot;Teal&quot; Width=&quot;150&quot; /&amp;gt; &amp;lt;/Grid&amp;gt;&amp;lt;/Canvas&amp;gt;第一列固定 100，第二列占 1 个比例的 *，第三列占 2 个比例的 *。你觉得最终的效果中，第二个 Border 和第三个 Border 的可见尺寸分别是多少呢？按下F5运行看看结果预料到了吗？虽然第二列和第三列的比例是 1:2，但最终的可见比例却是 1:1。这里是有破绽的，因为你可能会怀疑第三列其实已经是第二列的两倍，只是右侧是空白，看不出来。那么现在，我们去掉 Canvas，改用在父 Grid 中右对齐，也就是如下代码：&amp;lt;Grid HorizontalAlignment=&quot;Right&quot;&amp;gt; &amp;lt;Grid.ColumnDefinitions&amp;gt; &amp;lt;ColumnDefinition Width=&quot;100&quot; /&amp;gt; &amp;lt;ColumnDefinition Width=&quot;*&quot; /&amp;gt; &amp;lt;ColumnDefinition Width=&quot;2*&quot; /&amp;gt; &amp;lt;/Grid.ColumnDefinitions&amp;gt; &amp;lt;Border Grid.Column=&quot;0&quot; Background=&quot;CornflowerBlue&quot; Width=&quot;150&quot; /&amp;gt; &amp;lt;Border Grid.Column=&quot;1&quot; Background=&quot;Tomato&quot; Width=&quot;150&quot; /&amp;gt; &amp;lt;Border Grid.Column=&quot;2&quot; Background=&quot;Teal&quot; Width=&quot;150&quot; /&amp;gt;&amp;lt;/Grid&amp;gt;运行后，你会发现最右侧是没有空白的，也就是说第二列和第三列确实不存在 1:2 的比例——它们是等宽的。那么那一段失去的空间去哪里了呢？让我们缩小窗口：竟然在左侧还有剩余空间的情况下，右侧就开始压缩元素空间了！我们能说那段丢失的一个 * 长度的空白到左边去了吗？显然不能。不过，我们能够猜测，压缩右侧元素开始于最小 1:2 的比例正好不足时出现。刚好不够分的比例右对齐能够帮助我们区分右侧是否真的占有空间。那么我们继续右对齐做试验。现在，我们将第二列的 Border 做成跨第二和第三两列的元素。第三列的 Border 放到第二列中。（也就是说，我们第三列不放元素了。）&amp;lt;Grid HorizontalAlignment=&quot;Right&quot;&amp;gt; &amp;lt;Grid.ColumnDefinitions&amp;gt; &amp;lt;ColumnDefinition Width=&quot;100&quot; /&amp;gt; &amp;lt;ColumnDefinition Width=&quot;*&quot; /&amp;gt; &amp;lt;ColumnDefinition Width=&quot;2*&quot; /&amp;gt; &amp;lt;/Grid.ColumnDefinitions&amp;gt; &amp;lt;Border Grid.Column=&quot;0&quot; Background=&quot;CornflowerBlue&quot; Width=&quot;150&quot; /&amp;gt; &amp;lt;Border Grid.Column=&quot;1&quot; Grid.ColumnSpan=&quot;2&quot; Background=&quot;Tomato&quot; Width=&quot;150&quot; /&amp;gt; &amp;lt;Border Grid.Column=&quot;1&quot; Background=&quot;Teal&quot; Width=&quot;150&quot; /&amp;gt;&amp;lt;/Grid&amp;gt;运行看看，在得知前一节现象的情况下，新的现象并没有出现多大的意外。第三列凭空消失，第二列与之之间依然失去了 1:2 的比例关系。然而，我们还可以缩小窗口。缩小窗口后竟然为什么在缩小窗口的时候突然间出现了那个红色的 Border？为什么在红色 Border 的右边还留有空白？如果说第一节中我们认识到右对齐时右边剩余的空白空间会丢掉，那么为什么此时右边剩余的空白空间会突然出现？我试着稍微增加第二个 Border 的宽度，突然间，刚刚缩小窗口时的行为也能复现！自动尺寸也能玩比例现在，我们抛弃之前的右对齐测试方法，也不再使用预期按比例划分空间的 *。我们使用 Auto 来实现比例功能。&amp;lt;Grid&amp;gt; &amp;lt;Grid.ColumnDefinitions&amp;gt; &amp;lt;ColumnDefinition Width=&quot;Auto&quot; /&amp;gt; &amp;lt;ColumnDefinition Width=&quot;Auto&quot; /&amp;gt; &amp;lt;ColumnDefinition Width=&quot;Auto&quot; /&amp;gt; &amp;lt;/Grid.ColumnDefinitions&amp;gt; &amp;lt;Border Width=&quot;159&quot; Grid.ColumnSpan=&quot;3&quot; HorizontalAlignment=&quot;Center&quot; Background=&quot;PaleGreen&quot; /&amp;gt; &amp;lt;Border Width=&quot;28&quot; HorizontalAlignment=&quot;Left&quot; Background=&quot;#7FFF6347&quot; /&amp;gt; &amp;lt;Border Width=&quot;51&quot; Grid.Column=&quot;1&quot; HorizontalAlignment=&quot;Center&quot; Background=&quot;#7FC71585&quot; /&amp;gt; &amp;lt;Border Width=&quot;28&quot; Grid.Column=&quot;2&quot; HorizontalAlignment=&quot;Right&quot; Background=&quot;#7F008080&quot; /&amp;gt;&amp;lt;/Grid&amp;gt;具体说来，我们有四个 Border 了，放在 Auto 尺寸的三列中。第一个 Border 横跨三列，尺寸比其他总和都长，达到了 159；剩下的三个 Border 各占一列，其中两边等长，中间稍长。那么实际布局中各列是怎么分的呢？以下是设计器为我们显示的列宽：46、69、46 是怎么来的？莫非是 46:69 与 28:51 相同？然而实际计算结果却并不是！可万一这是计算误差呢？那么我们再来看看三个 Border 的另外两组值：50:50:50 和 25:50:25。▲ 50:50:50▲ 25:50:2550:50:50 最终得到的是相同比例，但是 25:50:25 得到的列宽比例与 1:2 相去甚远。也就是说，其实 Grid 内部并没有按照元素所需的尺寸来按比例计算列宽。相同比例也能有不同尺寸在上一节的试验中，不管比例如何，至少相同的设置尺寸带来了相同的最终可见尺寸。然而，就算是这一点，也是能被颠覆的。现在，我们将 3 列换成 4 列，Border 数量换成 6 个。&amp;lt;Grid&amp;gt; &amp;lt;Grid.ColumnDefinitions&amp;gt; &amp;lt;ColumnDefinition Width=&quot;Auto&quot; /&amp;gt; &amp;lt;ColumnDefinition Width=&quot;Auto&quot; /&amp;gt; &amp;lt;ColumnDefinition Width=&quot;Auto&quot; /&amp;gt; &amp;lt;ColumnDefinition Width=&quot;Auto&quot; /&amp;gt; &amp;lt;/Grid.ColumnDefinitions&amp;gt; &amp;lt;Border Width=&quot;159&quot; Grid.ColumnSpan=&quot;3&quot; HorizontalAlignment=&quot;Center&quot; Background=&quot;PaleGreen&quot; /&amp;gt; &amp;lt;Border Width=&quot;159&quot; Grid.Column=&quot;1&quot; Grid.ColumnSpan=&quot;3&quot; HorizontalAlignment=&quot;Center&quot; Background=&quot;PaleGreen&quot; /&amp;gt; &amp;lt;Border Width=&quot;28&quot; HorizontalAlignment=&quot;Left&quot; Background=&quot;#7FFF6347&quot; /&amp;gt; &amp;lt;Border Width=&quot;51&quot; Grid.Column=&quot;1&quot; HorizontalAlignment=&quot;Center&quot; Background=&quot;#7FC71585&quot; /&amp;gt; &amp;lt;Border Width=&quot;51&quot; Grid.Column=&quot;2&quot; HorizontalAlignment=&quot;Center&quot; Background=&quot;#7FC71585&quot; /&amp;gt; &amp;lt;Border Width=&quot;28&quot; Grid.Column=&quot;3&quot; HorizontalAlignment=&quot;Right&quot; Background=&quot;#7F008080&quot; /&amp;gt;&amp;lt;/Grid&amp;gt;具体来说，第一个 Border 跨前三列，第二个 Border 跨后三列，跟前一节的长 Border 一样长。第三和第六个 Border 分在两边，与之前的短 Border 一样短。中间的两个 Border 与之前中间的 Border 一样长。就像下图所示的这样。那么此时布局出来的列宽是多少呢？▲ 32:65:65:39等等！那个 39 是怎么来的？如果前一节里相等尺寸的 Border 会得到相等尺寸的列宽，那么这里也将颠覆！事实上，即便此时列宽比例与元素所需比例一致，在这种布局下也是有无穷多个解的。WPF 只是从这无穷多个解中挑选了一个出来——而且，还无法解释！总结 Grid 未定义的规则总而言之，言而总之，Grid 布局在特殊情况下是有一些不合常理的。我称之为“未定义的规则”。这些未定义的规则总结起来有以下三点： 在无穷大布局空间时的 * 的比例 在跨多列布局时 * 的比例 在全 Auto 尺寸时各列尺寸不过你也可能会吐槽我的用法不对，可是，作为一个连表现行为都公开的 API，其行为也是 API 的一部分，应该具有明确可追溯可文档化的行为；而不是由用户去探索，最终无法猜测可发生事情的行为。微软没有任何官方文档公开了这些诡异的行为，我也没有在任何第三方资料中找到这样的行为（这些都是我自己总结的）。我认为，微软没有为此公开文档是因为行为太过诡异，无法编写成文档！你可能还会质疑，可以去 Reference Source 查阅 Grid 布局的源码，那样就能解释这些诡异的行为了。确实如此，那里是这一切诡异布局背后的罪魁祸首。我阅读过 Grid 的布局源码，但没能全部理解，而且在阅读的过程中发现了一些微软官方承认的 Bug（我也没有能力去解决它）。不过，我整整三天的时间写了一个全新的 Grid 布局算法（感谢 @林德熙 抽出时间跟我探讨 Grid 的布局算法）。在新的算法中，对于微软公开的 Grid 布局行为，我跟它的表现是一样的。对于本文中提到的各种 Bug，我找不到手段实现跟它一模一样的布局结果，但是，我可以文档化地完全确定 Grid 整个布局的所有行为。包括以上所有我认为的“未定义的规则”。新 Grid 布局算法的源码在 GitHub 上，我提交给了 Avalonia：A new grid layout algorithm to improve performance and fix some bugs by walterlv · Pull Request #1517 · AvaloniaUI/Avalonia。" }, { "title": "The undefined behaviors of WPF Grid (the so-called bugs)", "url": "/post/the-bugs-of-grid-en.html", "categories": "", "tags": "wpf, uwp, xaml", "date": "2018-08-12 16:04:03 +0800", "snippet": "As long as you write code in XAML, I bet you must have used Grid in various ways. I wonder if you have seen any strange layout results of Grid.I’ll talk about the undefined behaviors of Grid layout in this post. I call them the bugs.This post is written in multiple languages. Please select yours: 中文 English Reading Tips: All of the examples described in this article are not common usages for Grid. (Microsoft is a great company. It will never do strange things on common situation.)Star Unit on Infinite spaceCopy and paste the code below and run to view the result:&amp;lt;Canvas&amp;gt; &amp;lt;Grid Height=&quot;100&quot;&amp;gt; &amp;lt;Grid.ColumnDefinitions&amp;gt; &amp;lt;ColumnDefinition Width=&quot;100&quot; /&amp;gt; &amp;lt;ColumnDefinition Width=&quot;*&quot; /&amp;gt; &amp;lt;ColumnDefinition Width=&quot;2*&quot; /&amp;gt; &amp;lt;/Grid.ColumnDefinitions&amp;gt; &amp;lt;Border Grid.Column=&quot;0&quot; Background=&quot;CornflowerBlue&quot; Width=&quot;150&quot; /&amp;gt; &amp;lt;Border Grid.Column=&quot;1&quot; Background=&quot;Tomato&quot; Width=&quot;150&quot; /&amp;gt; &amp;lt;Border Grid.Column=&quot;2&quot; Background=&quot;Teal&quot; Width=&quot;150&quot; /&amp;gt; &amp;lt;/Grid&amp;gt;&amp;lt;/Canvas&amp;gt;The 1st column is 100-pixel fixed-width. The 2nd column is *, and the 3rd one is 2*. Then what’s the visible width of the 2nd Border and the 3rd Border?PressF5inVisualStudiotoviewtheresultDid you predicate the result? Although the 2nd and the 3rd column width proportion is 1:2, the final visible proportion is 1:1.There are flaws here, because you may suspect that the 3rd column is already twice as much as the 2nd column, but the right side is blank and cannot be seen. So now, we remove the Canvas and use HorizontalAlignment=&quot;Right&quot;. The new code is shown below:&amp;lt;Grid HorizontalAlignment=&quot;Right&quot;&amp;gt; &amp;lt;Grid.ColumnDefinitions&amp;gt; &amp;lt;ColumnDefinition Width=&quot;100&quot; /&amp;gt; &amp;lt;ColumnDefinition Width=&quot;*&quot; /&amp;gt; &amp;lt;ColumnDefinition Width=&quot;2*&quot; /&amp;gt; &amp;lt;/Grid.ColumnDefinitions&amp;gt; &amp;lt;Border Grid.Column=&quot;0&quot; Background=&quot;CornflowerBlue&quot; Width=&quot;150&quot; /&amp;gt; &amp;lt;Border Grid.Column=&quot;1&quot; Background=&quot;Tomato&quot; Width=&quot;150&quot; /&amp;gt; &amp;lt;Border Grid.Column=&quot;2&quot; Background=&quot;Teal&quot; Width=&quot;150&quot; /&amp;gt;&amp;lt;/Grid&amp;gt;After running, you will find that there is no white space on the far right, that is to say, the 2nd and 3rd columns do not have a 1:2 ratio - they are equal.So where is the lost space? Let’s resize the window to check it.Even if there is space left on the left, the right side begins to clip the element space! Can we say that the length of a missing * length has gone to the left? Obviously not. However, we can guess that the clipping of the right side of the element begins at the 1:2 ratio.Star Unit at the Size Just RequiredHorizontalAlignment=&quot;True&quot; helps us a lot to distinguish whether the right side really occupies space. So we continue the testing on the right-alignment.Now, we modify the 2nd column Border to span the 2nd and 3rd columns. The 3rd column Border is placed into the 2nd column. (In other words, our 3rd column does not contain any Border.)&amp;lt;Grid HorizontalAlignment=&quot;Right&quot;&amp;gt; &amp;lt;Grid.ColumnDefinitions&amp;gt; &amp;lt;ColumnDefinition Width=&quot;100&quot; /&amp;gt; &amp;lt;ColumnDefinition Width=&quot;*&quot; /&amp;gt; &amp;lt;ColumnDefinition Width=&quot;2*&quot; /&amp;gt; &amp;lt;/Grid.ColumnDefinitions&amp;gt; &amp;lt;Border Grid.Column=&quot;0&quot; Background=&quot;CornflowerBlue&quot; Width=&quot;150&quot; /&amp;gt; &amp;lt;Border Grid.Column=&quot;1&quot; Grid.ColumnSpan=&quot;2&quot; Background=&quot;Tomato&quot; Width=&quot;150&quot; /&amp;gt; &amp;lt;Border Grid.Column=&quot;1&quot; Background=&quot;Teal&quot; Width=&quot;150&quot; /&amp;gt;&amp;lt;/Grid&amp;gt;The new behavior did not show much surprise to us because we have seen the behavior last section. The 3rd column disappeared, and the 2nd column still lost the 1:2 ratio.Narrow the window again.Narrowthe windowagaintoviewthe behaviorWhy did the tomato Border suddenly appear when the window was narrowing? Why is there a blank space on the right side of the tomato Border?If we have realized in the last post section that the right-side space is lost when it is right-aligned, why does the white space appear suddenly in the right-side again?I tried to slightly increase the width of the second Border. Suddenly, I reproduced the strange behavior that I reproduced just now when resizing the window!The Proportion of Auto SizeNow, abandon the previous right-aligned test method and no longer use the * width to separate the Grid. We use Auto instead.&amp;lt;Grid&amp;gt; &amp;lt;Grid.ColumnDefinitions&amp;gt; &amp;lt;ColumnDefinition Width=&quot;Auto&quot; /&amp;gt; &amp;lt;ColumnDefinition Width=&quot;Auto&quot; /&amp;gt; &amp;lt;ColumnDefinition Width=&quot;Auto&quot; /&amp;gt; &amp;lt;/Grid.ColumnDefinitions&amp;gt; &amp;lt;Border Width=&quot;159&quot; Grid.ColumnSpan=&quot;3&quot; HorizontalAlignment=&quot;Center&quot; Background=&quot;PaleGreen&quot; /&amp;gt; &amp;lt;Border Width=&quot;28&quot; HorizontalAlignment=&quot;Left&quot; Background=&quot;#7FFF6347&quot; /&amp;gt; &amp;lt;Border Width=&quot;51&quot; Grid.Column=&quot;1&quot; HorizontalAlignment=&quot;Center&quot; Background=&quot;#7FC71585&quot; /&amp;gt; &amp;lt;Border Width=&quot;28&quot; Grid.Column=&quot;2&quot; HorizontalAlignment=&quot;Right&quot; Background=&quot;#7F008080&quot; /&amp;gt;&amp;lt;/Grid&amp;gt;Specifically, we have four Border, placed in three columns of Auto size. The first Border spans three columns, and its size is longer than all the others, reaching 159. The remaining three Border each occupy a column, with two sides of equal length and a slightly longer middle.How are the columns in the actual layout divided? Here is the column width that the designer shows for us:Where do 46, 69, 46 come from? Could it be that the proportion of 46:69 is the same as that of 28:51? However, the actual calculation result is not!What if this is a calculation error?So let’s look at the other two sets of values ​​for the three Border: 50:50:50 and 25:50:25.▲ 50:50:50▲ 25:50:25In 50:50:50, we eventually get the 1:1:1 proportion. But the ratio of column widths in 25:50:25 is far from 1:2:1. That is, in fact, the Grid does not calculate the column widths by the proportion to the size of the element.The same Element Size but Different Column WidthIn the experiment in the previous section, we notice that the same size brought about the same final visible size regardless of the proportion. However, this conclusion still can be subverted.Now, we will replace 3 columns with 4 columns, and the number of Border will be replaced with 6.&amp;lt;Grid&amp;gt; &amp;lt;Grid.ColumnDefinitions&amp;gt; &amp;lt;ColumnDefinition Width=&quot;Auto&quot; /&amp;gt; &amp;lt;ColumnDefinition Width=&quot;Auto&quot; /&amp;gt; &amp;lt;ColumnDefinition Width=&quot;Auto&quot; /&amp;gt; &amp;lt;ColumnDefinition Width=&quot;Auto&quot; /&amp;gt; &amp;lt;/Grid.ColumnDefinitions&amp;gt; &amp;lt;Border Width=&quot;159&quot; Grid.ColumnSpan=&quot;3&quot; HorizontalAlignment=&quot;Center&quot; Background=&quot;PaleGreen&quot; /&amp;gt; &amp;lt;Border Width=&quot;159&quot; Grid.Column=&quot;1&quot; Grid.ColumnSpan=&quot;3&quot; HorizontalAlignment=&quot;Center&quot; Background=&quot;PaleGreen&quot; /&amp;gt; &amp;lt;Border Width=&quot;28&quot; HorizontalAlignment=&quot;Left&quot; Background=&quot;#7FFF6347&quot; /&amp;gt; &amp;lt;Border Width=&quot;51&quot; Grid.Column=&quot;1&quot; HorizontalAlignment=&quot;Center&quot; Background=&quot;#7FC71585&quot; /&amp;gt; &amp;lt;Border Width=&quot;51&quot; Grid.Column=&quot;2&quot; HorizontalAlignment=&quot;Center&quot; Background=&quot;#7FC71585&quot; /&amp;gt; &amp;lt;Border Width=&quot;28&quot; Grid.Column=&quot;3&quot; HorizontalAlignment=&quot;Right&quot; Background=&quot;#7F008080&quot; /&amp;gt;&amp;lt;/Grid&amp;gt;Specifically, the first Border spans the first three columns, and the second Border spans the last three columns, the same length as the long Border of the previous section. The third and sixth Borders are on two sides and are as short as the previous Border. The middle two Borders are as long as the previous Border. Just like the picture that is shown below.What is the width of the columns laid out at this time?▲ 32:65:65:39Wait! Where did the 39 come from? If the equal-size Border in the previous section would get equal-sized column widths, then this will also subvert! In fact, even if the proportion of the column width to the proportion of elements is the same at this time, there are as infinitely as many solutions under this layout. WPF picks only one out of this infinite number of solutions - and it cannot explain itself!The conclusion of the Grid undefined behaviorIn summary, the Grid layout has some unreasonable behaviors under special circumstances. I call them “the undefined behaviors”. These undefined behaviors are summarized in the following three points: Infinite layout space with * unit size * unit column/row with multiple-span elements Auto size in all column/rowHowever, you may think that I use the Grid in incorrect ways. However, as an API that exposes the behaviors, the behavior itself is also a part of the API. It should have clear traceable and documentable behavior instead of being explored and guess and failed by the user.Microsoft does not have any official documents that disclose these bizarre behaviors, and I have not found such behavior in any third-party references (this post is my own conclusion). I think that Microsoft did not publish this kind of documents because the behaviors are too bizarre to be documented!You may also be skeptical that I can go to Reference Source to check the source code of the `Grid’ layout, and then I can explain these strange behaviors. Indeed, the code there is the culprit behind this all-odd layout.I have read the layout source code of Grid, and I can’t understand all the logic of its layout algorithm, and I also have found out some official Microsoft-recognized bugs in my reading (But I have no ability to solve it).However, I have written a totally new Grid layout algorithm (thanks to @lindexi that he spend so much time on discussing the layout algorithm with me.). In the new algorithm, I do the same with Microsoft’s public documented Grid layout behavior. But for the various bugs mentioned in this post, I can’t find a way to achieve the same layout results as it does, but I can document and determine all the behaviors of the new Grid layout, without any undefined behavior.I’ve created a new pull request for the new Grid layout algorithm to Avalonia. Goto A new grid layout algorithm to improve performance and fix some bugs by walterlv · Pull Request #1517 · AvaloniaUI/Avalonia to view the source code and to see more details." }, { "title": "Introducing MSTestEnhancer to make unit test result easy to read", "url": "/post/introduce-mstest-enhancer.html", "categories": "", "tags": "csharp, dotnet, unittest", "date": "2018-08-12 16:03:10 +0800", "snippet": "Don’t you think that naming is very very hard? Especially naming for unit test method? Read this article for more data of naming: Don’t go into programming if you don’t have a good thesaurus - ITworld.MSTestEnhancer is a contract-style unit test extension for MSTestv2. You can write method contract descriptions instead of writing confusing test method name when writing unit tests. 中文 English You’ll get the test result like the picture shown below:▲ The unit test result that listed via ReSharper.Classical Style of Writing Unit TestsWe used to be recommended to write unit test like this:[TestClass]public class TheTestedClassTest{ [TestMethod] public void TheTestedMethod_Condition1_Expect1() { // Test code here... } [TestMethod] public void TheTestedMethod_Condition2_Expect2() { // Test code here... }}It is an example using MSTest. If we use NUnit or XUnit, we’ll get similar test code, too. Sometimes the conditions and expects are more complex, and we cannot write them down with only a few words. And the more complex the method name is, the more difficult for coders to read and comprehend them.Introduce MSTestEnhancerMSTestEnhancer is a MSTest v2 extension to connect unit test and the method that should be tested. You’ll find out that all unit test contracts are listed under target methods, and you can see all the result of them directly, no need to translate the obscure method name into what you want to test.Now, let’s start! Install MSTestEnhancer from the nuget.org. Write unit test code in the style listed below.Recommended Style of Writing Unit TestsAssuming that you want to test a class named TheTestedClass containing a method named TheTestedMethod. Then you can write unit tests like this: [TestClass] public class TheTestedClassTest { [ContractTestCase] public void TheTestedMethod() { &quot;When Xxx happens, results in Yyy.&quot;.Test(() =&amp;gt; { // Write test case code here... }); &quot;When Zzz happens, results in Www.&quot;.Test(() =&amp;gt; { // Write test case code here... }); } }Notice that the name of class and method are almost the name of the tested class and tested method. As a result, we don’t need to think about anything about naming unit test, nor to read the obscure name of the unit test.Advanced UsagesUnit Test with ArgumentsSome unit tests need multiple values to verify the contracts, so MSTestEnhancer provides WithArguments method to config the arguments.&quot;prime number.&quot;.Test((int num) =&amp;gt;{ // Write test case code here...}).WithArguments(2, 3, 5, 7, 11);&quot;{0} is not a prime number.&quot;.Test((int num) =&amp;gt;{ // Write test case code here...}).WithArguments(1, 4);You can pass up to 8 parameters into the test case.&quot;Contract 1: {0} and {1} are allowed in the contract description.&quot;.Test((int a, int b) =&amp;gt;{ // Now, a is 2 and b is 3.}).WithArguments(2, 3);&quot;Contract 2&quot;.Test((int a, int b) =&amp;gt;{ // Now the test case will run twice. The first group, a is 2 and b is 3; and the second group, a is 10 and b is 20. // ValueTuple is supported, too.}).WithArguments((2, 3), (10, 20));In this example, the contract description will be replaced to the arguments that you have passed into.Async Unit TestAll Test extension method support async action so that you can test any async method.Some Fantastic FeatureNested unit test classes are supported by MSTest v2, so you can write an infinite level unit test tree." }, { "title": "不再为命名而苦恼！使用 MSTestEnhancer 单元测试扩展，写契约就够了", "url": "/post/get-rid-or-naming-in-unit-test.html", "categories": "", "tags": "csharp, dotnet, unittest", "date": "2018-08-12 16:02:57 +0800", "snippet": "有没有觉得命名太难？有没有觉得单元测试的命名更难？没错，你不是一个人！看看这个你就知道了：程序员最头疼的事：命名 或它的英文原文 Don’t go into programming if you don’t have a good thesaurus - ITworld。立刻前往 nuget.org 下载安装 MSTestEnhancer 即可解决命名的苦恼。 中文 English 体验 MSTestEnhancer看看苦恼的单元测试怎么写：[TestClass]public class 被测类名Test{ [TestMethod] public void 被测方法名_条件1_预期1() { // 测试用例代码 } [TestMethod] public void 被测方法名_条件2_预期2() { // 测试用例代码 }}这是以 MSTest 为例，但 NUnit、XUnit 等编写体验于此也类似，都需要为测试方法命名。在这个例子中，我们写了中文的 条件 和 预期，在实际编写时，可能是更加复杂的短句，例如：ArgumentNull、ThrowsArgumentNullException，于是最终的方法名可能是 TargetMethod_ArgumentNull_ThrowsArgumentNullException。这样的方法多了也就难以读懂单元测试的代码了。然而现在看看 MSTestEnhancer 的单元测试怎么写：[TestClass]public class 被测类名Test{ [ContractTestCase] public void 被测方法名() { &quot;契约 1（当 Xxx 时，应该发生 Yyy）&quot;.Test(() =&amp;gt; { // 测试用例代码 }); &quot;契约 2（但当 Zzz 时，应该发生 Www）&quot;.Test(() =&amp;gt; { // 测试用例代码 }); }}有没有觉得很直观？条件和预期直接以中文字符串的形式写在了代码里，所有契约的阅读一目了然。而且由于不需要再写条件和预期了，所以测试方法名可以与被测方法名完全一样。也就是说——再也不用为单元测试的方法取名字而伤透脑筋了。可是，工具支持呢？不要紧，在工具中也能显示中文的契约，Visual Studio 中的测试管理器和 ReSharper 测试结果页都支持显示这些中文的契约。以下是 ReSharper 的单元测试结果页视图：每个契约按照方法名归类防止，测试结果一目了然。参数化的单元测试有些契约需要更多的值组合来验证正确性，那么可以在契约测试用例的后面添加参数。&quot;质数&quot;.Test((int num) =&amp;gt;{ // 测试用例代码}).WithArguments(2, 3, 5, 7, 11);&quot;{0} 不是质数&quot;.Test((int num) =&amp;gt;{ // 测试用例代码}).WithArguments(1, 4);也可以添加多个参数（最多支持 8 个）：&quot;契约 1，参数中可以带 {0} 和 {1}。&quot;.Test((int a, int b) =&amp;gt;{ // 现在，a 会等于 2，b 会等于 3。}).WithArguments(2, 3);&quot;契约 2&quot;.Test((int a, int b) =&amp;gt;{ // 现在有两组代码，一组 a=2, b=3；另一组 a=10, b=20。 // 当然也可以传入元组数组。}).WithArguments((2, 3), (10, 20));在显示单元测试结果时，如果契约字符串中含有格式化占位符 {0}、{1} 等，会被自动替换为参数的值。异步的单元测试Test 方法中传入的每个 Action 都支持 async 关键字，并会在执行测试用例时等待异步操作结束。额外的黑科技MSTest v2 支持嵌套类型的单元测试。也就是说，我们可以利用这一点做出近乎无限层级的单元测试树出来。" }, { "title": "使 WPF 支持触摸板的横向滚动", "url": "/post/handle-horizontal-scrolling-of-touchpad.html", "categories": "", "tags": "windows, wpf", "date": "2018-08-12 16:02:51 +0800", "snippet": "微软终于开始学苹果一样好好做触摸板了（就是键盘空格键下面那一大块）。然而鉴于以前没有好好做，以至于 WPF 程序甚至都没有对触摸板的横向滚动提供支持（竖向滚动是直接使用了 MouseWheel，汗……）。但有些功能真希望能够支持横向滚动！本文将介绍让触摸板支持横向滚动的方法，本质上也是用 MouseWheel，但却支持了横向。 中文 English ▲ 精确式触摸板我们需要从 Windows 的窗口消息中获取 WM_MOUSEHWHEEL 消息。对，就是鼠标滚轮消息！以前我们只取了纵向数据，现在我们要取横向数据。首先，我们需要能够监听得到消息才行。重写 Window 的 OnSourceInitialized 方法可以开始监听消息；如果代码没办法写到 Window 中，可以通过 Window.GetWindow(DependencyObject) 获取到窗口实例后监听它的 SourceInitialized 事件。如果拿不到这样的时机，则只要在任何 SourceInitialized 之后的时机（比如 Loaded）都可以写下面方法内部的两行代码。protected override void OnSourceInitialized(EventArgs e){ var source = PresentationSource.FromVisual(_board); ((HwndSource) source)?.AddHook(Hook);}private IntPtr Hook(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam, ref bool handled){ // 在这里添加消息的处理。 return IntPtr.Zero;}接下来，我们开始处理 WM_MOUSEHWHEEL：const int WM_MOUSEHWHEEL = 0x020E;private IntPtr Hook(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam, ref bool handled){ switch (msg) { case WM_MOUSEHWHEEL: int tilt = (short) HIWORD(wParam); OnMouseTilt(tilt); return (IntPtr) 1; } return IntPtr.Zero;}/// &amp;lt;summary&amp;gt;/// 取指针所在高位数值。/// &amp;lt;/summary&amp;gt;private static int HIWORD(IntPtr ptr){ var val32 = ptr.ToInt32(); return ((val32 &amp;gt;&amp;gt; 16) &amp;amp; 0xFFFF);}/// &amp;lt;summary&amp;gt;/// 取指针所在低位数值。/// &amp;lt;/summary&amp;gt;private static int LOWORD(IntPtr ptr){ var val32 = ptr.ToInt32(); return (val32 &amp;amp; 0xFFFF);}private void OnMouseTilt(int tilt){ // 这里就是触摸板横向滚动的时机，参数是横向滚动的数值，就像鼠标滚轮纵向滚动的数值一样。}OnMouseTilt 中就可以写我们触摸板横向滚动的处理代码。以上代码都可以封装成通用的方法，在 OnMouseTilt 中抛出一个类似于 MouseWheel 一样的事件是非常好的选择。微软的 Microsoft Sculpt Comfort Mouse 鼠标滚轮也是支持横向滚动的，以上方法也可以支持。" }, { "title": "Support Horizontal Scrolling of TouchPad in WPF Application", "url": "/post/handle-horizontal-scrolling-of-touchpad-en.html", "categories": "", "tags": "windows, wpf", "date": "2018-08-12 16:02:37 +0800", "snippet": "Finally, Microsoft started to support touchpad like Apple did years ago. As Microsoft never do well in touchpad, WPF application even doesn’t support horizontal scrolling of touchpad. Also, WPF uses MouseWheel to handle vertical scrolling, not a particular method.This article contains my method to support horizontal scrolling of touchpad in a WPF application. It uses MouseWheel indeed, but horizontals and verticals are all supported. 中文 English ▲ Precision TouchpadWe need to fetch WM_MOUSEHWHEEL message from our WPF window. Yes! That mouse wheel message. We fetch vertical data from it before, but we now fetch horizontal data from it.At first, we should hook the window message. override OnSourceInitialized method of a Window. If you could not write code in Window, SourceInitialized event of a Window is also a choice. (You can get the Window instance by using Window.GetWindow(DependencyObject) method.) If you cannot get the opportune moment, you can also write code after SourceInitialized event such as Loaded event or others.protected override void OnSourceInitialized(EventArgs e){ var source = PresentationSource.FromVisual(_board); ((HwndSource) source)?.AddHook(Hook);}private IntPtr Hook(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam, ref bool handled){ // Handle window message here. return IntPtr.Zero;}Next, let’s handle WM_MOUSEHWHEEL:const int WM_MOUSEHWHEEL = 0x020E;private IntPtr Hook(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam, ref bool handled){ switch (msg) { case WM_MOUSEHWHEEL: int tilt = (short) HIWORD(wParam); OnMouseTilt(tilt); return (IntPtr) 1; } return IntPtr.Zero;}/// &amp;lt;summary&amp;gt;/// Gets high bits values of the pointer./// &amp;lt;/summary&amp;gt;private static int HIWORD(IntPtr ptr){ var val32 = ptr.ToInt32(); return ((val32 &amp;gt;&amp;gt; 16) &amp;amp; 0xFFFF);}/// &amp;lt;summary&amp;gt;/// Gets low bits values of the pointer./// &amp;lt;/summary&amp;gt;private static int LOWORD(IntPtr ptr){ var val32 = ptr.ToInt32(); return (val32 &amp;amp; 0xFFFF);}private void OnMouseTilt(int tilt){ // Write your horizontal handling codes here.}You can write horizontal scrolling code in OnMouseTilt method.Better yet, you could pack all the codes above in a more common class and raise a MouseTilt event just like raising MouseWheel event.By the way, Microsoft Sculpt Comfort Mouse support horizontal scrolling also, and my codes above here support this kind of mouse.References c# - WPF - Two Finger Horizontal scrolling on Macbook pro trackpad - Stack OverflowThat’s my answer!" }, { "title": "图片点击放大，你的网页也能做到！", "url": "/post/create-click-to-zoom-image-for-web-pages.html", "categories": "", "tags": "site", "date": "2018-08-12 14:52:05 +0800", "snippet": "我经常在博客中插入大图，然而总需要借助浏览器的滚轮缩放功能放大观看实在是不方便。于是我希望做一个点击即放大的功能。下面就是一张可点击放大的图片，你可以点击试试！当然，我期望的效果是自动对所有博客中的图片生效。▲ Fluent Design App Header创建一个用于放图片的 HTML 节点如果你是普通的 HTML 网页，可以将下面的片段放入到你的页面中。&amp;lt;div id=&quot;image-cover-modal&quot; class=&quot;image-cover-modal&quot;&amp;gt; &amp;lt;img id=&quot;image-cover-image&quot; class=&quot;image-cover-modal-content&quot;&amp;gt; &amp;lt;div id=&quot;image-cover-caption&quot;&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;最外层是容器，里面包含一个关闭按钮，一张图片和一个图片标题。为图片的 HTML 节点添加 CSS 样式.image-cover-modal { display: flex; align-items: center; justify-content: center; opacity: 0; position: fixed; z-index: 30; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgb(0,0,0); background-color: rgba(0,0,0,0.9); transition: opacity ease 0.3s; pointer-events: none;}.model-shown { pointer-events: all; opacity: 1;}.image-cover-modal-content { display: block; max-width: 80%; max-height: 80%;}#image-cover-caption { display: block; position: absolute; width: 100%; height: 3rem; bottom: 0; line-height: 3rem; text-align: center; color: #fff; background: rgba(255, 255, 255, 0.33);}@media only screen and (max-width: 45rem){ .image-cover-modal-content { max-width: 100%; max-height: 100%; }}添加放大图片的 JS 脚本// Get the DOMvar modal = document.getElementById(&#39;image-cover-modal&#39;);var modalImg = document.getElementById(&quot;image-cover-image&quot;);var captionText = document.getElementById(&quot;image-cover-caption&quot;);var span = document.getElementsByClassName(&quot;image-cover-close&quot;)[0];// When the user clicks on &amp;lt;span&amp;gt; (x), close the modalmodal.onclick = function() { this.classList.remove(&quot;model-shown&quot;);}var i;for (i = 0; i &amp;lt; document.images.length; i++) { // Get the image and insert it inside the modal - use its &quot;alt&quot; text as a caption var img = document.images[i]; img.onclick = function(){ modal.classList.add(&quot;model-shown&quot;); modalImg.src = this.src; captionText.innerHTML = this.alt; }}专为 Jekyll 设计的简化版本如果你使用 Jekyll 搭建静态网页，那么只需要修改 3 个地方： 在 main.css 中添加前面的 css 片段。 在你想要添加放大图片的页面布局（例如 post.html）中添加 {% include clickable-image.html %}。 在 _includes 文件夹中添加一个 clickable-image.html 文件，存放以下内容。&amp;lt;div id=&quot;image-cover-modal&quot; class=&quot;image-cover-modal&quot;&amp;gt; &amp;lt;img id=&quot;image-cover-image&quot; class=&quot;image-cover-modal-content&quot;&amp;gt; &amp;lt;div id=&quot;image-cover-caption&quot;&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;script&amp;gt;// Get the DOMvar modal = document.getElementById(&#39;image-cover-modal&#39;);var modalImg = document.getElementById(&quot;image-cover-image&quot;);var captionText = document.getElementById(&quot;image-cover-caption&quot;);var span = document.getElementsByClassName(&quot;image-cover-close&quot;)[0];// When the user clicks on &amp;lt;span&amp;gt; (x), close the modalmodal.onclick = function() { this.classList.remove(&quot;model-shown&quot;);}var i;for (i = 0; i &amp;lt; document.images.length; i++) { // Get the image and insert it inside the modal - use its &quot;alt&quot; text as a caption var img = document.images[i]; img.onclick = function(){ modal.classList.add(&quot;model-shown&quot;); modalImg.src = this.src; captionText.innerHTML = this.alt; }}&amp;lt;/script&amp;gt;你可以参考我的文件： /_includes/clickable-image.html /_layouts/post.html /assets/css/main.css at master · walterlv/walterlv.github.io参考资料 How To Create Modal Images" }, { "title": "语法高亮不够漂亮？这里有你想要的 Rouge 主题", "url": "/post/available-themes-of-rouge-style.html", "categories": "", "tags": "site", "date": "2018-08-12 14:51:50 +0800", "snippet": "写了那么久的代码，找到了满意的代码着色风格吗？想必文本编辑器的代码着色风格你已经找到了中意的了，那么你在网上 post 上去的代码呢？Rouge 是一款基于 Ruby 的语法高亮工具，能为你的代码生成漂亮的语法高亮样式。本文将介绍如何使用它，并为大家提供它默认的语法高亮样式预览。在 Jekyll 中使用 Rouge 语法高亮插件Jekyll 中的 __config.yml 文件记录了 Jekyll 的最核心配置。其中，markdown 字段的值表示使用哪一款插件来将 Markdown 文本转换为 HTML 页面结构。GitHub 推荐使用的 Jekyll 的 Markdown 插件为 kramdown。kramdown 是一个强大且高性能的文本转换引擎，你可以通过阅读 kramdown 和 markdown 较大的差异比较 - Hom 了解 kramdown 的强大之处。不过，我们现在关系的是它可以使用的语法高亮工具 —— Rouge。在 Jekyll 的配置文件中这样配置它们：markdown: kramdownkramdown: input: GFM syntax_highlighter: rouge其中，input: GFM 指的是 GitHub Flavored Markdown Spec。Rouge 支持的语言可以前往此处查看：Rouge生成 Rouge 语法高亮样式当然，以上配置只是告诉 kramdown 转换引擎在转换 Markdown 为 HTML 的时候，使用 rouge 格式的样式（具体只语法高亮所用的 css 的 class）。我们需要另外使用 rougify 工具生成对应的样式文件才行。你需要先配好 Ruby 环境。如果没有配好，推荐阅读 快速在 Windows 上搭建 Jekyll 开发环境 快速配置。随后，你便可以使用命令来安装 Rouge。$ gem install rouge安装之后，使用以下命令查看自带的样式有哪些：$ rougify help style随后得到的输出中可以得知样式有很多种。usage: rougify style [&amp;lt;theme-name&amp;gt;] [&amp;lt;options&amp;gt;]Print CSS styles for the given theme. Extra options arepassed to the theme. Theme defaults to thankful_eyes.options: --scope (default: .highlight) a css selector to scope byavailable themes: base16, base16.dark, base16.light, base16.monokai, base16.monokai.dark, base16.monokai.light, base16.solarized, base16.solarized.dark, base16.solarized.light, colorful, github, gruvbox, gruvbox.dark, gruvbox.light, igorpro, molokai, monokai, monokai.sublime, thankful_eyes, tulip使用以下命令生成一个 github 风格的样式到 assets/css/syntax.css 文件中：$ rougify style github &amp;gt; assets/css/syntax.css别忘了在你的 &amp;lt;head&amp;gt; 中把这份 css 文件加进去哦！&amp;lt;link rel=&quot;stylesheet&quot; href=&quot;{{ &quot;/assets/css/syntax.css&quot; | prepend: site.baseurl }}&quot;&amp;gt;Rouge 自带语法高亮主题预览虽然 Rouge 自带了很多种不同的语法高亮样式，但都没有办法直接看到语法高亮的效果。于是我尝试了一些，并贴出了我的 C# 代码在 Rouge 自带语法高亮主题下的效果。一般来说很难找到一种语法高亮适用于各种语言，所以选择的时候推荐选一个差不多的，然后再慢慢改。以下每张图片的后面都标注了这种风格主题再 rouge 中的名称，使用上一节中提到的命令可以生成语法高亮样式。▲ github 需要额外设置前景色 #24292e▲ colorful▲ monokai.sublime▲ tulip▲ thankful_eyes▲ monokai▲ molokai▲ igorpro▲ gruvbox.dark▲ gruvbox▲ base16我修改的样式我发现我以前的样式与 monokai.sublime 是很接近的。这应该算是巧合，因为此前我是仿我的 VSCode 主题 One Dark Pro Vivid。既然如此，我就直接基于 monokai.sublime 修改好了。我将默认文字颜色从白色 #ffffff 改成了 #bbbbbb，然后将 diff 的颜色也修改成 monokai 的样式。点击下载 syntax.monokai.sublime.css参考资料 Plugins - Jekyll • Simple, blog-aware, static sites kramdown 和 markdown 较大的差异比较 - Hom GitHub Flavored Markdown Spec jneen/rouge: A pure-ruby code highlighter that is compatible with pygments http://rouge.jneen.net/ Rouge" }, { "title": "为博客或个人站点的 Markdown 添加 LaTeX 公式支持", "url": "/post/add-latex-support-for-web-pages.html", "categories": "", "tags": "site, web, vscode", "date": "2018-08-12 14:51:35 +0800", "snippet": "LaTeX 是一套排版系统，原生包含对科学和技术型文档内容的支持，而 LaTeX 公式（LaTeX math and equations）则是这种支持中非常重要的一部分。如果能够在博客或个人站点中使用到 LaTeX 的排版系统，或者说只是其中的数学公式部分，对学术性（或者只是使用到了部分数学原理）文章来说将会非常方便。本文将推荐一些脚本，以便添加 LaTeX 数学公式的支持。为站点添加 LaTeX 公式支持在你的站点中添加 MathJax.js 的支持即可。比如添加下面这段代码：&amp;lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&amp;gt;&amp;lt;/script&amp;gt;比如机器学习中的线性模型：\\[h_\\theta(x) = \\theta_1 x_1 + \\theta_2 x_2 + ... \\theta_n x_n = \\sum_{i=1}^n \\theta_i x_i\\]以及它的向量形式：\\[h_\\theta(x) = \\theta^T x\\]可以使用如下的 LaTeX 公式写出：$$h_\\theta(x) = \\theta_1 x_1 + \\theta_2 x_2 + ... \\theta_n x_n = \\sum_{i=1}^n \\theta_i x_i$$$$h_\\theta(x) = \\theta^T x$$而你所需做的，仅仅只是在 &amp;lt;head&amp;gt; 中加入如上那段 js 脚本。如果你希望写出更复杂的 LaTeX 公式，可以参考 Latex 公式速查。为 VSCode 编辑器添加 LaTeX 公式支持在 VSCode 插件商店中搜索 latex 可以得到不少的插件，我使用的是目前有 106K 下载量的 Markdown+Math 插件。在 VSCode 中，只需要预览 Markdown，即可看到这样的 LaTeX 公式支持：参考资料 Easily Add LaTeX Support To Jekyll Latex 公式速查" }, { "title": "为博客添加可切换的暗色和亮色主题", "url": "/post/add-light-dark-theme-support-for-blogs.html", "categories": "", "tags": "site, html, javascript, css", "date": "2018-08-12 14:50:56 +0800", "snippet": "不知从什么时候开始，越来越多的小伙伴喜欢在暗色的编辑器中编写代码；于是写博客的小伙伴们也得在博客中顺应这样的潮流，这样才能更接近平时写代码时的环境。然而——绝大多数的技术类博客或技术文章都是亮色主题的，代码在其中以和谐但不太好看的亮色存在，或者扎眼但熟悉的暗色存在。这始终觉得不那么舒适。于是，作为博主，我决定考虑添加亮色和暗色两种主题色的支持。如果你也喜欢这样的方式，可以读一读本文，快速 get 到修改方法。主题色改变的原理html/css 带来的样式改变是非常简单的，html 中的 class 对应 css 中的样式即可完成各种各样的风格变化。所以，我们考虑在 body 上额外添加一个 class，名为 dark-theme；运行时动态切换这个 class 的存在与否，我们便能在整个 body 范围之内切换样式。而对于 css，我们为每一个与主题色相关的颜色添加一个与之对应的 dark-theme 样式。那么，我们只需要即时切换 body 的 dark-theme 的出现与否，就能让浏览器为我们使用全新的样式和颜色。编写 css第一个要改变的，当然是背景色了。如果原来的背景色是设置到 body 上的，那么我们就通过 .dark-theme 指定一个暗色版的背景色。body { background: white}body.dark-theme { background: #282c34}还有前景色。当然，我们只改颜色，其他的不改：.post-content p,.post-content h1,.post-content h2,.post-content h3,.post-content h4,.post-content h5,.post-content ul,.post-content ol,.post-content iframe,.post-content div.post-inline { color: #4F4F4F; font-weight: 400;}body.dark-theme .post-content p,body.dark-theme .post-content h1,body.dark-theme .post-content h2,body.dark-theme .post-content h3,body.dark-theme .post-content h4,body.dark-theme .post-content h5,body.dark-theme .post-content ul,body.dark-theme .post-content ol,body.dark-theme .post-content iframe,body.dark-theme .post-content div.post-inline { color: white}不过，在暗色背景下，我希望标题不需要加粗，只需要更亮即可：.post-content h1,.post-content h2,.post-content h3,.post-content h4,.post-content h5 { font-weight: 700; font-style: normal}body.dark-theme .post-content h1,body.dark-theme .post-content h2,body.dark-theme .post-content h3,body.dark-theme .post-content h4,body.dark-theme .post-content h5 { font-weight: 200}像这样依次改下去，直到整个页面的暗色看起来都比较协调。当然，如果希望立即能够看到效果，应该在 body 上加上 dark-theme 这个 class。编写 js其实我们的 js 只有一句话，就是切换 body 上的 dark-theme，所以我选择直接内联。我增加了一个按钮，直接在 onclick 中编写切换 class 的代码：&amp;lt;a title=&quot;切换黑白主题 (beta)&quot; onclick=&quot;document.body.classList.toggle(&#39;dark-theme&#39;);&quot;&amp;gt; &amp;lt;span&amp;gt;切换黑白主题 (beta)&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;这样，只需要点击这个按钮，即可完成黑白主题的切换。处理第三方评论系统这样不支持动态切换主题色的部件在我基本上改完之后，发现 Disqus 却没有办法很轻松地改掉。事实上，Disqus 的个人站点设置页面上可以选择亮色或者暗色主题，但是，那是静态的。那么如何解决评论系统的问题呢？运行时动态切换吗？似乎没找到方法。于是，我们可以使用设计巧妙地规避这个问题。我使用灰色背景替代之前的近黑色背景，然后加上周围的圆角；这样，第三方评论系统的样式便似乎是本就这样设计一样：▲ 看起来还是很和谐的保存主题色简单的保存基本上就是使用 cookie，于是我准备了一个 theme=dark 这样的键值对。如果存在，则使用暗色，否则使用亮色。并且，在切换时设置 cookie。于是完整的切换代码就像这样：&amp;lt;a href=&quot;#&quot; title=&quot;切换黑白主题 (beta)&quot; onclick=&quot;(function(){ document.body.classList.toggle(&#39;dark-theme&#39;); if (document.body.classList.contains(&#39;dark-theme&#39;)) { document.cookie = &#39;theme=dark&#39;; } else { document.cookie = &#39;theme=light&#39;; }})()&quot;&amp;gt; &amp;lt;span&amp;gt;切换黑白主题 (beta)&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt; if (document.cookie.split(&#39;;&#39;).filter((item) =&amp;gt; { return item.includes(&#39;theme=light&#39;) }).length) { document.body.classList.remove(&#39;dark-theme&#39;); }&amp;lt;/script&amp;gt;试试点击本文上面的“切换黑白主题”按钮吧！" }, { "title": "转义，解决花括号在 Jekyll 被识别成 Liquid 代码的问题", "url": "/post/jekyll/raw-in-jekyll.html", "categories": "", "tags": "site", "date": "2018-08-12 14:49:15 +0800", "snippet": "在 DependencyProperty.UnsetValue 的正确打开方式 和 合并 Jekyll 多种类型的页面 这两篇博客中，我都遇到了代码中的花括号被 Jekyll 识别为 Liquid 代码的问题。然而 Liquid 的问题还需 Liquid 来解。而 Liquid 的 raw 就是用来解决这个问题的。{% raw %}{% comment %} 这里是各种包含奇怪花括号 {{{0}}} 的地方 {% endcomment %}{% endraw %}参考资料 Jekyll 大括号 {% %} 转义 · Xiao" }, { "title": "合并 Jekyll 多种类型的页面", "url": "/post/jekyll/jekyll-concat.html", "categories": "", "tags": "site", "date": "2018-08-12 14:49:01 +0800", "snippet": "以前胡思乱想时，有时会讲给小伙伴们听，有时会将想法在微信上发给自己，但多数时候是没有后文的，让胡思乱想烂在脑中。还好多数时候我记得，就像我亲自记得 3 岁时候的一些故事一样。但今天大脑被一些凌乱的事情撑爆了，心情极度低落。正好近期学着写博客，于是想把一些胡思乱想的事情写在自己的站点上。阅读本文，将学到如何用 Jekyll 做多种类型的页面，并在首页的列表中将这些不同种类的页面合并按日期排序。制作除博客之外的新页面类型Jekyll 不止支持博客（post）页面类型，也可以支持自定义页面类型。当然博客是它唯一的内建类型（hard-coded type）。我希望独立于博客写一些其他的胡思乱想的随笔。为了避免影响到正常博客的列表，我决定采用自定义页面类型。第一步：在 _config.yml 文件中添加自定义页面类型集合collections: article: output: true其中，article 是我为自定义类型取的名称。第二步：添加自定义页面类型文件夹需要在 Jekyll 项目根目录建立一个 _article 文件夹，此名称与第一步的类型名称一致，前面加下划线。此后，在这个文件夹里放跟 _posts 文件夹中一样规则的文件用于写文章。（可选）第三步：添加自定义页面类型默认元数据defaults: - scope: path: &quot;_article&quot; type: &quot;article&quot; values: layout: &quot;post&quot; author: &quot;walterlv 吕毅&quot;这里我让 article 类型使用 post 类型的页面布局。（可选）第四步：添加自定义页面类型的页面列表就像 posts 列表的页面一样制作一个 article 列表。可以参考我的 posts 布局文件和 article 布局文件，两者几乎一样都是可以的，只是 article 遍历的时候使用 site.article。制作一个合并了博客和其他页面类型的页面列表我希望在首页中混杂我的博客和胡思乱想，于是必须将两种不同类型的集合合并。使用如下代码：{% assign all_posts = &quot;&quot; | split: &quot;&quot; %}{% for article in site.article %} {% assign all_posts = all_posts | push: article %}{% endfor %}{% for post in site.posts %} {% assign all_posts = all_posts | push: post %}{% endfor %}{% assign all_posts = all_posts | sort: date | reverse %}由于 Jekyll 没有 concat 方法，所以只好一个个地将集合项添加进新集合。集合生成好后，按照日期排序。此后，遍历以生成列表的时候使用 all_posts 集合即可。参考资料 Concat arrays in Jekyll(liquid) Sorting &amp;amp; ordering collections · Issue #2515 · jekyll/jekyll jekyll - For loops in Liquid: using reversed in conjunction with limit:1 - Stack Overflow" }, { "title": "让 GitHub Pages 强制使用 HTTPS（含码云的 gitee/oschina.io）", "url": "/jekyll/2017/09/17/force-https-for-github-pages.html", "categories": "", "tags": "site, git, github", "date": "2018-08-12 14:48:47 +0800", "snippet": "一天晚上在手机上浏览自己的博客时，发现居然充斥着各种恶心的广告！顿时内心犹如一万只神兽呼啸而过，不过又能怪谁呢？！为避免引起读者不适，不贴图，只放链接，感兴趣自己点开看：图 2、图 1。本文的重点其实是括号里的码云（gitee.io）。GitHub Pages去自己的 GitHub Pages 仓库页找了找设置项（https://github.com/walterlv/walterlv.github.io/settings），果然发现了有强制 https 设置。开启后再打开 walterlv.github.io，果然 https 了。码云的 Pages 服务GitHub Pages 设置得这么轻松，想必码云的 Pages 服务应该也不难吧……去这里找：没有。去设置里找，还是没有……于是去码云 QQ 群里问了问，得到答复是直接在地址栏输入 https://walterl.gitee.io 就会是 https 的。可是，大多数读者怎么会去注意到去输入 https 呢？只好做重定向了。于是在 Jekyll 的 GitHub 仓库中找到有人在讨论此问题：https://github.com/jekyll/jekyll-redirect-from/issues/18。根据其中的讨论，我在所有页面的头文件（其实就是 /_includes/head.html 文件）中写下了这么一段代码：&amp;lt;script&amp;gt; if ((window.location.protocol != &quot;https:&quot;)) window.location = window.location.toString().replace(/^http:/, &quot;https:&quot;);&amp;lt;/script&amp;gt;本地跑起来一看，傻眼了，居然本机下是 https://localhost:4000，这肯定无法打开页面啊。好吧，那就对本机多做个判断，于是形成了下面这段代码：&amp;lt;script&amp;gt; // 判断非本机且未使用 https 时，强制重定向到 https。 if ((!window.location.host.startsWith(&quot;localhost&quot;)) &amp;amp;&amp;amp; (window.location.protocol != &quot;https:&quot;)) window.location = window.location.toString().replace(/^http:/, &quot;https:&quot;);&amp;lt;/script&amp;gt;现在本文用的就是这个。不信？往上看，把地址栏里 https 的 s 去掉回车，是不是还是 https？" }, { "title": "如何搭建一个基于 GitHub Pages 的 Jekyll 静态博客（目录）", "url": "/jekyll/2017/09/15/setup-a-jekyll-blog.html", "categories": "", "tags": "site", "date": "2018-08-12 14:48:37 +0800", "snippet": "GitHub Pages 为个人、组织和项目提供了展示一些页面的方式，GitHub 帮助页的 User, Organization, and Project Pages 页面就有说明。这里，我们使用 GitHub Pages 来搭建自己的博客，正好也是里面说的给 User 用作展示的页面的用途。当然，GitHub 甚至直接在官方页面中告诉大家，你可以用来当作你的博客使用，就是这句 Create a blog and spread your ideas. Whatever you want!（译：创建一个博客来传播你的想法，反正想做什么都行！）本文将是一系列文章的目录，用于帮助你搭建一个看起来很专业的让你爱不释手的个人博客。有三篇是翻译文章，来自于 Vincent Daubry，会比较专业；其它是自己的原创文章，用于一些补充。目录： [译] 搭建一个托管在 GitHub Pages 的 Jekyll 博客，并添加 Disqus 评论功能 [原] Setup up a jekyll blog using github pages and disqus comments 在 Windows 系统上安装 Jekyll 环境 [译] 为 Jekyll 博客添加社交分享按钮 [原] Add social sharing buttons to your Jekyll blog [译] 为 Jekyll 博客做搜索引擎优化（SEO） [原] SEO for your Jekyll blog 将 GitHub Pages 设置为 https 安全链接" }, { "title": "[译] 搭建一个托管在 GitHub Pages 的 Jekyll 博客，并添加 Disqus 评论功能", "url": "/jekyll/2017/09/15/setup-a-jekyll-blog-1.html", "categories": "", "tags": "site", "date": "2018-08-12 14:46:55 +0800", "snippet": "本文翻译自 Setup up a jekyll blog using github pages and disqus comments，原作者 Vincent Daubry。想不想马上就开始搭建个人博客，简单易学，还好看？这篇文章将教你用 Jekyll 搭建博客，配上一款养眼的主题，然后跑在 GitHub Pages 上。为什么选用静态的站点生成器？相比于使用类似 WordPress 这样的 CMS（译者注：内容管理系统，允许用户在 Web 上创建和发布内容），我们有几条理由来选择使用静态站点生成器。对于本文来说，我们主要关注于 Jekyll 带给我们的简单： 上手容易（熟悉 Markdown 的话就更好了） 相当少的设置 部署方便，不需要运行服务器端程序 可以直接放到 GitHub 上用（感谢 GitHub Pages）即便是静态站点生成器，这里也列出了很多款，那凭什么选择 Jekyll？ 这可是当下最流行的静态站点生成器之一（不信看这里） GitHub 在用（GitHub 创始人 Tom Preston-Werner 编写） 基于 Ruby 生态系统挑选一款 Jekyll 博客主题默认的模板在设计上只能说一般般，不过你可以从 jekyllthemes.org 找到更棒的模板。你正在阅读的本站博客用的是 Read Only 模板，把它克隆下来你就可以开始啦。（译者注：原文博客用的模板是 clean-blog）强烈推荐把每个页面顶部那张默认的大图换一张，在 stock-up 你可以找到很多基于知识共享许可协议的高清大图。为了在本地预览效果，你需要先安装 Jekyll，参见这里。不过总体来说再复杂也只是这一句：gem install jekyll（译者注：然而 Windows 系统上复杂一点点，上面那个命令在 Windows 上其实是跑不起来的，如果你没有配好环境，请先阅读 快速在 Windows 上搭建 Jekyll 开发环境。）为了让 Jekyll 在你的电脑上跑起来，请阅读 Jekyll 基本用法。部署 Jekyll 博客要部署你的博客，你只需要做以下任意一件事即可：1. 手动生成静态博客jekyll build执行完后会将静态页面全部生成到 _site 文件夹下，然后把这个文件夹用 HTML 服务进行托管即可： 在远程服务器上运行 Apache 扔到亚马逊 S3 上作为静态站点 拷贝到 Dropbox 上作为公开的文件夹（不确定有没有用，算了还是别试了……）（译者注：这句话是原作者说的，不关我的事……）2. 用 GitHub Pages 托管，而你需要做的只是在 GitHub 上建一个这种名字的仓库：your_github_username.github.io每次你把你的 Jekyll 博客仓库推送到 GitHub 仓库上，GitHub 就会自动为你生成和部署静态站点。使用 Disqus 为你的博客添加评论功能添加 Disqus 评论功能非常简单： 去 Disqus 创建个账号 一步步开通 Disqus 站点账号之后，进入到 Universal Code install instructions 页面 将 Disqus 提供的代码贴到 _layout / post.html 文件里面(译者注：国内接入社会化评论需取得 ICP 备案，也就是说随着国内使用人数的增多，Disqus 随时有被屏蔽的可能性。)添加发邮件功能Clean-Blog 模板（译者注：就是原文博主用的那个模板）自带一个非常棒的“联系我”页，不过他发邮件用的是 PHP 脚本，GItHub Pages 不会执行任何 PHP 脚本，所以这对我们来说根本没用。不过好在还有其他很多提供邮件发送功能的服务商可用，我选的是 formspree 因为他简单还免费。因为我并不需要验证整个邮件表单是否有效（只需要验证值的合法性、检查下邮件格式对不对），所以我直接把 jqBootstrapValidation 删掉只用纯 HTML5 验证。“联系我”表单使用 JavaScript 提交，所以我依然保留了这部分代码，然后稍稍做了点修改：$(function() { $(&quot;#contactForm&quot;).submit(function(e) { e.preventDefault(); $.ajax({ url: &quot;//formspree.io/my@email.com&quot;, method: &quot;POST&quot;, data: $(this).serialize(), dataType: &quot;json&quot;, success: function(data){ // Success message $(&#39;#success&#39;).html(&quot;&amp;lt;div class=&#39;alert alert-success&#39;&amp;gt;&quot;); $(&#39;#success &amp;gt; .alert-success&#39;).html(&quot;&amp;lt;button type=&#39;button&#39; class=&#39;close&#39; data-dismiss=&#39;alert&#39; aria-hidden=&#39;true&#39;&amp;gt;&amp;amp;times;&quot;) .append(&quot;&amp;lt;/button&amp;gt;&quot;); $(&#39;#success &amp;gt; .alert-success&#39;) .append(&quot;&amp;lt;strong&amp;gt;Your message has been sent. &amp;lt;/strong&amp;gt;&quot;); $(&#39;#success &amp;gt; .alert-success&#39;) .append(&#39;&amp;lt;/div&amp;gt;&#39;); //clear all fields $(&#39;#contactForm&#39;).trigger(&quot;reset&quot;); }, error: function(){ // Fail message $(&#39;#success&#39;).html(&quot;&amp;lt;div class=&#39;alert alert-danger&#39;&amp;gt;&quot;); $(&#39;#success &amp;gt; .alert-danger&#39;).html(&quot;&amp;lt;button type=&#39;button&#39; class=&#39;close&#39; data-dismiss=&#39;alert&#39; aria-hidden=&#39;true&#39;&amp;gt;&amp;amp;times;&quot;) .append(&quot;&amp;lt;/button&amp;gt;&quot;); $(&#39;#success &amp;gt; .alert-danger&#39;).append(&quot;&amp;lt;strong&amp;gt;Sorry it seems that my mail server is not responding. Please try again later!&quot;); $(&#39;#success &amp;gt; .alert-danger&#39;).append(&#39;&amp;lt;/div&amp;gt;&#39;); //clear all fields $(&#39;#contactForm&#39;).trigger(&quot;reset&quot;); } }); });});于是现在你不用写后端也能发邮件啦！以上。如果你觉得这篇教程还有提升空间，欢迎留言评论。本文源码在这里：vdaubry.github.io（译者注：翻译版的在这里 walterlv.github.io）" }, { "title": "使用 C# 代码创建快捷方式文件", "url": "/post/create-shortcut-file-using-csharp.html", "categories": "", "tags": "windows, csharp, dotnet", "date": "2018-08-11 09:58:29 +0800", "snippet": "快捷方式是一种特殊的文件，扩展名为 lnk。有很多种方式来创建快捷方式，不过使用 C# 代码创建一个却并不那么容易。本文分享三种不同的方式创建快捷方式。随处可用的代码这是最方便的方式了，因为这段代码随便放到一段代码中就能运行：/// &amp;lt;summary&amp;gt;/// 为当前正在运行的程序创建一个快捷方式。/// &amp;lt;/summary&amp;gt;/// &amp;lt;param name=&quot;lnkFilePath&quot;&amp;gt;快捷方式的完全限定路径。&amp;lt;/param&amp;gt;/// &amp;lt;param name=&quot;args&quot;&amp;gt;快捷方式启动程序时需要使用的参数。&amp;lt;/param&amp;gt;private static void CreateShortcut(string lnkFilePath, string args = &quot;&quot;){ var shellType = Type.GetTypeFromProgID(&quot;WScript.Shell&quot;); dynamic shell = Activator.CreateInstance(shellType); var shortcut = shell.CreateShortcut(lnkFilePath); shortcut.TargetPath = Assembly.GetEntryAssembly().Location; shortcut.Arguments = args; shortcut.WorkingDirectory = AppDomain.CurrentDomain.SetupInformation.ApplicationBase; shortcut.Save();}以上代码为当前正在运行的程序创建一个快捷方式。当然，如果你希望给其他文件创建快捷方式，就改一改里面的代码吧，将 TargetPath 和 WorkingDirectory 改为其他参数。▲ 快捷方式属性（其中 Target 等同于上面的 TargetPath 和 Arguments 一起，Start in 等同于上面的 WorkingDirectory）引用 COM 组件引用 COM 组件 Interop.IWshRuntimeLibrary.dll 能够获得类型安全，不过本质上和以上方法是一样的。private static void CreateShortcut(string lnkFilePath, string args = &quot;&quot;){ var shell = new IWshRuntimeLibrary.WshShell(); var shortcut = (IWshRuntimeLibrary.IWshShortcut) shell.CreateShortcut(linkFileName); shortcut.TargetPath = Assembly.GetEntryAssembly().Location; shortcut.Arguments = args; shortcut.WorkingDirectory = AppDomain.CurrentDomain.SetupInformation.ApplicationBase; shortcut.Save();}兼容 .NET 3.5 或早期版本如果你还在使用 .NET Framework 3.5 或更早期版本，那真的很麻烦。同情你一下，不过也贴一段代码：private static void CreateShortcut(string lnkFilePath, string args = &quot;&quot;){ var shellType = Type.GetTypeFromProgID(&quot;WScript.Shell&quot;); var shell = Activator.CreateInstance(shellType); var shortcut = shellType.InvokeMember(&quot;CreateShortcut&quot;, BindingFlags.Public | BindingFlags.Instance | BindingFlags.InvokeMethod, null, shell, new object[] { linkFileName }); var shortcutType = shortcut.GetType(); shortcutType.InvokeMember(&quot;TargetPath&quot;, BindingFlags.Public | BindingFlags.Instance | BindingFlags.SetProperty, null, shortcut, new object[] { Assembly.GetEntryAssembly().Location }); shortcutType.InvokeMember(&quot;Arguments&quot;, BindingFlags.Public | BindingFlags.Instance | BindingFlags.SetProperty, null, shortcut, new object[] { args }); shortcutType.InvokeMember(&quot;WorkingDirectory&quot;, BindingFlags.Public | BindingFlags.Instance | BindingFlags.SetProperty, null, shortcut, new object[] { AppDomain.CurrentDomain.SetupInformation.ApplicationBase }); shortcutType.InvokeMember(&quot;Save&quot;, BindingFlags.Public | BindingFlags.Instance | BindingFlags.InvokeMethod, null, shortcut, null);}" }, { "title": "发布了一款库（或工具包），如何持续地编写更新日志（ChangeLog）？", "url": "/post/how-to-write-changelog-and-keep-it-updating.html", "categories": "", "tags": "dotnet", "date": "2018-08-05 17:35:23 +0800", "snippet": "据说程序员最讨厌的两件事是 “别人没有写文档” 和 “要我写文档”。编写更新日志可是也落入此怪圈呢！程序员不写文档来自 GitHub 的开源调查问卷结果直接显示，最令人头痛的莫过于文档了： Incomplete or outdated documentation is a pervasive problem, observed by 93% of respondents, yet 60% of contributors say they rarely or never contribute to documentation. When you run into documentation issues, help a maintainer out and open a pull request that improves them.▲ 来自 http://opensourcesurvey.org自动化我曾经试图找到一些自动化的方式来生成更新日志，例如： 查找 git 提交日志 查找 issues 问题然而，这样生成的日志真难看懂！不信你试着把一个项目的 Issues 列表读一遍？更新日志应该包含哪些内容站在库的使用者的角度来看，程序员们希望看到什么样的更新日志，不希望看到什么样的更新日志？ 添加的接口 现有接口的改变 未来即将删除的接口 此版本已经删除的接口 此版本修复的 Bug 此版本的安全性改进然而这些都写了会让编写者很痛苦的……手工和自动化的结合当存在 API 比较工具的时候，我们可以很容易地比较各个版本间 API 的变化，包括新增、改变、即将移除和已经移除。而这部分的内容由工具生成是没什么阅读障碍的。另一部分，描述功能的手工编写会比较容易阅读。例如新增的功能、修改的功能、已经删除的功能。优秀文档的参考以下是 UWP 的开发文档，属手工和自动化结合生成。" }, { "title": "在 GitHub 公开仓库中隐藏自己的私人邮箱地址", "url": "/post/remove-personal-emails-from-public-repos.html", "categories": "", "tags": "git, github", "date": "2018-08-05 16:56:26 +0800", "snippet": "GitHub 重点在开方源代码，其本身还是非常注重隐私的。这一点与面向企业的 GitLab 很不一样。不过，你依然可能在 GitHub 上泄露隐私信息，例如企业内部所用的电子邮箱。GitHub 对个人隐私的尊重git 的设定，开发者需要设置自己的邮箱：▲ git 的邮箱设置（即便是公开的邮箱，我也不在博客里贴出来）而在 GitLab 上，我们可以很直接地在提交上面看到提交者的邮箱：▲ GitLab 上的提交信息（图片已被魔改，毕竟邮箱是隐私）但是在 GitHub 上，同样的行为是看不到邮箱的：▲ GitHub 上的提交信息（图片原封不动）不止是提交信息，在其他的很多页面中，你都不会看到 GitHub 暴露邮箱地址。依然能看到的邮箱地址在 GitHub 上可以单独看提交信息，比如你可以去这里看看：https://github.com/walterlv/Whitman/commit/1088973f71466aaed1eff7a5fdf00eb7f4604620。里面依然没有邮箱地址。然而，当你在地址的最后面加上 .patch 之后，就变得不一样了：https://github.com/walterlv/Whitman/commit/1088973f71466aaed1eff7a5fdf00eb7f4604620.patch。- https://github.com/walterlv/Whitman/commit/1088973f71466aaed1eff7a5fdf00eb7f4604620+ https://github.com/walterlv/Whitman/commit/1088973f71466aaed1eff7a5fdf00eb7f4604620.patchFrom 1088973f71466aaed1eff7a5fdf00eb7f4604620 Mon Sep 17 00:00:00 2001From: walterlv &amp;lt;lvyi@example.com&amp;gt;Date: Sat, 4 Aug 2018 17:37:01 +0800Subject: [PATCH] Use Segoe MDL2 Assets font.--- src/Whitman.Wpf/Themes/Window.Universal.xaml | 24 +++++++------------- 1 file changed, 8 insertions(+), 16 deletions(-)diff --git a/src/Whitman.Wpf/Themes/Window.Universal.xaml b/src/Whitman.Wpf/Themes/Window.Universal.xamlindex 8b78e41..522ab51 100644--- a/src/Whitman.Wpf/Themes/Window.Universal.xaml+++ b/src/Whitman.Wpf/Themes/Window.Universal.xaml注意第二行，出现了我的邮箱地址。为了脱敏，我将内容替换成了 lvyi@example.com；如果你想看真正的邮箱地址，请前往真实的网页查看。GitHub 在这一点上已经为我们做了很多了，至少查看邮箱地址已经不是普通人可以看得到的了。添加隐私邮箱GitHub 提供了两种方法来保护我们的邮箱隐私： 在推送时发现隐私邮箱则阻止推送； 使用 GitHub 专用的替代邮箱。前往 https://github.com/settings/emails 可以对自己的邮箱地址进行设置。在 Primary email address 一栏，我们能看到 GitHub 为我们提供了一个专用的用于在 git 中配置的邮箱地址。继续往 GitHub 邮箱设置页面往下看，可以看到两个隐私设置。 隐私地址转换：如果发现以上列表中的邮箱地址，则会转换为 GitHub 专用的邮箱地址。 阻止推送：如果发现暴露了邮箱地址，则阻止推送。参考资料 Email settings" }, { "title": "WPF 应用完全模拟 UWP 的标题栏按钮", "url": "/post/wpf-simulate-native-window-title-bar-buttons.html", "categories": "", "tags": "wpf, uwp, dotnet, windows", "date": "2018-08-05 10:21:51 +0800", "snippet": "WPF 自定义窗口样式有多种方式，不过基本核心实现都是在修改 Win32 窗口样式。然而，Windows 上的应用就应该有 Windows 应用的样子嘛，在保证自定义的同时也能与其他窗口样式保持一致当然能最大程度保证 Windows 操作系统上的体验一致性。本文将分享一个我自制的标题栏按钮样式，使其与 UWP 原生应用一模一样（同时支持自定义）。在 WPF 使用 WindowChrome，在自定义窗口标题栏的同时最大程度保留原生窗口样式（类似 UWP/Chrome） 一文中，我使用 WindowChrome 尽可能将 Windows 原生的窗口机制都用上了，试图完全模拟原生窗口的样式。不过，如果自定义了窗口的背景色，那么标题栏那三大金刚键的背景就显得很突兀。由于 Win32 原生的方法顶多只支持修改标题栏按钮的背景色，而不支持让标题栏按钮全透明，所以我们只能完全由自己来实现这三个按钮的功能了。标题栏的四个按钮一开始我说三个按钮，是因为大家一般都只能看得见三个。但这里说四个按钮，是因为实际实现的时候我们是四个按钮。事实上，Windows 的原生实现也是四颗按钮。 最小化 还原 最大化 关闭当窗口最小化时，显示还原、最大化和关闭按钮。当窗口普通显示时，显示最小化、最大化和关闭按钮，这也是我们见的最多的情况。当窗口最大化时，显示最小化、还原和关闭按钮。自绘标题栏按钮标题栏按钮并不单独存在，所以我直接做了一整个窗口样式。使用此窗口样式，窗口能够模拟得跟 UWP 一模一样。以下是模拟的效果：▲ WPF 模拟版本▲ UWP 原生版本（为避免说我拿同一个应用附图，我选了微软商店应用对比）为了使用到这样近乎原生的窗口样式，我们需要两个文件。一个放 XAML 样式，一个放样式所需的逻辑代码。因为代码很长，所以我把它们放到了最后。如何使用我制作的原生窗口样式当你把我的两份代码文件放入到你的项目中之后，在 App.xaml 中将资源引用即可：&amp;lt;Application.Resources&amp;gt; &amp;lt;ResourceDictionary&amp;gt; &amp;lt;ResourceDictionary.MergedDictionaries&amp;gt; &amp;lt;ResourceDictionary Source=&quot;Themes/Window.Universal.xaml&quot; /&amp;gt; &amp;lt;/ResourceDictionary.MergedDictionaries&amp;gt; &amp;lt;/ResourceDictionary&amp;gt;&amp;lt;/Application.Resources&amp;gt;随后，在 MainWindow 中就可以通过 Style=&quot;{StaticResource Style.Window.Universal}&quot; 使用这份样式。&amp;lt;Window x:Class=&quot;Walterlv.Demo.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:themes=&quot;clr-namespace:Walterlv.Themes&quot; Title=&quot;Walterlv.Demo.SimulateUwp&quot; Width=&quot;800&quot; Height=&quot;450&quot; Background=&quot;#279EDA&quot; Style=&quot;{StaticResource Style.Window.Universal}&quot;&amp;gt; &amp;lt;themes:UniversalWindowStyle.TitleBar&amp;gt; &amp;lt;themes:UniversalTitleBar ForegroundColor=&quot;White&quot; InactiveForegroundColor=&quot;#7FFFFFFF&quot; ButtonHoverForeground=&quot;White&quot; ButtonHoverBackground=&quot;#3FFFFFFF&quot; ButtonPressedForeground=&quot;#7FFFFFFF&quot; ButtonPressedBackground=&quot;#3F000000&quot; /&amp;gt; &amp;lt;/themes:UniversalWindowStyle.TitleBar&amp;gt; &amp;lt;Grid&amp;gt; &amp;lt;!-- 在这里添加你的正常窗口内容 --&amp;gt; &amp;lt;/Grid&amp;gt;&amp;lt;/Window&amp;gt;当然，我额外提供了 UniversalWindowStyle.TitleBar 附加属性，用于像 UWP 那样定制标题栏按钮的颜色。如果不设置，效果跟 UWP 默认情况下的效果完全一样。下面是这份样式在 Whitman - Microsoft Store 应用中实际使用的效果，其中的颜色设置就是上面代码中所指定的颜色：附样式代码文件样式文件 Window.Universal.xaml：&amp;lt;!-- Window.Universal.xaml --&amp;gt;&amp;lt;ResourceDictionary xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:themes=&quot;clr-namespace:Walterlv.Themes&quot;&amp;gt; &amp;lt;Style x:Key=&quot;Style.Window.Universal&quot; TargetType=&quot;Window&quot;&amp;gt; &amp;lt;Style.Resources&amp;gt; &amp;lt;SolidColorBrush x:Key=&quot;Brush.TitleBar.Foreground&quot; Color=&quot;{Binding Path=(themes:UniversalWindowStyle.TitleBar).ForegroundColor, RelativeSource={RelativeSource TemplatedParent}, Mode=OneWay}&quot; /&amp;gt; &amp;lt;SolidColorBrush x:Key=&quot;Brush.TitleBar.InactiveForeground&quot; Color=&quot;{Binding Path=(themes:UniversalWindowStyle.TitleBar).InactiveForegroundColor, RelativeSource={RelativeSource TemplatedParent}, Mode=OneWay}&quot; /&amp;gt; &amp;lt;SolidColorBrush x:Key=&quot;Brush.TitleBar.ButtonHoverForeground&quot; Color=&quot;{Binding Path=(themes:UniversalWindowStyle.TitleBar).ButtonHoverForeground, RelativeSource={RelativeSource TemplatedParent}, Mode=OneWay}&quot; /&amp;gt; &amp;lt;SolidColorBrush x:Key=&quot;Brush.TitleBar.ButtonHoverBackground&quot; Color=&quot;{Binding Path=(themes:UniversalWindowStyle.TitleBar).ButtonHoverBackground, RelativeSource={RelativeSource TemplatedParent}, Mode=OneWay}&quot; /&amp;gt; &amp;lt;SolidColorBrush x:Key=&quot;Brush.TitleBar.ButtonPressedForeground&quot; Color=&quot;{Binding Path=(themes:UniversalWindowStyle.TitleBar).ButtonPressedForeground, RelativeSource={RelativeSource TemplatedParent}, Mode=OneWay}&quot; /&amp;gt; &amp;lt;SolidColorBrush x:Key=&quot;Brush.TitleBar.ButtonPressedBackground&quot; Color=&quot;{Binding Path=(themes:UniversalWindowStyle.TitleBar).ButtonPressedBackground, RelativeSource={RelativeSource TemplatedParent}, Mode=OneWay}&quot; /&amp;gt; &amp;lt;/Style.Resources&amp;gt; &amp;lt;Setter Property=&quot;themes:UniversalWindowStyle.TitleBar&quot;&amp;gt; &amp;lt;Setter.Value&amp;gt; &amp;lt;themes:UniversalTitleBar /&amp;gt; &amp;lt;/Setter.Value&amp;gt; &amp;lt;/Setter&amp;gt; &amp;lt;Setter Property=&quot;WindowChrome.WindowChrome&quot;&amp;gt; &amp;lt;Setter.Value&amp;gt; &amp;lt;WindowChrome GlassFrameThickness=&quot;0 64 0 0&quot; NonClientFrameEdges=&quot;Left,Bottom,Right&quot; UseAeroCaptionButtons=&quot;False&quot; /&amp;gt; &amp;lt;/Setter.Value&amp;gt; &amp;lt;/Setter&amp;gt; &amp;lt;Setter Property=&quot;Template&quot;&amp;gt; &amp;lt;Setter.Value&amp;gt; &amp;lt;ControlTemplate TargetType=&quot;Window&quot;&amp;gt; &amp;lt;Border Padding=&quot;4 1 4 4&quot;&amp;gt; &amp;lt;Grid x:Name=&quot;RootGrid&quot; Background=&quot;{TemplateBinding Background}&quot;&amp;gt; &amp;lt;Grid x:Name=&quot;TitleBarPanel&quot; VerticalAlignment=&quot;Top&quot; Height=&quot;31&quot;&amp;gt; &amp;lt;FrameworkElement.Resources&amp;gt; &amp;lt;Style TargetType=&quot;{x:Type Button}&quot;&amp;gt; &amp;lt;Setter Property=&quot;Width&quot; Value=&quot;46&quot;/&amp;gt; &amp;lt;Setter Property=&quot;BorderThickness&quot; Value=&quot;0&quot; /&amp;gt; &amp;lt;Setter Property=&quot;Foreground&quot; Value=&quot;{StaticResource Brush.TitleBar.Foreground}&quot; /&amp;gt; &amp;lt;Setter Property=&quot;Background&quot; Value=&quot;Transparent&quot;/&amp;gt; &amp;lt;Setter Property=&quot;Stylus.IsPressAndHoldEnabled&quot; Value=&quot;False&quot; /&amp;gt; &amp;lt;Setter Property=&quot;Stylus.IsFlicksEnabled&quot; Value=&quot;False&quot; /&amp;gt; &amp;lt;Setter Property=&quot;Stylus.IsTapFeedbackEnabled&quot; Value=&quot;False&quot; /&amp;gt; &amp;lt;Setter Property=&quot;Stylus.IsTouchFeedbackEnabled&quot; Value=&quot;False&quot; /&amp;gt; &amp;lt;Setter Property=&quot;WindowChrome.IsHitTestVisibleInChrome&quot; Value=&quot;True&quot;/&amp;gt; &amp;lt;Setter Property=&quot;Template&quot;&amp;gt; &amp;lt;Setter.Value&amp;gt; &amp;lt;ControlTemplate TargetType=&quot;Button&quot;&amp;gt; &amp;lt;Border Name=&quot;OverBorder&quot; BorderThickness=&quot;0 1 0 0&quot; Background=&quot;{TemplateBinding Background}&quot;&amp;gt; &amp;lt;TextBlock x:Name=&quot;MinimizeIcon&quot; Foreground=&quot;{TemplateBinding Foreground}&quot; Text=&quot;{TemplateBinding Content}&quot; FontSize=&quot;10&quot; FontFamily=&quot;Segoe MDL2 Assets&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;/&amp;gt; &amp;lt;/Border&amp;gt; &amp;lt;/ControlTemplate&amp;gt; &amp;lt;/Setter.Value&amp;gt; &amp;lt;/Setter&amp;gt; &amp;lt;Style.Triggers&amp;gt; &amp;lt;MultiTrigger&amp;gt; &amp;lt;!-- When the pointer is over the button. --&amp;gt; &amp;lt;MultiTrigger.Conditions&amp;gt; &amp;lt;Condition Property=&quot;IsMouseOver&quot; Value=&quot;True&quot; /&amp;gt; &amp;lt;Condition Property=&quot;IsStylusOver&quot; Value=&quot;False&quot; /&amp;gt; &amp;lt;/MultiTrigger.Conditions&amp;gt; &amp;lt;Setter Property=&quot;Foreground&quot; Value=&quot;{StaticResource Brush.TitleBar.ButtonHoverForeground}&quot; /&amp;gt; &amp;lt;Setter Property=&quot;Background&quot; Value=&quot;{StaticResource Brush.TitleBar.ButtonHoverBackground}&quot; /&amp;gt; &amp;lt;/MultiTrigger&amp;gt; &amp;lt;!-- When the pointer is pressed. --&amp;gt; &amp;lt;MultiTrigger&amp;gt; &amp;lt;MultiTrigger.Conditions&amp;gt; &amp;lt;Condition Property=&quot;IsPressed&quot; Value=&quot;True&quot; /&amp;gt; &amp;lt;Condition Property=&quot;AreAnyTouchesOver&quot; Value=&quot;False&quot; /&amp;gt; &amp;lt;/MultiTrigger.Conditions&amp;gt; &amp;lt;Setter Property=&quot;Foreground&quot; Value=&quot;{StaticResource Brush.TitleBar.ButtonPressedForeground}&quot; /&amp;gt; &amp;lt;Setter Property=&quot;Background&quot; Value=&quot;{StaticResource Brush.TitleBar.ButtonPressedBackground}&quot; /&amp;gt; &amp;lt;/MultiTrigger&amp;gt; &amp;lt;!-- When the touch device is pressed. --&amp;gt; &amp;lt;MultiTrigger&amp;gt; &amp;lt;MultiTrigger.Conditions&amp;gt; &amp;lt;Condition Property=&quot;IsPressed&quot; Value=&quot;True&quot; /&amp;gt; &amp;lt;Condition Property=&quot;AreAnyTouchesOver&quot; Value=&quot;True&quot; /&amp;gt; &amp;lt;/MultiTrigger.Conditions&amp;gt; &amp;lt;Setter Property=&quot;Foreground&quot; Value=&quot;{StaticResource Brush.TitleBar.ButtonPressedForeground}&quot; /&amp;gt; &amp;lt;Setter Property=&quot;Background&quot; Value=&quot;{StaticResource Brush.TitleBar.ButtonPressedBackground}&quot; /&amp;gt; &amp;lt;/MultiTrigger&amp;gt; &amp;lt;/Style.Triggers&amp;gt; &amp;lt;/Style&amp;gt; &amp;lt;Style x:Key=&quot;Style.Button.Close&quot; TargetType=&quot;Button&quot; BasedOn=&quot;{StaticResource {x:Type Button}}&quot;&amp;gt; &amp;lt;Style.Triggers&amp;gt; &amp;lt;MultiTrigger&amp;gt; &amp;lt;!-- When the pointer is over the button. --&amp;gt; &amp;lt;MultiTrigger.Conditions&amp;gt; &amp;lt;Condition Property=&quot;IsMouseOver&quot; Value=&quot;True&quot; /&amp;gt; &amp;lt;Condition Property=&quot;IsStylusOver&quot; Value=&quot;False&quot; /&amp;gt; &amp;lt;/MultiTrigger.Conditions&amp;gt; &amp;lt;Setter Property=&quot;Foreground&quot; Value=&quot;White&quot; /&amp;gt; &amp;lt;Setter Property=&quot;Background&quot; Value=&quot;#E81123&quot; /&amp;gt; &amp;lt;/MultiTrigger&amp;gt; &amp;lt;!-- When the pointer is pressed. --&amp;gt; &amp;lt;MultiTrigger&amp;gt; &amp;lt;MultiTrigger.Conditions&amp;gt; &amp;lt;Condition Property=&quot;IsPressed&quot; Value=&quot;True&quot; /&amp;gt; &amp;lt;Condition Property=&quot;AreAnyTouchesOver&quot; Value=&quot;False&quot; /&amp;gt; &amp;lt;/MultiTrigger.Conditions&amp;gt; &amp;lt;Setter Property=&quot;Foreground&quot; Value=&quot;Black&quot; /&amp;gt; &amp;lt;Setter Property=&quot;Background&quot; Value=&quot;#F1707A&quot; /&amp;gt; &amp;lt;/MultiTrigger&amp;gt; &amp;lt;!-- When the touch device is pressed. --&amp;gt; &amp;lt;MultiTrigger&amp;gt; &amp;lt;MultiTrigger.Conditions&amp;gt; &amp;lt;Condition Property=&quot;IsPressed&quot; Value=&quot;True&quot; /&amp;gt; &amp;lt;Condition Property=&quot;AreAnyTouchesOver&quot; Value=&quot;True&quot; /&amp;gt; &amp;lt;/MultiTrigger.Conditions&amp;gt; &amp;lt;Setter Property=&quot;Foreground&quot; Value=&quot;Black&quot; /&amp;gt; &amp;lt;Setter Property=&quot;Background&quot; Value=&quot;#F1707A&quot; /&amp;gt; &amp;lt;/MultiTrigger&amp;gt; &amp;lt;/Style.Triggers&amp;gt; &amp;lt;/Style&amp;gt; &amp;lt;/FrameworkElement.Resources&amp;gt; &amp;lt;TextBlock x:Name=&quot;TitleTextBlock&quot; FontSize=&quot;12&quot; Text=&quot;{TemplateBinding Title}&quot; Margin=&quot;12 0 156 0&quot; VerticalAlignment=&quot;Center&quot; Foreground=&quot;{StaticResource Brush.TitleBar.Foreground}&quot; /&amp;gt; &amp;lt;StackPanel x:Name=&quot;TitleBarButtonPanel&quot; Orientation=&quot;Horizontal&quot; Margin=&quot;0 -1 0 0&quot; HorizontalAlignment=&quot;Right&quot;&amp;gt; &amp;lt;Button x:Name=&quot;MinimizeButton&quot; Content=&quot;&amp;amp;#xE921;&quot; themes:UniversalWindowStyle.TitleBarButtonState=&quot;Minimized&quot; /&amp;gt; &amp;lt;Button x:Name=&quot;RestoreButton&quot; Content=&quot;&amp;amp;#xE923;&quot; themes:UniversalWindowStyle.TitleBarButtonState=&quot;Normal&quot; /&amp;gt; &amp;lt;Button x:Name=&quot;MaximizeButton&quot; Content=&quot;&amp;amp;#xE922;&quot; themes:UniversalWindowStyle.TitleBarButtonState=&quot;Maximized&quot; /&amp;gt; &amp;lt;Button x:Name=&quot;CloseButton&quot; Content=&quot;&amp;amp;#xE106;&quot; Style=&quot;{StaticResource Style.Button.Close}&quot; themes:UniversalWindowStyle.IsTitleBarCloseButton=&quot;True&quot; /&amp;gt; &amp;lt;/StackPanel&amp;gt; &amp;lt;/Grid&amp;gt; &amp;lt;AdornerDecorator&amp;gt; &amp;lt;ContentPresenter /&amp;gt; &amp;lt;/AdornerDecorator&amp;gt; &amp;lt;/Grid&amp;gt; &amp;lt;/Border&amp;gt; &amp;lt;ControlTemplate.Triggers&amp;gt; &amp;lt;Trigger Property=&quot;WindowState&quot; Value=&quot;Maximized&quot;&amp;gt; &amp;lt;Setter TargetName=&quot;RootGrid&quot; Property=&quot;Margin&quot; Value=&quot;4 7 4 4&quot; /&amp;gt; &amp;lt;Setter TargetName=&quot;TitleBarPanel&quot; Property=&quot;Height&quot; Value=&quot;32&quot; /&amp;gt; &amp;lt;Setter TargetName=&quot;MaximizeButton&quot; Property=&quot;Visibility&quot; Value=&quot;Collapsed&quot; /&amp;gt; &amp;lt;/Trigger&amp;gt; &amp;lt;Trigger Property=&quot;WindowState&quot; Value=&quot;Normal&quot;&amp;gt; &amp;lt;Setter TargetName=&quot;RestoreButton&quot; Property=&quot;Visibility&quot; Value=&quot;Collapsed&quot; /&amp;gt; &amp;lt;/Trigger&amp;gt; &amp;lt;Trigger Property=&quot;WindowState&quot; Value=&quot;Minimized&quot;&amp;gt; &amp;lt;Setter TargetName=&quot;MinimizeButton&quot; Property=&quot;Visibility&quot; Value=&quot;Collapsed&quot; /&amp;gt; &amp;lt;/Trigger&amp;gt; &amp;lt;Trigger Property=&quot;IsActive&quot; Value=&quot;False&quot;&amp;gt; &amp;lt;Setter TargetName=&quot;TitleTextBlock&quot; Property=&quot;Foreground&quot; Value=&quot;{StaticResource Brush.TitleBar.InactiveForeground}&quot; /&amp;gt; &amp;lt;Setter TargetName=&quot;MinimizeButton&quot; Property=&quot;Foreground&quot; Value=&quot;{StaticResource Brush.TitleBar.InactiveForeground}&quot; /&amp;gt; &amp;lt;Setter TargetName=&quot;RestoreButton&quot; Property=&quot;Foreground&quot; Value=&quot;{StaticResource Brush.TitleBar.InactiveForeground}&quot; /&amp;gt; &amp;lt;Setter TargetName=&quot;MaximizeButton&quot; Property=&quot;Foreground&quot; Value=&quot;{StaticResource Brush.TitleBar.InactiveForeground}&quot; /&amp;gt; &amp;lt;Setter TargetName=&quot;CloseButton&quot; Property=&quot;Foreground&quot; Value=&quot;{StaticResource Brush.TitleBar.InactiveForeground}&quot; /&amp;gt; &amp;lt;/Trigger&amp;gt; &amp;lt;/ControlTemplate.Triggers&amp;gt; &amp;lt;/ControlTemplate&amp;gt; &amp;lt;/Setter.Value&amp;gt; &amp;lt;/Setter&amp;gt; &amp;lt;/Style&amp;gt;&amp;lt;/ResourceDictionary&amp;gt;逻辑代码文件 Window.Universal.xaml.cs（当然，名字可以随意）：// Window.Universal.xaml.csusing System;using System.Windows;using System.Windows.Controls;using System.Windows.Media;namespace Walterlv.Themes{ public class UniversalWindowStyle { public static readonly DependencyProperty TitleBarProperty = DependencyProperty.RegisterAttached( &quot;TitleBar&quot;, typeof(UniversalTitleBar), typeof(UniversalWindowStyle), new PropertyMetadata(new UniversalTitleBar(), OnTitleBarChanged)); public static UniversalTitleBar GetTitleBar(DependencyObject element) =&amp;gt; (UniversalTitleBar) element.GetValue(TitleBarProperty); public static void SetTitleBar(DependencyObject element, UniversalTitleBar value) =&amp;gt; element.SetValue(TitleBarProperty, value); public static readonly DependencyProperty TitleBarButtonStateProperty = DependencyProperty.RegisterAttached( &quot;TitleBarButtonState&quot;, typeof(WindowState?), typeof(UniversalWindowStyle), new PropertyMetadata(null, OnButtonStateChanged)); public static WindowState? GetTitleBarButtonState(DependencyObject element) =&amp;gt; (WindowState?) element.GetValue(TitleBarButtonStateProperty); public static void SetTitleBarButtonState(DependencyObject element, WindowState? value) =&amp;gt; element.SetValue(TitleBarButtonStateProperty, value); public static readonly DependencyProperty IsTitleBarCloseButtonProperty = DependencyProperty.RegisterAttached( &quot;IsTitleBarCloseButton&quot;, typeof(bool), typeof(UniversalWindowStyle), new PropertyMetadata(false, OnIsCloseButtonChanged)); public static bool GetIsTitleBarCloseButton(DependencyObject element) =&amp;gt; (bool) element.GetValue(IsTitleBarCloseButtonProperty); public static void SetIsTitleBarCloseButton(DependencyObject element, bool value) =&amp;gt; element.SetValue(IsTitleBarCloseButtonProperty, value); private static void OnTitleBarChanged(DependencyObject d, DependencyPropertyChangedEventArgs e) { if (e.NewValue is null) throw new NotSupportedException(&quot;TitleBar property should not be null.&quot;); } private static void OnButtonStateChanged(DependencyObject d, DependencyPropertyChangedEventArgs e) { var button = (Button) d; if (e.OldValue is WindowState) { button.Click -= StateButton_Click; } if (e.NewValue is WindowState) { button.Click -= StateButton_Click; button.Click += StateButton_Click; } } private static void OnIsCloseButtonChanged(DependencyObject d, DependencyPropertyChangedEventArgs e) { var button = (Button) d; if (e.OldValue is true) { button.Click -= CloseButton_Click; } if (e.NewValue is true) { button.Click -= CloseButton_Click; button.Click += CloseButton_Click; } } private static void StateButton_Click(object sender, RoutedEventArgs e) { var button = (DependencyObject) sender; var window = Window.GetWindow(button); var state = GetTitleBarButtonState(button); if (window != null &amp;amp;&amp;amp; state != null) { window.WindowState = state.Value; } } private static void CloseButton_Click(object sender, RoutedEventArgs e) =&amp;gt; Window.GetWindow((DependencyObject) sender)?.Close(); } public class UniversalTitleBar { public Color ForegroundColor { get; set; } = Colors.Black; public Color InactiveForegroundColor { get; set; } = Color.FromRgb(0x99, 0x99, 0x99); public Color ButtonHoverForeground { get; set; } = Colors.Black; public Color ButtonHoverBackground { get; set; } = Color.FromRgb(0xE6, 0xE6, 0xE6); public Color ButtonPressedForeground { get; set; } = Colors.Black; public Color ButtonPressedBackground { get; set; } = Color.FromRgb(0xCC, 0xCC, 0xCC); }}兼容 Windows 10 之前的系统上面的样式中我们使用了 Segoe MDL2 Assets 字体，而这款字体仅 Windows 10 上才有。于是如果我们的应用还要兼容 Windows 10 之前的系统怎么办呢？需要改动两个地方： 按钮模板中图标的显示方式（从 TextBlock 改成 Path； 按钮图标的指定方式（从字符串改成 StreamGeometry）。&amp;lt;ControlTemplate TargetType=&quot;Button&quot;&amp;gt; &amp;lt;Border Name=&quot;OverBorder&quot; BorderThickness=&quot;0 1 0 0&quot; Background=&quot;{TemplateBinding Background}&quot;&amp;gt; &amp;lt;Path x:Name=&quot;MinimizeIcon&quot; Fill=&quot;{TemplateBinding Foreground}&quot; Data=&quot;{TemplateBinding Content}&quot; Width=&quot;16&quot; Height=&quot;16&quot; SnapsToDevicePixels=&quot;True&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;/&amp;gt; &amp;lt;/Border&amp;gt;&amp;lt;/ControlTemplate&amp;gt;&amp;lt;Button x:Name=&quot;MinimizeButton&quot; themes:UniversalWindowStyle.TitleBarButtonState=&quot;Minimized&quot;&amp;gt; &amp;lt;StreamGeometry&amp;gt;M 3,8 L 3,9 L 13,9 L 13,8 Z&amp;lt;/StreamGeometry&amp;gt;&amp;lt;/Button&amp;gt;&amp;lt;Button x:Name=&quot;RestoreButton&quot; themes:UniversalWindowStyle.TitleBarButtonState=&quot;Normal&quot;&amp;gt; &amp;lt;StreamGeometry&amp;gt;M 3,3 L 3,4 L 13,4 L 13,3 Z M 3,12 L 3,13 L 13,13 L 13,12 Z M 3,4 L 3,12 L 4,12 L 4,4 Z M 12,4 L 12,12 L 13,12 L 13,4 Z&amp;lt;/StreamGeometry&amp;gt;&amp;lt;/Button&amp;gt;&amp;lt;Button x:Name=&quot;MaximizeButton&quot; themes:UniversalWindowStyle.TitleBarButtonState=&quot;Maximized&quot;&amp;gt; &amp;lt;StreamGeometry&amp;gt;M 3,3 L 3,4 L 13,4 L 13,3 Z M 3,12 L 3,13 L 13,13 L 13,12 Z M 3,4 L 3,12 L 4,12 L 4,4 Z M 12,4 L 12,12 L 13,12 L 13,4 Z&amp;lt;/StreamGeometry&amp;gt;&amp;lt;/Button&amp;gt;&amp;lt;Button x:Name=&quot;CloseButton&quot; Style=&quot;{StaticResource Style.Button.Close}&quot; themes:UniversalWindowStyle.IsTitleBarCloseButton=&quot;True&quot;&amp;gt; &amp;lt;StreamGeometry&amp;gt;M 3,3 L 3,4 L 4,4 L 4,3 Z M 5,5 L 5,6 L 6,6 L 6,5 Z M 7,7 L 7,9 L 9,9 L 9,7 Z M 9,9 L 9,10 L 10,10 L 10,9 Z M 11,11 L 11,12 L 12,12 L 12,11 Z M 4,4 L 4,5 L 5,5 L 5,4 Z M 6,6 L 6,7 L 7,7 L 7,6 Z M 12,3 L 12,4 L 13,4 L 13,3 Z M 10,10 L 10,11 L 11,11 L 11,10 Z M 12,12 L 12,13 L 13,13 L 13,12 Z M 11,4 L 11,5 L 12,5 L 12,4 Z M 10,5 L 10,6 L 11,6 L 11,5 Z M 9,6 L 9,7 L 10,7 L 10,6 Z M 6,9 L 6,10 L 7,10 L 7,9 Z M 5,10 L 5,11 L 6,11 L 6,10 Z M 4,11 L 4,12 L 5,12 L 5,11 Z M 3,12 L 3,13 L 4,13 L 4,12 Z&amp;lt;/StreamGeometry&amp;gt;&amp;lt;/Button&amp;gt;" }, { "title": ".NET 三个字母究竟应该如何大小写？前面的 “.” 什么时候能够去掉？（.NET Standard / dotnet-core / net472）", "url": "/post/case-of-dotnet-writing.html", "categories": "", "tags": "dotnet", "date": "2018-07-30 19:47:02 +0800", "snippet": "本文将解释在 .NET 技术栈中各种不同使用方式下 N E T 三个字母何时大写何时小写；前面的 “.” 什么时候加上，什么时候去掉，什么时候又使用 “dot”。.NET 在技术文档中如果你阅读过 https://docs.microsoft.com/zh-cn/dotnet/ 中的多数 .NET 技术文档，你应该几乎已经注意到了，在所有对大小写敏感的地方，NET 三个字母都是大写的。“.NET” 是 .NET 技术栈名称的最官方写法了，如果能写出 “.NET” 且不会产生其他问题的地方，都应该使用 “.NET”。▲ 首先映入眼帘的，便是 .NET 技术栈中的所有文档标题.NET 在代码中.NET 在代码中并不符合 PascalCase 对命名规范的大小写建议。一般来说三个字母无论是单个单词还是多个单词的缩写，在 PascalCase 中都应该是首字母大写，其后全部小写。但在微软的代码中，NET 依然都是全大写的。例如 Microsoft.NET.Sdk，去 dotnet/sdk - GitHub 上看，写法都是 NET 全大写的。.NET 在标识符中其实，我这里想说的标识符并不是指类名或方法名，那是上一节 .NET 在代码中 所说的内容。这里想说的是，当 .NET 作为用于识别 .NET 某种特征所用的标识符。一般这种标识符有一些命名限制（例如 “.” 开头经常就不符合限制）。通常作为这种类型的标识符是大小写不敏感的，于是，微软在文档中对此的惯用写法是全部小写。例如，在 Url 中： https://docs.microsoft.com/zh-cn/dotnet/前面的 “.” 被改写成了 “dot”。例如，在项目的目标框架中作为标识符使用时： netstandard2.0 netcoreapp2.1 net472这时，连前面的 “.” 都直接去掉了。.NET 在文件系统中在文件系统中，“.” 作为前缀的文件或文件夹在 OSX 和 Linux 上都是有特殊用途的，代表隐藏文件夹。这意味着如果没有特别的安排，尽量不要为常规文件夹使用 “.” 作为前缀。这就意味着，如果你想建一个 .NET 文件夹，你应该去掉前面的 “.”。可是去掉之后的辨识度就太低了，看不出来是 .NET 技术栈。那么怎么命名呢？这里给一些建议： dotNET 适用于有大小写规范的命名中（例如为了跟 Windows/Android/iOS/OSX 这样的名称保持统一） dotnet 适用于作为普通标识符的命名中（例如为了跟 windows/android/ios/osx 这样的名称保持统一） net 适用于使用缩写的命名中（例如为了跟 win/android/ios/osx 这样的名称保持统一）.NET 作为产品或机构名称的一部分JetBrains 家的 .NET 团队很喜欢用 dot 作为软件名称的前缀，例如 dotCover、dotMemory、dotPeek、dotTrace。去 JetBrains: Developer Tools for Professionals and Teams 看看很快就能找到这几款软件的名称。.NET Core 开源峰会使用 dnc 这样奇怪的缩写，代表 dotnet-core。总结合理的 .NET 写法有这些： .NET 推荐 NET dotNET dotnet net如果与其他相关技术名词进行组合： .NET Core ML.NET Microsoft.NET.Sdk dotnet-standard net472" }, { "title": "每次都要重新编译？太慢！让跨平台的 MSBuild/dotnet build 的 Target 支持差量编译", "url": "/post/msbuild-incremental-build.html", "categories": "", "tags": "visualstudio, msbuild", "date": "2018-07-28 17:52:22 +0800", "snippet": "如果你干预到了项目的编译过程，可能就需要考虑到差量编译了。不然——当你的项目大起来的时候，就会感受到每次都重新编译时，每次重复调试的过程都要进行漫长等待时的绝望和无奈。如果你正遭遇差量编译失效，每次都要重新编译的问题，那么阅读本文应该能够帮助你解决问题。msbuild.exe 和 dotnet build 编译项目的方式是一样的，只不过前者使用完整的 .NET Framework，而后者使用 .NET Core。所以后面我们说到 Target 的差量编译的时候，就不再区分这两者了。一个差量编译的例子先看一个 Target 的例子，这里例子来源于我的另一篇文章如何创建一个基于 MSBuild Task 的跨平台的 NuGet 工具包 - 吕毅。在例子中，我没有加入任何的差量编译支持。&amp;lt;Target Name=&quot;WalterlvDemo&quot; BeforeTargets=&quot;CoreCompile&quot; Inputs=&quot;$(MSBuildAllProjects);@(Compile)&quot; Outputs=&quot;$(IntermediateOutputPath)Doubi.cs&quot;&amp;gt; &amp;lt;Exec Command=&quot;dotnet walterlv-tool.dll $(IntermediateOutputPath)Doubi.cs&quot; /&amp;gt;&amp;lt;/Target&amp;gt;上述例子的作用是在编译期间执行一个名为 walterlv-tool.dll 的 .NET Core 应用，在命令执行结束之后，将生成一份新的代码文件 $(IntermediateOutputPath)Doubi.cs 并加入编译。如果你觉得上面的写法非常陌生，或者说不清楚那个 Target 节点的作用，建议先阅读： 理解 C# 项目 csproj 文件格式的本质和编译流程 - 吕毅 如何创建一个基于 MSBuild Task 的跨平台的 NuGet 工具包 - 吕毅差量编译的关键每一个 Target 都有 Inputs 和 Outputs 属性，可以设置，也可以不用设置。 当两者都没有指定时，MSBuild 会认定为此 Target 在每次编译时都会执行 当两者都指定时，MSBuild 会认定为此 Target 需要进行差量执行 不能只指定其中的一个而不指定另一个（MSBuild 直接会提示此 Target 没有正确指定 Inputs 和 Outputs）另外，Inputs 和 Outputs 必须指定为文件或文件的集合。因为差量编译的判定规则是 “文件存在，且前后两次编译的大小和修改时间相同”。Inputs 和 Outputs 的格式都是一组用 ; 分隔的字符串，每一项都是一个文件的路径。不过不用特别考虑如何使用 ; 拼接，因为当我们使用 @ 符号时，收集到的每一项便是使用 ; 分隔的。例如 @(Compile) 表示在 &amp;lt;ItemGroup&amp;gt; 中每一个 Compile 类型的节点。如果不清楚 &amp;lt;ItemGroup&amp;gt; 和 &amp;lt;Compile&amp;gt; 的作用，建议建议先阅读理解 C# 项目 csproj 文件格式的本质和编译流程 - 吕毅。假设我们指定 Inputs 为 @(Compile)，Outputs 指定为某个 xxx.exe 生成的临时文件的位置（在 如何创建一个基于命令行工具的跨平台的 NuGet 工具包 一文中，我假定为了 $(IntermediateOutputPath)Doubi.cs），那么 MSBuild 就会在执行此 Target 之前检查所有这些输入输出文件。如果所有 &amp;lt;Compile&amp;gt; 节点中对应的文件都没有改变，而且 $(IntermediateOutputPath)Doubi.cs 存在且没改变，那么此 Target 将不需要执行。任何一个文件不满足此条件，则 Target 都将重新执行。不是所有的 Target 都适合差量编译注意！不是所有的 Target 都适合设置 Inputs 和 Outputs 属性！在本文前面的例子中，我们的 Target 是有明确的输入和输出文件的；然而有些 Target 是没有输入输出文件的——他们的输出依赖于其他 Target 的输出。例如我们有另一个 &amp;lt;Target&amp;gt;，它的作用是生成一个属性的值，或者一组文件的名字；而另外一个 &amp;lt;Target&amp;gt; 使用这个属性的值和这组文件。典型的例子如我在如何创建一个基于命令行工具的跨平台的 NuGet 工具包 中写的那个 NuGet 工具。&amp;lt;Target Name=&quot;WalterlvDemo&quot; BeforeTargets=&quot;CoreCompile&quot; Inputs=&quot;$(MSBuildAllProjects);@(Compile)&quot; Outputs=&quot;$(IntermediateOutputPath)Doubi.cs&quot;&amp;gt; &amp;lt;Exec Command=&quot;dotnet walterlv-tool.dll $(IntermediateOutputPath)Doubi.cs&quot; /&amp;gt;&amp;lt;/Target&amp;gt;&amp;lt;Target Name=&quot;WalterlvDemoUseResult&quot; AfterTargets=&quot;WalterlvDemo&quot; BeforeTargets=&quot;CoreCompile&quot;&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;Compile Include=&quot;$(IntermediateOutputPath)Doubi.cs&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt;&amp;lt;/Target&amp;gt;WalterlvDemo 生成文件，而 WalterlvDemoUseResult 使用文件。这时，WalterlvDemo 适合使用差量编译，而 WalterlvDemoUseResult 却不适合！因为前者已经生成了文件，如果不执行，文件依然存在；但后者一旦不执行，那么我们就会少一个编译的文件。这将导致后续名为 CoreCompile 的 Target 执行时，发现少了一个文件，将重新执行编译。所以前者的 Inputs 指定为空字符串，Outputs 指定为 $(IntermediateOutputPath)Doubi.cs；但是后者不应该指定 Inputs 和 Outputs。" }, { "title": "像黑客一样！Chrome 完全键盘操作指南（原生快捷键 + Vimium 插件）", "url": "/post/use-chrome-like-a-hacker.html", "categories": "", "tags": "windows", "date": "2018-07-28 07:40:40 +0800", "snippet": "有那么一波小伙伴，多数时候都不需要用到鼠标，通常他们正好是“黑客”。当你开始使用键盘操作一切时，便能体会到无需用鼠标瞄准按钮时的干脆，无需在键盘和鼠标之间移动手时的轻松。Chrome 原生自带大量快捷键，Vimium 在原生的基础上又增加了大量网页操作。结合两者，你完全能摆脱鼠标。Chrome 原生快捷键Chrome 原生快捷键估计多数人都能说出其中的一部分出来，例如 F5 刷新，Ctrl+W 关闭标签页。这里我列出日常浏览时会用到的快捷键： F3 查找 应该没有人不知道吧 Ctrl+G 查找下一条 Ctrl+Shift+G 查找上一条 F6 转到地址栏 于是能够立即开始输入新网址 Enter 跳转页面或搜索 应该没有人不知道吧 Ctrl+Enter 加上 www. 前缀和 .com 后缀然后打开网站 Alt+Enter 在新标签页中跳转页面或搜索 Ctrl+K 转到地址栏并搜索 F10 转到 Chrome 菜单按钮 F11 全屏模式 F12 打开开发者工具 Ctrl+T 新建标签页配合 Vimium，你可以操作 Chrome 界面上的所有按钮了：▲ 蓝色表示 Chrome 原生快捷键，橙色表示 Vimium 快捷键更多 Chrome 快捷键可以去官网上查阅：Chrome 键盘快捷键 - Google Chrome帮助。Vimium 插件继续阅读之前，请先点此安装 Vimium 插件。Vimium = Vim + ChromiumChromium 是 Chrome 浏览器所用的内核。Vim，如果你知道这款编辑器，那就最好了，因为我太懒不想介绍。但如果你不知道，我也不会介绍，因为太懒了；不过你可以看看 知乎，它是入门门槛高到爆但功能强大到爆的文本编辑器。完全键盘操作就靠 Vimium 了。是的，完全可以脱离鼠标！如果你正在阅读这篇博客，那么直接按下 “?” 试试！（我想你应该记得要加上 Shift 才能输入 “?” 吧！）于是你打开了 Vimium 的快捷键帮助页面：如果英文阅读吃力，可以阅读下面我精简过后的中文版： 页面滚动 j 按住向下滚，直到松开 k 按住向上滚，直到松开 gg 滚到顶部 G 滚到底部 d 向下滚半页 u 向上滚半页 h 按住向左滚，直到松开 l 按住向右滚，直到松开 页面导航 yy 复制当前标签页的 url p 在当前标签页粘贴并打开 url P 在新标签页粘贴并打开 url f 在当前页打开链接 F 在新标签页中打开链接 H 后退 L 前进 快速启动框 o 检索书签或历史记录，找到网址后打开 O 检索书签或历史记录，找到网址后在新标签页中打开 b 检索书签，找到网址后打开 B 检索书签，找到网址后在新标签页中打开 T 检索打开的标签页，选择后切换到此标签页 页面标签 t 打开一个新标签页 J 切换到左边的标签页 K 切换到右边的标签页 ^ 切换到刚刚访问的标签页 g0 切换到第一个标签页 g$ 切换到最后一个标签页 yt 复制当前的标签页 x 关闭当前标签页 X 恢复刚刚关闭的标签页 你应该已经注意到了，多数情况下小写字母表示当前标签页，大写字母表示新标签页。而区分大小写也是 Vimium 与 Chrome 原生快捷键很大的一个不同点（不信你试试按下 CapsLock 键）。Vimium 不止是快捷键，你应该页注意到上面的 “快速启动框” 了，凭借着模糊搜索，你能迅速定位到你曾经访问过的网页，而无需再用鼠标一个个去翻找了。而这么多的快捷键中唯一一个能被别人看出来你是在用 Vimium 的只有 f 和 F 了，因为按下后网页上会显示每个链接的快捷键，按下屏幕上新显示的快捷键能够打开链接（或在新标签页中打开链接）。摆脱鼠标，像黑客一样操作 Chrome快捷键虽然多，但其实只需要练习几个小时就熟练了，双手不需要再不断在鼠标和键盘之间移动时，你的效率已暗中提高了。我会偷偷告诉你我鼠标坏了吗？参考资料 Chrome 键盘快捷键 - Google Chrome帮助" }, { "title": ".NET/C# 使用 Span&lt;T&gt; 为字符串处理提升性能", "url": "/post/improve-string-performance-using-span.html", "categories": "", "tags": "dotnet, csharp", "date": "2018-07-22 00:51:23 +0800", "snippet": ".NET Core 2.1 和 C# 7.2 带来了 Span 的原生支持，原本需要使用不安全代码操作的内存块现在可以使用安全的方式来完成。此前在性能和稳定性上需要有所取舍，而现在可以兼得了。简单的例子先来看一个字符串处理时使用 Span&amp;lt;T&amp;gt; 的最简单的例子：using System;using System.Text;namespace Walterlv.Demo.StringSpan{ internal class Program { static void Main(string[] args) { var text = &quot;https://walterlv.github.io/&quot;; var nameSpan = text.AsSpan(8, 8); var builder = new StringBuilder(&quot;Hello &quot;); builder.Append(nameSpan); builder.AppendLine(&quot;!&quot;); Console.WriteLine(builder.ToString()); } }}这个例子是从 https://walterlv.github.io/ 字符串中取出第 8 个字符开始长度为 8 的部分，随后与其它字符串进行拼接。最后，我们得到了拼接的字符串：这种方式取出字符串替代了 SubString 这种会额外生成临时字符串的方式。如果上述代码发生在较大或较多文本的处理中，那么反复的拼接将生成大量的临时字符串，造成大量 GC 压力；而使用 Span&amp;lt;T&amp;gt; 将不会额外生成任何临时字符串。语言/框架的支持然而，只有 .NET Core 2.1 是原生支持字符串的 AsSpan&amp;lt;T&amp;gt; 方法的，.NET Core 2.0、.NET Framework 4.7.2 是不支持的。.NET Core 2.0 可以无视，因为有了 2.1。但 .NET Framework 的低版本却不能无视，因为用户的计算机上通常都是安装低版本的 .NET Framework。然而我们可以安装 System.Memory，以在低版本的 .NET 中获得字符串扩展方法 AsSpan&amp;lt;T&amp;gt; 的支持。那么问题来了，低版本的 .NET StringBuilder 中并没有提供 Append(ReadOnlySpan&amp;lt;char&amp;gt;) 方法，于是我们即便使用高性能的方式得到了字符串的一个片段，依然无法将其反复进行拼接。这真是一个悲伤的故事！低版本 .NET 中有限的字符串性能提升缺少了 StringBuilder 对 ReadOnlySpan&amp;lt;char&amp;gt; 的支持，广泛使用的字符串拼接功能便没有办法获得 Span 的支持。不过，System.Memory 中提供了其它有限的字符串处理支持，来源于以下两个类型： System.Buffers.Text.Utf8Parser System.Buffers.Text.Utf8Formatter前者提供从 ReadOnlySpan&amp;lt;char&amp;gt; 到 Int32、Double、DateTime、Guid 等类型的解析，后者提供相反的转换。期待 Microsoft 在未来版本的 System.Memory 库中提供对字符串拼接在低版本 .NET 生态中的支持。参考资料 Welcome to C# 7.2 and Span - .NET Blog C# 7.2: Understanding Span - Connect(); 2017 - Channel 9 C# Span 入门" }, { "title": "使用 PInvoke.net Visual Studio Extension 辅助编写 Win32 函数签名", "url": "/post/pinvoke-net-visual-studio-extension.html", "categories": "", "tags": "dotnet, csharp, visualstudio, windows", "date": "2018-07-21 22:35:49 +0800", "snippet": "在 .NET 程序中使用 Win32 函数并不如 C++ 中方便。因为 C# 中不能引入 C++ 中常用的头文件，于是各种方法签名、结构体定义等等都需要各种寻找。然而 PInvoke.net 帮助我们解决了这个问题。本文推荐一款 Visual Studio 插件来帮助我们更快速地插入 Win32 函数签名。PInvoke.netPInvoke.net 的官方网站是 https://www.pinvoke.net/，如果你只是希望临时找一找 P/Invoke 函数调用的方法签名，那么直接去网站就能搜索。不过，如果你期望写代码时能够随时方便地插入，那么安装插件还是非常方便的。前往 Visual Studio Marketplace 即可下载安装 PInvoke.net Visual Studio Extension 扩展。不过，更推荐直接在 Visual Studio 的“工具-&amp;gt;扩展和更新”里面在线下载安装插件：下载完关闭所有的 Visual Studio 后，会弹出扩展安装界面，继续安装即可。使用 PInvoke.net 扩展在安装了 PInvoke.net 插件后，可以在顶部菜单栏中寻找到 PInvoke.net 菜单项，里面可以插入 PInvoke 的函数调用签名：现在，我们搜索 MoveWindow 函数：随后点击 Insert 便在代码中得到了一份 MoveWindow 的 P/Invoke 函数签名。/// &amp;lt;summary&amp;gt;/// The MoveWindow function changes the position and dimensions of the specified window. For a top-level window, the/// position and dimensions are relative to the upper-left corner of the screen. For a child window, they are relative/// to the upper-left corner of the parent window&#39;s client area./// &amp;lt;para&amp;gt;/// Go to https://msdn.microsoft.com/en-us/library/windows/desktop/ms633534%28v=vs.85%29.aspx for more/// information/// &amp;lt;/para&amp;gt;/// &amp;lt;/summary&amp;gt;/// &amp;lt;param name=&quot;hWnd&quot;&amp;gt;C++ ( hWnd [in]. Type: HWND )&amp;lt;br /&amp;gt; Handle to the window.&amp;lt;/param&amp;gt;/// &amp;lt;param name=&quot;X&quot;&amp;gt;C++ ( X [in]. Type: int )&amp;lt;br /&amp;gt;Specifies the new position of the left side of the window.&amp;lt;/param&amp;gt;/// &amp;lt;param name=&quot;Y&quot;&amp;gt;C++ ( Y [in]. Type: int )&amp;lt;br /&amp;gt; Specifies the new position of the top of the window.&amp;lt;/param&amp;gt;/// &amp;lt;param name=&quot;nWidth&quot;&amp;gt;C++ ( nWidth [in]. Type: int )&amp;lt;br /&amp;gt;Specifies the new width of the window.&amp;lt;/param&amp;gt;/// &amp;lt;param name=&quot;nHeight&quot;&amp;gt;C++ ( nHeight [in]. Type: int )&amp;lt;br /&amp;gt;Specifies the new height of the window.&amp;lt;/param&amp;gt;/// &amp;lt;param name=&quot;bRepaint&quot;&amp;gt;/// C++ ( bRepaint [in]. Type: bool )&amp;lt;br /&amp;gt;Specifies whether the window is to be repainted. If this/// parameter is TRUE, the window receives a message. If the parameter is FALSE, no repainting of any kind occurs. This/// applies to the client area, the nonclient area (including the title bar and scroll bars), and any part of the/// parent window uncovered as a result of moving a child window./// &amp;lt;/param&amp;gt;/// &amp;lt;returns&amp;gt;/// If the function succeeds, the return value is nonzero.&amp;lt;br /&amp;gt; If the function fails, the return value is zero./// &amp;lt;br /&amp;gt;To get extended error information, call GetLastError./// &amp;lt;/returns&amp;gt;[DllImport(&quot;user32.dll&quot;, SetLastError = true)]internal static extern bool MoveWindow(IntPtr hWnd, int X, int Y, int nWidth, int nHeight, bool bRepaint);不过，插件内所带的 P/Invoke 函数似乎并不够多，因为对于 DwmSetWindowAttribute 这样的函数并没有在插件中出现。不过 https://www.pinvoke.net/ 中是包含的。除了包含 C# 调用所需的函数签名之外，还包含函数签名中所用的结构体或枚举类型定义。[DllImport(&quot;dwmapi.dll&quot;, PreserveSig = true)]public static extern int DwmSetWindowAttribute(IntPtr hwnd, DWMWINDOWATTRIBUTE attr, ref int attrValue, int attrSize);enum DWMWINDOWATTRIBUTE : uint{ NCRenderingEnabled = 1, NCRenderingPolicy, TransitionsForceDisabled, AllowNCPaint, CaptionButtonBounds, NonClientRtlLayout, ForceIconicRepresentation, Flip3DPolicy, ExtendedFrameBounds, HasIconicBitmap, DisallowPeek, ExcludedFromPeek, Cloak, Cloaked, FreezeRepresentation}感谢广大 .NET 的社区开发者帮助收集各种 PInvoke 函数签名；如果你发现了一些没有收录的，也欢迎加入。" }, { "title": "使用 IFTTT 做 RSS 的邮件订阅服务", "url": "/post/rss-email-using-ifttt.html", "categories": "", "tags": "miscellaneous", "date": "2018-07-21 17:40:56 +0800", "snippet": "IFTTT 是一个奇特的网络服务。它本身没有提供什么功能，但因为它的工作方式类似编程，所以你可以拿它做各种各样难以想象的事情。本文将使用 IFTTT 做一个 RSS 的邮件订阅服务。IFTTTIFTTT 这种神奇的名字还是需要介绍一下的 —— 读作 [ɪft]，意思是 If This Then That。直接翻译，是“如果这个，那就那个”。这其实挺有趣的，因为这就像编程语言中的 if 语句：If This Then That()这个句子本身并不涉及什么功能，但我们能通过修改这个语句中的 This 和 That 来达到执行各种功能的效果。做一个 RSS 邮件订阅服务首先，前往 IFTTT：https://ifttt.com/。你需要注册一个账号，在登录后再进行下面的操作。在首页，我们能找到 MyApplets 标签，进去后，我们便可以新建我们的 RSS 邮件订阅服务。在 MyApplets 页面，点击 New Applet 新建一个 Applet。这时，我们能看到一个大大的 “if +this then that” 的短语。注意到 this 的颜色不同，而且前面有一个加号 —— 这是一个大大的按钮，提醒你当前的步骤是修改 this。点击 this 之后，我们发现 IFTTT 为我们提供了大量的 this 触发源。找到 RSS Feed，随后选择 New feed item。贴上一个 RSS 的链接 https://walterlv.github.io/feed.xml：创建完成之后，我们又能看到大量的动作：选择邮件：然后可选修改邮件中的格式：完成：这样，当我的博客中有新的文章发布的一小时内，邮箱中就可以收到邮件通知了。参考资料 IFTTT - 维基百科，自由的百科全书" }, { "title": "理解 Roslyn 中的红绿树（Red-Green Trees）", "url": "/post/the-red-green-tree-of-roslyn.html", "categories": "", "tags": "roslyn, dotnet, csharp", "date": "2018-07-19 19:48:52 +0800", "snippet": "Roslyn 的 API 是非常易用的。即便如此复杂的 C# 语法，建立的复杂的 C# 语法树，还有其复杂的树遍历和修改过程，也都被其 API 包装得干净简洁。而这背后是它的重要设计思路 —— 红绿树。红绿树的影子如果你是通过搜索找到这篇文章的，那么至少证明你调试过 Roslyn API 的使用，或者阅读过 Roslyn 的源码。因为正常使用 Roslyn 的 API 时你是看不到红绿树的，这是 Roslyn 的实现细节。但你在调试的时候可能会看到 Green 属性，或者在阅读源码时看到 GetRed 方法。▲ 调试时看到的绿树protected T GetRed&amp;lt;T&amp;gt;(ref T field, int slot) where T : SyntaxNode{ var result = field; if (result == null) { var green = this.Green.GetSlot(slot); if (green != null) { Interlocked.CompareExchange(ref field, (T)green.CreateRed(this, this.GetChildPosition(slot)), null); result = field; } } return result;}▲ Roslyn 中获取红树的源代码源代码摘抄自：roslyn/SyntaxNode.cs at master · dotnet/roslyn。Roslyn 的设计理念Roslyn 一开始就将漂亮的 API 作为目标的一部分，同时还要非常高的性能；所以 Roslyn 的开发团队需要找到一种特殊的数据结构来描述语言（如 C#）的语法。这种数据结构要满足这些期望的要求： 不可变（Immutable） 树的形式 可以容易地访问父节点和子节点 可以非常容易地将任何一个节点对应到源代码文件的一段文本区间 可重用（Persistent）最后一个的英文说法是 Persistent，单词的原本意思是“可持久的，连续的”，我把它翻译为“可重用”（Reusable）。Roslyn 的设计中有一个重要的业务需求，希望能够分析源代码文件并在开发者编辑的过程中不断提供建议。也就是说，当我们连续不断地去修改源代码中的文本内容时，Roslyn 也需要具备很高的性能。如果每次编辑代码都去重新解析一次整份源代码，然后全部重新生成整个数据结构，那将是大量的性能浪费；更不可能实时去分析开发者编辑的源码。所以，在 Roslyn 的设计中，希望源代码文本改变时，整棵树中的大多数节点都是能够重复使用的（无需重新生成）。而如果将数据结构设计成不可变的（Immutable），那么重用这些节点将会非常容易。当然不止对于 Roslyn，对其它数据来说，不可变也一样有各种好处；比如可以随时重用这份数据的实例而不用担心可能被各个不同的业务模块意外修改，比如天然是线程安全的。那么问题来了，到底什么样的数据结构能够在同时满足以上所有的特点的前提下，同时还能设计出简单易用的 API 呢？ 既然要容易地访问到父节点和子节点，那么我们是先构造父节点还是子节点呢？如果先构造父节点，那子节点还没有创建出来；而先构造子节点，那父节点就没构造出来。我们要求这样的数据结构具有不可变性，所以我们不可能先把它们都构造出来再去修改它们的父子关系。 还有，我们也不能随意地去为任何子节点指定新的父节点，因为子节点是不可变的。然而我们同时有希望能够在连续修改的情况下具备较高的性能，如果连修改父节点都不能办到，那也很难重用之前的节点，最终不得不再次重新生成所有的子节点。 另外，如果你在源代码文件中插入了一个字符，那么这个字符后面的每一个节点对应的源代码区间都需要改变。然而这非常不利于连续修改，因为随便一个字符的插入都将导致更新大量节点中的文本区间信息。而由于不可变性，我们只能重新生成这些节点而没法儿重用它们。于是 Roslyn 团队就折腾出了“红绿树”（Red-Green Trees）。红绿树红绿树并不是一棵树，而是两棵树。绿树（the green tree）是不可变的，可重用的，没有父节点的引用。绿树的构建是自下而上的，每一个节点都保存它在文本区间中的字符个数（说通用点是宽度）。如果源代码的内容被编辑，我们只需要重新创建受编辑影响的绿树的部分；相比于重新分析整棵树，其时间复杂度只有 O(log n)。红树（the red tree）也是不可变的，是围绕绿树而建的外观（参见 外觀模式）。红树的构建是自上而下的，但红树只在需要时才会创建，而一旦编辑了源代码文件，红树就直接丢弃不用了。如果有需要，红树就会开始创建；它会根据绿树自上而下计算最新的父节点引用，计算节点最新对应的文本区间。这两棵树设计起来协同工作，前者负责解决 Roslyn 语法分析的性能问题，后者负责对开发人员提供友好的 API 调用。由于最开始 Roslyn 团队的大佬们在会议室讨论时，前者是用红笔画的，后者是用绿笔画的，于是就合在一起称作“红绿树”。自此，Roslyn 团队设计出的这种数据结构满足了以上所有的要求。不过，如果红树太大，每次重新生成依然会耗费比较多的性能。参考资料 Persistence, Facades and Roslyn’s Red-Green Trees – Fabulous Adventures In Coding 外觀模式 - 维基百科，自由的百科全书" }, { "title": "Roslyn 语法树中的各种语法节点及每个节点的含义", "url": "/post/roslyn-syntax-tree-nodes.html", "categories": "", "tags": "roslyn, dotnet, csharp", "date": "2018-07-18 20:24:00 +0800", "snippet": "使用 Roslyn 进行源码分析时，我们会对很多不同种类的语法节点进行分析。如果能够一次性了解到各种不同种类的语法节点，并明白其含义和结构，那么在源码分析的过程中将会更加得心应手。本文将介绍 Roslyn 中各种不同的语法节点、每个节点的含义，以及这些节点之间的关系和语法树结构。基本概念using System;namespace Walterlv.Demo{ class Program { static void Main(string[] args) { Console.WriteLine(&quot;Hello Walterlv!&quot;); } }}以上是一个非常简单但完整的 .cs 文件。在 Roslyn 的解析中，这就是一个“编译单元”（Compilation Unit）。编译单元是 Roslyn 语法树的根节点。紧接着的 using System 是 using 指令（Using Directives）；随后是命名空间声明（Namespace Declaration），包含子节点类型声明（Class Declaration）；类型声明包含子节点方法声明（Method Declaration）。接下来，我们会介绍 Roslyn 语法树中各种不同种类的节点，以及其含义。语法节点语法树CompilationUnit，是语法树的根节点。关键字UsingKeyword、NamespaceKeyword、PublicKeyword、InternalKeyword、PrivateKeyword、ProtectedKeyword、StaticKeyword、ClassKeyword、InterfaceKeyword、StructKeyword。分别是 C# 的各种关键字：using, namespace, public, internal, private, protected, static, class, interface, struct。InKeyword、OutKeyword、RefKeyword、ReturnKeyword、ConstKeyword、DefaultKeyword。分别是 C# 的另一波关键字 in、out、ref、return、const、default。ByteKeyword、CharKeyword、IntKeyword、LongKeyword、BoolKeyword、FloatKeyword、DoubleKeyword、DecimalKeyword。分别是 C# 中的基元类型关键字byte、char、int、long、bool、float、double、decimal。需要注意的是，var 和 dynamic 并不是基元类型关键字，在语法节点中，它是 IdentifierName。AsyncKeyword、AwaitKeyword。分别是 async、await 关键字。TrueKeyword、FalseKeyword。分别是 true 和 false 关键字。LockKeyword、CheckedKeyword、UncheckedKeyword、UnsafeKeyword、FixedKeyword。分别是 lock、checked、unchecked、unsafe、fixed 关键字。符号DotToken、SemicolonToken、OpenBraceToken、CloseBraceToken、LessThanToken、GreaterThanToken、OpenParenToken、CloseParenToken。分别是 C# 中的各种符号：., ;, {, }, &amp;lt;, &amp;gt;, (, )。空白EndOfLineTrivia 表示换行，WhitespaceTrivia 表示空格，EndOfFileToken 表示文件的末尾。通常，这两个语法节点会在另一个节点的里面，作为另一个节点的最后一部分。比如 using Walterlv.Demo; 是一个 UsingDirective，它的最后一个节点 Semicolon 中就会包含换行符 EndOfLineTrivia。指令UsingDirective 是 using 指令。一个 using 指令包含一个 UsingKeyword，一个 QualifiedName 和一个 Semicolon（;）。声明NamespaceDeclaration、ClassDeclaration、MethodDeclaration、PropertyDeclaration、FieldDeclaration、VariableDeclaration。分别是命名空间、类型、方法、属性、。其中，属性声明包含一个 AccessorList，即属性访问器列表，访问期列表可以包含 GetAccessorDeclaration（属性 get）、SetAccessorDeclaration（属性 set）的声明。这些声明通常是嵌套存在的。例如一个常规的文件的第 0、1 级语法节点通常是这样的： CompilationUnit UsingDirective UsingDirective NamespaceDeclaration EndOfFileToken 类型声明是命名空间声明的子节点，类型成员的声明是类型声明的子节点。名称和标识符 QualifiedName 限定名称，可以理解为完整的名称。 例如命名空间 Walterlv.DemoTool 的限定名称就是这个全称 Walterlv.DemoTool；类型 Walterlv.DemoTool.Foo 的限定名称也是这个全程 Walterlv.DemoTool.Foo。 IdentifierName 标识名称，当前上下文下的唯一名称。 例如 Walterlv 和 DemoTool 都是 Walterlv.DemoTool 这个命名空间的标识符。 IdentifierToken 标识符，具体决定 IdentifierName 的一个字符串。 这其实与 IdentifierName 是一样的意思，但是在语法树上的不同节点。 GenericName 泛型名称，即 Foo 这种。 特性AttributeList、Attribute。一个允许添加特性的地方，如果添加了特性，那么可以得到 AttributeList 节点，内部包含了多个 Attribute 子节点。形参和实参形参是 parameter，实参是 argument。前者是定义的参数，后者是实际传入的参数。语法节点中有两种不同的形参和实参，一个是泛型，一个是普通参数。 ParameterList 形参列表，出现在方法声明中，即 void Foo(string a, bool b) 中的 (string a, bool b) 部分。 Parameter 形参，即以上例子中的 string a 和 bool b 部分。 ArgumentList 实参列表，出现在方法调用中，即 this.Foo(a, b) 中的 (a, b) 部分。 Argument 实参，即以上例子中的 a 和 b 部分。 TypeParameterList 泛型形参列表，出现在类型声明或者方法声明中，即 void Foo&amp;lt;T1, T2&amp;gt;(string a) 中的 &amp;lt;T1, T2&amp;gt; 部分。 TypeParameter 泛型形参，即以上例子中的 T1 和 T2 部分。 TypeArgumentList 泛型实参列表，出现在使用泛型参数的地方，例如 this.Foo&amp;lt;T1, T2&amp;gt;() 中的 &amp;lt;T1, T2&amp;gt; 部分。 TypeArgument 泛型实参，即以上例子中的 T1 和 T2 部分。 语句块 Block 即用 { 和 } 包裹的语句代码。 当然并不是所有 { 和 } 包裹的都是语句（例如类型声明就不是），里面真正有代码时才是语句。 EqualsValueClause 等号子句，例如 = null。我们经常称之为“赋值”语句。 语句一个语句是指包含分号在内的实际执行的句子。 LocalDeclarationStatement 本地变量声明语句，即 var a = 0; 这样的句子；其中，去掉分号的部分即前面我们提到的变量声明 VariableDeclaration。 一个本地变量声明的语句也可以不包含赋值。 ExpressionStatement 表达式语句，即 this.Foo(); 这样的一次方法调用。如果去掉分号，剩下的部分是表达式（Expression）。 IfStatement if 语句，即一个完整的 if-else if-else。 ForStatement for 语句。 ForEachStatement for 语句。 WhileStatement while 语句，即一个完整的 while。 DoStatement do-while 语句。 DefaultStatement default(); 语句。 ReturnStatement return 语句。 CheckedStatement checked 语句。 UncheckedStatement checked 语句。 UnsafeStatement unsafe 语句。 FixedStatement unsafe 语句。 表达式 EqualsExpression 相等判断表达式，即 a == b。 InvocationExpression 调用表达式，即 Class.Method(xxx) 或 instance.Method(xxx) 这种完整的调用。 SimpleMemberAccessExpression 这是 InvocationExpression 的子节点，是方法调用除去参数列表的部分，即 Class.Method 或 instance.Method。 如果是获取属性（没有参数列表），那么也是这个节点。 AwaitExpression await 表达式，即 await this.Foo() 这样的调用。 DefaultExpression default() 表达式。 TrueLiteralExpression true 表达式。 FalseLiteralExpression false 表达式。 ParenthesizedLambdaExpression 带括号的 lambda 表达式，例如： () =&amp;gt; xxx、(a) =&amp;gt; xxx、(a, b) =&amp;gt; xxx、(int a, string b) =&amp;gt; xxx () =&amp;gt; { }、(a) =&amp;gt; { }、(a, b) =&amp;gt; { }、(int a, string b) =&amp;gt; { } SimpleLambdaExpression 不带括号的 lambda 表达式，例如： a =&amp;gt; xxx、a =&amp;gt; { } 基元类型PredefinedType 是所有基元类型的节点。它的子节点可能是 BoolKeyword、StringKeyword 或其它基元类型的关键字。C# 内建类型NullableType、TupleType、ArrayType。这三个分别是 C# 中语法级别支持的类型，分别是可空类型、元组类型和数组类型。 NullableType 即 bool? 这种用于创建 Nullable&amp;lt;bool&amp;gt; 的语法。 TupleType 即 (bool, string) 这种用于创建 ValueTuple&amp;lt;bool, string&amp;gt; 的语法。 ArrayType 即 [] 这种用于创建数组类型的语法。 " }, { "title": ".NET Standard 的管理策略", "url": "/post/net-standard-governance.html", "categories": "", "tags": "dotnet", "date": "2018-07-08 22:28:41 +0800", "snippet": ".NET Standard 作为各大 .NET 的标准，我们有必要了解一下它是如何在各种 .NET 的实现之间履行自己的职责的。所以，本文会说说它的管理策略。都有哪些 .NET Standard 的实现？目前 .NET Standard 的实现有这些： .NET Core .NET Framework Mono Unity Xamarin标准在前还是实现在前？标准在前指的是先制定出 .NET Standard 的某个版本的标准，然后再由各个 .NET Standard 的实现去完成实现。而实现在前指的是待各个 .NET Standard 的实现完成某个版本的发布之后，.NET Standard 再进行新版本的发布，确保发布时所有实现都已有版本完成。.NET Standard 采取的是后者——实现在前。主要在于，如果 .NET Standard 的 API 先发布，那么很多开发者基于新 .NET Standard API 开发的应用可能根本就没有办法编译到 .NET 的各个实现，例如 Mono/Xamarin。标准之内还是使用标准？.NET Standard 的发布有两种不同的方式。第一种，也是大家经常提及的一种，即要求各大 .NET 实现都内置的 API 集。当我们在项目文件中指定 TargetFramework 为 netstandard 时，我们可以直接地原生地使用到的那些 API。第二种，是通过 NuGet 包发布的基于 .NET Standard 标准实现的 TargetFramework 指定为 netstandard 的类库。不止微软通过这种方式发布了大量基于 .NET Standard 的类库， 上大量流行的库也基本上都有生成基于 `netstandard` 的版本。而这种并不需要各大 .NET 实现对此做额外的发布都能够正常使用，因为这种发布到 NuGet 上的包本身已自带一份实现。这两种不同的方式分别独立更新而互不影响。并不一定都能实现的标准.NET Standard 中的 API 并不一定都是能被各大 .NET 的实现来实现的，因为现实的运行环境总是有或多或少的限制。典型的例子是——苹果 App Store 的应用商店不允许应用在运行时生成可执行代码，所以 Xamarin 的 iOS 版本就无法实现运行时代码生成的部分标准。参考资料 standard/README.md at master · dotnet/standard" }, { "title": "在 Visual Studio 的解决方案资源管理器中隐藏一些文件", "url": "/post/make-items-invisible-in-vs-solution-explorer.html", "categories": "", "tags": "msbuild, nuget, visualstudio, dotnet", "date": "2018-07-04 20:30:08 +0800", "snippet": "项目文件中有一些属性几乎是专门为 IDE 而准备的，不过考虑到 .NET 生态的开发者多数都使用 Visual Studio，所以基本上也只有 Visual Studio 对这些特性支持的最全面。（才不会透漏这些属性其实本就是为 Visual Studio 而准备的呢。）本文将介绍如何在 Visual Studio 的解决方案资源管理器中隐藏一些文件。原生支持Visual Studio 原生支持 Visible 属性用来控制某一项文件是否在 Visual Studio 的解决方案资源管理器中显示。具体来说，是这样设置的：&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;TargetFramework&amp;gt;netcoreapp2.1&amp;lt;/TargetFramework&amp;gt; &amp;lt;EnableDefaultItems&amp;gt;false&amp;lt;/EnableDefaultItems&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;Compile Include=&quot;**\\*.cs&quot; Exclude=&quot;obj\\**\\*.cs&quot; Visible=&quot;false&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt;&amp;lt;/Project&amp;gt;好了，任务完成，全文结束！要是只有这样，我才不会写这篇文章呢！原生不支持考虑一下像上图那样有些文件在文件夹中的情况，然后我们再次设置 Visible=&quot;false&quot; 属性：文件夹竟然还在！这是 Visual Studio 的 Bug 吗？还真是，至少在 Visual Studio 的项目系统中就有这样的 Issue 处于打开的状态： Content Visible=false hides the item, but not the directories in Solution Explorer · Issue #162 · Microsoft/VSProjectSystem回复是： Yes this is a known issue. We are discussing options to resolve it over here dotnet/roslyn-project-system#1233好吧，那就等着解决吧！不过等大家的 Visual Studio 更新到解决的版本还需要很久吧。变通解决所以，我们只好采取其他手段来解决，最容易想到的是编写一个 &amp;lt;Target /&amp;gt;。&amp;lt;Target Name=&quot;IncludeSourceCodes&quot; BeforeTargets=&quot;CoreCompile&quot;&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;Compile Include=&quot;**\\*.cs&quot; Exclude=&quot;bin\\**\\*.cs;obj\\**\\*.cs;&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt;&amp;lt;/Target&amp;gt;这样，引入这些文件就是通过在编译时才引入的。没有开始编译时，项目中自然看不见。如果这样的例子发生在制作的 NuGet 包中，那么这个文件可能在 NuGet 包中的路径是 /build/Walterlv.Demo.targets；为了引用额外的源码，我们可以加上额外的路径信息：&amp;lt;Target Name=&quot;IncludeSourceCodes&quot; BeforeTargets=&quot;CoreCompile&quot;&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;Compile Include=&quot;$(MSBuildThisFileDirectory)..\\src\\**\\*.cs&quot; Exclude=&quot;$(MSBuildThisFileDirectory)..\\src\\bin\\**\\*.cs;$(MSBuildThisFileDirectory)..\\src\\obj\\**\\*.cs;&quot; /&amp;gt; &amp;lt;/ItemGroup&amp;gt;&amp;lt;/Target&amp;gt;活学活用这并不是说在 Visual Studio 的解决方案资源管理器中，隐藏文件都应该采用 &amp;lt;Target /&amp;gt; 来做，毕竟这样太复杂了。如果没有太复杂的要求，直接些 Visible=&quot;false&quot; 也未尝不可。比较复杂的情况可能比如： 制作跨平台的 NuGet 源码包，安装后就像直接把源码放进项目一样 需要额外为项目准备一些辅助运行的必要文件参考资料 Content Visible=false hides the item, but not the directories in Solution Explorer · Issue #162 · Microsoft/VSProjectSystem" }, { "title": "如何在 MSBuild Target（Exec）中报告编译错误和编译警告", "url": "/post/standard-error-warning-format.html", "categories": "", "tags": "dotnet, msbuild", "date": "2018-07-02 20:49:55 +0800", "snippet": "我曾经写过一篇文章 如何创建一个基于命令行工具的跨平台的 NuGet 工具包，通过编写一个控制台程序来参与编译过程。但是，相比于 基于 Task 的方式，可控制的因素还是太少了。有没有什么办法能够让控制台程序也能与 MSBuild Target 之间发生更多的信息交换呢？比如报告编译错误和编译警告？答案是有的，通过格式化控制台输出。编译错误和编译警告MSBuild 的 Exec 自带有错误和警告的标准格式，按照此格式输出，将被识别为编译错误和编译警告。而格式只是简简单单的 error: 开头或者 warning: 开头。冒号前面也可以加上空格。using System;namespace Walterlv.Demo{ internal class Program { private static void Main(string[] args) { Console.WriteLine(&quot;warning: walterlv 最好是一个逗比。&quot;); Console.WriteLine(&quot;error: walterlv 必须是一个逗比。&quot;); } }}对于这样一段在编译期间执行的程序，编译时将显示如下信息，并产生编译错误和编译警告。当然，在这个例子中，我直接在编译完成后执行自己，产生了这样的编译错误。&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;TargetFramework&amp;gt;net47&amp;lt;/TargetFramework&amp;gt; &amp;lt;Target Name=&quot;PostBuild&quot; AfterTargets=&quot;PostBuildEvent&quot;&amp;gt; &amp;lt;Exec Command=&quot;$(OutputPath)$(AssemblyName).exe&quot; /&amp;gt; &amp;lt;/Target&amp;gt;&amp;lt;/Project&amp;gt;更复杂的错误和警告控制实际上，上面的 warning、error 只是省略的格式，而完整的部分是这样的：file_path(line_start,column_start,line_end,column_end): error_or_warning key: message file_path 是文件的绝对路径或相对于项目文件的路径，这样的输出之后在 Visual Studio 中双击之后可以定位到文件。 line_start、column_start、line_end、column_end 控制双击之后选中文件的开始和结束行列。 error_or_warning 可选为 error 或者 warning。 key 是一个唯一标识符，如果用户认为可以忽略这样的错误，则可以使用这个唯一的 key 来禁止某一特定项的警告。 message 则是普通的消息提示内容。Demo.cs(344,59,344,78): warning CS0067: The event &#39;WalterlvClass.Foo&#39; is never used.阻止编译错误和编译警告的格式化识别当然，有可能你只是需要一个 error: 开头或者 warning: 开头的格式，并不希望真的产生编译错误或者编译警告，那么只需要在执行 Exec 的时候设置 IgnoreStandardErrorWarningFormat=&quot;True&quot;。&amp;lt;Exec IgnoreStandardErrorWarningFormat=&quot;True&quot; Command=&quot;$(OutputPath)$(AssemblyName).exe&quot; /&amp;gt;参考资料 Exec task and “error :” in output" }, { "title": "语义耦合（Semantic Coupling）", "url": "/post/semantic-coupling.html", "categories": "", "tags": "dotnet, framework", "date": "2018-06-30 15:01:06 +0800", "snippet": "跟小伙伴一起重构一段 UI，试图将用户界面和业务代码分离的时候，小伙伴试图在业务代码中直接调用 UI。我们当然都知道这会产生耦合，于是小伙伴试图定义一些属性、变量或接口来解决这个耦合。虽然在代码的静态分析中，这一的耦合消失了，但我始终觉得不妥。觉得耦合依然存在，只是不再能被静态分析了。我想到一个词——“语义耦合（Semantic Coupling）”，搜索发现也有很多小伙伴在关心这个问题。而且，从他们的文章和讨论中，我也了解到更多关于语义耦合的种类和危害。什么是语义耦合这是区别于常规意义上的“耦合”而言的。即类 Foo 依赖于类 Bar，即是常规意义上的耦合。静态代码分析工具就可以为我们发现这种耦合。如果将 Bar 拆开成两个部分，一是类 Bar 的实现本身，另一个是接口 IBar；现在 Foo 依赖的是接口 IBar，那么 Foo 就没有依赖类 Bar了。在静态代码分析工具中就会发现这样的依赖就解除了。在静态代码分析工具认为没有耦合的情况之下，如果两个类之间还交换带有隐含意义的数据，假设对方已为自己完成了某种工作，暗示对方执行期望的代码，那么这两个类在语义上还存在着耦合。我们说耦合的危害是修改一个类的时候，另一个类也需要做对应的修改。显式耦合有工具帮我们做重构时的解耦，而语义上的耦合却很难有准确帮助我们的工具。一些变态的工具（例如 ReSharper）能够帮助我们解决一部分。哪些代码算作语义耦合按照上面的定义，语义耦合的概念依然模糊，但都有一个统一的核心——在实现细节上存在依赖，而不是在调用上存在依赖。交换带有隐含意义的数据在这段代码中，Bar 依赖于 Foo，他们都依赖于 FooInfo。至少静态代码分析工具是这么认为的。public class Foo{ public void Do(object arg) { var info = (FooInfo) arg; // 后续代码。 }}public class Bar{ public void Test() { var info = new FooInfo(); _foo.Do(info); }}但是，其实这里的 Foo 也依赖于 Bar（反向依赖），因为 Foo 总假设 Bar 一定传了一个 FooInfo 类型的参数。在这里，Foo 对 Bar 的隐式依赖就构成了“语义耦合”。如何消灭这段语义耦合呢？将 object 类型的参数改为 FooInfo 类型是一个可选方案。但是，如果此函数是为了实现某个接口，object 是接口中对应方法的参数类型，那就不能这么改了。此时应该审视是否应该传入这个参数，或者审视接口设计的合理性。假设对方已为自己完成了某种工作典型的情况是要求调用某方法前先调用 Init。public class Foo{ private string _demo; public void Init() { _demo = &quot;walterlv&quot;; } public void Demo() { Console.WriteLine(_demo.Length); }}public class Bar{ public void Test() { var foo = new Foo(); foo.Init(); foo.Demo(); }}在这段代码中，如果 Bar 在使用 Demo 方法之前没有调用 Init，Foo 是会抛出异常的（事实上实现代码的异常不应该抛出，详情请参阅我的另一篇文章 永远不应该让实现异常抛出 - 吕毅）。类似的情况还有 Foo 中存在必须先赋值才能正常使用的字段/属性，或者必须按照特定的顺序调用才能正常实现的业务。这里 Foo 便产生了对 Bar 语义上的耦合。虽然并没有明显的依赖，但几乎所有使用 Foo 的对象都要求要写成 Bar.Test() 里面的实现那样，否则用起来就不正常。解决这里的语义耦合倒是有很多方法： 去掉 Init 方法，改到构造函数中 将 Init 改为普通的别的名称（比如 InitializeXxx），然后让 Demo 方法允许在 _demo 为 null 时正常工作（并能解释为什么正常） 如果初始化非常复杂必须在其他方法中实现，那么需要在 Demo 方法的开头进行状态预判，并抛出异常说明必须先进行初始化（毕竟通过异常报告使用错误是强有力的文档，关于使用错误，请参阅我的另一篇文章 使用错误 - 吕毅）。只有去掉 Init 方法才是真的解决了语义耦合，其他都是缓解语义耦合带来的危害。暗示对方执行期望的代码目前主流的 MVVM 框架几乎都支持 Message 机制，为了解决部分情况下 ViewModel 的操作需要通知到 View 来完成的情况。这是一个好机制，因为它在框架层完成了 ViewModel 对 View 消息的传递，避免了 ViewModel 对 View 的依赖。但是，这个机制太万能了，以至于各种不同的开发中可能写出实际上依然在耦合的代码（名义上已经不耦合了）：public class DemoView : IMessageReceiver&amp;lt;ShowErrorInfoMessage&amp;gt;, IMessageReceiver&amp;lt;DeleteAnimationMessage&amp;gt;{ public void OnReceived(ShowIOErrorInfoMessage message) { // 弹窗显示 IO 错误。 } public void OnReceived(DeleteAnimationMessage message) { // 播放某一项数据删除的动画。 }}public class DemoViewModel : ViewModelBase{ private void Test() { try { // 执行某段业务代码。 SendMessage(new DeleteAnimationMessage(removingItemId)); // 继续执行某段业务代码。 } catch(IOException ex) { SendMessage(new ShowIOErrorInfoMessage(ex)); } }}在代码中，ViewModel 试图向 View 发送播放删除动画的消息和显示错误提示的消息，让 View 来播放动画并显示这些错误。如果进行静态代码分析，ViewModel 依然对 View 没有任何依赖，但它们依然存在语义耦合。因为已经可以通过阅读代码来明白 ViewModel 正在试图播放动画和显示错误提示框。ViewModel正在期望对方来为自己实现某项自己无法单独实现的功能。Message 毕竟是 MVVM 框架中一个强大的组成部分，只依赖于此机制也能够部分消除此耦合。方法是将 DeleteAnimationMessage 改名为 ItemRemovingMessage，将 ShowIOErrorInfoMessage 改名为 ErrorOccurredMessage。如此改动，那么 ViewModel 的代码中将不再包含任何期望 View 执行的逻辑，View 自己决定删除元素时是否播放动画（还是决定元素变灰），自己决定是否显示错误提示（还是决定自动纠正）。这样的改动基本上没有语义耦合了，但我认为依然存在很弱的耦合，因为依然存在 ViewModel 试图期望 View 做某个任务，只是任务已经非常抽象了。我在自己编写的 MVVM 框架中弱化了 Message 的机制（是非常的弱），逼迫 ViewModel 的实现者不要试图通知 View 做任何事情，而是由 View 的实现者决定是否对 ViewModel 中任务的执行结果进行反馈。为什么语义耦合也有危害直接的耦合可以在静态代码分析工具的帮助下帮助我们理清楚依赖关系并批量重构（重命名等），不过这个过程是非常痛苦的，尤其是耦合是双向的时候，或者被非常多类耦合的时候。而语义上的耦合很难被静态代码分析工具分析出来，危害没有直接的耦合那么大，改起来也不那么痛苦。不过也有一些问题： 可能会隐藏着某些 BUG（尤其是在修改了被语义耦合的类时，根本就不知道对方会用怎样的方式在语义上耦合自己，改完还不一定出异常） 不利于单元测试（语义耦合会使得单元测试的用例变多，但可能根本就是无效或重复的；或者使得某些用例变得不可测，例如上面例子中要求单元测试播放动画或者显示错误提示框是不合理的） 设计上不那么好看（至少对强迫症患者来说是这样）参考资料 The Perils of Semantic Coupling - Wide Awake Developers Semantic coupling in code - Alejandro Duarte" }, { "title": "XML 的 XPath 语法", "url": "/post/xml-xpath.html", "categories": "", "tags": "dotnet", "date": "2018-06-24 19:43:39 +0800", "snippet": "XPath 是 XML 路径语言（XML Path Language），用来确定XML文档中某部分位置的语言。无论是什么语言什么框架，几乎都可以使用 XPath 来高效查询 XML 文件。本文将介绍 XPath 的一些语法。本文读写的 XML 文件会以 文章末尾的代码 - 假设的 XML 文件 作为示例。XPath 被称作 XML 路径语言，正出自于其最重要的 —— 路径表达式。路径 /package/metadata/id 这样的路径描述语法将可以找到 package 节点下的 metadata 节点下的 id 节点。 /package/metadata/*[1] 使用 * 可以找到任意名称，于是这样的路径描述语法将可以找到 metadata 下第一个节点，名称是任意的。 尤其要注意的是，XPath 的路径语法第一个节点从 1 开始，而不是 0。 /package//dependency // 表示只要是前面节点的内部即可，无论中间经过了多少层。 如果把 // 写到了最前面，例如 //dependency，那么表示寻找任意位置的 dependency 节点。 其实，上面的那些语法都是简写形式的语法，如果将它们完整写出来，将是这样的形式： /child::package/child::metadata/child::id /child::package/child::metadata/child::node()[1] /child::package/descendant-or-self::dependency这里的 child、descendant-or-self 是轴描述语法，除了这两个，还有这些： child 子节点 可以省略不写 attribute 属性 可以用 @ 来缩写 descendant 子孙节点 descendant-or-self 自身引用及子孙节点，可以用 // 来缩写 parent 父节点 可以用 .. 来缩写 ancestor 祖先节点 ancestor-or-self 自身引用及祖先节点 following 在此节点后的所有完整节点，即不包含其祖先节点 preceding 在此节点前的所有完整节点，即不包含其子孙节点 following-sibling 下一个同级节点 preceding-sibling 上一个同级节点 self 自己 可以用 . 来缩写 namespace 命名空间 对于 attribute 的使用，例如 //repository/@type 查找任意位置的 repository 节点的 type 属性。节点类型在前面的路径中，我们已经使用了 node() 来寻找元素节点，除 node() 表达式之外，还有： comment() 注释，也就是 &amp;lt;!-- 注释 --&amp;gt; text() 文字 processing-instruction() XML 处理指令，也就是 &amp;lt;? 处理指令 ?&amp;gt; node() 节点 节点内容使用中括号来描述节点的内容。例如 //repository[@type=&#39;git&#39;] 用来查找任意位置的 repository 节点，并且它有一个 type 属性值为 git。中括号是可以写多个的，例如： //dependency[contains(@exclude, &#39;Build&#39;)][../group/@targetFramework=&#39;.NETStandard2.0&#39;]/@id 这将查找所有满足这些条件 dependency 节点的 id 属性： 其 exclude 属性中包含 Build 字符串 其父节点为 group 且 targetFramework 属性为 .NETStandard2.0 运算符 /、//、.. 这是前面描述的路径运算符 | 用于取两个节点查找结果的并集 例如 //licenseUrl | //projectUrl | //iconUrl 取任意位置的 licenseUrl、projectUrl 和 iconUrl 节点。 and、or 对两个条件取“与”或者“或” not() 函数 对条件取“非” +、-、*、div 以及 mod 加减乘除以及取余数 =、!=、&amp;lt;、&amp;gt;、&amp;lt;=、&amp;gt;= 比较相等或大小 更多函数w3c 对 XPath 支持的函数有详细的查询页面，可以访问 XPath and XQuery Functions and Operators 3.1 查询。在 .NET 中使用 XPath 语法在 .NET 中使用 XPath 语法可以参考我的另一篇文章：.NET 使用 XPath 来读写 XML 文件。假设的 XML 文件&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;package xmlns=&quot;http://schemas.microsoft.com/packaging/2012/06/nuspec.xsd&quot;&amp;gt; &amp;lt;metadata&amp;gt; &amp;lt;id&amp;gt;MSTestEnhancer&amp;lt;/id&amp;gt; &amp;lt;version&amp;gt;1.6.0&amp;lt;/version&amp;gt; &amp;lt;authors&amp;gt;walterlv&amp;lt;/authors&amp;gt; &amp;lt;owners&amp;gt;walterlv&amp;lt;/owners&amp;gt; &amp;lt;requireLicenseAcceptance&amp;gt;false&amp;lt;/requireLicenseAcceptance&amp;gt; &amp;lt;licenseUrl&amp;gt;https://github.com/easiwin/MSTestEnhancer/blob/master/LICENSE&amp;lt;/licenseUrl&amp;gt; &amp;lt;projectUrl&amp;gt;https://easiwin.github.io/mstest-enhancer&amp;lt;/projectUrl&amp;gt; &amp;lt;iconUrl&amp;gt;https://easiwin.github.io/mstest-enhancer/icon.png&amp;lt;/iconUrl&amp;gt; &amp;lt;description&amp;gt;MSTestEnhancer helps you to write unit tests without naming any method. You can write method contract descriptions instead of writing confusing test method name when writing unit tests.&amp;lt;/description&amp;gt; &amp;lt;releaseNotes&amp;gt;Support passing null into WithArgument method.&amp;lt;/releaseNotes&amp;gt; &amp;lt;copyright&amp;gt;Copyright (c) 2018 dotnet职业技术学院&amp;lt;/copyright&amp;gt; &amp;lt;repository type=&quot;git&quot; url=&quot;https://github.com/easiwin/MSTestEnhancer.git&quot; /&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;group targetFramework=&quot;.NETFramework4.5&quot;&amp;gt; &amp;lt;dependency id=&quot;MSTest.TestFramework&quot; version=&quot;1.2.0&quot; exclude=&quot;Build,Analyzers&quot; /&amp;gt; &amp;lt;dependency id=&quot;System.ValueTuple&quot; version=&quot;4.4.0&quot; exclude=&quot;Build,Analyzers&quot; /&amp;gt; &amp;lt;/group&amp;gt; &amp;lt;group targetFramework=&quot;.NETFramework4.7&quot;&amp;gt; &amp;lt;dependency id=&quot;MSTest.TestFramework&quot; version=&quot;1.2.0&quot; exclude=&quot;Build,Analyzers&quot; /&amp;gt; &amp;lt;/group&amp;gt; &amp;lt;group targetFramework=&quot;.NETStandard2.0&quot;&amp;gt; &amp;lt;dependency id=&quot;MSTest.TestFramework&quot; version=&quot;1.2.0&quot; exclude=&quot;Build,Analyzers&quot; /&amp;gt; &amp;lt;/group&amp;gt; &amp;lt;/dependencies&amp;gt; &amp;lt;/metadata&amp;gt;&amp;lt;/package&amp;gt;参考资料 XPath - 维基百科，自由的百科全书" }, { "title": "UWP 将图片裁剪成圆形（椭圆）", "url": "/post/clip-uwp-image-to-ellipse.html", "categories": "", "tags": "xaml, uwp", "date": "2018-06-15 21:21:21 +0800", "snippet": "不知从什么时候开始，头像流行使用圆形了，于是各个平台开始追逐显示圆形裁剪图像的技术。UWP 有内建的机制支持这种圆形图像裁剪，不过，仅限于画刷。WPF 的圆形裁剪请左转参考：WPF 中使用附加属性，将任意 UI 元素或控件裁剪成圆形（椭圆）。与 WPF 不同，UWP 中 UIElement.Clip 属性是 RectangleGeometry 类型的，这意味着利用此属性是没有办法完成圆形裁剪的。但是，存在一个与 WPF 一样的简单一些的方案，直接使用 ImageBrush：&amp;lt;Grid&amp;gt; &amp;lt;Ellipse Width=&quot;512&quot; Height=&quot;512&quot;&amp;gt; &amp;lt;Ellipse.Fill&amp;gt; &amp;lt;ImageBrush ImageSource=&quot;Conan_C2.png&quot; /&amp;gt; &amp;lt;/Ellipse.Fill&amp;gt; &amp;lt;/Ellipse&amp;gt;&amp;lt;/Grid&amp;gt;这是我的头像，原图是这样的：" }, { "title": "C#/.NET 中推荐的 Dispose 模式的实现", "url": "/post/recommended-dispose-implementation.html", "categories": "", "tags": "csharp, dotnet", "date": "2018-06-13 11:02:37 +0800", "snippet": "如果你觉得你的类需要实现 IDisposable 接口，还是需要注意一些坑的。不过前人准备了 Dispose 模式 供我们参考，最大程度避免这样的坑。C#程序中的 Dispose 方法，一旦被调用了该方法的对象，虽然还没有垃圾回收，但实际上已经不能再使用了。所以使用上要仔细考虑细节。需要明确一下 C# 程序（或者说 .NET）中的资源。简单的说来，C# 中的每一个类型都代表一种资源，而资源又分为两类： 托管资源：由 CLR 管理分配和释放的资源，即由 CLR 里 new 出来的对象； 非托管资源：不受 CLR 管理的对象，Windows 内核对象，如文件、数据库连接、套接字、COM 对象等；毫无例外地，如果我们的类型使用到了非托管资源，或者需要显式释放的托管资源，那么，就需要让类型继承接口 IDisposable。这相当于是告诉调用者，该类型是需要显式释放资源的，你需要调用我的 Dispose 方法。不过，这一切并不这么简单，一个标准的继承了 IDisposable 接口的类型应该像下面这样去实现。这种实现我们称之为 Dispose 模式：public class DisposableObject : IDisposable{ /// &amp;lt;summary&amp;gt; /// 获取或设置一个值。该值指示资源已经被释放。 /// &amp;lt;/summary&amp;gt; private bool _disposed; /// &amp;lt;summary&amp;gt; /// 执行与释放或重置非托管资源相关的应用程序定义的任务。 /// &amp;lt;/summary&amp;gt; public void Dispose() { Dispose(true); GC.SuppressFinalize(this); } /// &amp;lt;summary&amp;gt; /// 关闭此对象使用的所有资源。 /// &amp;lt;/summary&amp;gt; public void Close() { Dispose(); } /// &amp;lt;summary&amp;gt; /// 由终结器调用以释放资源。 /// &amp;lt;/summary&amp;gt; ~DisposableObject() { Dispose(false); } /// &amp;lt;summary&amp;gt; /// 执行与释放或重置非托管资源相关的应用程序定义的任务。 /// 派生类中重写此方法时，需要释放派生类中额外使用的资源。 /// &amp;lt;/summary&amp;gt; protected virtual void Dispose(bool disposing) { if (_disposed) { return; } if (disposing) { // 清理托管资源 // if (managedResource != null) // { // managedResource.Dispose(); // managedResource = null; // } } // 清理非托管资源 // if (nativeResource != IntPtr.Zero) // { // Marshal.FreeHGlobal(nativeResource); // nativeResource = IntPtr.Zero; // } // 标记已经被释放。 _disposed = true; }}" }, { "title": "文件被占用？系统自带的“资源监视器(resmon)”也能帮你找到占用它的真凶", "url": "/post/find-out-which-process-is-using-a-file.html", "categories": "", "tags": "windows", "date": "2018-05-27 09:02:27 +0800", "snippet": "文件或文件夹被占用，然后无法删除？这真的很恼人。关键是还不知道究竟是哪个程序占用的，想退出都不行。有各种工具解决此问题，平时下载屯着他们能够省下不少事儿。如果突然间情况非常紧急怎么办？学会使用本文介绍的系统自带工具“资源监视器”，也能立即着手找到真凶！删除拒绝提示：▲ 文件夹访问被拒绝 1即便点了继续，依然拒绝：▲ 文件夹访问被拒绝 2现在，去搜索框（小娜）中搜索“资源监视器”。（如果小娜已经挂掉了，使用 resmon 命令打开。）▲ 启动资源监视器然后，在“关联的句柄”中搜索被占用文件或文件夹的名称。如果名称太通用会搜到太多，所以可以像我这样加上一部分路径。▲ 搜索关联的句柄现在，你就能得到占用这个文件夹的程序了，右击可以结束进程。不过我习惯于正常退出（毕竟这种方式帮助我找到我到底哪个程序忘记关掉了）。▲ 搜索到的进程感谢评论区 @晒太阳的猫 推荐的界面和“资源监视器”一样丑不拉叽但功能强大的 LockHunter 和 @林德熙 推荐的软媒家两年没更新的十八般武器 软媒魔方 - 文件解除。" }, { "title": "神器如 dnSpy，无需源码也能修改 .NET 程序", "url": "/post/edit-and-recompile-assembly-using-dnspy.html", "categories": "", "tags": "dotnet", "date": "2018-05-22 22:02:13 +0800", "snippet": "dnSpy 是 0xd4d 开发的 .NET 程序调试神器。说它是神器真的毫不为过！它能在完全没有源码的情况下即时调试程序，甚至还能修改程序！本文讲向大家介绍如何使用 dnSpy 修改 .NET 程序。dnSpy 的主打功能是无需源码的调试，林德熙 有一篇文章 断点调试 Windows 源代码 介绍了这个方法。而本文主要说其另一项强大的功能 —— 修改程序集。看看 dnSpydnSpy 长着一身 Visual Studio 一样的外观，调试的时候给你熟悉的感觉。我们只需要讲我们需要调试或修改的程序集拖入左侧的程序集列表中即可（它会自动为我们把此程序集依赖的程序集也添加进来）。我把以前我写过的一个程序 ManipulationDemo 拖进来了。实操修改程序集现在我们来修改它，修改什么好呢？为了让效果明显一点，我决定在启动时弹一个窗口。于是我们展开进入到 App 类中。然后在类中右键“Edit class (C#)”：在里面重写 OnStartup 方法。发现，它竟然连智能感知提示都做了！改完只需要点击一下右下角的编译，即可讲修改应用到我们刚刚打开的程序集中。保存修改的程序集如果只是修改了可以立刻运行，那么充其量只是可以辅助调试。但是 dnSpy 是可以将程序集另存到本地的。点击“File”-&amp;gt;“Save Module”：为了以示区分，我写了一个新的名字：保存完之后，运行：我们会发现，我们刚刚新增的对话框已经弹出来了。“OK”之后原来的窗口才会显示出来。发挥想象力的时候到了既然有如此简单的修改程序集的方法，那么我们可以用来做什么事儿呢？用来做什么事儿呢？做什么事儿呢？什么事儿呢？事儿呢？呢？想象力时间顺便说一下，就算程序集被混淆了也难不倒它。" }, { "title": "推荐近乎免费的调试神器——OzCode", "url": "/post/using-ozcode-to-improve-debug.html", "categories": "", "tags": "visualstudio", "date": "2018-05-22 09:47:14 +0800", "snippet": "当一只断点打在 Visual Studio 的代码编辑器中，程序命中断点的那一刻，调试才刚刚开始……这个时候忙碌的手在键盘和鼠标之间来回跳跃，试图抓住每一次单步执行带来的状态改变。如果命中断点的那一刻多数我需要的状态都自动呈现，偶尔需要的状态能够快速定位，那该多好！于是，有了 OzCode……OzCode 的官网在这里：OzCode: Innovative debugging extension for Visual Studio。OzCode 有这些非常吸引我的地方： 当程序进入断点的时候，OzCode 会用红黄绿三色指示程序即将进入的分支 OzCode 会在每一个局部变量上方标注它现在的值（不过这一功能 Visual Studio 15.5 开始也提供了） 调试 UI 对象时，常常的属性列表在 OzCode 的帮助之下可以快速搜索 长长的 linq 语句可以利用 OzCode 看到集合中的每一项对结果的影响（通过滚轮查看）▲ 分支着色（图片来源于官网）▲ 搜索属性（图片来源于官网）官网下载的时候会看到提示——一个月免费试用。但事实上，每次 Visual Studio 更新，OzCode 都会重置试用天数。事实上 Visual Studio 2017 开始，更新间隔基本上都在一个月以内。也就是说——只要勤更新 VS，OzCode 几乎一直免费！▲ 每次更新 Visual Studio 之后，OzCode 都会重置" }, { "title": "Grid 布局算法！自己动手实现一个 Grid", "url": "/post/grid-layout-algorithm.html", "categories": "", "tags": "wpf, uwp, algorithm", "date": "2018-05-20 15:11:54 +0800", "snippet": "Avalonia 是一款尚在开发中的基于 .NET Core 的跨平台 UI 框架。目前用在个人项目中还是不错的，不过还需要大家在开源社区中多多支持。我为它写了一个全新的 Grid 布局算法，此算法是 WPF 在通常情况下的性能的两倍。本文将分享我在此项目中实现的算法的原理。Grid 的布局行为到底是怎样的？Grid 算是 WPF/UWP 入门中非常重要的一个布局容器了。面对它那强大而熟悉的布局方式，大家应该没有什么疑问吧！比如： 可以定义行和列 可以分别为每一行和列指定宽高 宽高的值可选 Auto, * 和数值 Auto 表示 Grid 将按照元素的实际所需尺寸进行布局 * 表示行列在布局中的比例，* 前面的数值表示比例值 数值使用的是 WPF/UWP 布局单位 元素在 Grid 中可跨行或跨列基本上大家所熟知的 Grid 布局差不多就这样么多了。如果想了解 WPF/UWP 的布局单位，可以阅读我之前的一篇文字将 UWP 的有效像素（Effective Pixels）引入 WPF - 吕毅。然而，事实上 Grid 的布局行为才没有那么简单呢！它诡异的地方在于没有定义好多种复杂布局情况下的交叉行为。我写了中英两篇文章来说明了这些不太符合预期的行为： WPF/UWP 的 Grid 布局竟然有 Bug，还不止一个！了解 Grid 中那些未定义的布局规则 - 吕毅 The undefined behaviors of WPF Grid (the so-called bugs) - 吕毅作为一个非常有潜力的 .NET Core 跨平台 UI 框架 Avalonia，应该认真定义好这些行为，而不是像 WPF/UWP 现有的 Grid 那样在某些情况下比较含糊，出现难以解释的布局行为。为这样的 Grid 布局行为设计一套算法如果你熟知 WPF/UWP 的布局系统，那么 MeasureOverride 和 ArrangeOverride 一定不陌生，虽然它们只是布局的一部分（为什么是一部分？详见 Visual-&amp;gt;UIElement-&amp;gt;FrameworkElement，带来更多功能的同时也带来了更多的限制 - 吕毅）。不过，写一个 Grid 确实只需要关心这两个函数就够了。MeasureOverride 传入父级测量的可用尺寸，返回此 Grid 测量发现所需的最小尺寸；ArrangeOverride 传入父级实际可提供的可用尺寸，返回此 Grid 实际布局所用的尺寸。分析 Grid 的布局思路如果行或列设置为 Auto，那么 Grid 的行或者列将为这个元素的尺寸进行适配，并且元素的所需尺寸也会影响到 Grid 的最小所需尺寸；如果行或列设置为 *，那么 Grid 的行列不会为此元素适配，但是元素的所需尺寸依然会影响到 Grid 的最小所需尺寸。由于我们必须要计算 Grid 的最小所需尺寸，所以整个布局过程中，必须得到每个行列的最小所需尺寸。这意味着，即便我们不能确定此行或此列的尺寸，或者甚至在父级尺寸确定的情况下能够确定此行或此列时，也应该计算最小尺寸。而 Auto、元素的 DesiredSize、* 或者行列的最小值都会影响到此最小尺寸，所以这些都应该先考虑。而行或列的最大值应该在最后再考虑。于是，我们将整个布局过程分成以下几步： 测量行列范围中包含 Auto 或 * 的元素（前者影响行列和最小尺寸，后者仅影响最小尺寸） 将所有的已确定尺寸确定 将所有的有最小尺寸，且 * 展开后超过此最小尺寸的行列按最小值确定 将所有 Auto 行列确定 按照父级尺寸估算 * 的尺寸 计算 Grid 所需的最小尺寸 将估算缩得的尺寸作为实际尺寸进行测量布局算法设计Grid 的布局算法似乎难以用语言描述，不过，我可以尝试用更具体的文字用接近代码的方式来描述： 测量过程 寻找所有行列范围中包含 Auto 和 * 的元素，使用全部可用尺寸提前测量 排除所有固定尺寸的行列，然后从总长中将其减掉 进行循环（以排除全部 min 要求的，总长为负也要继续） 计算单位星长（单位星长 = 剩余总长 / 星数，最小为 0） 找出第一个不满足 min 要求的 *，置其长度为 min，排除此行列，然后从总长中将其减掉 所有的 * 检查完毕后，退出循环 进行循环（以排除全部 Auto，总长为负也要继续） 计算单位星长（单位星长 = 剩余总长 / 星数，最小为 0） 找到第一个 Auto，找到对此 Auto 的约束（跨行列或不跨行列都需要） 对每个约束，检查目前尺寸是否满足约束（跨行列尺寸 &amp;gt;= Max(DesiredSize, min.Sum()） 满足约束的忽略，不满足的约束需要计算约束大出行列的尺寸值，将此值设定为此 Auto 的待选长度 当所有的约束检查完毕，在所有的待选长度中取最大值，设定为 Auto 的尺寸，排除此行列，然后从总长中将其减掉 所有的 Auto 检查完毕后，退出循环 按照父级尺寸估算 * 的尺寸 如果还有剩余长度，则将 * 展开，但需要考虑 * 行列的最小尺寸 确定 Grid 的 DesiredSize 如果剩余总长 &amp;gt;= 0，则 Grid.DesiredSize = 可用长度 - 剩余总长 如果剩余总长 &amp;lt; 0，则返回的 Grid.DesiredSize = 可用长度，实际需求的 Grid.DesiredSize = 可用长度 - 剩余总长 如果总长 &amp;gt;= 0，则进行循环（以确定剩余全部子元素的测量所用尺寸）；否则直接将剩余 * 全部设置为 0 进行循环 计算单位星长（单位星长 = 剩余总长 / 星数） 找出第一个不满足 max 要求的 *，置其长度为 max，排除此行列，然后从总长中将其减掉 所有的 * 检查完毕后，退出循环 至此，剩余的所有 * 都将不再有约束（即便元素 DesiredSize 不满足也无需处理，直接将元素裁剪） 计算单位星长（单位星长 = 剩余总长 / 星数） 计算所有剩余 * 的长度 至此，所有子元素测量所用尺寸已经全部确定，使用此尺寸对子元素进行测量 分开保存 1~5、6 计算后的所得结果，布局过程即结束 排列过程 如果排列可用尺寸大于测量可用尺寸，则测量过程中的全部计算部分需要重新进行（因为可能此前的 min 现在不满足条件） 如果排列可用尺寸等于测量可用尺寸，则直接使用测量第 6 步的结果，依次进行排列，不足部分的空间全部使用 0 如果排列可用尺寸小于测量可用尺寸，则重新执行测量第 6 步的计算，以确定新的行列尺寸，依次进行排列，不足部分的空间全部使用 0 我在 Avalonia 的代码注释中，画出了每一个步骤的变化图。// 1. 测量行列范围中包含 `Auto` 或 `*` 的元素（前者影响行列和最小尺寸，后者仅影响最小尺寸）//// 2. 将所有的已确定尺寸确定// +-----------------------------------------------------------+// | * | A | * | P | A | * | P | * | * |// +-----------------------------------------------------------+// |#fix#| |#fix#|//// 3. 将所有的有最小尺寸，且 `*` 展开后超过此最小尺寸的行列按最小值确定// +-----------------------------------------------------------+// | * | A | * | P | A | * | P | * | * |// +-----------------------------------------------------------+// | min | max | | | min | | min max | max |// | fix | |#fix#| fix |//// 4. 将所有 `Auto` 行列确定// +-----------------------------------------------------------+// | * | A | * | P | A | * | P | * | * |// +-----------------------------------------------------------+// | min | max | | | min | | min max | max |// |#fix#| | fix |#fix#| fix | fix |//// 5. 按照父级尺寸估算 `*` 的尺寸// +-----------------------------------------------------------+// | * | A | * | P | A | * | P | * | * |// +-----------------------------------------------------------+// | min | max | | | min | | min max | max |// |#des#| fix |#des#| fix | fix | fix | fix | #des# |#des#|//// 6. 计算 `Grid` 所需的最小尺寸//// 7. 将估算缩得的尺寸作为实际尺寸进行测量// +-----------------------------------------------------------+// | * | A | * | P | A | * | P | * | * |// +-----------------------------------------------------------+// | min | max | | | min | | min max | max |// |#fix#| fix |#fix#| fix | fix | fix | fix | #fix# |#fix#|布局算法的代码为了让代码更容易调试，我专门写了一个 GridLayout 类来完成布局过程，而且 GridLayout 的计算设计为与 Grid 布局过程无关。做法是，将 GridLayout 的大部分方法设计为“纯方法”（纯方法只随便调用，调用此方法不会改变任何系统状态，只有拿到其返回值才会真正发挥作用）。具体的代码非常长，含单元测试供 1200+ 行，建议去 Avalonia 仓库查看： Avalonia/Grid.cs at master · AvaloniaUI/Avalonia Avalonia/GridLayout.cs at master · AvaloniaUI/Avalonia效果和性能在性能测试中，此算法还是表现不错的，以下是 Pull Request 中的性能测试截图（已经合并）。" }, { "title": "安利一款非常好用的命令行参数库：McMaster.Extensions.CommandLineUtils", "url": "/post/mcmaster-extensions-commandlineutils.html", "categories": "", "tags": "dotnet, dotnet-core, dotnet-standard", "date": "2018-04-26 20:39:31 +0800", "snippet": "命令行参数解析想必是每一个命令行程序都难以避开的工程。这工程可小可大，但每次都写始终是在浪费时间。而且，不同人实现也千差万别，使得不同的命令行程序命令参数传入的体验总有差异。于是安利一款命令行工具库——McMaster.Extensions.CommandLineUtils，它符合当下各大主流命令行工具的参数体验；而且，代码非常简洁。更新：如果你之前阅读过我这篇博客，可能知道我之前推荐的是 Microsoft.Extensions.CommandlineUtils，是微软出品；不过微软官方已经在 GitHub 上将此命令行项目重定向到了 aspnet/Common，原有的单独的命令行不复存在。McMaster.Extensions.CommandLineUtils 是微软官方指定的命令行仓库的正统 Folk 版本。它的仓库和 NuGet 包： GitHub: https://github.com/natemcmaster/CommandLineUtils NuGet: https://www.nuget.org/packages/McMaster.Extensions.CommandLineUtils体验超级简洁的代码吧！我正在自己的项目中采用这款库，项目名为 mdmeta，用于自动生成 Markdown 前的元数据标签，写博客非常方便。项目地址：walterlv/markdown-metadata: Markdown Metadata (also called mdmeta) is a tool to generate and manage the front matter metadata. It is a cross-platform console app based on .Net Core 2.0.体验主流的命令行参数体验# 不带任何参数mdmeta# 一个简单的命令mdmeta echo# 一个带参数（Argument）的简单的命令mdmeta echo &quot;Hello!&quot;# 一个带选项（Option）的简单命令mdmeta echo --upper# 一个带参数（Argument）带选项（Option）且选项中带值的简单命令mdmeta echo &quot;Hello!&quot; -s &quot;, &quot;# 一个带参数（Argument）带多种选项（Option）且部分选项中带多个值的简单命令mdmeta echo &quot;Hello!&quot; --repeat-count=3 -s &quot;, &quot; -s &quot;| &quot;体验库的 Builder APIMcMaster.Extensions.CommandLineUtils 使用 Builder API 配出以上的命令，代码非常简洁。static int Main(string[] args){ var app = new CommandLineApplication{Name = &quot;mdmeta&quot;}; app.HelpOption(&quot;-?|-h|--help&quot;); app.OnExecute(() =&amp;gt; { app.ShowHelp(); return 0; }); app.Command(&quot;echo&quot;, command =&amp;gt; { command.Description = &quot;输出用户输入的文字。&quot;; command.HelpOption(&quot;-?|-h|-help&quot;); var wordsArgument = command.Argument(&quot;[words]&quot;, &quot;指定需要输出的文字。&quot;); var repeatOption = command.Option(&quot;-r|--repeat-count&quot;, &quot;指定输出重复次数&quot;, CommandOptionType.SingleValue); var upperOption = command.Option(&quot;--upper&quot;, &quot;指定是否全部大写&quot;, CommandOptionType.NoValue); var separatorOption = command.Option(&quot;-s|--separator&quot;, &quot;指定重复输出用户文字时重复之间应该使用的分隔符，可以指定多个，这将依次应用到每一次分割。&quot;, CommandOptionType.MultipleValue); command.OnExecute(() =&amp;gt; { // 在这里使用上面各种 Argument 和 Option 的 Value 或 Values 属性拿值。 return 0; }); }); return app.Execute(new []{&quot;-?&quot;});}体验我封装的命令行参数配置原生库配置命令行参数已经非常方便了，几乎是一行一个功能，但 lambda 表达式嵌套太多是一个问题，会导致代码随着参数种类的增多变得急剧膨胀；于是我针对原生库做了一个基于反射的版本。于是，实现一个命令行参数只需要写这些代码就够啦：更新：McMaster.Extensions.CommandLineUtils 接手微软之后，也添加了 Attribute 的 API，使用方法与下面的大同小异。[CommandMetadata(&quot;echo&quot;, Description = &quot;Output users command at specified format.&quot;)]public sealed class SampleTask : CommandTask{ private int _repeatCount; [CommandArgument(&quot;[words]&quot;, Description = &quot;The words the user wants to output.&quot;)] public string Words { get; set; } [CommandOption(&quot;-r|--repeat-count&quot;, Description = &quot;Indicates how many times to output the users words.&quot;)] public string RepeatCountRaw { get =&amp;gt; _repeatCount.ToString(); set =&amp;gt; _repeatCount = value == null ? 1 : int.Parse(value); } [CommandOption(&quot;--upper&quot;, Description = &quot;Indicates that whether all words should be in upper case.&quot;)] public bool UpperCase { get; set; } [CommandOption(&quot;-s|--separator&quot;, Description = &quot;Specify a string to split each repeat.&quot;)] public List&amp;lt;string&amp;gt; Separators { get; set; } public override int Run() { // 当用户敲入的命令已准备好，上面的参数准备好，那么这个函数就会在这里执行啦。 return 0; }}你一定会吐槽代码变多了。确实如此！但是，当命令的种类和参数的种类变得急剧膨胀的时候，这种方式可以将各种命令都隔离开来。于是，你只需要专注于实现自己的命令就好啦！将以下这些文件放入自己的项目中即可立刻写出上面的代码（注意 Main 函数也是需要的，因为它启动了反射）：如果发现这一行的后面不是代码，那么极有可能是被不小心屏蔽了，请手动访问：gitee.com/codes。支持的平台支持 .Net Standard 1.3，这意味着 .Net Core 可以使用，.NET Framework 4.5.1 及以上即可使用。这意味着可以很随意地跨全平台。参考资料 Creating Neat .NET Core Command Line Apps-natemcmaster/CommandLineUtils: Command line parsing and utilities for .NET Core and .NET Framework." }, { "title": "冷算法：自动生成代码标识符（类名、方法名、变量名）", "url": "/post/algorithm-of-generating-random-identifiers.html", "categories": "", "tags": "algorithm", "date": "2018-04-26 08:04:56 +0800", "snippet": "竟然有小伙伴喜欢在编写代码时使用随机字符当作类名、方法名、变量名，例如这一篇博客里的代码：使用 Resharper 特性 - 林德熙。既然随机，那也随机得像一些啊！于是我改进了标识符的随机算法，使得生成的标识符更像真实单词的组合。看看标识符的生成效果吧！0、2、4……行是 PascalCase，即首字母大写的；1、3、5……行是 camelCase 即首字母小写的。▲ 是不是感觉甚至能读出来？嗯嗯，因为生成规则中考虑到了辅音和元音的组合，而且……嗯……还考虑到了部件出现的概率。比如一个单词中的音节数，单音节概率 44%，双音节概率 31%，三音节概率 19%，四音节概率 6%。而这样的概率是通过一个幂函数来实现的。具体来说，是下面这个函数：好吧，把我的源码放出来：public class RandomIdentifier{ private readonly Random _random = new Random(); public string Generate(bool pascal) { var builder = new StringBuilder(); var wordCount = _random.Next(2, 4); for (var i = 0; i &amp;lt; wordCount; i++) { var syllableCount = 4 - (int) Math.Sqrt(_random.Next(0, 16)); for (var j = 0; j &amp;lt; syllableCount; j++) { var consonant = Consonants[_random.Next(Consonants.Count)]; var vowel = Vowels[_random.Next(Vowels.Count)]; if ((pascal || i != 0) &amp;amp;&amp;amp; j == 0) { consonant = CultureInfo.CurrentCulture.TextInfo.ToTitleCase(consonant); } builder.Append(consonant); builder.Append(vowel); } } return builder.ToString(); } private static readonly List&amp;lt;string&amp;gt; Consonants = new List&amp;lt;string&amp;gt; { &quot;q&quot;,&quot;w&quot;,&quot;r&quot;,&quot;t&quot;,&quot;y&quot;,&quot;p&quot;,&quot;s&quot;,&quot;d&quot;,&quot;f&quot;,&quot;g&quot;,&quot;h&quot;,&quot;j&quot;,&quot;k&quot;,&quot;l&quot;,&quot;z&quot;,&quot;x&quot;,&quot;c&quot;,&quot;v&quot;,&quot;b&quot;,&quot;n&quot;,&quot;m&quot;, &quot;w&quot;,&quot;r&quot;,&quot;t&quot;,&quot;p&quot;,&quot;s&quot;,&quot;d&quot;,&quot;f&quot;,&quot;g&quot;,&quot;h&quot;,&quot;j&quot;,&quot;k&quot;,&quot;l&quot;,&quot;c&quot;,&quot;b&quot;,&quot;n&quot;,&quot;m&quot;, &quot;r&quot;,&quot;t&quot;,&quot;p&quot;,&quot;s&quot;,&quot;d&quot;,&quot;h&quot;,&quot;j&quot;,&quot;k&quot;,&quot;l&quot;,&quot;c&quot;,&quot;b&quot;,&quot;n&quot;,&quot;m&quot;, &quot;r&quot;,&quot;t&quot;,&quot;s&quot;,&quot;j&quot;,&quot;c&quot;,&quot;n&quot;,&quot;m&quot;, &quot;tr&quot;,&quot;dr&quot;,&quot;ch&quot;,&quot;wh&quot;,&quot;st&quot;, &quot;s&quot;,&quot;s&quot; }; private static readonly List&amp;lt;string&amp;gt; Vowels = new List&amp;lt;string&amp;gt; { &quot;a&quot;,&quot;e&quot;,&quot;i&quot;,&quot;o&quot;,&quot;u&quot;, &quot;a&quot;,&quot;e&quot;,&quot;i&quot;,&quot;o&quot;,&quot;u&quot;, &quot;a&quot;,&quot;e&quot;,&quot;i&quot;, &quot;a&quot;,&quot;e&quot;, &quot;e&quot;, &quot;ar&quot;,&quot;as&quot;,&quot;ai&quot;,&quot;air&quot;,&quot;ay&quot;,&quot;al&quot;,&quot;all&quot;,&quot;aw&quot;, &quot;ee&quot;,&quot;ea&quot;,&quot;ear&quot;,&quot;em&quot;,&quot;er&quot;,&quot;el&quot;,&quot;ere&quot;, &quot;is&quot;,&quot;ir&quot;, &quot;ou&quot;,&quot;or&quot;,&quot;oo&quot;,&quot;ou&quot;,&quot;ow&quot;, &quot;ur&quot; };}而使用方法，则是简单的一个调用：var identifier = new RandomIdentifier();var pascal = _identifier.Generate(true);var camel = _identifier.Generate(false);传入 true 生成首字母大写的版本，传入 false 生成首字母小写的版本。" }, { "title": "利用 TypeConverter，转换字符串和各种类型只需写一个函数", "url": "/dotnet/2017/01/17/convert-using-type-converter.html", "categories": "", "tags": "dotnet", "date": "2018-04-23 07:31:32 +0800", "snippet": "本文代码基于 .NET Framework 实现。本来只想进行简单的配置存储的，不料发现 .NET 的基本类型多达十多种。于是，如果写成下面这样，那代码可就太多了哦：// 注：`Configurator`是我的配置类，用于读写字符串的。public static int GetInt32(this Configurator config, string key){ return int.Parse(config[key], CultureInfo.InvariantCulture);}public static void SetInt32(this Configurator config, string key, int value){ config[key] = value.ToString(CultureInfo.InvariantCulture);}public static bool GetBoolean(this Configurator config, string key){ return bool.Parse(config[key]);}// 还没完，这才 1.5 种而已。// ……尝试使用泛型这些方法都比较相似，于是自然而然想到了泛型，所以写出了这段代码：public static T GetValue&amp;lt;T&amp;gt;(this Configurator config, string key) where T : struct{ var @string = config[key]; // T value = 某种通用的转换(@string); // 问题来了，这里该怎么写？ return value;}这里就郁闷了，因为虽然方法内部的实现都长得差不多，但他们之间除了名字相同之外（比如 Parse和ToString），并没有什么联系；这样，便不能使用统一的接口或者抽象类等等来调用。尝试使用反射既然名字类似，那自然又能想到反射。可是，拥有 Parse 的类型并不多，ToString 中能传入 CultureInfo.InvariantCulture 且参数顺序保持一致的类型也少的可怜。于是，反射只能保证写得出来代码，却并不能保证多种类型的支持。另外想到一点，Int32 类型的 TryParse 中有 out 关键字修饰的参数，反射能否支持呢？StackOverflow 上找到了答案： You invoke a method with an out parameter via reflection just like any other method. The difference is that the returned value will be copied back into the parameter array so you can access it from the calling function. object[] args = new object[] { address, request };_DownloadDataInternal.Invoke(this, args);request = (WebRequest)args[1]; 意思是说，这在反射中不用作什么考虑，传入的参数数组天然就已经支持了 out 关键字。尝试寻找更通用的方案在 Google 上继续漫游，在 StackOverflow 上发现这篇讨论：How to convert string to any type。最高票答案给出的回复是： using System.ComponentModel;TypeConverter typeConverter = TypeDescriptor.GetConverter(propType);object propValue = typeConverter.ConvertFromString(inputValue); 这可打开了思路，原来 .NET Framework 内部已经有了这种转换机制和相关的方法。于是用这种方法修改我的方法，成了这样子：public static T GetValue&amp;lt;T&amp;gt;(this Configurator config, string key) where T : struct{ var @string = config[key]; var td = TypeDescriptor.GetConverter(typeof (T)); return (T) td.ConvertFromInvariantString(@string);}public static void SetValue&amp;lt;T&amp;gt;(this Configurator config, string key, T value) where T : struct{ var td = TypeDescriptor.GetConverter(typeof (T)); var @string = td.ConvertToInvariantString(value); config[key] = @string;}编写单元测试发现，这种方法能够支持的类型真的非常多，byte char short ushort int uint long ulong bool float double decimal DateTime Point Vector Size Rect Matrix Color……看看代码中 TypeDescriptor.GetConverter 的返回值发现是 TypeConverter 类型的，而我们在 WPF 的 xaml 中编写自定义类型时，经常需要执行此类型的 TypeConverter。凭这一点可以大胆猜测，xaml 中能够通过字符串编写的类型均可以通过这种方式进行转换。然而，目前我还为对此进行验证。验证猜想 去 https://referencesource.microsoft.com/ 看 TypeDescriptor.GetConverter 的源码（点击进入）。 尝试自定义一个类型，在类型上标记 TypeConverter，并对此类进行测试。" }, { "title": "命令“&quot;xxx.exe&quot; xxx”已退出，代码为 3/123/9009。VS 的这些编译错误代码代表了什么意思？", "url": "/post/error-code-in-vs-build-events.html", "categories": "", "tags": "visualstudio", "date": "2018-04-16 18:56:22 +0800", "snippet": "我们在 cmd 中输入常见命令的时候，如果命令输入错误或使用错误，cmd 中会提示错误原因，帮助我们定位并解决问题。然而如果相同的命令放到了 Visual Studio 的生成事件中，我们就只能得到 Visual Studio 返回的错误代码了。为了能够快速地根据错误代码大致猜测错误原因，本文整理了一部分错误代码的通用原因。命令“&quot;xxx.exe&quot; xxx”已退出，代码为 n。命令的格式为： 命令 参数1 参数2 参数3错误代码: 3系统找不到指定的路径。这意味着我们在编译生成命令中写的“命令”部分，在那个路径下并不存在命令中写的可执行文件。比如： 文件或文件夹的名称写错了，或者写上级目录时“..”的层数不对 依赖的是一部分人开发环境中才有的可执行文件，如果你的开发环境中没有这个文件，就会是此错误 依赖的文件需要提前生成但还没有生成，某些 BT 的项目会要求先执行一些编译命令以生成命令的可执行文件错误代码: 123文件名、目录名或卷标语法不正确。如果路径字符串根本无法拼出路径，就会引发此错误。比如： D:\\walterlv.github.io\\D:\\Bin\\Debug 这样的路径就是不合理的一般人当然不会写出这样的命令出来，但如果路径中间有一些环境变量作为占位符，实际执行时本来期望填入相对路径的地方填入了绝对路径就会这样。错误代码: 9009‘xxx’ 不是内部或外部命令，也不是可运行的程序或批处理文件。 命令写错了，而不是可执行文件写错了 比如 xcopy 写成了 xcapy 可执行文件因为缺少引号包括路径中的空格，导致被识别成无法识别的命令 比如 C:\\Program Files\\XXX 因为没有引号的包裹，被识别成了 C:\\Program 命令 持续整理中……" }, { "title": "VS 编译太慢了吗？新建解决方案配置关闭一部分项目的编译", "url": "/post/skip-building-using-solution-configuration.html", "categories": "", "tags": "visualstudio", "date": "2018-04-03 07:59:35 +0800", "snippet": "手头的解决方案真大！里面的项目个数达到了 30 个或是 50 个？然而接近一半是单元测试项目和辅助工具。再加上一些不尽如人意的项目优化，编译速度真的是无力吐槽。幸好 Visual Studio 提供了解决方案配置功能，可以让我们在编译时略过一些项目。在解决方案上右击选择“属性”，我们将打开“解决方案属性页”。在属性页种选择“配置”，则可以开始指定项目是否生成或部署。然而，我们只在这两种情况下才不需要单元测试： 有些电脑性能太差，带不动这么大的解决方案 Release 下是用于发布产品的，不需要编译和执行单元测试（这并不是说发布产品前不用跑单元测试）对于第一种情况，我们需要新建一个解决方案配置来应对，让电脑性能较差的开发者使用单独的配置；第二种情况则可以直接在 Release 上改。要新建配置，需要进入“配置管理器”，在“活动解决方案配置”中选择“新建”。然后补充新建的信息：在新的解决方案配置和 Release 中取消单元测试项目的生成。关闭和确认对话框之后，就会发现 Visual Studio 中之前用于选择 Debug/Release 的下拉框现在多出了 Debug-WithoutTests 配置。并且如果选中了 Debug-WithoutTests 或者 Release 后，无论是生成还是重新生成解决方案，更或者是使用命令行编译，都不会生成单元测试项目。额外的，这些配置是团队共享的，因为它储存在 sln 文件中；至于哪一个处于选中状态是团队成员自己的配置，不会互相影响。" }, { "title": "利用 ReSharper 自定义代码中的错误模式，在代码审查之前就发现并修改错误", "url": "/post/analyze-and-fix-code-using-resharper-custom-pattern.html", "categories": "", "tags": "visualstudio, csharp, resharper", "date": "2018-03-20 20:35:30 +0800", "snippet": "多人协作开发的项目总会遇到代码编写风格上的差异。一般工具都能帮我们将常见的差异统一起来——例如 if 的换行；但也有一些不那么通用，但项目中却经常会出现的写法也需要统一。例如将单元测试中的 Assert.AreEqual(foo.GetType(), typeof(Foo)); 换成 Assert.IsInstanceOfType(foo, typeof(Foo));。阅读本文将学习如何使用 ReSharper 的 Custom Pattern 功能来完成这样的警告和转换。预览效果我们团队中自定义了一个代码风格规范，在单元测试中 Assert.AreEqual(foo.GetType(), typeof(Foo)); 应该被换成 Assert.IsInstanceOfType(foo, typeof(Foo));。于是，ReSharper 会给出警告，并给出推荐的写法；如果遵循 ReSharper 的建议，ReSharper 将自动为我们修改代码。▲ 给出警告，并提供建议▲ 可以遵循建议▲ 然后代码就被修改成我们建议的写法了开始编写自定义模式我们需要打开 ReSharper 的选项窗口，然后在里面找到“自定义模式”：点击“Add Pattern”之后，我们就可以开始编写 Custom Pattern 了。为了快速开始，可以将下面的两行代码分别复制到两个黑框中。（如果你只看到了一个黑框，请在右上角将“Find”按钮切换到“Replace”按钮。）// 将下面这一句话复制到第一个黑色框中。Assert.AreEqual($instance$.GetType(), typeof($type$));// 将下面这一句话复制到第二个黑色框中。Assert.IsInstanceOfType($instance$, typeof($type$));这时，占位符框中就会出现我们编写的两个占位符：▲ 占位符列表我们需要将 instance 占位符从表达式修改为标识符： 解释一下这几项的意思： Argument Placeholder 参数占位符 意味着这里是参数列表，可以是一个或多个参数，中间用逗号分隔。参数数量可以额外指定。 Expression Placeholder 表达式占位符 形如 foo.Bar()，注意，分号并不是表达式的一部分。 Identifier Placeholder 标识符占位符 Statement Placeholder 语句占位符 形如 if (foo is null) throw new ArgumentNullException(nameof(foo));，注意，分号属于语句的一部分。 Type Placeholder 类型占位符 形如 Foo，或者 Walterlv.Demo.Foo。 确定之后我们填写其他的信息： Pattern severity：警告 如果你需要，修改成“错误”也是可以的；事实上我们的项目中就是标记为错误，这样找出的代码就会是红色的错误下划线了。 Suppression key：AssertEqualToInstanceOfType （可选）只有指定了用于阻止检查的标识字符串，才可以在特殊情况下用以下几种方法阻止检查；否则你将对错误无能为力。 // ReSharper disable once AssertEqualToInstanceOfType [SuppressMessage(&quot;ReSharper&quot;, &quot;AssertEqualToInstanceOfType&quot;)] 上面的 Description：建议简化成 InstanceOfType 以提升可读性。 这将在鼠标滑到找到的语句上面时给出提示。 下面的 Description：简化成 InstanceOfType 这将在在 Alt+Enter 时出现的重构列表中显示 设置完之后，“Edit Highlighting Pattern”窗口应该是这样的：当然，在“Custom Pattern”列表中也可以统一设置所有模式的警告级别。最后，把这些规则保存到团队共享中，那么所有安装了 ReSharper 的此项目的团队成员都将遵循这一套规则。自己动手，发掘潜能Custom Pattern 功能只是为了给我们一个格式转换吗？才不止是这样哦！它能够帮助我们发现一些潜在的错误。例如使用 MSTestEnhancer 进行单元测试时，如果使用了它推荐的单元测试风格，就应该配套使用 ContractTestCase 特性，如果不这么写，必定意味着错误。于是，我们可以编写一个自定义模式来发现和修改这样的错误。你认为可以怎么写呢？我在下面给出了我的写法。你还可以发掘出更多的潜能吗？非常期待！" }, { "title": "WPF 程序无法触摸操作？我们一起来找原因和解决方法！", "url": "/wpf/2017/09/12/touch-not-work-in-wpf.html", "categories": "", "tags": "wpf", "date": "2018-03-19 19:30:45 +0800", "snippet": "WPF 自诞生以来就带着微软先生的傲慢。微软说 WPF 支持触摸，于是 WPF 就真的支持触摸了。对，我说的是“支持触摸”，那种摸上去能点能动的；偶尔还能带点儿多指的炫酷效果。但是，WPF 推出那会儿，绝大部分开发者都还没有触摸屏呢，开发个程序要怎么验证支不支持触摸呢？微软先生无奈地决定——你写鼠标的代码就好了，我帮你转换！于是……一大波 BUG 袭来……WPF 触摸失效的分类我将 WPF 的触摸失效总结成三种不同的类型。 触摸下 Stylus/Touch 事件正常触发，但不提升为 Mouse 事件；导致仅使用 Mouse 事件的控件无法使用 触摸下 Stylus/Touch 有触发，但触发点位置在 (0, 0) 处或上一个触摸点处；导致即使触发了，当前控件也收不到 触摸下无 Stylus/Touch 事件，也不提升为 Mouse 事件，但鼠标下有 Mouse 事件；导致整个界面完全无法触摸使用第一种情况使用触摸或者触笔操作时，如果 Up 事件中发生了任何异常，会导致 StylusLogic.PostProcessInput 的后续逻辑不会正确执行，这就包括了用于清理触控资源的 StylusTouchDevice.OnDeactivate 方法。需要注意的是：Up 事件不止是 TouchUp 或者 StylusUp，MouseUp 也会引发这样的触摸失效。而在 StylusTouchDevice.OnDeactivate 方法中，会重置 StylusLogic.CurrentMousePromotionStylusDevice 属性为 null 或 NoMousePromotionStylusDevice。此方法不执行会直接导致 StylusLogic.ShouldPromoteToMouse 方法对当前触控设备的判断出现错误，持续返回 false，即不会再执行触控转鼠标的逻辑，出现触摸无效的现象。第二种情况如果 WPF 的 StylusUp 事件被阻断（例如 e.Handled = true，或者在 StylusUp 事件中弹出一个模态窗口），则下一次触摸时获取到的点坐标将是上一次被阻断时的点坐标。于是，阻断后的第一次点击必将点中之前点的那个点，而不管现在点中了什么。如果阻断时点在新窗口外，则几乎相当于触摸失效。需要注意的是，这种情况下 MouseUp 的 e.Handled = true 是可以使用而不会导致触摸失效的。第三种情况WPF 程序在启动期间，如果触摸组件发生了异常，极有可能会使得触摸根本就没有初始化成功！比如，System.Windows.Input.StylusLogic.RegisterStylusDeviceCore(StylusDevice stylusDevice) 方法在启动时抛出 System.InvalidOperationException，虽然内部有 catch，但实际获取到的 TabletDevice 个数是 0 个，根本无法获取触摸设备，于是触摸无效。或者，在 WorkerOperationGetTabletsInfo.OnDoWork 方法中，获取到了错误的触摸设备个数：IPimcManager pimcManager = UnsafeNativeMethods.PimcManager;uint count;pimcManager.GetTabletCount(out count);解决之道目前为止，这三种问题都没有根本的解决办法，但是我们可以规避。第一种情况我们没有办法阻止每一处的 Up 事件，所以我的做法是在禁止那些可能会在 Up 中引发异常的操作监听 Up 事件，而是统一由我封装好的 Down/Move/Up 中进行分发。在我的 Up 中 catch 所有异常，随后延迟引发。try{ // 分发真正业务上的 Up 事件。 DeliverUpEvent(e);}catch (Exception ex){ // 使用触摸或者触笔操作时，如果 Up 事件中发生了任何异常，会导致 StylusLogic.PostProcessInput 的后续逻辑不会正确执行， // 这就包括了用于清理触控资源的 StylusTouchDevice.OnDeactivate 方法。 // // 而在 StylusTouchDevice.OnDeactivate 方法中，会重置 StylusLogic.CurrentMousePromotionStylusDevice 属性 // 为 null 或 NoMousePromotionStylusDevice。此方法不执行会直接导致 StylusLogic.ShouldPromoteToMouse 方法 // 对当前触控设备的判断出现错误，持续返回 false，即不会再执行触控转鼠标的逻辑，出现触摸无效的现象。 // // 这里通过 InvokeAsync 的方式再次抛出异常是为了在保证 Stylus 逻辑不出错的情况下，将异常暴露。 Dispatcher.CurrentDispatcher.InvokeAsync(() =&amp;gt; { ExceptionDispatchInfo.Capture(ex).Throw(); });}第二种情况一样的，我们没有办法阻止每一处的 Up 事件。于是我们只能要求多人开发项目中的每一位开发人员都注意不要在 StylusUp 中 e.Handled = true。然而，要求每一个人都这么做是不现实的，尤其是团队成员不稳定的情况下。目前我还没有找到具体可实施的自动化的解决办法，不过我最近正在尝试的 Roslyn 扩展可能可以解决这样的问题。有关 Roslyn 扩展的开发，可以阅读我的另一篇文章：Roslyn 入门：使用 Roslyn 静态分析现有项目中的代码。第三种情况启动时触摸设备获取错误的问题我还没有一个彻底的解决方案，目前是检测第一次机会异常，并在发现错误堆栈是以上情况的时候重新启动应用程序。能够采取这样的策略是因为此异常发生在我们的 App 类初始化之后 MainWindow 显示出来之前。更多的想法期待你有更多的想法，我希望在我们的交流之下，能够帮助更多人发现和解决 WPF 的触摸失效问题，甚至更多 WPF 的疑难杂症。" }, { "title": "在移动端打开 Google 的网页快照", "url": "/post/view-google-cache-in-mobile.html", "categories": "", "tags": "web", "date": "2018-03-09 07:55:03 +0800", "snippet": "Google 的网页快照功能在原网页意外挂掉的时候能够临时为我们提供网页内的信息。例如我们要搜索的某项技术资料来源于某个个人站点，而现在他的域名到期了没有续费；例如我现在的博客在部署期间挂掉了，不能继续访问。这时 Google 网页快照都能够帮我们临时访问网页缓存。PC 端的网页快照很容易找到并且点开：然而移动端就不那么幸运了，找不到那个打开快照的小按钮：这个时候，可以复制以下网址到地址栏中，将预留的 网址 二字替换成希望点进去但挂掉了的链接地址（可以从 Google 的搜索结果页点开去地址栏复制）。 http://webcache.googleusercontent.com/search?cache:网址 多数时候我们能在缓存中访问到完整的网页，如果目标站点的域名挂掉，那么可能我们只能访问到支离破碎的纯 html 了。" }, { "title": "在 HTML 超链接上添加可交互的 ToolTip", "url": "/post/add-tooltip-for-html-a.html", "categories": "", "tags": "web, html, css", "date": "2018-03-08 18:39:40 +0800", "snippet": "当鼠标滑过超链接的那一刻，我们都能想象出一个熟悉的白色提示框从鼠标指针所在的位置淡入。那是 ToolTip 提示框。HTML 中我们能通过简单的属性设置获得 ToolTip，但如果希望 ToolTip 是能交互的，那么就阅读本文吧！原生 ToolTip先来看看 HTML 原生自带的 ToolTip：请将鼠标划至这里代码非常简单：&amp;lt;a title=&quot;你看到了什么？对，这就是原生自带的 ToolTip！&quot; href=&quot;#&quot;&amp;gt;请将鼠标划至这里&amp;lt;/a&amp;gt;可交互 ToolTip可交互的 ToolTip 就没那么幸运了，没有自带。于是，我们可考虑通过自己拼接的 html 容器来实现。效果像这样： 请将鼠标划至这里 这是 内部的链接哦这是靠一组 html 容器和一些配套的 css 来实现的。&amp;lt;span class=&quot;tooltip&quot;&amp;gt; &amp;lt;span&amp;gt;&amp;lt;a href=&quot;https://walterlv.github.io&quot;&amp;gt;请将鼠标划至这里&amp;lt;/a&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;tooltip-text&quot;&amp;gt;这是&amp;lt;a href=&quot;https://walterlv.github.io&quot;&amp;gt;内部的链接哦&amp;lt;/a&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/span&amp;gt;.tooltip .tooltip-text{ visibility: hidden; width: 14rem; margin-left: -7rem; bottom: 100%; left: 50%; background: #eee; border-radius: 0.5rem; text-align: center; padding: 2px 0; position: absolute; z-index: 1}.tooltip:hover .tooltip-text{ visibility: visible}本博客底部的版权信息中使用到了这种交互式 ToolTip。" }, { "title": "如何删除 Windows 10 系统生成的 WindowsApps 文件夹", "url": "/post/how-to-delete-windows-apps-folder.html", "categories": "", "tags": "windows, sysprep", "date": "2018-02-28 00:03:43 +0800", "snippet": "如果曾经修改过 Windows 10 应用安装路径到非系统盘，那么那个盘下就会生成一些文件夹。如果以后重装了系统或者应用删除了，挪位置了，那些文件夹依然在那里——删不掉！大家都知道这是权限问题，然而如何修改权限以便成功删除呢？▲ 更改应用的保存位置那么，现在开始解决删不掉的问题吧！第一步：属性→安全→高级第二步：更改所有者▲ 更改所有者▲ 在这里输入自己的用户名（如果是在线账户，则是邮箱；如果是本地账户，则是本地用户名）▲ 检查名称（点击之后会显示自己的名称）▲ 确定之后记得勾选“替换子容器和对象的所有者”▲ 确定以关掉这个对话框于是就会有一个等待窗口，等待即可：▲ 更改所有权第三步：更改权限这时再次点击高级，“高级安全设置”对话框中的“更改权限”按钮可以点了：▲ 更改权限▲ 现在可以添加权限了▲ 选择主体▲ 用同样的方式检查名称▲ 完全控制▲ 发现自己已被添加一路点击确认，就设置好啦：▲ 设置安全信息享受成果现在删除，即可完成！▲ 删除" }, { "title": "制作 Windows 10 安装盘，解决大于 4GB 的 Windows 10 镜像在 UEFI 模式下的安装问题", "url": "/post/create-bootable-usb-drive-with-wim-file-larger-than-4gb.html", "categories": "", "tags": "windows, sysprep", "date": "2018-02-22 22:14:19 +0800", "snippet": "制作一个 Windows 安装 U 盘是很容易的，使用 UltraISO 这样的刻录工具量产一个 iso 镜像文件到 U 盘即可。然而随着 Windows 10 版本号的提升，镜像变得越来越大，终于 FAT32 文件系统不再能够容纳得下安装镜像文件 install.wim 了。本文将介绍如何制作镜像文件大于 4GB 的 UEFI 启动的系统安装盘。充分利用 Windows 8 和 Windows 10 中的特性——“快速启动”，我们必须使用 UEFI 模式启动操作系统；这就要求我们制作的 U 盘安装盘必须以 UEFI 模式启动；这就要求 U 盘文件系统必须是 FAT32 的；这就要求我们的系统镜像文件 install.wim 不大于 4GB。然而 Windows 10 1709 的镜像文件就是大于 4GB，于是悲剧诞生……如果你熟悉如何制作 U 盘安装盘，那么可直接从第二步开始阅读；如果不了解，就直接开始吧！第一步：下载 Windows 10 iso 镜像文件微软一般不提供 Windows 10 的下载镜像，但 MSDN I Tell You 收集了几乎所有的 Windows 10 正式版本镜像文件，所以可以 前往 MSDN I Tell You 下载。第二步：使用镜像文件制作安装 U 盘曾经我一直使用 UltraISO 来制作启动 U 盘，毕竟是老牌刻录软件。无论刻录的时候选择了什么样的配置，刻录完之后 U 盘文件系统都会是 FAT32 格式。直到 Windows 10 的前一两个版本，install.wim 都没有超过 4GB，所以我一直以为微软会刻意避免让镜像文件超过 4GB；于是我依然使用它来制作安装盘。然而没有想到的是，当真的超过了 4GB 后，整个刻录过程居然没有报错（虽然事实上证明会安装失败）。 为什么 UEFI 方式启动的 U 盘必须使用 FAT32 文件系统？可能因为 UltraISO 太老了，以至于都没有看到对大尺寸镜像文件的支持。于是，我招到了另一款——rufus：推荐使用开源软件 rufus rufus 官网 rufus 的 GitHub 仓库官方对它的广告词是： The Reliable USB Formatting Utility靠谱的 U 盘格式化工具启动后就只有一个设置界面：对我们至关重要的选项就是分区方案和目标系统类型（Partition scheme and target system type）：这意味着我们量产后的 U 盘将支持 UEFI 启动，同时支持 GPT 分区。这样，我们便能够以 UEFI 的方式启动 U 盘。另一个选项是文件系统（File system）：由于 Windows 10 的系统镜像大于 4GB，所以我们需要选择 NTFS（exFAT 也行，但此文件系统不太成熟）。其他保持默认即可，或者按照我图中所选。记得点击此处选择要使用的镜像 iso 文件。点击“开始”后静待进度条结束，我们便得到了一个可以 UEFI 启动的 Windows 安装 U 盘。观察 rufus 制作的 U 盘这不是安装过程中必要的步骤，只是为了满足好奇心。可以看到，rufus 实际做了这些事情： 将 U 盘所有内容清除，并转换成 GPT 格式（更多转换信息可阅读我的另一篇博客）。 将 U 盘分成两个区，一个 FAT，包含用于在 EFI 下加载 NTFS 文件系统所必须的组件；一个 NTFS，包含安装 Windows 所需的真正文件（4GB 的镜像不在话下）。第三步：重启电脑并选择 UEFI U 盘启动在 Windows 系统中按住 Shift，然后点击“重启”按钮，Windows 10 将会在重启后进入 RE 环境：在 RE 环境中选择使用可移动存储设备启动即可使用 U 盘启动。使用更传统的方案当然，大部分主板都支持开机期间按下 F12 来临时选择启动设备。不过，如果在主板上开启了“快速启动”，那么很有可能根本就来不及按下 F12！这时可以采用上面的方案。选择带 UEFI 前缀的 U 盘。不管使用哪一种方案，启动后将看到此时启动的 U 盘会提示正在加载 NTFS EFI loader：第四步：选择 GPT 分区的驱动器，并按套路安装 Windows在安装界面中，我们需要确保选择的驱动器是 GPT 分区的，因为 UEFI 启动时不支持 MBR 分区表。如果没有驱动器是 GPT 分区的，该怎么办？可以使用命令转换一个 MBR 分区的驱动器到 GPT 分区。参见 在 Windows 安装期间将 MBR 驱动器转换为 GPT 驱动器。接下来，一路下一步并略加设置即可。参考资料 Creating Windows 10 UEFI fat32 USB Stick from NTFS Windows 10 ISO not possible · Issue #589 · pbatard/rufus" }, { "title": "在 Windows 安装期间将 MBR 磁盘转换为 GPT 磁盘", "url": "/post/convert-mbr-to-gpt-during-windows-installation.html", "categories": "", "tags": "windows, sysprep", "date": "2018-02-22 22:13:16 +0800", "snippet": "以 UEFI 启动的 Windows 磁盘必须是 GPT 格式。本文将介绍如何在安装 Windows 期间将磁盘从 MBR 转换成 GPT。特别注意：操作不慎可能丢失所有数据，如果你懂得安装系统的一些基本概念，那么可以继续阅读并尝试实操；否则请交给专业人士操作。切记，切记，切记！！！第一步：按下 Shift + F10 启动命令提示符在 Windows 的安装界面其实是可以启动命令提示符的，只需按下 Shift + F10 即可。第二步：敲命令启动 Diskpart：&amp;gt; diskpart启动后提示符的前面会出现“DISKPART”前缀：DISKPART&amp;gt; list disk这时命令提示符中会列出此计算机上所有的磁盘和其格式： 磁盘 ### 状态 大小 可用 Dyn Gpt -------- ------------- ------- ------- --- --- 磁盘 0 联机 119 GB 118 GB * 磁盘 1 联机 465 GB 1024 KB 磁盘 2 联机 28 GB 0 B *磁盘 0 是我准备装系统的系统盘。================ ！！！特别注意！！！ ================ 注意这里选择的是磁盘，而不是分区！不是通常所说的 C 盘/D 盘，而是一块 SSD，或一块机械硬盘。 后续操作会清除选中磁盘中的所有数据，是所有数据，毫无保留！================ ！！！特别注意！！！ ================现在，我们选中“磁盘 0”：DISKPART&amp;gt; select disk 0这里的序号取决于安装 SSD 或机械硬盘的的连接线序号，所以一定要仔细查清楚，不要选错了。接着，敲入 clean 命令清除此磁盘上的所有内容，注意，这包括了所有的分区：DISKPART&amp;gt; clean等待清除结束，然后敲入 convert gpt 命令完成转换。DISKPART&amp;gt; convert gpt第三步：平复激动的心情操作结束之后直接按下 Alt + F4 切换到 Windows 安装程序继续安装即可。如果你是强迫症重度患者，敲一个 exit 命令结束“Diskpart”程序也未尝不可。DISKPART&amp;gt; exit" }, { "title": "安装 Windows 需要知道的 256 个问题", "url": "/post/faq-in-installing-windows.html", "categories": "", "tags": "windows, sysprep", "date": "2018-02-22 20:57:12 +0800", "snippet": "如果你希望更刺激地安装 Windows，那么你需要了解很多 Windows 系统相关的问题。为什么 UEFI 方式启动的 U 盘必须使用 FAT32 文件系统？因为 NTFS 是 Windows 系统专属的文件系统，而 UEFI 目前并不支持 NTFS。于是，如果在主板设置中选择“仅 UEFI 启动”，那么 NTFS 格式的启动 U 盘在 F12 启动选项中将不可见；而如果设置为“UEFI 启动并兼容旧模式”，那么虽可以在 F12 启动选项中看得见启动 U 盘，但选择启动后是普通的 BIOS 启动。注意：在 F12 的启动选项中，UEFI 启动的选项会有一个前缀“UEFI: ”。" }, { "title": "WPF 和 UWP 中，不用设置 From 或 To，Storyboard 即拥有更灵活的动画控制", "url": "/post/using-storyboard-without-from-or-to.html", "categories": "", "tags": "wpf, uwp", "date": "2018-02-20 06:41:52 +0800", "snippet": "无论是 WPF 还是 UWP 开发，如果用 Storyboard 和 Animation 做动画，我们多数时候都会设置 From 和 To 属性，用于从起始值动画到目标值。然而动画并不总是可以静态地指定这些值，因为更多的时候动画的起始值和目标值取决于当前 UI 的状态。本文中，我将将尽量避免设置 From 和 To 值，让动画可以随时中断并重新开始，而中途不会出现突兀的变化。本文涉及到的代码均在 GitHub 上以 MIT License 开源：walterlv/sharing-demo at demo/storyboard-without-using-from-or-to。预览效果下面是本文期望实现的基本效果： 在 WPF 中的动画效果 在 UWP 中的动画效果预备代码为了让读者能够最快速地搭建一个可供试验的 DEMO，我这里贴出界面部分核心代码。XAML 是这样的（这里的 XAML，WPF 和 UWP 完全一样，可以互相使用而不用修改任何代码）： 布局部分&amp;lt;Grid Background=&quot;White&quot;&amp;gt; &amp;lt;Grid.RowDefinitions&amp;gt; &amp;lt;RowDefinition Height=&quot;Auto&quot;/&amp;gt; &amp;lt;RowDefinition/&amp;gt; &amp;lt;/Grid.RowDefinitions&amp;gt; &amp;lt;Grid.ColumnDefinitions&amp;gt; &amp;lt;ColumnDefinition/&amp;gt; &amp;lt;ColumnDefinition/&amp;gt; &amp;lt;ColumnDefinition/&amp;gt; &amp;lt;/Grid.ColumnDefinitions&amp;gt; &amp;lt;Button Grid.Row=&quot;0&quot; Grid.Column=&quot;0&quot; Content=&quot;平移至随机位置&quot; Click=&quot;BeginStoryboard_Click&quot;/&amp;gt; &amp;lt;Button Grid.Row=&quot;0&quot; Grid.Column=&quot;1&quot; Content=&quot;从随机位置平移&quot; Click=&quot;BeginStoryboard2_Click&quot;/&amp;gt; &amp;lt;Button Grid.Row=&quot;0&quot; Grid.Column=&quot;2&quot; Content=&quot;暂停&quot; Click=&quot;PauseStoryboard_Click&quot;/&amp;gt; &amp;lt;Canvas x:Name=&quot;DisplayCanvas&quot; Grid.Row=&quot;1&quot; Grid.Column=&quot;0&quot; Grid.ColumnSpan=&quot;2&quot;&amp;gt; &amp;lt;Rectangle x:Name=&quot;DisplayShape&quot; Fill=&quot;ForestGreen&quot; Width=&quot;120&quot; Height=&quot;40&quot;&amp;gt; &amp;lt;UIElement.RenderTransform&amp;gt; &amp;lt;TranslateTransform x:Name=&quot;TranslateTransform&quot; X=&quot;0&quot; Y=&quot;0&quot;/&amp;gt; &amp;lt;/UIElement.RenderTransform&amp;gt; &amp;lt;/Rectangle&amp;gt; &amp;lt;/Canvas&amp;gt;&amp;lt;/Grid&amp;gt; 资源部分&amp;lt;Page.Resources&amp;gt; &amp;lt;CircleEase x:Key=&quot;EasingFunction.Translate&quot; EasingMode=&quot;EaseOut&quot;/&amp;gt; &amp;lt;!-- 为了方便使用，在 UWP 中加上了 x:Name；WPF 代码请删除 x:Name --&amp;gt; &amp;lt;Storyboard x:Name=&quot;TranslateStoryboard&quot; x:Key=&quot;Storyboard.Translate&quot;&amp;gt; &amp;lt;DoubleAnimation Storyboard.TargetName=&quot;TranslateTransform&quot; Storyboard.TargetProperty=&quot;X&quot; EasingFunction=&quot;{StaticResource EasingFunction.Translate}&quot;/&amp;gt; &amp;lt;DoubleAnimation Storyboard.TargetName=&quot;TranslateTransform&quot; Storyboard.TargetProperty=&quot;Y&quot; EasingFunction=&quot;{StaticResource EasingFunction.Translate}&quot;/&amp;gt; &amp;lt;/Storyboard&amp;gt;&amp;lt;/Page.Resources&amp;gt;.xaml.cs 文件中预备一些属性和字段方便使用：#if !WINDOWS_UWP// 因为 WPF 不能在资源中指定 x:Name，所以需要在后台代码中手动查找动画资源。private Storyboard TranslateStoryboard =&amp;gt; (Storyboard)FindResource(&quot;Storyboard.Translate&quot;);#endifprivate DoubleAnimation TranslateXAnimation =&amp;gt; (DoubleAnimation) TranslateStoryboard.Children[0];private DoubleAnimation TranslateYAnimation =&amp;gt; (DoubleAnimation) TranslateStoryboard.Children[1];private readonly Random _random = new Random(DateTime.Now.Ticks.GetHashCode());private Point NextRandomPosition(){ var areaX = (int) Math.Round(DisplayCanvas.ActualWidth - DisplayShape.ActualWidth); var areaY = (int) Math.Round(DisplayCanvas.ActualHeight - DisplayShape.ActualHeight); return new Point(_random.Next(areaX) + 1, _random.Next(areaY) + 1);}探索动画由于我们期望元素从当前所在的位置开始动画，到我们指定的另一个随机位置，所以直接在 XAML 中指定 From 和 To 是一个艰难的行为。我们只好在 .xaml.cs 文件中指定。WPF在 WPF 中，如果我们没有指定动画的 From，那么动画将从当前值开始；如果我们没有指定动画的 To，那么动画将到当前值结束。从这个角度上说，似乎不设置 From 和 To 将导致动画保持在当前值不变，不会有动画效果。但是，WPF 允许在动画进行中修改动画参数，于是我们可以直接开始动画，然后再动画进行中修改元素属性到目标值。也就是说，可以这么写：private void BeginStoryboard_Click(object sender, RoutedEventArgs e){ TranslateStoryboard.Begin(); var nextPosition = NextRandomPosition(); TranslateTransform.X = nextPosition.X; TranslateTransform.Y = nextPosition.Y;}快速点击这个按钮看看，你会发现每次点击都可以立即从当前位置开始向新的目标位置动画。不过你应该注意到了一个坑——第一次并没有播放动画，而是直接跳到了目标位置；这是因为动画还没有保持住元素的位置。我们需要在初始化的时候播放一次动画；private void OnLoaded(object sender, RoutedEventArgs e){ TranslateStoryboard.Begin(); TranslateStoryboard.Stop();}这样就解决了第一次动画不播放的问题。现在，我们加上暂停按钮：private void PauseStoryboard_Click(object sender, RoutedEventArgs e){ TranslateStoryboard.Pause();}即便是中途有暂停，依然能够继续让动画朝新的目标位置动画。如果我们希望动画从一个新的起点开始，而不是从当前状态开始，则只需要在动画开始之前设置元素的位置即可：private void BeginStoryboard2_Click(object sender, RoutedEventArgs e){ MoveToRandomPosition(); TranslateStoryboard.Begin(); MoveToRandomPosition(); void MoveToRandomPosition() { var nextPosition = NextRandomPosition(); TranslateTransform.X = nextPosition.X; TranslateTransform.Y = nextPosition.Y; }}UWPUWP 的情况就不如 WPF 那么灵活了。在 UWP 中，如果不给动画指定 To 值，那么动画根本就会直接朝 0 位置执行。于是在动画执行之前，设置动画的 To 值不可避免：private void BeginStoryboard_Click(object sender, RoutedEventArgs e){ AnimateToRandomPosition(); TranslateStoryboard.Begin(); void Uwp_AnimateToRandomPosition() { var nextPosition = NextRandomPosition(); TranslateXAnimation.To = nextPosition.X; TranslateYAnimation.To = nextPosition.Y; }}在这样的写法下，灵活性与 WPF 相当，但 WPF 中支持在动画没有播放的时候随时设置元素位置，而这种方式则不行（其值会被动画保持）。完整的后台代码public partial class StoryboardPage : Page{ public StoryboardPage() { InitializeComponent(); Loaded += OnLoaded; }#if !WINDOWS_UWP private Storyboard TranslateStoryboard =&amp;gt; (Storyboard)FindResource(&quot;Storyboard.Translate&quot;);#endif private DoubleAnimation TranslateXAnimation =&amp;gt; (DoubleAnimation) TranslateStoryboard.Children[0]; private DoubleAnimation TranslateYAnimation =&amp;gt; (DoubleAnimation) TranslateStoryboard.Children[1]; private readonly Random _random = new Random(DateTime.Now.Ticks.GetHashCode()); private void OnLoaded(object sender, RoutedEventArgs e) { Loaded -= OnLoaded; TranslateStoryboard.Begin(); TranslateStoryboard.Stop(); } private void BeginStoryboard_Click(object sender, RoutedEventArgs e) { Uwp_AnimateToRandomPosition(); TranslateStoryboard.Begin(); MoveToRandomPosition(); } private void BeginStoryboard2_Click(object sender, RoutedEventArgs e) { MoveToRandomPosition(); Uwp_AnimateToRandomPosition(); TranslateStoryboard.Begin(); MoveToRandomPosition(); } private void PauseStoryboard_Click(object sender, RoutedEventArgs e) { TranslateStoryboard.Pause(); } [Conditional(&quot;WINDOWS_UWP&quot;)] private void Uwp_AnimateToRandomPosition() { var nextPosition = NextRandomPosition(); TranslateXAnimation.To = nextPosition.X; TranslateYAnimation.To = nextPosition.Y; } [Conditional(&quot;WPF&quot;)] private void MoveToRandomPosition() { var nextPosition = NextRandomPosition(); TranslateTransform.X = nextPosition.X; TranslateTransform.Y = nextPosition.Y; } private Point NextRandomPosition() { var areaX = (int) Math.Round(DisplayCanvas.ActualWidth - DisplayShape.ActualWidth); var areaY = (int) Math.Round(DisplayCanvas.ActualHeight - DisplayShape.ActualHeight); return new Point(_random.Next(areaX) + 1, _random.Next(areaY) + 1); }}总结 在 WPF 中，可以不通过 From 和 To 来指定动画的起始值和终止值；但如果真的不指定 From 和 To，需要提前播放一次动画以确保动画能保持住元素状态； 在 WPF 中，如果没有指定 From 和 To，那么动画结束后依然能直接为元素属性复制，且会立刻生效（正常情况下需要先清除动画）； 在 UWP 中，必须指定动画的 To 才能按照期望播放到目标值。" }, { "title": "分享一个算法，计算能在任何背景色上清晰显示的前景色", "url": "/post/get-gray-reversed-color.html", "categories": "", "tags": "algorithm, wpf, uwp, dotnet, csharp", "date": "2018-02-20 06:37:19 +0800", "snippet": "背景色千差万别，如果希望在这样复杂的背景色下显示清晰可辨的前景色（例如显示文字），那如何选择这样的前景色才能确保适用于所有的背景呢？灰度图的心理学公式红绿蓝三色是非常不直观的颜色表示的方法，如果不经过训练，人类几乎没有办法直接通过 RGB 的值来猜出大概的颜色来。而 HSB 是用来解决人眼感知问题的，它将颜色用色相、饱和度、明度来表示。可是，即便是 HSB 也不能完美解决人眼的感知问题。看下图，黄色和蓝色的饱和度和明度一样，只是色相不同，你觉得哪一个颜色更亮，哪一个更暗？相信大家都会觉得黄色更亮，蓝色总给人一种阴暗的感觉。所以，在饱和度和明度之外，一定还有一种人眼对亮度的感觉是与色相相关的。我们将不同色相的颜色排成一圈，观察下哪些颜色更亮，哪些更暗：我们将上面的不同颜色直接转成灰度图像，这是最能反映人眼感知的灰度图像，它将是这样的：也就是说，不同的颜色值总能找到一个人眼感知的灰度值，这是著名的心理学公式： 灰度 = 红×0.299 + 绿×0.587 + 蓝×0.114在灰度背景色上决定前景色一个图像的每一个像素经过上面的公式计算得到的新的图像，即是人眼感知亮度的灰度图。于是，当我们期望计算一个能在背景色上清晰显示的前景色时，我们可将背景颜色转换为灰度颜色，然后根据灰度程度，选取黑色或白色作为前景色。当然，如果你喜欢，可以将一段黑色或接近于黑色的灰度色作为浅色背景的前景；将一段白色或颉俊宇白色的灰度色作为深色背景的前景。代码实现为了实现这个效果，我们先写一个灰度/亮度的计算函数：/// &amp;lt;summary&amp;gt;/// 获取一个颜色的人眼感知亮度，并以 0~1 之间的小数表示。/// &amp;lt;/summary&amp;gt;private static double GetGrayLevel(Color color){ return (0.299 * color.R + 0.587 * color.G + 0.114 * color.B) / 255;}然后写一个根据感知亮度计算反色的方法：private static Color GetReverseForegroundColor(double grayLevel) =&amp;gt; grayLevel &amp;gt; 0.5 ? Colors.Black : Colors.White;于是，当我们希望计算某个背景色上一定能清晰显示的前景色时，只需要调用 GetReverseForegroundColor 即可。我封装的方便的 API不过，总是写后台代码来计算，对于 XAML 类的程序来说还是麻烦了些，于是我写了一些用于 XAML 的标记扩展，方便让一些文字自动根据背景色改变颜色。这是期望的最简用法：&amp;lt;TextBlock Foreground=&quot;{media:LuminanceForeground}&quot; Text=&quot;我是前景 by walterlv&quot;/&amp;gt;因为内部已经使用绑定来实现动态变化，所以，无需在颜色更改时再次更新：由于这份封装的 API 目前还在完善中，会经常改动，所以只贴出 GitHub 仓库地址，不放在这里： LuminanceForegroundExtension 写出此用法的关键类 LuminanceReverseColor 包含亮度灰度值反色的逻辑 DependencyMarkupExtension 给标记扩展中一些恶心的代码提供封装参考资料 Luma (video) - Wikipedia 从RGB色转为灰度色算法（转） - carekee - 博客园" }, { "title": "在 Windows 10 上为 WPF 窗口添加模糊特效（就像开始菜单和操作中心那样）", "url": "/post/win10/2017/10/02/wpf-transparent-blur-in-windows-10.html", "categories": "", "tags": "win10, windows, wpf", "date": "2018-02-20 06:31:10 +0800", "snippet": "其实我是希望能够找到为 Win32 桌面程序实现 Fluent Design System 效果的，不过一直没找到。倒是发现了一个可以让 Win32 桌面程序做出类似 Windows 10 开始菜单和操作中心那种模糊效果的方法。写这篇文章并不意味着我推荐大家这么去做，只是希望将方法总结出来，作为一个研究点而已。本文提供了一个完整的用于在 Windows 10 上实现模糊特效的 C# 类，没有放到 GitHub 也没有其他类型的开源。如果需要直接拿走就好。为什么不推荐使用？当初 Windows Vista 推出 Aero 特效后惊艳了世人。然而那还是个 30 帧动画大行其道的年代，即便是后来的 Windows 7 也是如此。这个特效不能使用更高帧率就在于对资源的消耗量太感人。然而 Windows 8/8.1 的推出，动画是其中的一个重要部分——那全屏的感人的流畅的动画，那丝般的顺滑，让人难忘。然而这么流畅是有代价的——需要 60 帧满速运行，而且不能占用太多资源，不然依然卡顿。于是微软只好砍掉了背景高斯模糊功能……充满遗憾……被世人唾骂……忍受不了世人的咒骂，微软只好再把高斯模糊效果带回 Windows 10。可是，在算法没有从根本上得到改进的情况下，大量的资源消耗依然是不可忽视的问题。所以微软现在只好在少数几个地方先用用，满足大家曾经对于 Aero 的呼声，适当提升一点点审美。既然微软能用，那么我们也理应能用。然而事实情况是——微软没有任何文档来说明如何实现这样的效果。足以说明微软也不希望他们担心的性能问题大量出现在用户的电脑上。（对于移动设备如 Surface 来说，带来的就是电池可用时间的缩短。）叛逆者 说，他们终于在特效的算法上有了质的突破，创意来源于平时小组言谈中一点点想法。这就是 Fluent Design System！终于只需要非常少量的计算资源就能达到非常炫酷的现代效果。让人印象深刻的可以替代 Aero 的就属亚克力（Acrylic）了。这效果是在 DWM 进程上运行的（与 Aero 特效一样），所以也不会额外占用应用程序本身的计算资源。然而，本文探究的方法并不是 Fluent Design System 中的任何部分。依然是微软不期望大家使用的方法，所以，本文并不推荐大家作为真实项目使用，而是作为一种探究学习的途径。我封装的 API为了方便大家使用，我封装了一个小的 API。于是大家可以非常方便地使用。如果你想在 XAML 里用，直接在 MainWindow 上加上以下两行：xmlns:interop=&quot;clr-namespace:Walterlv.Demo.Interop&quot;interop:WindowBlur.IsEnabled=&quot;True&quot;如果你希望直接在 cs 文件里面写，则这样就好了：WindowBlur.SetIsEnabled(this, true);注意这里的 this 指的是 MainWindow。事实上，当你用了上面的 API 试图看一看效果的时候，你会发现其实并不如本文一开始的图片那样。而是一个非常丑陋的窗口：你需要做两件事情才能变得好看一些： 设置窗口背景色为透明（Transparent）/半透明（#A0FFFFFF），以便去掉默认的白色背景。 为窗口设置 WindowChrome 属性，以便去掉标题栏颜色的不同，并修复周围阴影几个像素的半透明偏差。完整的代码可以看这里：&amp;lt;Window x:Class=&quot;Walterlv.Demo.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:interop=&quot;clr-namespace:Walterlv.Demo.Interop&quot; mc:Ignorable=&quot;d&quot; Title=&quot;Blur Demo&quot; Height=&quot;350&quot; Width=&quot;525&quot; interop:WindowBlur.IsEnabled=&quot;True&quot; Background=&quot;Transparent&quot;&amp;gt; &amp;lt;WindowChrome.WindowChrome&amp;gt; &amp;lt;WindowChrome GlassFrameThickness=&quot;-1&quot; /&amp;gt; &amp;lt;/WindowChrome.WindowChrome&amp;gt; &amp;lt;Grid Background=&quot;#A0FFFFFF&quot;&amp;gt; &amp;lt;TextBlock Foreground=&quot;White&quot; FontSize=&quot;20&quot; FontWeight=&quot;Light&quot; TextAlignment=&quot;Center&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;&amp;gt; &amp;lt;Run Text=&quot;Hello World&quot; FontSize=&quot;48&quot;/&amp;gt; &amp;lt;LineBreak/&amp;gt; &amp;lt;Run Text=&quot;白底效果&quot; /&amp;gt; &amp;lt;LineBreak/&amp;gt; &amp;lt;Run Text=&quot;walterlv.github.io&quot;/&amp;gt; &amp;lt;/TextBlock&amp;gt; &amp;lt;/Grid&amp;gt;&amp;lt;/Window&amp;gt;实现原理——SetWindowCompositionAttributeWindowBlur 类内部用到了微软从未开放的 API，叛逆者 也已经证实这就是微软在开始菜单和操作中心中用到的 API。这个 API 就是 SetWindowCompositionAttribute。事实上此类中的代码来源也是多个地方找到的，最开始是 C 语言的版本，而后从 Nukepayload2/sample-win10-aeroglass 找到了 C# 的版本，最终基于它改造成了现在这个样子。代码见本文最后，因为我想把参考资料放到前面来，以感谢前人的努力。参考资料 如何评价微软在 Build 2017 上提出的 Fluent Design System？ - 知乎 windows - Mimicking Acrylic in a Win32 app - Stack Overflow winapi - How do you set the glass blend colour on Windows 10? - Stack Overflow 调用未公开API SetWindowCompositionAttribute 在Win10下开启Aero - CSDN博客 Windows 10 开始菜单的高斯模糊效果是如何实现的？ - 知乎 从编程的角度来说，Windows 的开始菜单是如何实现的？ - 知乎 Windows 10 Creators Update 新功能——画中画模式和窗口高斯模糊 - yinyue200 - 博客园 Nukepayload2/sample-win10-aeroglass附：封装好的 API 代码" }, { "title": "应该抛出什么异常？不应该抛出什么异常？（.NET/C#）", "url": "/post/throws-which-exception.html", "categories": "", "tags": "dotnet, csharp", "date": "2018-02-04 21:25:51 +0800", "snippet": "我在 .NET/C# 建议的异常处理原则 中描述了如何 catch 异常以及重新 throw。然而何时应该 throw 异常，以及应该 throw 什么异常呢？究竟是谁错了？代码中从上到下从里到外都是在执行一个个的包含某种目的的代码，我们将其称之为“任务”。当需要完成某项任务时，任务的完成情况只有两种结果： 成功完成 失败异常处理机制就是处理上面的第 2 种情况。这里我们不谈论错误码系统，那么，异常便应该在任务执行失败时抛出异常。抛出异常后，报告错误只是手段，真正要做的是帮助开发者修复错误。于是，第一个要做的就是区分到底——谁错了！ 任务的使用者用错了 任务的执行代码写错了 任务执行时所在的环境不符合预期简单说来，就是：使用错误，实现错误、环境错误。让我们把异常归类到这些错误中本文的重点在于指导我们何时应该抛出什么异常，也就是说——我们的角色是——任务的编写者。那么，编写者有责任编写出一段没有错误的代码。这就说明——永远不应该抛出表示自己写错了的异常。那么，我们对常见的异常进行分类。使用错误 ArgumentException 表示参数使用错了 ArgumentNullException 表示参数不应该传入 null ArgumentOutOfRangeException 表示参数中的序号超出了范围 InvalidEnumArgumentException 表示参数中的枚举值不正确 InvalidOperationException 表示当前状态下不允许进行此操作（也就是说存在着允许进行此操作的另一种状态） ObjectDisposedException 表示对象已经 Dispose 过了，不能再使用了 NotSupportedException 表示不支持进行此操作（这是在说不要再试图对这种类型的对象调用此方法了，不支持） PlatformNotSupportedException 表示在此平台下不支持（如果程序跨平台的话） 实现错误 NullReferenceException 试图在空引用上执行某些方法，除了告诉实现者出现了意料之外的 null 之外，没有什么其它价值了 IndexOutOfRangeException 使用索引的时候超出了边界 InvalidCastException 表示试图对某个类型进行强转但类型不匹配 StackOverflow 表示栈溢出，这通常说明实现代码的时候写了不正确的显式或隐式的递归 OutOfMemoryException 表示托管堆中已无法分出期望的内存空间，或程序已经没有更多内存可用了 AccessViolationException 这说明使用非托管内存时发生了错误 BadImageFormatException 这说明了加载的 dll 并不是期望中的托管 dll TypeLoadException 表示类型初始化的时候发生了错误环境错误 IOException 下的各种子类 Win32Exception 下的各种子类 ……无法归类不应该抛出，却又不得不抛出的异常： NotImplementedException 这只能说明此功能还在开发中，一旦进入正式环境，不要抛出此异常（如果那时真的没有完成，这个方法就应该删除） AggregateException 如果可能，真的不要抛出此异常，因为它本身不包含异常信息，让使用者很难正确 catch 这样的异常。如果内部只有一个异常，应该使用 ExceptionDispatchInfo 将内部异常合并（请参阅 使用 ExceptionDispatchInfo 捕捉并重新抛出异常 - 吕毅）（Task 在执行多个任务后，如果多个任务都发生了异常，就抛出了 AggregateException，但这已经是没有办法的事情了，因为没有办法将两个可能不是同类的异常合并成一个）永远都不应该抛出异常： FormatException 这算是 .NET 设计上的失误吧……因为当它抛出来时无法准确描述到底什么错了 ApplicationException 这是各种异常的基类，本身并没有明确的意义 SystemException 这是各种异常的基类，本身并没有明确的意义 Exception 这可是顶级基类，这都抛出来了，使用者再也无法正确地处理此异常了是时候该决定抛什么异常了对于使用错误，应该在第一时间抛出既然对方已经用错了，那么代码继续执行也只会错上加错。public string Foo(Bar demo){ demo.Output(&quot;Walterlv&quot;); return _anotherDemo.ToString();}例如上面的方法中使用者传入了一个 null 参数后，方法必然执行失败 —— 抛出了一个 NullReferenceException。但是，当拿着这样的异常去调查哪里错了的时候，我们会发现 demo 和 anotherDemo 都可能为 null。然而很明显，这时使用者的错，使用者确保传入的参数不为 null，方法就可以继续执行。如果在方法的一开始就抛出使用异常 ArgumentNullException，那么就可以向使用者报告这样的参数使用错误。另外的情况，_anotherDemo 是此类型中的另一个字段，此时也要求必须非 null。而要确保非 null，使用者必须使用其它方式隐式初始化这个字段，那么应该抛出 InvalidOperationException，告诉使用者应该先调用其他的某个方法。那么，应该改成：public string Foo([NotNull] Bar demo){ if (demo == null) throw new ArgumentNullException(nameof(demo)); if (_anotherDemo == null) throw new InvalidOperationException(&quot;必须使用 XXX 设置某个值之后才能使用 Foo 方法。&quot;); demo.Output(&quot;Walterlv&quot;); return _anotherDemo.ToString();}当然，不像 ArgumentNullException，InvalidOperationException 通常并不一定能在开始就确定是否满足状态要求，但最好能尽可能在第一时间抛出，避免错误蔓延。做到了第一时间抛出使用错误，就能让使用者明确知道自己用错了，需要修改使用代码。（这正是被另外一项事实所逼——典型的程序员是不看文档的，“使用异常”代替了一部分文档。）永远不应该让实现错误抛出这一节的标题其实说了三件事情： 永远不应该主动用 throw 句式抛出“实现错误”章节中提到的任何异常 如果你在调用某个别人实现的代码时遇到了“实现错误”章节中提到的异常，那说明“那个人”的代码写出 BUG 了，确信无疑。 如果自己写的代码发现抛出了这些异常，那就说明自己写出了 BUG，需要第一时解决 BUG（是解决，不是逃避）我们假设实现了这段代码：var button = (Button) sender;button.Content = &quot;Clicked&quot;;如果在执行到第一句时发生了 InvalidCastException，说明实现代码编写是不正确的。为了防止发生异常，可能有些人会改成这样：// 请注意：这段示例是错误的！if (sender is Button button) button.Content = &quot;Clicked&quot;;这是在逃避问题，而不是解决问题！这是一段典型的事件处理函数代码，sender 通常是事件的引发者。写这段代码的人并没有调查 sender 不是 Button 类型的原因，到底是因为在 Grid 上监听了路由事件的 Click，还是因为多个控件都把事件处理函数设为了这个方法。如果是前者，这样的改法会让这段代码的全部逻辑失效；如果是后者，这样的改法会让部分逻辑失效。更应该去做的，是去检查 += 的左边是否乱入了非 Button 的事件引发者。grid.Click += OnButtonClickbutton.Click += OnButtonClick;修改这些源头上就已经不正确的代码，才是真正解决问题。另一个角度，如果事件的引发者确实可能有多种，那么事件处理函数就应该加上 else 逻辑，或者不要再使用 sender，或者强制转换时使用基类型。这也是在真正的解决问题。额外的，对于 OutOfMemoryException，这通常意味着“实现”部分的代码存在着性能问题，应该着手解决。对于环境错误，关注于规避和恢复环境错误是难以提前预估的；或者说预估的成本太高，不值得去预估。于是，当发生了环境错误，我们更加关注于这样的环境中是什么导致了异常，以及程序是否正确处理了这样的异常并恢复错误。.NET 中已经为我们准备了很多场景下的多套环境异常，例如 IO 相关的异常，网络连接相关的异常。这些异常都不是我们应该抛出的。程序中的异常在异常处理中，每一位开发者应该从根源上在自己的代码中消灭“实现异常”（而不是“逃避”），同时在“使用异常”的帮助下正确调用其他方法，那么代码中将只剩下“环境异常”（和小部分性能导致的“实现异常”）。此时，开发者们将有更多的精力关注在“解决的具体业务”上面，而不是不停地解决编码上的 BUG。特别的，“实现异常”可以被单元测试进行有效的检测。" }, { "title": ".NET/C# 建议的异常处理原则", "url": "/post/suggestions-for-handling-exceptions.html", "categories": "", "tags": "csharp, dotnet, wpf", "date": "2018-02-04 21:19:06 +0800", "snippet": "“体验”一词早已泛滥却又能够粗略地表达开发团队对客户端产品的要求，“质量”在 卡诺模型（KANO Model） 中是“必备特性”——做得好了用户感觉不到，做得差一点儿用户就会破口大骂。本文将以提升客户端 GUI 产品质量为目标，谈谈 .NET/C# 中建议的异常处理方式。（如果想了解更具体的应该抛出什么异常，请前往我的另一篇文章 应该抛出什么异常？ - 吕毅）不恰当的异常处理会带来什么影响？DEMO 和学习资料是无所谓的，找个地方写写 try-catch-finally 就完了……但是一旦这一行为迁移到了大型产品或软件系统中，不恰当的异常处理将会带来严重的体验下降或者巨大的额外维护成本。严重的体验下降众所周知，如果应用中存在大量未经处理的异常，那么应用分分钟崩溃死掉。如果软件面向最终用户，那么用户将不停地遭遇闪退或者“停止工作”。如果面向服务器或其他系统，频繁挂掉也几乎意味着服务不可用。这是异常处理“不足”造成的影响。不过，处理“不足”这种情况大家见得少，因为实际开发中更多遇到的不是很多异常未经处理，而是各种异常都处理掉了。算是“过度”吧。巨大的额外维护成本如果我们在各个功能上都加上 try-catch 块，在 catch 里吞掉异常，软件确实是不会崩了，但部分功能代码也不会执行执行了。本来用户那里崩溃一下还能逼着开发者去调查一下原因，现在连崩溃都看不到，甚至都不知道软件已经濒临挂掉的边缘。积少成多的这些小错误会瞬间积累，形成一组复杂的不可描述和预知的现象。没有人能说明这现象背后到底是哪个模块的错误导致的。于是，分析一个用户反馈的错误将变得非常低效，每一次错误都难以说出具体出错的模块到底是哪个——软件的质量只有日益下降，维护成本持续升高了。不要说在每个 catch 块里记了 log，log 是开发者们从来不会主动去看的文件，从来都是出了问题才看的，而且看了也只能修复 BUG，解决不了问题！我举个例子：软件为用户储存一份文档，在此过程中发生了异常却被吞掉了（就算记了 log）；那么用户极有可能得到一份缺失重要内容的损坏的文档——看 log 能帮用户找回损失吗？！总揽全局——分层的异常处理异常的处理可以分为四个层： 任务的执行细节 调用任务执行的顶级 UI、顶级命令或包含完整功能的 API 线程级别和应用程序域级别 驱动模块或应用程序的框架▲ 上图在垂直方向上存在直接调用关系，而在水平方向上是不同时机上的调用其中第 4 层并没有出现在上图中，因为它并不能按照执行时机或调用关系来定位，而是可能出现在上图中的任何一处。在不同的层上应该做不同的事情，如果每一层都做正确的处理，那么便能够既保留足够的异常信息供开发人员分析，又不会因为异常致使用户用起来感觉软件不稳定。接下来，我们将分别说明在每一层应该做些什么，原则是什么。定出原则——职责分明执行细节执行细节通常有这些代码： 组件库/公共组件 业务实现代码这些代码几乎都是要被调用才会开始执行，但在编写时一般较难预见到调用方的使用方式和时机。它的异常处理原则是： 提前判断参数和状态，不满足则抛出异常如果调用方需要提前准备一些状态或参数才能正常执行，那么必须提前判断这些状态；如果判断不通过，需要抛出异常提示调用方需要正确地调用。（如果非私有方法的判断已经足够了，内部的私有方法可以不用再做判断。） 执行方法承诺的任务，若无法履行承诺，则抛出异常如果调用的更底层的方法抛出了异常，要么保留这些异常对外抛出（推荐），要么抛出自己的异常并将底层异常包装为内部异常。 如果异常会导致状态错误或应用程序功能雪崩，需要恢复并重新抛出异常catch 是用来恢复错误的，而不是用来防止崩溃的。finally 是用来恢复状态的。需要说明的是，这部分代码通常是一层嵌一层地调用，是每一层都要注意以上原则。顶级 UI/命令或 API对异常的处理本不应该区分具体的业务实现还是顶级命令或 UI 的，在我试图推荐的异常处理方式中，它也应该遵循前面执行细节里的三项处理原则。但实际在执行的过程中，如果不把顶级命令和 UI 单独拿出来说，会有理解上的困难。 对顶级 UI 或命令来说，提前判断的参数通常是用户的输入和当前应用程序的若干状态。对用户输入来说，提前从交互上防止用户出错是最佳的方式，但也不可避免会存在遗漏，这时肯定不能直接抛个异常给用户；所以此时的最佳处理方案是给出适当的 UI 反馈以告知用户出现的问题和建议的恢复方法。对程序当前的状态来说，如果不符合执行某个命令的要求，这个命令应该被禁用并告知用户禁用的原因；而不是执行时抛个异常或者什么都不做。 对顶级 UI 或命令来说，承诺的任务已经开始包含必要的异常处理以及与此处理相关的交互。也就是说，catch 掉已知的几种异常并用友好的 UI 交互形式与用户进行互动也是承诺的一部分。既然承诺的任务能够达成，也不需要抛出异常。（未知原因的异常依然不应该私自处理，因为这依然会导致问题难以定位，何况还是未知异常。） 应用程序级别对外公开的 API 考虑到安全性问题，考虑到第三方调用者参差不齐的水平，也会考虑有限地通过 UI 交互来吞掉部分已知的异常。而这时也如以上所说，这些处理也是此 API 承诺任务的一部分。程序统一处理Dispatcher.UnhandledException 可以处理掉当前 UI 线程上未经处理的异常；AppDomain.UnhandledException 可以让我们知道当前应用程序域中所有未经处理的异常。正是因为统一处理的存在，才使得我们可以放心大胆地在业务代码中抛出能够足够描述当前异常原因的异常而不用担心应用程序会频繁地挂掉。不过统一处理的地方能够进行的处理操作有限，比如记个 log 之类，毕竟不知道业务需求。所以并不要指望在统一处理时能够恢复错误，错误还是需要到各个业务方去恢复的。框架框架代码可能被业务代码调用，也可能调用业务代码。无论哪种，框架从来都不能相信业务代码按照要求和契约来编程。处理框架代码被调用时，以正常实现细节被调用的异常处理原则一样即可——确保参数正确，承诺完成并且不完成就抛出异常。处理框架调用业务代码时，几乎一定要处理业务代码任何种类崩溃的情况。也就是说，几乎需要恢复错误然后重新抛出异常。" }, { "title": "有些异常堆栈中真没我们写的源码", "url": "/dotnet/2017/01/19/there-is-no-code-of-mine-in-the-stack-trace.html", "categories": "", "tags": "dotnet", "date": "2018-01-16 09:57:50 +0800", "snippet": "有时候会发生一些异常，但异常的堆栈信息中完全找不到我们自己写的源码，这样的异常到底怎么调试！本文基于 WPF on .NET Framework 4.5文章一开始，先列出几个异常的前几行。System.ComponentModel.Win32Exception (0x80004005): Not enough quota is available to process this command.System.Runtime.InteropServices.COMException (0x80070008): Not enough storage is available to process this command. (Exception from HRESULT: 0x80070008)System.Runtime.InteropServices.COMException (0x88980411): Exception from HRESULT: 0x88980411System.OutOfMemoryException: Insufficient memory to continue the execution of the program.异常堆栈太长了，这里只列出一行，详细的可以看本文文末的“附”节，免得影响大家阅读。为什么会发生这些异常？初步看这些异常，几乎都没有什么头绪，因为根本就不是从我们的代码调用中引发的。所以，如果我们不能接触到发生异常的现场的话，几乎就只剩下搜索这一条路线可走了。0x80004005: 配额不足，无法处理此命令。 问题状态：尚未解决。 复现步骤：有一种复现方式，疯狂给某个窗口发送 Windows 消息，这个窗口所在的进程可能会收到此错误。 表现现象：但从查阅的资料来看，极有可能是导致窗口不渲染（Window Freezes）。 猜测原因：窗口用于储存消息队列的容器存储空间耗尽。查阅资料： Mysterious “Not enough quota is available to process this command” in WinRT port of DataGrid https://stackoverflow.com/questions/12584619/mysterious-not-enough-quota-is-available-to-process-this-command-in-winrt-port Not enough quota is available to process this command -WPF https://stackoverflow.com/questions/20964360/not-enough-quota-is-available-to-process-this-command-wpf （在查阅此页一天后，此页已无法访问） https://support.microsoft.com/en-us/kb/327699 Invisible WPF dialog filling up windows message queue? https://social.msdn.microsoft.com/Forums/vstudio/en-US/6e94283a-76be-42b3-98e6-a8e18c4e43de/invisible-wpf-dialog-filling-up-windows-message-queue?forum=wpf Diagnosis on “Quota Exceeded” Win32Exception https://stackoverflow.com/questions/10086985/diagnosis-on-quota-exceeded-win32exception WPF app fails to start second time https://social.msdn.microsoft.com/Forums/vstudio/en-US/664f2de6-342f-4527-977e-a7e12eac8d90/wpf-app-fails-to-start-second-time-?forum=wpf MsOfficeTracker - Not enough quota available（由于我在此页上有回复，所以此页包含了以上所有链接。） https://github.com/sealuzh/PersonalAnalytics/issues/62 Pushing the Limits of Windows: Handles https://blogs.technet.microsoft.com/markrussinovich/2009/09/29/pushing-the-limits-of-windows-handles/ Why does my WPF application use up so many Windows handles? [closed] https://stackoverflow.com/questions/25316479/why-does-my-wpf-application-use-up-so-many-windows-handles The current process has used all of its system allowance of handles for Window Manager objects https://social.msdn.microsoft.com/Forums/windows/en-US/73aaa1f3-30a7-4593-b299-7ec1fd582b27/the-current-process-has-used-all-of-its-system-allowance-of-handles-for-window-manager-objects?forum=winforms 0x80070008: 存储空间不足，无法处理此命令。 问题状态：尚未解决。 复现步骤：复现一次，但难以总结步骤，其它通过日志搜集。 表现现象：从唯一的一次复现来看，会导致整个窗口无法操作，无任何响应。 问题进展：微软说，这是 TextInterface 的内存泄露问题，.NET Framework 4.6 解了，要升 4.6 才行。 https://stackoverflow.com/questions/35182703/wpf-error-when-calling-measure-not-enough-storage-is-available-to-process-thi/41341668#41341668 https://social.msdn.microsoft.com/Forums/vstudio/en-US/350a8d21-f361-4983-9bc3-65c71a78cb52/comexception-this-command-is-not-enough-memory-available?forum=wpf https://connect.microsoft.com/VisualStudio/feedback/details/1468770/exception-with-textinterface MS.Internal.Text.TextInterface.Native.Util.ConvertHresultToException 里的 System.OutOfMemoryException问题状态：跟进中……附：异常的详细堆栈1. System.ComponentModel.Win32Exception (0x80004005): 配额不足，无法处理此命令。System.ComponentModel.Win32Exception (0x80004005): Not enough quota is available to process this command. at MS.Win32.UnsafeNativeMethods.PostMessage(HandleRef hwnd, WindowMessage msg, IntPtr wparam, IntPtr lparam) at System.Windows.Interop.HwndTarget.UpdateWindowSettings(Boolean enableRenderTarget, Nullable`1 channelSet) at System.Windows.Interop.HwndTarget.UpdateWindowPos(IntPtr lParam) at System.Windows.Interop.HwndTarget.HandleMessage(WindowMessage msg, IntPtr wparam, IntPtr lparam) at System.Windows.Interop.HwndSource.HwndTargetFilterMessage(IntPtr hwnd, Int32 msg, IntPtr wParam, IntPtr lParam, Boolean&amp;amp; handled) at MS.Win32.HwndWrapper.WndProc(IntPtr hwnd, Int32 msg, IntPtr wParam, IntPtr lParam, Boolean&amp;amp; handled) at MS.Win32.HwndSubclass.DispatcherCallbackOperation(Object o) at System.Windows.Threading.ExceptionWrapper.InternalRealCall(Delegate callback, Object args, Int32 numArgs) at MS.Internal.Threading.ExceptionFilterHelper.TryCatchWhen(Object source, Delegate method, Object args, Int32 numArgs, Delegate catchHandler)2. System.Runtime.InteropServices.COMException (0x80070008): 存储空间不足，无法处理此命令。 (Exception from HRESULT: 0x80070008)System.Runtime.InteropServices.COMException (0x80070008): Not enough storage is available to process this command. (Exception from HRESULT: 0x80070008) at System.Runtime.InteropServices.Marshal.ThrowExceptionForHRInternal(Int32 errorCode, IntPtr errorInfo) at System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(Int32 errorCode, IntPtr errorInfo) at MS.Internal.Text.TextInterface.Native.Util.ConvertHresultToException(Int32 hr) at MS.Internal.Text.TextInterface.FontFace.GetDisplayGlyphMetrics(UInt16* pGlyphIndices, UInt32 glyphCount, GlyphMetrics* pGlyphMetrics, Single emSize, Boolean useDisplayNatural, Boolean isSideways, Single pixelsPerDip) at System.Windows.Media.GlyphTypeface.GlyphMetrics(UInt16* pGlyphIndices, Int32 characterCount, GlyphMetrics* pGlyphMetrics, Double emSize, Single pixelsPerDip, TextFormattingMode textFormattingMode, Boolean isSideways) at System.Windows.Media.GlyphTypeface.GetGlyphMetricsAndIndicesOptimized(UInt32* pCodepoints, Int32 characterCount, Double emSize, Single pixelsPerDip, UInt16[] glyphIndices, GlyphMetrics[] glyphMetrics, TextFormattingMode textFormattingMode, Boolean isSideways) at System.Windows.Media.GlyphTypeface.GetGlyphMetricsOptimized(CharacterBufferRange characters, Double emSize, Single pixelsPerDip, UInt16[] glyphIndices, GlyphMetrics[] glyphMetrics, TextFormattingMode textFormattingMode, Boolean isSideways) at System.Windows.Media.Typeface.CheckFastPathNominalGlyphs(CharacterBufferRange charBufferRange, Double emSize, Single pixelsPerDip, Double scalingFactor, Double widthMax, Boolean keepAWord, Boolean numberSubstitution, CultureInfo cultureInfo, TextFormattingMode textFormattingMode, Boolean isSideways, Boolean breakOnTabs, Int32&amp;amp; stringLengthFit) at MS.Internal.TextFormatting.SimpleRun.CreateSimpleTextRun(CharacterBufferRange charBufferRange, TextRun textRun, TextFormatterImp formatter, Int32 widthLeft, Boolean emergencyWrap, Boolean breakOnTabs, Double pixelsPerDip) at MS.Internal.TextFormatting.SimpleRun.Create(FormatSettings settings, CharacterBufferRange charString, TextRun textRun, Int32 cp, Int32 cpFirst, Int32 runLength, Int32 widthLeft, Int32 idealRunOffsetUnRounded, Double pixelsPerDip) at MS.Internal.TextFormatting.SimpleTextLine.Create(FormatSettings settings, Int32 cpFirst, Int32 paragraphWidth, Double pixelsPerDip) at MS.Internal.TextFormatting.TextFormatterImp.FormatLineInternal(TextSource textSource, Int32 firstCharIndex, Int32 lineLength, Double paragraphWidth, TextParagraphProperties paragraphProperties, TextLineBreak previousLineBreak, TextRunCache textRunCache) at MS.Internal.TextFormatting.TextFormatterImp.FormatLine(TextSource textSource, Int32 firstCharIndex, Double paragraphWidth, TextParagraphProperties paragraphProperties, TextLineBreak previousLineBreak, TextRunCache textRunCache) at MS.Internal.Text.Line.Format(Int32 dcp, Double width, TextParagraphProperties lineProperties, TextLineBreak textLineBreak, TextRunCache textRunCache, Boolean showParagraphEllipsis) at System.Windows.Controls.TextBlock.MeasureOverride(Size constraint) at System.Windows.FrameworkElement.MeasureCore(Size availableSize) at System.Windows.UIElement.Measure(Size availableSize) at System.Windows.Controls.Grid.MeasureCell(Int32 cell, Boolean forceInfinityV) at System.Windows.Controls.Grid.MeasureCellsGroup(Int32 cellsHead, Size referenceSize, Boolean ignoreDesiredSizeU, Boolean forceInfinityV, Boolean&amp;amp; hasDesiredSizeUChanged) at System.Windows.Controls.Grid.MeasureCellsGroup(Int32 cellsHead, Size referenceSize, Boolean ignoreDesiredSizeU, Boolean forceInfinityV) at System.Windows.Controls.Grid.MeasureOverride(Size constraint) at System.Windows.FrameworkElement.MeasureCore(Size availableSize) at System.Windows.UIElement.Measure(Size availableSize) at System.Windows.Controls.Grid.MeasureCell(Int32 cell, Boolean forceInfinityV) at System.Windows.Controls.Grid.MeasureCellsGroup(Int32 cellsHead, Size referenceSize, Boolean ignoreDesiredSizeU, Boolean forceInfinityV, Boolean&amp;amp; hasDesiredSizeUChanged) at System.Windows.Controls.Grid.MeasureCellsGroup(Int32 cellsHead, Size referenceSize, Boolean ignoreDesiredSizeU, Boolean forceInfinityV) at System.Windows.Controls.Grid.MeasureOverride(Size constraint) at System.Windows.FrameworkElement.MeasureCore(Size availableSize) at System.Windows.UIElement.Measure(Size availableSize) at MS.Internal.Helper.MeasureElementWithSingleChild(UIElement element, Size constraint) at System.Windows.Controls.ContentPresenter.MeasureOverride(Size constraint) at System.Windows.FrameworkElement.MeasureCore(Size availableSize) at System.Windows.UIElement.Measure(Size availableSize) at System.Windows.Controls.Border.MeasureOverride(Size constraint) at System.Windows.FrameworkElement.MeasureCore(Size availableSize) at System.Windows.UIElement.Measure(Size availableSize) at System.Windows.Controls.Control.MeasureOverride(Size constraint) at System.Windows.FrameworkElement.MeasureCore(Size availableSize) at System.Windows.UIElement.Measure(Size availableSize) at System.Windows.Controls.Grid.MeasureOverride(Size constraint) at System.Windows.FrameworkElement.MeasureCore(Size availableSize) at System.Windows.UIElement.Measure(Size availableSize) at System.Windows.Documents.Adorner.MeasureOverride(Size constraint) at System.Windows.FrameworkElement.MeasureCore(Size availableSize) at System.Windows.UIElement.Measure(Size availableSize) at System.Windows.Documents.AdornerLayer.MeasureOverride(Size constraint) at System.Windows.FrameworkElement.MeasureCore(Size availableSize) at System.Windows.UIElement.Measure(Size availableSize) at System.Windows.Documents.AdornerDecorator.MeasureOverride(Size constraint) at System.Windows.FrameworkElement.MeasureCore(Size availableSize) at System.Windows.UIElement.Measure(Size availableSize) at System.Windows.Window.MeasureOverrideHelper(Size constraint) at System.Windows.Window.MeasureOverride(Size availableSize) at System.Windows.FrameworkElement.MeasureCore(Size availableSize) at System.Windows.UIElement.Measure(Size availableSize) at System.Windows.ContextLayoutManager.UpdateLayout() at System.Windows.ContextLayoutManager.UpdateLayoutCallback(Object arg) at System.Windows.Media.MediaContext.InvokeOnRenderCallback.DoWork() at System.Windows.Media.MediaContext.FireInvokeOnRenderCallbacks() at System.Windows.Media.MediaContext.RenderMessageHandlerCore(Object resizedCompositionTarget) at System.Windows.Media.MediaContext.RenderMessageHandler(Object resizedCompositionTarget) at System.Windows.Threading.ExceptionWrapper.InternalRealCall(Delegate callback, Object args, Int32 numArgs) at System.Windows.Threading.ExceptionWrapper.TryCatchWhen(Object source, Delegate callback, Object args, Int32 numArgs, Delegate catchHandler)……3. System.Runtime.InteropServices.COMException (0x88980411): Exception from HRESULT: 0x88980411System.Runtime.InteropServices.COMException (0x88980411): Exception from HRESULT: 0x88980411 at System.Windows.Media.Composition.DUCE.Channel.ReleaseOnChannel(ResourceHandle handle) at System.Windows.Media.Composition.DUCE.MultiChannelResource.ReleaseOnChannel(Channel channel) at System.Windows.Media.DashStyle.System.Windows.Media.Composition.DUCE.IResource.ReleaseOnChannel(Channel channel) at System.Windows.Media.Pen.DashStylePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e) at System.Windows.DependencyObject.OnPropertyChanged(DependencyPropertyChangedEventArgs e) at System.Windows.Freezable.OnPropertyChanged(DependencyPropertyChangedEventArgs e) at System.Windows.DependencyObject.NotifyPropertyChange(DependencyPropertyChangedEventArgs args) at System.Windows.DependencyObject.UpdateEffectiveValue(EntryIndex entryIndex, DependencyProperty dp, PropertyMetadata metadata, EffectiveValueEntry oldEntry, EffectiveValueEntry&amp;amp; newEntry, Boolean coerceWithDeferredReference, Boolean coerceWithCurrentValue, OperationType operationType) at System.Windows.DependencyObject.SetValueCommon(DependencyProperty dp, Object value, PropertyMetadata metadata, Boolean coerceWithDeferredReference, Boolean coerceWithCurrentValue, OperationType operationType, Boolean isInternal) at System.Windows.DependencyObject.SetValueInternal(DependencyProperty dp, Object value) at System.Windows.Media.Pen.set_DashStyle(DashStyle value) at System.Windows.Shapes.Shape.GetNaturalSize() at System.Windows.Shapes.Shape.MeasureOverride(Size constraint) at System.Windows.FrameworkElement.MeasureCore(Size availableSize) at System.Windows.UIElement.Measure(Size availableSize) at System.Windows.Controls.Grid.MeasureCell(Int32 cell, Boolean forceInfinityV) at System.Windows.Controls.Grid.MeasureCellsGroup(Int32 cellsHead, Size referenceSize, Boolean ignoreDesiredSizeU, Boolean forceInfinityV, Boolean&amp;amp; hasDesiredSizeUChanged) at System.Windows.Controls.Grid.MeasureOverride(Size constraint) at System.Windows.FrameworkElement.MeasureCore(Size availableSize) at System.Windows.UIElement.Measure(Size availableSize) at System.Windows.Controls.Control.MeasureOverride(Size constraint) at System.Windows.FrameworkElement.MeasureCore(Size availableSize) at System.Windows.UIElement.Measure(Size availableSize) at System.Windows.Controls.StackPanel.StackMeasureHelper(IStackMeasure measureElement, IStackMeasureScrollData scrollData, Size constraint) at System.Windows.Controls.StackPanel.MeasureOverride(Size constraint) at System.Windows.FrameworkElement.MeasureCore(Size availableSize) at System.Windows.UIElement.Measure(Size availableSize) at System.Windows.Controls.Grid.MeasureOverride(Size constraint) at System.Windows.FrameworkElement.MeasureCore(Size availableSize) at System.Windows.UIElement.Measure(Size availableSize) at System.Windows.Controls.Grid.MeasureCell(Int32 cell, Boolean forceInfinityV) at System.Windows.Controls.Grid.MeasureCellsGroup(Int32 cellsHead, Size referenceSize, Boolean ignoreDesiredSizeU, Boolean forceInfinityV, Boolean&amp;amp; hasDesiredSizeUChanged) at System.Windows.Controls.Grid.MeasureCellsGroup(Int32 cellsHead, Size referenceSize, Boolean ignoreDesiredSizeU, Boolean forceInfinityV) at System.Windows.Controls.Grid.MeasureOverride(Size constraint) at System.Windows.FrameworkElement.MeasureCore(Size availableSize) at System.Windows.UIElement.Measure(Size availableSize) at System.Windows.Controls.Grid.MeasureOverride(Size constraint) at System.Windows.FrameworkElement.MeasureCore(Size availableSize) at System.Windows.UIElement.Measure(Size availableSize) at MS.Internal.Helper.MeasureElementWithSingleChild(UIElement element, Size constraint) at System.Windows.Controls.ContentPresenter.MeasureOverride(Size constraint) at System.Windows.FrameworkElement.MeasureCore(Size availableSize) at System.Windows.UIElement.Measure(Size availableSize) at System.Windows.Controls.Border.MeasureOverride(Size constraint) at System.Windows.FrameworkElement.MeasureCore(Size availableSize) at System.Windows.UIElement.Measure(Size availableSize) at System.Windows.Controls.Control.MeasureOverride(Size constraint) at System.Windows.FrameworkElement.MeasureCore(Size availableSize) at System.Windows.UIElement.Measure(Size availableSize) at System.Windows.Controls.Grid.MeasureOverride(Size constraint) at System.Windows.FrameworkElement.MeasureCore(Size availableSize) at System.Windows.UIElement.Measure(Size availableSize) at System.Windows.Controls.Grid.MeasureCell(Int32 cell, Boolean forceInfinityV) at System.Windows.Controls.Grid.MeasureCellsGroup(Int32 cellsHead, Size referenceSize, Boolean ignoreDesiredSizeU, Boolean forceInfinityV, Boolean&amp;amp; hasDesiredSizeUChanged) at System.Windows.Controls.Grid.MeasureCellsGroup(Int32 cellsHead, Size referenceSize, Boolean ignoreDesiredSizeU, Boolean forceInfinityV) at System.Windows.Controls.Grid.MeasureOverride(Size constraint) at System.Windows.FrameworkElement.MeasureCore(Size availableSize) at System.Windows.UIElement.Measure(Size availableSize) at MS.Internal.Helper.MeasureElementWithSingleChild(UIElement element, Size constraint) at System.Windows.Controls.ContentPresenter.MeasureOverride(Size constraint) at System.Windows.FrameworkElement.MeasureCore(Size availableSize) at System.Windows.UIElement.Measure(Size availableSize) at System.Windows.Controls.Border.MeasureOverride(Size constraint) at System.Windows.FrameworkElement.MeasureCore(Size availableSize) at System.Windows.UIElement.Measure(Size availableSize) at System.Windows.Controls.Control.MeasureOverride(Size constraint) at System.Windows.FrameworkElement.MeasureCore(Size availableSize) at System.Windows.UIElement.Measure(Size availableSize) at System.Windows.Controls.Grid.MeasureOverride(Size constraint) at System.Windows.FrameworkElement.MeasureCore(Size availableSize) at System.Windows.UIElement.Measure(Size availableSize) at System.Windows.Controls.Grid.MeasureCell(Int32 cell, Boolean forceInfinityV) at System.Windows.Controls.Grid.MeasureCellsGroup(Int32 cellsHead, Size referenceSize, Boolean ignoreDesiredSizeU, Boolean forceInfinityV, Boolean&amp;amp; hasDesiredSizeUChanged) at System.Windows.Controls.Grid.MeasureCellsGroup(Int32 cellsHead, Size referenceSize, Boolean ignoreDesiredSizeU, Boolean forceInfinityV) at System.Windows.Controls.Grid.MeasureOverride(Size constraint) at System.Windows.FrameworkElement.MeasureCore(Size availableSize) at System.Windows.UIElement.Measure(Size availableSize) at MS.Internal.Helper.MeasureElementWithSingleChild(UIElement element, Size constraint) at System.Windows.Controls.ContentPresenter.MeasureOverride(Size constraint) at System.Windows.FrameworkElement.MeasureCore(Size availableSize) at System.Windows.UIElement.Measure(Size availableSize) at System.Windows.Controls.Grid.MeasureOverride(Size constraint) at System.Windows.FrameworkElement.MeasureCore(Size availableSize) at System.Windows.UIElement.Measure(Size availableSize) at System.Windows.Controls.Border.MeasureOverride(Size constraint) at System.Windows.FrameworkElement.MeasureCore(Size availableSize) at System.Windows.UIElement.Measure(Size availableSize) at Demo.PopupRoot.MeasureOverride(Size constraint) at System.Windows.FrameworkElement.MeasureCore(Size availableSize) at System.Windows.UIElement.Measure(Size availableSize) at System.Windows.Documents.AdornerDecorator.MeasureOverride(Size constraint) at System.Windows.FrameworkElement.MeasureCore(Size availableSize) at System.Windows.UIElement.Measure(Size availableSize) at System.Windows.Window.MeasureOverrideHelper(Size constraint) at System.Windows.Window.MeasureOverride(Size availableSize) at System.Windows.FrameworkElement.MeasureCore(Size availableSize) at System.Windows.UIElement.Measure(Size availableSize) at System.Windows.ContextLayoutManager.UpdateLayout() at System.Windows.ContextLayoutManager.UpdateLayoutCallback(Object arg) at System.Windows.Media.MediaContext.InvokeOnRenderCallback.DoWork() at System.Windows.Media.MediaContext.FireInvokeOnRenderCallbacks() at System.Windows.Media.MediaContext.RenderMessageHandlerCore(Object resizedCompositionTarget) at System.Windows.Media.MediaContext.RenderMessageHandler(Object resizedCompositionTarget) at System.Windows.Threading.ExceptionWrapper.InternalRealCall(Delegate callback, Object args, Int32 numArgs) at MS.Internal.Threading.ExceptionFilterHelper.TryCatchWhen(Object source, Delegate method, Object args, Int32 numArgs, Delegate catchHandler)4. System.OutOfMemoryException: Insufficient memory to continue the execution of the program.System.OutOfMemoryException: Insufficient memory to continue the execution of the program. ---&amp;gt; System.OutOfMemoryException: Insufficient memory to continue the execution of the program. at System.Runtime.InteropServices.Marshal.ThrowExceptionForHRInternal(Int32 errorCode, IntPtr errorInfo) at System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(Int32 errorCode, IntPtr errorInfo) at MS.Internal.Text.TextInterface.Native.Util.ConvertHresultToException(Int32 hr) at MS.Internal.Text.TextInterface.TextAnalyzer.GetGlyphs(UInt16* textString, UInt32 textLength, Font font, UInt16 blankGlyphIndex, Boolean isSideways, Boolean isRightToLeft, CultureInfo cultureInfo, DWriteFontFeature[][] features, UInt32[] featureRangeLengths, UInt32 maxGlyphCount, TextFormattingMode textFormattingMode, ItemProps itemProps, UInt16* clusterMap, UInt16* textProps, UInt16* glyphIndices, UInt32* glyphProps, Int32* pfCanGlyphAlone, UInt32&amp;amp; actualGlyphCount) at MS.Internal.TextFormatting.LineServicesCallbacks.GetGlyphsRedefined(IntPtr pols, IntPtr* plsplsruns, Int32* pcchPlsrun, Int32 plsrunCount, Char* pwchText, Int32 cchText, LsTFlow textFlow, UInt16* puGlyphsBuffer, UInt32* piGlyphPropsBuffer, Int32 cgiGlyphBuffers, Int32&amp;amp; fIsGlyphBuffersUsed, UInt16* puClusterMap, UInt16* puCharProperties, Int32* pfCanGlyphAlone, Int32&amp;amp; glyphCount) --- End of inner exception stack trace --- at MS.Internal.TextFormatting.TextMetrics.FullTextLine.FormatLine(FullTextState fullText, Int32 cpFirst, Int32 lineLength, Int32 formatWidth, Int32 finiteFormatWidth, Int32 paragraphWidth, LineFlags lineFlags, FormattedTextSymbols collapsingSymbol) at MS.Internal.TextFormatting.TextFormatterImp.FormatLineInternal(TextSource textSource, Int32 firstCharIndex, Int32 lineLength, Double paragraphWidth, TextParagraphProperties paragraphProperties, TextLineBreak previousLineBreak, TextRunCache textRunCache) at MS.Internal.TextFormatting.TextFormatterImp.FormatLine(TextSource textSource, Int32 firstCharIndex, Double paragraphWidth, TextParagraphProperties paragraphProperties, TextLineBreak previousLineBreak, TextRunCache textRunCache) at MS.Internal.Text.Line.Format(Int32 dcp, Double width, TextParagraphProperties lineProperties, TextLineBreak textLineBreak, TextRunCache textRunCache, Boolean showParagraphEllipsis) at System.Windows.Controls.TextBlock.MeasureOverride(Size constraint) at System.Windows.FrameworkElement.MeasureCore(Size availableSize) at System.Windows.UIElement.Measure(Size availableSize) at System.Windows.ContextLayoutManager.UpdateLayout() at System.Windows.ContextLayoutManager.UpdateLayoutCallback(Object arg) at System.Windows.Media.MediaContext.InvokeOnRenderCallback.DoWork() at System.Windows.Media.MediaContext.FireInvokeOnRenderCallbacks() at System.Windows.Media.MediaContext.RenderMessageHandlerCore(Object resizedCompositionTarget) at System.Windows.Media.MediaContext.RenderMessageHandler(Object resizedCompositionTarget) at System.Windows.Media.MediaContext.Resize(ICompositionTarget resizedCompositionTarget) at System.Windows.Interop.HwndTarget.OnResize() at System.Windows.Interop.HwndTarget.HandleMessage(WindowMessage msg, IntPtr wparam, IntPtr lparam) at System.Windows.Interop.HwndSource.HwndTargetFilterMessage(IntPtr hwnd, Int32 msg, IntPtr wParam, IntPtr lParam, Boolean&amp;amp; handled) at MS.Win32.HwndWrapper.WndProc(IntPtr hwnd, Int32 msg, IntPtr wParam, IntPtr lParam, Boolean&amp;amp; handled) at MS.Win32.HwndSubclass.DispatcherCallbackOperation(Object o) at System.Windows.Threading.ExceptionWrapper.InternalRealCall(Delegate callback, Object args, Int32 numArgs) at MS.Internal.Threading.ExceptionFilterHelper.TryCatchWhen(Object source, Delegate method, Object args, Int32 numArgs, Delegate catchHandler)" }, { "title": "卡诺模型（KANO Model）", "url": "/post/kano-model.html", "categories": "", "tags": "ux", "date": "2018-01-09 17:57:54 +0800", "snippet": "卡诺模型是一种研究影响顾客满意度因素的方法，在软件工程中可以用来辅助做需求分析和优化产品的质量。作为一种方法，卡诺模型将某一种特性的存在程度作为横坐标，越大表示某个功能或特性做得越多，越小则表示做得越少。而纵坐标是用户满意度/认可程度，越高表示用户越喜欢，越低表示用户越讨厌此特性。于是，卡诺模型为不同的特性分成五个类别： 魅力特性：如果产品没有此特性，用户并不关心；而产品拥有此特性时，用户会非常满意。 期望特性：如果产品的此特性做得越多，用户会越满意；而做得越少则越不满意。 必备特性：如果此特性做得很好，用户并不会有什么感觉；但没有此特性用户会非常不满意。 无差异特性：此特性不管做多做少，用户都不会在意。 反向特性：如果产品中有此特性，用户会不满意，做得越多越不满意。产品的稳定性和性能属于“必备特性”，做到极致时用户感知不到我们对产品稳定性所做的努力，但做不好时却会让体验明显下降。参考资料 什么是卡诺KANO模型？ - 知乎 KANO模型 - MBA智库百科 需求分析神器Kano模型 - 简书" }, { "title": "为什么委托的减法（- 或 -=）可能出现非预期的结果？（Delegate Subtraction Has Unpredictable Result）", "url": "/post/delegate-subtraction-has-unpredictable-result.html", "categories": "", "tags": "csharp, dotnet", "date": "2017-12-28 10:03:44 +0800", "snippet": "当我们为一个委托写 -= 的时候，ReSharper 会提示“Delegate Subtraction Has Unpredictable Result”，即“委托的减法可能出现非预期的结果”。然而在写为事件写 -= 的时候却并没有这样的提示。然而这个提示是什么意思呢？为什么会“非预期”？为什么委托会提示而事件不会提示？阅读本文将了解委托的减法。▲ 委托的减法可能出现非预期的结果ReSharper 的官方帮助文档例子和现象从 ReSharper 的提示中，我们可以跳转到官方帮助文档 Code Inspection: Delegate subtractions - Help - ReSharper。官方文档中给出了一个非常典型的 Demo 程序： static void Main(){ Action a = () =&amp;gt; Console.Write(&quot;A&quot;); Action b = () =&amp;gt; Console.Write(&quot;B&quot;); Action c = () =&amp;gt; Console.Write(&quot;C&quot;); Action s = a + b + c + Console.WriteLine; s(); //ABC (s - a)(); //BC (s - b)(); //AC (s - c)(); //AB (s - (a + b))(); //C (s - (b + c))(); //A (s - (a + c))(); //ABC} 关键就在最后一行的输出结果。由于 s 等于 a + b + c，s - (a + c) 却依然输出 ABC，而不是前面例子中就像数学加减法一样的输出。ReSharper 同时还给出另一个例子，说明委托的减法顺序也可能非预期： s = a + b + a;(s - a)(); // AB 它会从尾部减起，而这一点也容易被大家忽视。原理究其原因，ReSharper 官方文档也已说明。因为委托保存了一个调用列表，委托的 a + b，是将 b 的调用列表追加到 a 的调用列表之后；而委托的 a - b 是从 a 的调用列表中移除 b 的调用列表子序列。也就是说，委托的加减其实就是委托调用列表中序列的拼接和子序列的移除。用图来表示这个调用列表的加减过程，可以画成这样。其中 a, b 是委托，x, y, z, w 是调用列表中的每一项。▲ 调用列表的加减其实就是序列的拼接和子序列的移除将委托和事件比较既然 ReSharper 对委托做出了这样的提示，而事件几乎就是委托的封装，那为何事件不给出提示呢？！带着疑问，我将 ReSharper 官方例子中的 s 改成了事件，其他代码完全一样。private static event Action s;static void Main(){ Action a = () =&amp;gt; Console.Write(&quot;A&quot;); Action b = () =&amp;gt; Console.Write(&quot;B&quot;); Action c = () =&amp;gt; Console.Write(&quot;C&quot;); // 这一句注释掉，因为 s 换成了事件，而事件必须定义在类中。 // Action s = a + b + c + Console.WriteLine; s(); //ABC (s - a)(); //BC (s - b)(); //AC (s - c)(); //AB (s - (a + b))(); //C (s - (b + c))(); //A (s - (a + c))(); //ABC}后面用于代表输出结果的注释我依然没改，因为输出结果真的没变！！！也就是说，理论上使用事件并不能帮助减少委托减法带来的结果不确定性。但是——事件是观察者模式的一种实现，从设计上说，事件只作通知之用，不确保顺序，也不保证结果。在这个角度上说，如果依然用事件写出上面 demo 那样的“不可预期”代码，那简直不把事件当事件用。不再用委托减法了吗？至少从设计模式上说，事件里委托减法的的那些非预期就忽略吧，那么没有定义成事件的那些委托呢？我们需要如何处理减法？其实，大可不必太担心，因为大多数场合下我们进行委托加法和减法时，都是用一个包含调用列表的委托与其它只有一个调用节点的委托进行加减，通常结果都是符合预期的，也通常不会对顺序敏感。但是，如果委托的减法是库 API 的一部分，那就需要小心，因为库的使用者可能写出任何一种诡异的代码！这种情况下，换成事件是一个不错的选择。参考资料 Code Inspection: Delegate subtractions - Help - ReSharper events - “Delegate subtraction has unpredictable result” in ReSharper/C#? - Stack Overflow" }, { "title": "使 32 位程序使用大于 2GB 的内存", "url": "/windows/2017/09/12/32bit-application-use-large-memory.html", "categories": "", "tags": "windows", "date": "2017-12-26 09:05:27 +0800", "snippet": "不管在 32 位 Windows 上还是在 64 位 Windows 上，32 位的应用程序都只能使用最大 2GB 的内存，这是我们司空见惯的一个设定。但其实 Windows 提供了一些方法让我们打破这样的设定，使程序使用大于 2GB 的内存。为什么 32 位程序只能使用最大 2GB 内存？32 位寻址空间只有 4GB 大小，于是 32 位应用程序进程最大只能用到 4GB 的内存。然而，除了应用程序本身要用内存，操作系统内核也需要使用。应用程序使用的内存空间分为用户空间和内核空间，每个 32 位程序的用户空间可独享前 2GB 空间（指针值为正数），而内核空间为所有进程共享 2GB 空间（指针值为负数）。所以，32 位应用程序实际能够访问的内存地址空间最多只有 2GB。让 32 位程序使用大于 2GB 内存的三种方法推荐：dotnetCampus.LargeAddressAware 库详见：为 .NET Core / Framework 程序开启大内存感知（LargeAddressAware），使 32 位程序支持最多 4GB 的用户空间内存editbin这是 Visual Studio 2017 采用的做法。我们需要使用到两个工具——editbin 和 dumpbin。前者用于编辑我们编译生成好的程序使之头信息中声明支持大于 2GB 内存，后者用于查看程序的头信息验证我们是否改好了。编辑一个程序使之声明支持大于 2GB 内存的命令是：editbin /largeaddressaware xxx.exe其中，xxx.exe 是我们准备修改的程序，可以使用相对路径或绝对路径（如果路径中出现空格记得带引号）。验证这个程序是否改好了的命令是：dumpbin /headers xxx.exe | more同样，xxx.exe 是我们刚刚改好准备检查的程序，可以使用相对路径或绝对路径。editbin 改之前和改之后用 dumpbin 查看我们的程序头信息，得到下面两张图：注意到 FILE HEADER VALUES 块的倒数第二行多出了 Application can handle large (&amp;gt;2GB) addresses。如果没发现，一定是你命令执行中发生了错误，检查一下吧！最容易出现的错误是执行后发现根本就没有这个命令。是的，editbin 命令从哪里来呢？可以在开始菜单中的 Visual Studio 文件夹中查找 Developer Command Prompt for VS 2017，运行这个启动的命令行中就带有 editbin 和 dumpbin。如果希望能够在 Visual Studio 编译的时候自动调用这个工具，请参见：LargeAddressAware Visual Studio 2015 C#。编译成 AnyCPU (Prefer 32-bit)这是本文更推荐的做法，也是最简单的做法。方法是打开入口程序集的属性页，将“目标平台”选为“AnyCPU”，然后勾选“首选 32 位”。需要注意的是，这种生成方式是 .NET Framework 4.5 及以上版本才提供的。至于 AnyCPU (Prefer 32-bit) 和 x86 两种生成方式的区别，请参见：WPF 编译为 AnyCPU 和 x86 有什么区别 - 林德熙 和 What is the purpose of the “Prefer 32-bit” setting in Visual Studio 2012 and how does it actually work?。声明支持大于 2GB 内存后，能使用多少内存？对于 32 位操作系统，程序依然只能使用 2GB 内存，除非开启了 /3GB 开关，开启方法详见：/3GB。开启后，应用程序的用户态将可以使用 3GB 内存，但内核态将只能使用 1GB 内存。微软认为，是否打开 /3GB 开关是计算机设备开发商需要做的事情，开发商也需要自己测试开启后驱动程序的性能表现和稳定性。对于 64 位操作系统，Windows 将很豪放地将 4GB 全部贡献给这样的程序，因为系统自己已经有更多的内存寻址空间可以使用了，没必要跟 32 位应用程序抢占寻址空间。参考资料 AnyCPU (32bit preferred) What is the purpose of the “Prefer 32-bit” setting in Visual Studio 2012 and how does it actually work? WPF 编译为 AnyCPU 和 x86 有什么区别 - 林德熙 IMAGE_FILE_LARGE_ADDRESS_AWARE Memory Limits for Windows and Windows Server Releases Getting 32-bit application to use more than 2GB on 64-bit Windows 7? /LARGEADDRESSAWARE (Handle Large Addresses) Why 2 GB memory limit when running in 64 bit Windows? Pushing the Limits of Windows: Paged and Nonpaged Pool Can a 32bit process access more memory on a 64bit windows OS? /3GB /3GB editbin/dumpbin editbin /largeaddressaware xxx.exe dumpbin /headers xxx.exe | more verify if largeAddressAware is in effect? LargeAddressAware Visual Studio 2015 C# " }, { "title": "让 ScrollViewer 的滚动带上动画", "url": "/post/scrollviewer-animation.html", "categories": "", "tags": "wpf", "date": "2017-12-19 20:19:41 +0800", "snippet": "WPF 的 ScrollViewer 没有水平滚动和垂直滚动的属性 HorizontalScrollOffset VerticalScrollOffset，只有水平滚动和垂直滚动的方法 ScrollToHorizontalOffset ScrollToVerticalOffset，那么怎么给滚动过程加上动画呢？既然没有属性，那我们加个属性好了，反正附加属性就是用来干这个事儿的。namespace Walterlv{ public static class ScrollViewerBehavior { public static readonly DependencyProperty HorizontalOffsetProperty = DependencyProperty.RegisterAttached(&quot;HorizontalOffset&quot;, typeof(double), typeof(ScrollViewerBehavior), new UIPropertyMetadata(0.0, OnHorizontalOffsetChanged)); public static void SetHorizontalOffset(FrameworkElement target, double value) =&amp;gt; target.SetValue(HorizontalOffsetProperty, value); public static double GetHorizontalOffset(FrameworkElement target) =&amp;gt; (double)target.GetValue(HorizontalOffsetProperty); private static void OnHorizontalOffsetChanged(DependencyObject target, DependencyPropertyChangedEventArgs e) =&amp;gt; (target as ScrollViewer)?.ScrollToHorizontalOffset((double)e.NewValue); public static readonly DependencyProperty VerticalOffsetProperty = DependencyProperty.RegisterAttached(&quot;VerticalOffset&quot;, typeof(double), typeof(ScrollViewerBehavior), new UIPropertyMetadata(0.0, OnVerticalOffsetChanged)); public static void SetVerticalOffset(FrameworkElement target, double value) =&amp;gt; target.SetValue(VerticalOffsetProperty, value); public static double GetVerticalOffset(FrameworkElement target) =&amp;gt; (double)target.GetValue(VerticalOffsetProperty); private static void OnVerticalOffsetChanged(DependencyObject target, DependencyPropertyChangedEventArgs e) =&amp;gt; (target as ScrollViewer)?.ScrollToVerticalOffset((double)e.NewValue); }}我们在属性的变更通知中调用了 ScrollToHorizontalOffset 和 ScrollToVerticalOffset 方法。这样，便能够通过动画改变属性的方式来调用这两个方法。那么现在我们就加上动画：&amp;lt;Storyboard x:Key=&quot;ScrollStoryboard&quot;&amp;gt; &amp;lt;DoubleAnimation Storyboard.TargetName=&quot;ScrollViewer&quot; Storyboard.TargetProperty=&quot;(walterlv:ScrollViewerBehavior.HorizontalOffset)&quot; From=&quot;0&quot; To=&quot;500&quot; Duration=&quot;0:0:0.6&quot;&amp;gt; &amp;lt;DoubleAnimation.EasingFunction&amp;gt; &amp;lt;CircleEase EasingMode=&quot;EaseOut&quot;/&amp;gt; &amp;lt;/DoubleAnimation.EasingFunction&amp;gt; &amp;lt;/DoubleAnimation&amp;gt;&amp;lt;/Storyboard&amp;gt;添加一些用于测试的按钮和 ScrollViewer：&amp;lt;ScrollViewer Grid.Row=&quot;0&quot; Grid.RowSpan=&quot;2&quot; Grid.Column=&quot;0&quot; Grid.ColumnSpan=&quot;3&quot; x:Name=&quot;ScrollViewer&quot; HorizontalScrollBarVisibility=&quot;Visible&quot; VerticalScrollBarVisibility=&quot;Visible&quot;&amp;gt; &amp;lt;Image Source=&quot;https://walterlv.github.io/static/posts/2017-12-09-21-19-50.png&quot; Width=&quot;1000&quot;/&amp;gt;&amp;lt;/ScrollViewer&amp;gt; &amp;lt;Button Grid.Row=&quot;1&quot; Grid.Column=&quot;0&quot; Grid.ColumnSpan=&quot;3&quot; x:Name=&quot;ConnectionDestination&quot; VerticalAlignment=&quot;Bottom&quot; Height=&quot;50&quot; Content=&quot;动画目标&quot; Panel.ZIndex=&quot;1&quot;&amp;gt; &amp;lt;Button.Triggers&amp;gt; &amp;lt;EventTrigger RoutedEvent=&quot;Button.Click&quot;&amp;gt; &amp;lt;BeginStoryboard Storyboard=&quot;{StaticResource ScrollStoryboard}&quot;/&amp;gt; &amp;lt;/EventTrigger&amp;gt; &amp;lt;/Button.Triggers&amp;gt;&amp;lt;/Button&amp;gt;现在，我们点击按钮，就可以看到 ScrollViewer 的滚动动画生效了，如下：额外的，如果希望这个附加属性能够附加到 ListView 或者 ListBox 中，则需要修改 ScrollViewerBehavior 类，然后在 OnHorizontalOffsetChanged 和 OnVerticalOffsetChanged 方法中判断 ListView 和 ListBox，然后在其中寻找可视元素子级 ScrollViewer。" }, { "title": "真的要比较 for 和 foreach 的性能吗？（内附性能比较的实测数据）", "url": "/post/for-vs-foreach.html", "categories": "", "tags": "csharp, dotnet", "date": "2017-12-07 23:30:35 +0800", "snippet": "小伙伴告诉我，List&amp;lt;T&amp;gt;.Find 方法比 List.FirstOrDefault 扩展方法性能更高，详见：C＃ Find vs FirstOrDefault - 林德熙。这可让我震惊了，因为我从来都没有考虑过在如此微观尺度衡量它们的性能差异。少不了的源码于是，我立刻翻开了 Find 和 FirstOrDefault 的源代码：public T Find(Predicate&amp;lt;T&amp;gt; match) { if( match == null) { ThrowHelper.ThrowArgumentNullException(ExceptionArgument.match); } Contract.EndContractBlock(); for(int i = 0 ; i &amp;lt; _size; i++) { if(match(_items[i])) { return _items[i]; } } return default(T);}public static TSource FirstOrDefault&amp;lt;TSource&amp;gt;(this IEnumerable&amp;lt;TSource&amp;gt; source, Func&amp;lt;TSource, bool&amp;gt; predicate) { if (source == null) throw Error.ArgumentNull(&quot;source&quot;); if (predicate == null) throw Error.ArgumentNull(&quot;predicate&quot;); foreach (TSource element in source) { if (predicate(element)) return element; } return default(TSource);}这难道不是在 PK for 和 foreach 吗？接下来的分析才发现，没这么简单。Find V.S. FirstOrDefault我写了两段代码，然后在单元测试中测量它们的性能。方法我按不同顺序写了两遍，试图降低初始化影响和偶然事件的影响。[TestClass]public class FindAndFirstOrDefaultTest{ public FindAndFirstOrDefaultTest() { _testTarget = new List&amp;lt;int&amp;gt;(count); for (var i = 0; i &amp;lt; count; i++) { _testTarget.Add(i); } } private const int count = 100; private readonly List&amp;lt;int&amp;gt; _testTarget; [TestMethod] public void _A0_Find() { _testTarget.Find(x =&amp;gt; x &amp;gt; count - 1); } [TestMethod] public void _A1_FirstOrDefault() { _testTarget.FirstOrDefault(x =&amp;gt; x &amp;gt; count - 1); } [TestMethod] public void _B0_FirstOrDefault2() { _testTarget.FirstOrDefault(x =&amp;gt; x &amp;gt; count - 1); } [TestMethod] public void _B1_Find2() { _testTarget.Find(x =&amp;gt; x &amp;gt; count - 1); }} 100 长度的 List&amp;lt;int&amp;gt;，其性能数据如下：很明显，数据量太少不好测量，也收到单元测试本身的影响。我们需要增大数据量，以减少那些因素的影响。居然真的存在性能差异！！！而且，Find 是 FirstOrDefault 性能的两倍！！！这似乎能够解释，因为 foreach 毕竟还要生成 IEnumerator 对象，还要有方法调用；而 for 却只有 List&amp;lt;T&amp;gt; 集合的访问。然而，这真的只是 for 和 foreach 之间的性能差异吗？for V.S. foreach为了看看其性能差异来自于 for 和 foreach，我把 Find 和 FirstOrDefault 的调用修改为 for 和 foreach：[TestClass]public class ForAndForeachTest{ public ForAndForeachTest() { _testTarget = new List&amp;lt;int&amp;gt;(count); for (var i = 0; i &amp;lt; count; i++) _testTarget.Add(i); } private const int count = 100; private readonly List&amp;lt;int&amp;gt; _testTarget; [TestMethod] public void _A0_Find() { for (var i = 0; i &amp;lt; count; i++) { var target = _testTarget[i]; if (target &amp;gt; count - 1) return; } } [TestMethod] public void _A1_FirstOrDefault() { foreach (var target in _testTarget) { if (target &amp;gt; count - 1) return; } } [TestMethod] public void _B0_FirstOrDefault2() { for (var i = 0; i &amp;lt; count; i++) { var target = _testTarget[i]; if (target &amp;gt; count - 1) return; } } [TestMethod] public void _B1_Find2() { foreach (var target in _testTarget) { if (target &amp;gt; count - 1) return; } }}一样，100 长度的 List&amp;lt;int&amp;gt; 并没有参考性：50000000 长度的则可以减少影响：然而结论居然是——for 比 foreach 有“轻微”的性能优势！这与 Find 和 FirstOrDefault 两倍的性能差异就小多了。是什么原因造成了如此的性能差异呢？轻微的性能优势，还是两倍的性能优势？为了了解原因，我将 Find 和 FirstOrDefault 中的方法写到测试里面：private int For(Predicate&amp;lt;int&amp;gt; match){ for (var i = 0; i &amp;lt; count; i++) { if (match(_testTarget[i])) return _testTarget[i]; } return default(int);}private int ForEach(Func&amp;lt;int, bool&amp;gt; predicate){ foreach (var element in _testTarget) { if (predicate(element)) return element; } return default(int);}为了能够不让数据超过 1 秒导致单元测试计时精度降低，我将长度减小到了 40000000。▲ 调用 For 和 Foreach性能相比于直接写 for 和 foreach 有轻微的损失，但是调用 For 和调用 Foreach 却并没有两倍的性能差异，虽然方法的实现与 Find 和 FirstOrDefault 几乎一模一样！而且，相同数量的 List&amp;lt;int&amp;gt;，调用 Find 居然比自己写的 For 更快，调用 FirstOrDefault 却比自己写的 Foreach 更慢：▲ 调用 Find 和 FirstOrDefault我写的 For 和 Find 中一定还存在着哪里不一样——对，是索引器！以下是 List&amp;lt;T&amp;gt; 索引器的源码：public T this[int index] { get { // Following trick can reduce the range check by one if ((uint) index &amp;gt;= (uint)_size) { ThrowHelper.ThrowArgumentOutOfRangeException(); } Contract.EndContractBlock(); return _items[index]; } set { if ((uint) index &amp;gt;= (uint)_size) { ThrowHelper.ThrowArgumentOutOfRangeException(); } Contract.EndContractBlock(); _items[index] = value; _version++; }}我的 For 内部索引访问相比于 Find 内部索引访问多了数组越界判断，同时还可能存在 JIT 的特别优化。如果要验证这个问题，我就需要比较数组了。List V.S. Array改写我们的测试代码，这回的 For 方法有两个重载，一个列表一个数组。private int For(List&amp;lt;int&amp;gt; list, Predicate&amp;lt;int&amp;gt; match){ for (var i = 0; i &amp;lt; count; i++) { if (match(list[i])) return list[i]; } return default(int);}private int For(int[] array, Predicate&amp;lt;int&amp;gt; match){ for (var i = 0; i &amp;lt; count; i++) { if (match(array[i])) return array[i]; } return default(int);}[TestMethod]public void _A0_List(){ For(_testTarget, x =&amp;gt; x &amp;gt; count - 1);}[TestMethod]public void _A1_Array(){ For(_testArray, x =&amp;gt; x &amp;gt; count - 1);}[TestMethod]public void _B0_Array(){ For(_testArray, x =&amp;gt; x &amp;gt; count - 1);}[TestMethod]public void _B1_List(){ For(_testTarget, x =&amp;gt; x &amp;gt; count - 1);}同样的数据量：可以发现，即便是数组，其性能也赶不上原生的 Find。只有现象，却没有结论参考资料 C＃ Find vs FirstOrDefault - 林德熙 c# - In .NET, which loop runs faster, ‘for’ or ‘foreach’? - Stack Overflow An easy and efficient way to improve .NET code performances - Patrick Smacchia C# For Versus Foreach Performance - Dot Net Perls" }, { "title": "当我们使用 MVVM 模式时，我们究竟在每一层里做些什么？", "url": "/post/mvvm-do-and-dont.html", "categories": "", "tags": "windows, wpf, uwp", "date": "2017-11-30 01:29:14 +0800", "snippet": "这篇文章不会说 MVVM 是什么，因为讲这个的文章太多了；也不会说 MVVM 的好处，因为这样的文章也是一搜一大把。我只是想说说我们究竟应该如何理解 M-V-VM，当我们真正开始写代码时，应该在里面的每一层里写些什么。MVVM，当然三层——M-V-VM。就凭这个“三层”结构，WPF/UWP 开发者们就能折腾出一个完整的程序出来。M——定义数据模型啊，V——视图啊，VM——视图模型。其中 M 和 V 的中文词语和英文单词是很好理解的，但是 VM 就不是个日常用词；于是各种不知道应该放在哪里的代码便一窝蜂全放进了 VM 中，最终导致了 VM 的无限膨胀，成百上千行也是司空见惯啊！可是，若 VM 不膨胀，那让 M 或者 V 膨胀吗？当然不是，谁都不要膨胀！于是那么多的代码写到哪里呢？答案：MVVM 之外。我们的代码不止 MVVM 三层MVVM 不是应用程序架构，只是一个 GUI 类程序的开发模式而已。这意味着它只是用来解决我们应用程序中 GUI 部分的开发问题，并不能用来解决其他问题。而一个能持续发展的程序怎么能只有 GUI 呢？ MVVM 只是数据驱动型 GUI 程序建议的开发模式；无论是三层中的哪一层，本质上都是在解决 UI 问题。而非 UI 问题根本就不在 MVVM 的讨论之列。不知看到这里时你会不会喷我一脸——“V”解决 UI 问题也就算了，“VM”和“M”算什么 UI！VM，视图模型。其本质是模型。什么的模型？“视图”的模型。这是为真实的 UI 做的一层抽象模型。也就是说，VM 其实是“抽象的 UI”。接着喷——“V”和“VM”解决 UI 问题也就算了，“M”算什么 UI！M，数据模型。作为数据驱动型 GUI 程序，这些数据是用于驱动 UI 的数据；比如网络请求的数据，本地文件储存的数据。定义这些数据模型是为了与其他组件、其他程序、其他设备传递数据，并将这些数据为视图模型所用。那些不驱动 UI 的数据根本不在此谈论之列。如果你觉得这样的解释有些牵强，那我也无话可说；但是当我们将它理解成“驱动 UI 的数据”时，我们将能够更容易地组织我们的代码，使之不容易发生混乱。MVVM 模式按此理解后，我们将更能够将代码放到合适的位置，避免 VM 代码的膨胀： 公共的控件或者辅助代码应该抽出来放到别处，比如形成公共组件 一些非 UI 的业务功能单独做，独立于 MVVM 模式，对 VM 提供调用接口即可。MVVM，应该做什么，不应该做什么这一节内容部分参考自：MVVM standardization - W3Cgeek。View 想进行测试的逻辑都不要放到这里 不止能是 Window/Page/UserControl，还能是 Control/DataTemplate 可以考虑使用 DataTrigger、ValueConverter、VisualState 或者 Blend 中提供的 Behivor 机制来处理 ViewModel 对应的 UI 展现方式 ViewModel 这里需要保持抽象 UI 的状态，这样才可以在据此 ViewModel 创建多个 View 的时候，这些 View 能够完全一致而不用把此前逻辑再跑一边 无论如何都不能引用 View，就算是接口也不行 注意不要去调用一些单例类或者带状态的静态类，这样才好进行单元测试 Model 那些通过各种途径搜罗来的数据 不能引用 View，也不能引用 ViewModel View 通知 ViewModel 推荐用数据绑定 尽量不要直接调用 ViewModel，但必要的时候也可以去调用 ViewModel 通知 View 属性绑定 事件通知 消息（比如 EventAggregator/Message/RX 框架） 通过中间服务调用 直接由 View 传入一个委托，ViewModel 去调用那个委托 参考资料 Recommendations and best practices for implementing MVVM and XAML/.NET applications « Rico Suter MVVM standardization - W3Cgeek" }, { "title": "极限压缩 PNG", "url": "/post/limit-png.html", "categories": "", "tags": "windows", "date": "2017-11-29 20:17:21 +0800", "snippet": "为了让博客的访问者有更快的访问速度，同时兼顾显示效果，我们有些选择却不多——比如选用 WebP 格式。但考虑到浏览器兼容性问题，有时不得不考虑依然 PNG。这里我找到一款极限 PNG 压缩工具——LimitPNG。limitPNG - PNG 图片极限压缩工具这是 nullice · 不知语冰 的软件。在极限压缩的时候，压缩一张 PNG 的耗时真的很长，几分钟算是很理想的状态了。部分图片压缩比依然不够大，不过如果愿意丢失一点点精度，可以换取非常大的压缩比提升。考虑到大量图片批量压缩，作者又做了另外一款软件：gluttonyPNG – 大批量 PNG 图片压缩工具于是，应该能应付日常各种需要极限压缩的场景了。" }, { "title": "自定义 Windows PowerShell 和 cmd 的字体", "url": "/post/customize-fonts-of-command-window.html", "categories": "", "tags": "windows, powershell", "date": "2017-11-23 00:26:13 +0800", "snippet": "Windows 系统下的命令行界面，字体要么是点阵字体，要么是宋体；但无论哪种，始终觉得难看了。然而，字体选择界面却始终没办法选择到我们新安装的各种字体。本文将推荐一款可以为 PowerShell 和 cmd 使用的等宽字体，适合程序员使用。对字体要求当然，安装了 git 后，会自动帮我们安装 mintty，bash 风格，自定义方便，着色也很棒。如果可能，我还是更希望用 mintty。可是，总有免不了要用 cmd 的时候，或者虽然强大但很丑的 PowerShell……▲ 很丑的 cmd微软说，cmd 和 PowerShell 对字体的要求非常苛刻，在 Necessary criteria for fonts to be available in a command window 一文种就有说到： The fonts must meet the following criteria to be available in a command session window: The font must be a fixed-pitch font. The font cannot be an italic font. The font cannot have a negative A or C space. If it is a TrueType font, it must be FF_MODERN. If it is not a TrueType font, it must be OEM_CHARSET.Additional criteria for Asian installations: If it is not a TrueType font, the face name must be “Terminal.” If it is an Asian TrueType font, it must also be an Asian character set. 翻译过来是： 要能在命令行种使用，字体必须满足： 必须是等宽字体 不能是斜体 该字体不能有A或C负空间 如果是 TrueType 字体，则它必须是 FF_MODERN 如果不是 TrueType 字体，则它必须是 OEM_CHARSET如果是给亚洲地区使用，还必须满足这些条件： 如果不是 TrueType 字体，字体名必须是“Terminal” 如果是亚洲的 TrueType 字体，还必须使用亚洲的字符集。 这还真不是一般字体能够满足的……推荐可用的字体我找了好几款字体，然而只发现下面两款字体是真正可以在 PowerShell 或 cmd 里面用的： Inziu Iosevka作者：Belleve - 微软字体设计师，新中文字体主催 Microsoft YaHei Mono on GitHub微软为 WSL/Bash on Ubuntu on Windows 设计的字体，PowerShell 和 cmd 也能用效果相当于微软雅黑和 Consolas 的混搭然而发现能用的都出自微软之手……Inziu 字体族较多，实测有些有效有些无效：所以，我更倾向于推荐 Microsoft YaHei Mono，效果如下图：▲ PowerShell▲ cmd控制台字体设置方法对于上面推荐的两款字体，直接安装就可以了，下次打开 PowerShell 或者 cmd 时，属性界面里面就可以找到新安装的字体，就可以选择了。▲ 属性▲ 选择字体参考资料 Necessary criteria for fonts to be available in a command window 为什么 Windows 下 cmd 和 PowerShell 不能方便地自定义字体？ - 知乎 HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Console\\TrueTypeFont List of all colors available for powershell? - Stack Overflow" }, { "title": "从 Matrix 解构出 Translate/Scale/Rotate（平移/缩放/旋转）", "url": "/post/extract-translation-scaling-rotation-from-matrix.html", "categories": "", "tags": "xaml, wpf, uwp", "date": "2017-11-22 21:24:08 +0800", "snippet": "在 XAML 中，我们对一个 UIElement 进行一个 RenderTransform 是再常见不过的事情了，我们可以从众多叠加的 TransformGroup 瞬间得到一个 Matrix 表示整个变换的综合变换矩阵，然而反过来却不好做——从变换矩阵中反向得到变换分量。首先明确的是，各种 TranslateTransform、ScaleTransform、RotateTransform 到 Matrix 具有唯一确定的解，然而反向转换却是有无穷多个解的。于是如果我们要得到一个解，我们需要给定一个条件，然后得到这个条件下的其中一个解。准备工作为了写出一个通用的变换方法来，我准备了一个测试控件，并为它随意填写一个变换：&amp;lt;Border x:Name=&quot;DisplayShape&quot; Background=&quot;#FF1B6CB0&quot; Width=&quot;200&quot; Height=&quot;100&quot;&amp;gt; &amp;lt;UIElement.RenderTransform&amp;gt; &amp;lt;TransformGroup&amp;gt; &amp;lt;ScaleTransform ScaleX=&quot;0.8&quot; ScaleY=&quot;2&quot;/&amp;gt; &amp;lt;SkewTransform/&amp;gt; &amp;lt;RotateTransform Angle=&quot;-48.366&quot;/&amp;gt; &amp;lt;TranslateTransform x:Name=&quot;TranslateTransform&quot; X=&quot;85&quot; Y=&quot;160&quot;/&amp;gt; &amp;lt;/TransformGroup&amp;gt; &amp;lt;/UIElement.RenderTransform&amp;gt; &amp;lt;TextBlock Foreground=&quot;{media:LuminanceForeground TargetName=DisplayShape}&quot; Text=&quot;walterlv&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;/&amp;gt;&amp;lt;/Border&amp;gt;▲ LuminanceForeground 的作用可参见我的另一篇文章：计算能在任何背景色上清晰显示的前景色▲ 一个随便应用了一个变换的控件我们将从这个控件中取得变换矩阵 Matrix，然后计算出变换分量的一个解，应用到新的控件上：&amp;lt;Rectangle x:Name=&quot;TraceShape&quot; Width=&quot;200&quot; Height=&quot;100&quot; Stroke=&quot;#FFE2620A&quot; StrokeThickness=&quot;4&quot;/&amp;gt;▲ 我们希望计算一组变换分量以便让这个框追踪变换了的控件于是，我们写下了测试代码：private void OnLoaded(object sender, RoutedEventArgs args){ var matrix = DisplayShape.RenderTransform.Value; var (scaling, rotation, translation) = ExtractMatrix(matrix); var group = new TransformGroup(); group.Children.Add(new ScaleTransform {ScaleX = scaling.X, ScaleY = scaling.Y}); group.Children.Add(new RotateTransform {Angle = rotation}); group.Children.Add(new TranslateTransform {X = translation.X, Y = translation.Y}); TraceShape.RenderTransform = group;}private (Vector Scaling, double Rotation, Vector Translation) ExtractMatrix(Matrix matrix){ // 我们希望在这里写出一个方法，以便得到三个变换分量。}OnLoaded 是为了让代码运行起来，而 ExtractMatrix 才是我们的核心——将变换分量解构出来。思路和初步成果我们的思路是创造一个单位矩形，让它应用这个变换，然后测量变换后矩形的宽高变化，角度变化和位置变化。由于直接使用 Rect 类型时无法表示旋转后的矩形，所以我们直接使用四个顶点来计算，于是我们写出如下代码：private (Vector Scaling, double Rotation, Vector Translation) ExtractMatrix(Matrix matrix){ var unitPoints = new[] {new Point(0, 0), new Point(1, 0), new Point(1, 1), new Point(0, 1)}; var transformedPoints = unitPoints.Select(matrix.Transform).ToArray(); var scaling = new Vector( (transformedPoints[1] - transformedPoints[0]).Length, (transformedPoints[3] - transformedPoints[0]).Length); var rotation = Vector.AngleBetween(new Vector(1, 0), transformedPoints[1] - transformedPoints[0]); var translation = transformedPoints[0] - unitPoints[0]; return (scaling, rotation, translation);}运行后，我们发现追踪框已经与原始控件完全贴合，说明计算正确。▲ 追踪框完全贴合可以灵活应用计算结果不过如果真要在产品中做追踪框，肯定不能像上图那样被严重拉伸。所以，我们把缩放分量去掉，换成尺寸变化：private void OnLoaded(object sender, RoutedEventArgs args){ var matrix = DisplayShape.RenderTransform.Value; var (scaling, rotation, translation) = ExtractMatrix(matrix); var group = new TransformGroup(); TraceShape.Width = DisplayShape.ActualWidth * scaling.X; TraceShape.Height = DisplayShape.ActualHeight * scaling.Y; group.Children.Add(new RotateTransform {Angle = rotation}); group.Children.Add(new TranslateTransform {X = translation.X, Y = translation.Y}); TraceShape.RenderTransform = group;}以上代码中，ScaleTransform 已经被去掉，取而代之的是宽高的设置。▲ 没有被拉伸的追踪框更通用的方法以上虽然达到了目的，不过实际应用中可能会有更多的限制，例如： 变换中心不是 (0, 0) 最终应用的顺序不是 Scale-&amp;gt;Rotate-&amp;gt;Translate首先来解决变换中心的通用性问题。我们将变换中心设为 (0.5, 0.5)：&amp;lt;Rectangle x:Name=&quot;TraceShape&quot; Width=&quot;200&quot; Height=&quot;100&quot; Stroke=&quot;#FFE2620A&quot; StrokeThickness=&quot;4&quot; RenderTransformOrigin=&quot;0.5 0.5&quot;/&amp;gt;于是，追踪框不知道飞到哪里去了……▲ 改变了变换中心这时，我们需要将变换中心导致的额外平移量考虑在内。如果 S 表示所求变换的缩放分量，R 表示所求变换的旋转分量，T 表示所求变换的平移分量；M 表示需要模拟的目标矩阵。那么，S 将可以通过缩放比和参数指定的缩放中心唯一确定；R 将可以通过旋转角度和参数指定的旋转中心唯一确定；T 不能确定，是我们要求的。由于我们按照缩放-&amp;gt;旋转-&amp;gt;平移的顺序模拟 M，所以：\\[SRT=M\\]即：\\[T=S^{-1}R^{-1}M\\]所以，我们在上面的之前成果的代码上再做些额外的处理，加上以上公式的推导结果：public static (Vector Scaling, double Rotation, Vector Translation) MatrixToGroup(Matrix matrix, CenterSpecification specifyCenter = null){ // 生成一个单位矩形（0, 0, 1, 1），计算单位矩形经矩阵变换后形成的带旋转的矩形。 // 于是，我们将可以通过比较这两个矩形中点的数据来求出一个解。 var unitPoints = new[] {new Point(0, 0), new Point(1, 0), new Point(1, 1), new Point(0, 1)}; var transformedPoints = unitPoints.Select(matrix.Transform).ToArray(); // 测试单位矩形宽高的长度变化量，以求出缩放比（作为参数 specifyCenter 中变换中心的计算参考）。 var scaling = new Vector((transformedPoints[1] - transformedPoints[0]).Length, (transformedPoints[3] - transformedPoints[0]).Length); // 测试单位向量的旋转变化量，以求出旋转角度。 var rotation = Vector.AngleBetween(new Vector(1, 0), transformedPoints[1] - transformedPoints[0]); var translation = transformedPoints[0] - unitPoints[0]; // 如果指定了变换分量的变换中心点。 if (specifyCenter != null) { // 那么，就获取指定的变换中心点（缩放中心和旋转中心）。 var (scalingCenter, rotationCenter) = specifyCenter(scaling); // 如果 S 表示所求变换的缩放分量，R 表示所求变换的旋转分量，T 表示所求变换的平移分量；M 表示传入的目标矩阵。 // 那么，S 将可以通过缩放比和参数指定的缩放中心唯一确定；R 将可以通过旋转角度和参数指定的旋转中心唯一确定。 // S = scaleMatrix; R = rotateMatrix. var scaleMatrix = Matrix.Identity; scaleMatrix.ScaleAt(scaling.X, scaling.Y, scalingCenter.X, scalingCenter.Y); var rotateMatrix = Matrix.Identity; rotateMatrix.RotateAt(rotation, rotationCenter.X, rotationCenter.Y); // T 是不确定的，它会受到 S 和 T 的影响；但确定等式 SRT=M，即 T=S^{-1}R^{-1}M。 // T = translateMatrix; M = matrix. scaleMatrix.Invert(); rotateMatrix.Invert(); var translateMatrix = Matrix.Multiply(rotateMatrix, scaleMatrix); translateMatrix = Matrix.Multiply(translateMatrix, matrix); // 用考虑了变换中心的平移量覆盖总的平移分量。 translation = new Vector(translateMatrix.OffsetX, translateMatrix.OffsetY); } // 按缩放、旋转、平移来返回变换分量。 return (scaling, rotation, translation);}本来第二个参数是可以用 Func 的，但那样的意义解释起来太费劲，所以改成了委托的定义：/// &amp;lt;summary&amp;gt;/// 为 &amp;lt;see cref=&quot;MatrixToGroup&quot;/&amp;gt; 方法提供变换中心的指定方法。/// &amp;lt;/summary&amp;gt;/// &amp;lt;param name=&quot;scalingFactor&quot;&amp;gt;先进行缩放后进行旋转时，旋转中心的计算可能需要考虑前面缩放后的坐标。此参数可以得知缩放比。&amp;lt;/param&amp;gt;/// &amp;lt;returns&amp;gt;绝对坐标的缩放中心和旋转中心。&amp;lt;/returns&amp;gt;public delegate (Point ScalingCenter, Point RotationCenter) CenterSpecification(Vector scalingFactor);这时我们就可以得到我们想要的 TransformGroup，而且 RenderTransformOrigin 随便设：private void OnLoaded(object sender, RoutedEventArgs args){ var matrix = DisplayShape.RenderTransform.Value; var (scaling, rotation, translation) = TransformMatrix.MatrixToGroup(matrix, scalingFactor =&amp;gt; (new Point(), new Point( DisplayShape.ActualWidth * scalingFactor.X / 2, DisplayShape.ActualHeight * scalingFactor.Y / 2))); TraceShape.RenderTransform = ScaleAtZeroRotateAtCenter(scaling, rotation, translation, DisplayShape.RenderSize, TraceShape.RenderTransformOrigin);}public static TransformGroup ScaleAtZeroRotateAtCenter(Vector scaling, double rotation, Vector translation, Size originalSize, Point renderTransformOrigin = default(Point)){ var group = new TransformGroup(); var scaleTransform = new ScaleTransform { ScaleX = scaling.X, ScaleY = scaling.Y, CenterX = -originalSize.Width * renderTransformOrigin.X, CenterY = -originalSize.Height * renderTransformOrigin.Y, }; var rotateTransform = new RotateTransform { Angle = rotation, CenterX = originalSize.Width * (scaling.X / 2 - renderTransformOrigin.X), CenterY = originalSize.Height * (scaling.Y / 2 - renderTransformOrigin.Y), }; group.Children.Add(scaleTransform); group.Children.Add(rotateTransform); group.Children.Add(new TranslateTransform {X = translation.X, Y = translation.Y}); return group;}考虑到前面可以灵活地运用得到的变换分量，我们现在也这么用：private void OnLoaded(object sender, RoutedEventArgs args){ var matrix = DisplayShape.RenderTransform.Value; var (scaling, rotation, translation) = TransformMatrix.MatrixToGroup(matrix, scalingFactor =&amp;gt; (new Point(), new Point( DisplayShape.ActualWidth * scalingFactor.X / 2, DisplayShape.ActualHeight * scalingFactor.Y / 2))); TraceShape.Width = DisplayShape.ActualWidth * scaling.X; TraceShape.Height = DisplayShape.ActualHeight * scaling.Y; TraceShape.RenderTransform = NoScaleButRotateAtOrigin( rotation, translation, DisplayShape.RenderSize);}public static TransformGroup NoScaleButRotateAtOrigin(double rotation, Vector translation, Size originalSize){ var group = new TransformGroup(); group.Children.Add(new RotateTransform {Angle = rotation}); group.Children.Add(new TranslateTransform {X = translation.X, Y = translation.Y}); return group;}我们的 RenderTransformOrigin 是随意设的，效果也像下图一样稳定可用。为了直观，我把两种用法放到了一起比较：▲ 设置了 RenderTransformOrigin 依然有用" }, { "title": "用动画的方式画出任意的路径（直线、曲线、折现）", "url": "/post/draw-path-animatedly.html", "categories": "", "tags": "xaml, wpf, uwp", "date": "2017-11-20 09:07:07 +0800", "snippet": "WPF/UWP 中提供的 Path 类可以为我们绘制几乎所有可能的矢量图形。但是，如果这些矢量图形可以以动画的形式播放出来，那将可以得到非常炫酷的演示效果。我用 Blend 画了我的名字：&amp;lt;Canvas x:Name=&quot;DisplayCanvas&quot; Grid.Row=&quot;1&quot; Grid.Column=&quot;0&quot; Grid.ColumnSpan=&quot;2&quot;&amp;gt; &amp;lt;FrameworkElement.Resources&amp;gt; &amp;lt;Style TargetType=&quot;Path&quot;&amp;gt; &amp;lt;Setter Property=&quot;Stretch&quot; Value=&quot;None&quot;/&amp;gt; &amp;lt;Setter Property=&quot;Stroke&quot; Value=&quot;#FF1B6CB0&quot;/&amp;gt; &amp;lt;Setter Property=&quot;StrokeThickness&quot; Value=&quot;4&quot;/&amp;gt; &amp;lt;/Style&amp;gt; &amp;lt;/FrameworkElement.Resources&amp;gt; &amp;lt;Path x:Name=&quot;w&quot; Data=&quot;M501.5,309.22 L510.5,356.22 524,324.72 536,355.72 546,306.22&quot;/&amp;gt; &amp;lt;Path x:Name=&quot;a&quot; Data=&quot;M588.5,316.22 C588.5,316.22 561.5,308.72 558,334.72 554.5,360.72 579.5,369.21978 588,357.71985 596.5,346.21993 587.00002,315.22013 588.99999,310.22011 590.49998,326.72017 589.50007,359.22028 597.99998,359.22028&quot;/&amp;gt; &amp;lt;Path x:Name=&quot;l1&quot; Data=&quot;M613.5,283.22 C613.5,283.22 607,372.22 623.5,357.22&quot;/&amp;gt; &amp;lt;Path x:Name=&quot;t_1&quot; Data=&quot;M635.5,317.72 L656.5,316.22&quot;/&amp;gt; &amp;lt;Path x:Name=&quot;t_2&quot; Data=&quot;M644,285.72 C644,285.72 642.5,334.72 644,345.72 645.5,356.72 657.99343,366.72 661.99155,342.72&quot;/&amp;gt; &amp;lt;Path x:Name=&quot;e&quot; Data=&quot;M678.5,329.72 L711.5,327.72 C711.5,327.72 711,306.22 692,307.72 673,309.22 677,325.72 677,336.22 677,346.71999 685.99986,355.21999 692.49989,353.71999 698.99993,352.21999 709.49999,349.22025 709.99999,343.72022&quot;/&amp;gt; &amp;lt;Path x:Name=&quot;r&quot; Data=&quot;M725.5,306.72 C740,309.22 733.5,336.22 733.5,344.72 735.5,326.22 726.99993,300.72 763.49829,307.22&quot;/&amp;gt; &amp;lt;Path x:Name=&quot;l2&quot; Data=&quot;M786,281.22 C786,281.22 769,372.22 789.5,362.72&quot;/&amp;gt; &amp;lt;Path x:Name=&quot;v&quot; Data=&quot;M803,308.22 L817,358.22 835.5,310.22&quot;/&amp;gt;&amp;lt;/Canvas&amp;gt;然后将它做成了动画：而要做到这一点，我们只需要关心 Path 的两个属性即可： StrokeDashArray StrokeDashOffsetStrokeDashArray 是一个包含有很多个 double 的浮点数集合，决定了虚线虚实的变化趋势；StrokeDashOffset 是给这个变化趋势添加一个偏移量。如果一条直线其长度为 100，粗细为 1，StrokeDashArray=&quot;5,5&quot; 表示这段直线用虚线表示绘制；一开始的 5 长度绘制，接下来 5 长度不绘制，再接下来 5 长度绘制，依此类推。在这种情况下，我们再设置 StrokeDashOffset=&quot;1&quot;，则将虚实的变化延后 1 个长度，即一开始空出 1 长度不绘制后，才接着 5 长度绘制。于是，如果我们设置 StrokeDashArray=&quot;100,100&quot;，那么意味着一开始整条线都绘制，随后在看不见的线条的后面一倍长度上不绘制。我们设置 StrokeDashOffset=&quot;100&quot; 则意味着将这个绘制整体延后 100 长度，也就是完全看不见。当 StrokeDashOffset 设置成中间值的时候，这跟线条只会绘制一部分。于是我们的思路是： 设置 StrokeDashArray，使其虚实部分都等于线的长度 动画设置 StrokeDashOffset，使其从长度变化到 0这是为此制作的动画 XAML：&amp;lt;CubicEase x:Key=&quot;EasingFunction.DrawLine&quot; EasingMode=&quot;EaseOut&quot;/&amp;gt;&amp;lt;Storyboard x:Key=&quot;Storyboard.DrawName&quot;&amp;gt; &amp;lt;DoubleAnimation Storyboard.TargetName=&quot;w&quot; Storyboard.TargetProperty=&quot;StrokeDashOffset&quot; To=&quot;0&quot; BeginTime=&quot;0:0:0&quot; Duration=&quot;0:0:1&quot; EasingFunction=&quot;{StaticResource EasingFunction.DrawLine}&quot;/&amp;gt; &amp;lt;DoubleAnimation Storyboard.TargetName=&quot;a&quot; Storyboard.TargetProperty=&quot;StrokeDashOffset&quot; To=&quot;0&quot; BeginTime=&quot;0:0:1&quot; Duration=&quot;0:0:1&quot; EasingFunction=&quot;{StaticResource EasingFunction.DrawLine}&quot;/&amp;gt; &amp;lt;DoubleAnimation Storyboard.TargetName=&quot;l1&quot; Storyboard.TargetProperty=&quot;StrokeDashOffset&quot; To=&quot;0&quot; BeginTime=&quot;0:0:2&quot; Duration=&quot;0:0:1&quot; EasingFunction=&quot;{StaticResource EasingFunction.DrawLine}&quot;/&amp;gt; &amp;lt;DoubleAnimation Storyboard.TargetName=&quot;t_1&quot; Storyboard.TargetProperty=&quot;StrokeDashOffset&quot; To=&quot;0&quot; BeginTime=&quot;0:0:3&quot; Duration=&quot;0:0:0.4&quot; EasingFunction=&quot;{StaticResource EasingFunction.DrawLine}&quot;/&amp;gt; &amp;lt;DoubleAnimation Storyboard.TargetName=&quot;t_2&quot; Storyboard.TargetProperty=&quot;StrokeDashOffset&quot; To=&quot;0&quot; BeginTime=&quot;0:0:3.4&quot; Duration=&quot;0:0:0.6&quot; EasingFunction=&quot;{StaticResource EasingFunction.DrawLine}&quot;/&amp;gt; &amp;lt;DoubleAnimation Storyboard.TargetName=&quot;e&quot; Storyboard.TargetProperty=&quot;StrokeDashOffset&quot; To=&quot;0&quot; BeginTime=&quot;0:0:4&quot; Duration=&quot;0:0:1&quot; EasingFunction=&quot;{StaticResource EasingFunction.DrawLine}&quot;/&amp;gt; &amp;lt;DoubleAnimation Storyboard.TargetName=&quot;r&quot; Storyboard.TargetProperty=&quot;StrokeDashOffset&quot; To=&quot;0&quot; BeginTime=&quot;0:0:5&quot; Duration=&quot;0:0:1&quot; EasingFunction=&quot;{StaticResource EasingFunction.DrawLine}&quot;/&amp;gt; &amp;lt;DoubleAnimation Storyboard.TargetName=&quot;l2&quot; Storyboard.TargetProperty=&quot;StrokeDashOffset&quot; To=&quot;0&quot; BeginTime=&quot;0:0:6&quot; Duration=&quot;0:0:1&quot; EasingFunction=&quot;{StaticResource EasingFunction.DrawLine}&quot;/&amp;gt; &amp;lt;DoubleAnimation Storyboard.TargetName=&quot;v&quot; Storyboard.TargetProperty=&quot;StrokeDashOffset&quot; To=&quot;0&quot; BeginTime=&quot;0:0:7&quot; Duration=&quot;0:0:1&quot; EasingFunction=&quot;{StaticResource EasingFunction.DrawLine}&quot;/&amp;gt;&amp;lt;/Storyboard&amp;gt;于是我们便可以在 C# 代码中初始化那些 XAML 里算不出来的值（Path 中线的长度）：private Storyboard DrawLineStoryboard =&amp;gt; (Storyboard) FindResource(&quot;Storyboard.DrawName&quot;);private async void OnLoaded(object sender, RoutedEventArgs args){ for (var i = 0; i &amp;lt; DrawLineStoryboard.Children.Count; i++) { InitializePathAndItsAnimation((Path) DisplayCanvas.Children[i], (DoubleAnimation) DrawLineStoryboard.Children[i]); } DrawLineStoryboard.Begin();}private void InitializePathAndItsAnimation(System.Windows.Shapes.Path path, DoubleAnimation animation){ var length = path.Data.GetProximateLength() / path.StrokeThickness; path.StrokeDashOffset = length; path.StrokeDashArray = new DoubleCollection(new[] {length, length}); animation.From = length;}上述代码中存在一个线长度的估值算法，我们的策略是用多边形近似：public static class GeometryExtensions{ public static double GetProximateLength(this Geometry geometry) { var path = geometry.GetFlattenedPathGeometry(); var length = 0.0; foreach (var figure in path.Figures) { var start = figure.StartPoint; foreach (var segment in figure.Segments) { if (segment is PolyLineSegment polyLine) { // 一般的路径会转换成折线。 foreach (var point in polyLine.Points) { length += ProximateDistance(start, point); start = point; } } else if (segment is LineSegment line) { // 少部分真的是线段的路径会转换成线段。 length += ProximateDistance(start, line.Point); start = line.Point; } } } return length; double ProximateDistance(Point p1, Point p2) { return Math.Sqrt(Math.Pow(p1.X - p2.X, 2) + Math.Pow(p1.Y - p2.Y, 2)); } }}参考资料 SVG技术入门：如何画出一条会动的线 – WEB骇客 c# - Getting Geometry length - Stack Overflow" }, { "title": "使用不安全代码将 Bitmap 位图转为 WPF 的 ImageSource 以获得高性能和持续小的内存占用", "url": "/post/convert-bitmap-to-imagesource-using-unsafe-method.html", "categories": "", "tags": "wpf", "date": "2017-11-10 14:42:45 +0800", "snippet": "在 WPF 中将一个现成的 Bitmap 位图转换成 ImageSource 用于显示一个麻烦的事儿，因为 WPF 并没有提供多少可以转过来的方法。不过产生 Bitmap 来源却非常多，比如屏幕截图、GDI 图、数组或其它非托管框架生成的图片。WPF 官方提供了一种方法，使用 System.Windows.Interop.Imaging.CreateBitmapSourceFromHBitmap() 方法。官方解释称这是托管和非托管位图相互转换所用的方法。然而此方法有一个很严重的弊端——每次都会生成全新的位图，即便每次 DeleteObject 之后，内存依然不会即时释放。DeleteObject：[DllImport(&quot;gdi32&quot;)]static extern int DeleteObject(IntPtr o);DeleteObject 的指针源于 Bitmap.GetHbitmap() 方法，且得到的指针会作为 System.Windows.Interop.Imaging.CreateBitmapSourceFromHBitmap() 的参数之一。在持续输出图像的时候（例如播放 Gif 图、持续显示屏幕截图等）不及时释放内存非常致命！为了防止重复创建图片，WriteableBitmap 似乎成了比较好的选择。但是 WriteableBitmap 没有提供与位图 Bitmap 的互操作。然而它们都提供了像素操作。于是，我们考虑内存拷贝来完成转换，代码如下：public static class WriteableBitmapExtensions{ public static void CopyFrom(this WriteableBitmap wb, Bitmap bitmap) { if (wb == null) throw new ArgumentNullException(nameof(wb)); if (bitmap == null) throw new ArgumentNullException(nameof(bitmap)); var ws = wb.PixelWidth; var hs = wb.PixelHeight; var wt = bitmap.Width; var ht = bitmap.Height; if (ws != wt || hs != ht) throw new ArgumentException(&quot;暂时只支持相同尺寸图片的复制。&quot;); var width = ws; var height = hs; var bytes = ws * hs * wb.Format.BitsPerPixel / 8; var rBitmapData = bitmap.LockBits(new Rectangle(0, 0, width, height), ImageLockMode.ReadOnly, bitmap.PixelFormat); wb.Lock(); unsafe { Buffer.MemoryCopy(rBitmapData.Scan0.ToPointer(), wb.BackBuffer.ToPointer(), bytes, bytes); } wb.AddDirtyRect(new Int32Rect(0, 0, width, height)); wb.Unlock(); bitmap.UnlockBits(rBitmapData); }}我写了一个持续不断截取屏幕并输出显示的控件，在我的 The New Surface Pro 2736*1826 分辨率下内存一直保持 168M 从不变化。这个方法的简化空间还非常大，比如，如果数据源是一个一次申请不断修改的数组，那么连 Bitmap 都可以不需要了，直接拷贝数组空间即可。我的朋友林德熙为此将这段代码简化得只剩下几行代码了：WPF 使用不安全代码快速从数组转 WriteableBitmap - 林德熙。" }, { "title": "Visual Studio 也开始支持 Ctrl 点击跳转了，于是需要解决跟 ReSharper 的冲突", "url": "/post/resolve-ctrl-click-confiliction-between-vs-and-resharper.html", "categories": "", "tags": "visualstudio", "date": "2017-11-07 15:55:11 +0800", "snippet": "微软在 2017年10月9日 发布了 Visual Studio 2017 version 15.4.0。而这个版本带来了大家期待已久的 Ctrl+Click 跳转到定义的功能。然而……ReSharper 也是这样的快捷键，也是这样的功能！！！居然冲突了啊，怎么办？这里可以阅读发布日志：Visual Studio 2017 15.4 Release Notes。 Editor We added the popular Productivity Power Tools navigation feature Control Click Go To Definition to the core Visual Studio product. For supported languages (currently C#, VB and Python, with more languages coming in future releases), holding down the Ctrl key will allow you to click on a symbol in the Visual Studio editor and navigate to its definition. If you prefer to keep the older Ctrl+Click word selection behavior, you can control the feature’s key usage via Tools &amp;gt; Options &amp;gt; Text Editor &amp;gt; General &amp;gt; Enable mouse click to perform Go To Definition, which lets you select other modifier keys, or turn off the feature if you wish. 所以 Visual Studio 和 ReSharper 开始冲突，具体表现为，点击跳转到定义后，如果鼠标在转到定义之后刚好还落在另一个单词上，那么还会跳转到那个新的单词，非常恶心！只恶心自己就好了，为了防止恶心到大家，我找了几天，终于分别找到了 Visual Studio 和 ReSharper 两者的设置项。如下图，关掉一个就好了。" }, { "title": "修复 WPF 窗口在启动期间短暂的白底显示", "url": "/post/fix-white-screen-when-wpf-window-launching.html", "categories": "", "tags": "wpf", "date": "2017-11-03 23:08:46 +0800", "snippet": "不管你做的 WPF 窗口做得多么简单，是否总感觉启动的那一瞬间窗口内是白白的一片？是否试过无数偏方黑科技，但始终无法解决？本文将介绍一种简单的方法来彻底解决这个问题。看看下面这张图，你便能知道本文要解决的问题是否跟你希望解决的是同一个问题：是否发现窗口启动期间，窗口中的内容是白色的呢？然而我的 Window 超级简单：&amp;lt;Window x:Class=&quot;Walterlv.Demo.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:Walterlv.Demo&quot; mc:Ignorable=&quot;d&quot; Title=&quot;星i&quot;&amp;gt; &amp;lt;Border Background=&quot;Teal&quot;&amp;gt; &amp;lt;TextBlock Text=&quot;walterlv&#39;s demo&quot; Foreground=&quot;White&quot; FontSize=&quot;24&quot; FontWeight=&quot;Thin&quot; TextAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;&amp;gt;&amp;lt;/TextBlock&amp;gt; &amp;lt;/Border&amp;gt;&amp;lt;/Window&amp;gt;这个问题在网上 Google 搜索结果上已发现有很多讨论： WPF Window with black background flashes white when first shown White screen before loading main window contents How can I avoid flicker in a WPF fullscreen app?然而基本上观点都是相似的： 这是 WPF 的已知 BUG（this is a known issue in WPF） 可以先设置窗口 WindowState=&quot;Minimized&quot;，然后等 Loaded 或 ContentRendered 之后再设回 Normal/Maximized。经过多次尝试，甚至都改掉了 Window 的 Template 都无法解决这个问题。&amp;lt;Window x:Class=&quot;Walterlv.Demo.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:Walterlv.Demo&quot; mc:Ignorable=&quot;d&quot; Title=&quot;星i&quot;&amp;gt; &amp;lt;Window.Template&amp;gt; &amp;lt;ControlTemplate TargetType=&quot;Window&quot;&amp;gt; &amp;lt;ContentPresenter/&amp;gt; &amp;lt;/ControlTemplate&amp;gt; &amp;lt;/Window.Template&amp;gt; &amp;lt;Border Background=&quot;Teal&quot;&amp;gt; &amp;lt;TextBlock Text=&quot;walterlv&#39;s demo&quot; Foreground=&quot;White&quot; FontSize=&quot;24&quot; FontWeight=&quot;Thin&quot; TextAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;&amp;gt;&amp;lt;/TextBlock&amp;gt; &amp;lt;/Border&amp;gt;&amp;lt;/Window&amp;gt;但是！！！发现使用 WindowChrome 定制窗口非客户区的时候，此问题就不再出现了！！！也就是说，此问题在微软彻底解决之前，也是有规避方案的！——那就是 WindowChrome！这是效果：做法就是给 Window 设置 WindowChrome 附加属性：&amp;lt;WindowChrome.WindowChrome&amp;gt; &amp;lt;WindowChrome/&amp;gt;&amp;lt;/WindowChrome.WindowChrome&amp;gt;无需额外设置任何值，即可修复此问题（不过此时在 Visual Studio 中调试可能发现启动动画丢失）。但是，由于此时开始能够在非客户区（NonClientArea）显示控件了，所以可能需要自己调整一下视觉效果。&amp;lt;WindowChrome.WindowChrome&amp;gt; &amp;lt;WindowChrome GlassFrameThickness=&quot;0 31 0 0&quot; CornerRadius=&quot;0&quot; UseAeroCaptionButtons=&quot;True&quot;/&amp;gt;&amp;lt;/WindowChrome.WindowChrome&amp;gt;" }, { "title": "为 Web 页面添加 iPhone 固定标签页的图标", "url": "/post/add-icon-for-pinned-tab-icons.html", "categories": "", "tags": "web, ios", "date": "2017-10-28 00:16:52 +0800", "snippet": "我曾经将一个 Web 标签页固定到 iPhone 的主屏幕上，发现居然有一个图标。当时没有留意，可直到今天发现我的博客页面在我的 iPhone 主屏幕上显示一片空白后，才想起来原来还可以自定义图标。将 Web 页面图标固定到主屏幕：方法非常简单，只需要在我 html 里的 head 中加入以下代码即可：&amp;lt;link rel=&quot;apple-touch-icon&quot; href=&quot;图标的链接.svg&quot; /&amp;gt;对于我的博客，也就是这篇文章来说，我用了我的个人头像作为图标。最终固定到 iPhone 主屏幕的效果还不错！参考资料 Creating Pinned Tab Icons Configuring Web Applications" }, { "title": "使用 ExceptionDispatchInfo 捕捉并重新抛出异常", "url": "/post/exceptiondispatchinfo-capture-throw.html", "categories": "", "tags": "dotnet, dotnet-core, dotnet-standard, csharp", "date": "2017-10-27 07:38:48 +0800", "snippet": "当你跑起了一个异步线程，并用 await 异步等待时，有没有好奇为什么能够在主线程 catch 到异步线程的异常？当你希望在代码中提前收集好异常，最后一并把收集到的异常抛出的时候，能不能做到就像在原始异常发生的地方抛出一样？本文介绍 ExceptionDispatchInfo，专门用于重新抛出异常。它在 .NET Framework 4.5 中首次引入，并原生在 .NET Core 和 .NET Standard 中得到支持。先探索为什么需要重新抛出异常，再了解如何最佳地重新抛出异常。如果你只希望了解 ExceptionDispatchInfo，请直接从以下导航中点击跳转到最后一节。重新抛出异常说起重新抛出异常，你是否会认为就是写出如下代码？try{ DoButExceptionsMayOccur();}catch(Exception ex){ // 在这里进行抢救。 // 永远不要写出下面这句代码！（Don&#39;t write the code below forever!） throw ex;}为了防止这段代码被意外复制出去危及项目，我特地在注释中标明了永远不应该直接写出 throw ex 这样的句子！这是因为 throw 语句会为异常的实例填充调用栈信息，范围为 throw 的地方开始，到 catch 的地方结束。也就是说，在异常刚刚发生的时候，也就是 DoButExceptionsMayOccur 里面的某一个调用会成为调用栈的起点，上面写了 catch 所在的函数会成为调用栈的终点。然而，一旦在 catch 中写出了 throw ex 这样的语句，那么 ex 中的调用栈将会被重写，范围从这一句 throw 开始，到外面能 catch 的地方为止。具体说来，假设上面那段代码出现在 Test 方法中，里面的 DoButExceptionsMayOccur 调用了方法 Inner，Inner 中发生了异常；而 Outer 调用了 Test 方法，Outer 中也 catch 了异常；即整个调用链为 Outer-&amp;gt;Test-&amp;gt;DoButExceptionsMayOccur-&amp;gt;Inner。那么，当刚刚 catch 到异常时，ex 的调用栈为 Test-&amp;gt;DoButExceptionsMayOccur-&amp;gt;Inner，而如果写了 throw ex，那么 Outer 中将只能发现调用栈为 Outer-&amp;gt;Test，丢失了内部真正出错的原因，这对诊断和修复异常非常不利！如果只是为了解决上述文字中所说的问题，其实只需要去掉那个 ex 即可，即：try{ DoButExceptionsMayOccur();}catch(Exception){ // 在这里进行抢救。 throw;}然而，有时候这个异常并不直接从这里抛出（例如后台线程），或者说我们期望这是一个分步骤收集的异常（例如遍历）。这两种情况都有一个共同特点，就是重新抛出的地方根本就不在 catch 的地方。后台线程的例子：Exception exception = null;DoSomething(() =&amp;gt;{ // 这个 try-catch 块将在另一个线程执行。 try { DoButExceptionsMayOccur(); } catch(Exception ex) { exception = ex; }});if (exception != null){ // 重新抛出异常。}收集异常的例子：List&amp;lt;Exception&amp;gt; exceptions = new List&amp;lt;Exception&amp;gt;();foreach(var item in collection){ try { DoButExceptionsMayOccur(item); } catch(Exception ex) { exceptions.Add(ex); }}if (exceptions.Any()){ // 重新抛出异常。}使用内部异常.NET Framework 早期就提供了内部异常功能，专为解决保留调用栈而重新抛出异常而生。上面两段代码标记为// 重新抛出异常。的注释部分改为：// 对应第一种情况。throw new XxxException(ex);// 对应第二种情况。throw new AggregateException(exceptions);于是两边的调用栈就被分别保留在了多个不同的 Exception 实例中。然而看异常总要一层层点开查看，始终不便。尤其是从产品中收集异常时，如何在异常分析系统中显示和分析也是个问题。ExceptionDispatchInfo如果将第一种情况写为：ExceptionDispatchInfo.Capture(ex).Throw();那么，这时外面的方法再 catch 异常，则会从外层直接看到里层，只在中间插入了一段文字，却看起来就像直接从原始出处抛出一样。第二种情况写为：if(exceptions.Count == 1){ ExceptionDispatchInfo.Capture(exceptions.First()).Throw();}else if(exceptions.Count &amp;gt; 1){ throw new AggregateException(exceptions);}使用这种方式，你看到的调用栈将是这样的：至于多个异常的情况，那就只能使用内部异常来处理了。而这些，正是 Task 管理异步线程异常时采用的策略——单个异常直接在调用线程直接抛出，多个异常抛出 AggregateException。" }, { "title": "如何组织一个同时面向 UWP/WPF/.Net Core 控制台的 C# 项目解决方案", "url": "/post/organize-csharp-project-targeting-multiple-platforms.html", "categories": "", "tags": "dotnet, dotnet-core, dotnet-standard, wpf, uwp", "date": "2017-10-21 11:20:54 +0800", "snippet": "希望写一个小型工具，给自己和需要的人。考虑到代码尽可能的复用，我准备采用 .Net Standard 来编写大多数核心代码，并基于 .Net Core 编写跨平台控制台入口，用 WPF 编写桌面端 UI 入口，用 UWP 作为可上架商店的 UI 入口，然后用 Shared Project 共享 WPF 和 UI 的多数 UI 入口代码。阅读本文将了解到如何在尽可能复用代码的情况下组织这样的 C# 解决方案。工具型项目，选择了控制台用 WPF 开发桌面 UI，因为其有强大的 .NET Framework 库在背后支持，外加方便而功能齐全的 XAML 开发环境，在用 C# 进行桌面应用程序开发的时候不失为一种优秀的选择。但微软却并不怎么重视 WPF，而一直投入较大资源在半死不活的 UWP 上，导致 WPF 现在有非常多的坑是在 UWP 上才解的。然而，微软却并没有好好运营 UWP，以至于其开发者急剧减少，再在上面投入太多精力投入产出比显得太低。.NET Framework 是个优秀的框架，可是与 Windows 桌面端绑得太死，以至于在当下多平台发展得都不错的情况下失去了大多数的竞争力。但是 .NET Core 解决了这个问题。然而谈到 UI 的跨平台，就是一个巨大的投入和难以见底的坑，以至于基于 .NET Core 且跨平台的 UI 框架目前依然没有出现。毕竟只是工具型项目，并不想去动用大型 UI 框架 Xamarin/Unity，以至于写一个 .NET Core 控制台程序成了小型工具型项目的最佳解决方案了。工具型项目是任务导向的，能完成任务为最终目的。控制台与配置文件的配合不仅足以完成任务，还为自动化或其他工具集成提供了方便。这里提供 UI 只是为了方便此工具用户的初学使用和理解。组织一个 C# 解决方案我们总共涉及到的 Visual Studio 项目类型有这五个： 类库(.NET Standard) 共享项目 控制台应用(.NET Core) WPF 应用(.NET Framework) 空白应用(通用 Windows).NET Standard 和共享项目是默认就装上的，但其他三个却不是。需要在 Visual Studio 安装界面中额外勾选： 用于安装通用 Windows 项目，如果你对此不感兴趣，忽略即可 用于安装 WPF 应用，如果你对此不感兴趣，忽略即可 用于安装 .NET Core 项目，这是跨平台的重点，建议安装在 Visual Studio 中创建一个解决方案的时候依次添加这五种项目。 我们的主要逻辑代码全在 .NET Standard 项目中。这里包含了完整的功能实现，可以脱离其他四种实现完整功能。 .NET Core 控制台项目仅仅作为入口，引用 .NET Standard 的项目，将用户输入的命令转为具体的函数调用。 共享项目的代码主要是 UI 或 UI 辅助代码，例如控制 UI 的逻辑和 ViewModel。 UWP 和 WPF 项目仅包含 UI（XAML）和必要的不一致的 UI 控制逻辑，通过链接的方式将共享项目中的代码引入如何链接？。 其他的工具库当然也是需要的，但为了通用，建议优先选择 .NET Standard 的库。这样，项目在 Visual Studio 中看起来大概是这样的：" }, { "title": "UWP 和 WPF 不同，ListView 中绑定的集合修改顺序时，UI 的刷新规则", "url": "/post/binded-items-move-behavior-in-listview.html", "categories": "", "tags": "dotnet, wpf, uwp", "date": "2017-10-20 08:14:00 +0800", "snippet": "ObservableCollection&amp;lt;T&amp;gt; 中有一个 Move 方法，而这个方法在其他类型的集合中是很少见的。由于 ObservableCollection&amp;lt;T&amp;gt; 主要用于绑定，涉及到 UI 更新，而 UI 更新普遍比普通的集合修改慢了不止一个数量级，所以可以大胆猜想，Move 的存在是为了提升 UI 刷新性能。然而事实真是这样的吗？试验将 ObservableCollection&amp;lt;T&amp;gt; 用于 UI 绑定的目前只有 UWP 和 WPF，于是我写了两个 App 来验证这个问题。代码已上传 GitHub walterlv/ListViewBindingDemo for ItemsMove。验证方式主要看两个点： UI 元素的 Hash 值有没有更改，以便了解 UWP 或 WPF 框架是否有为此移动的数据创建新的 UI。 UI 元素的焦点有没有变化，以便了解 UWP 或 WPF 是否将此 UI 元素移出过视觉树。结果如下图： 在 UWP 中，移动数据的元素焦点没有改变，Hash 值也没有改变。 在 UWP 中，未被移动数据的元素 Hash 值没有改变。 在 WPF 中，移动数据的元素焦点丢失，Hash 值已经改变。 在 WPF 中，未被移动数据的元素 Hash 值没有改变。 猜想 UWP 真的对 ObservableCollection&amp;lt;T&amp;gt; 的 Move 操作有优化，根本就没有将移动数据的元素移除视觉树。 WPF 似乎并没有对 ObservableCollection&amp;lt;T&amp;gt; 的 Move 操作进行优化，因为 Hash 值都变了，直接就是创建了个新的。几乎等同于将原来的 UI 元素移除之后再创建了一个新的。调查.Net Standard 统一了 ObservableCollection&amp;lt;T&amp;gt; 的 API，所以 UWP 和 WPF 这些基本的 API 是一样的。由于 .NET Framework 发布了源代码，.Net Core 直接开源，所以这两者的代码我们都能翻出来。这是 [Net Framework 版的 ObservableCollection.MoveItem](http://referencesource.microsoft.com/#System/compmod/system/collections/objectmodel/observablecollection.cs,270a83d222656b02)/// &amp;lt;summary&amp;gt;/// Called by base class ObservableCollection&amp;amp;lt;T&amp;amp;gt; when an item is to be moved within the list;/// raises a CollectionChanged event to any listeners./// &amp;lt;/summary&amp;gt;protected virtual void MoveItem(int oldIndex, int newIndex){ CheckReentrancy(); T removedItem = this[oldIndex]; base.RemoveItem(oldIndex); base.InsertItem(newIndex, removedItem); OnPropertyChanged(IndexerName); OnCollectionChanged(NotifyCollectionChangedAction.Move, removedItem, newIndex, oldIndex);}这是 [.Net Core 版的 ObservableCollection.MoveItem](https://github.com/dotnet/corefx/blob/master/src/System.ObjectModel/src/System/Collections/ObjectModel/ObservableCollection.cs)/// &amp;lt;summary&amp;gt;/// Called by base class ObservableCollection&amp;amp;lt;T&amp;amp;gt; when an item is to be moved within the list;/// raises a CollectionChanged event to any listeners./// &amp;lt;/summary&amp;gt;protected virtual void MoveItem(int oldIndex, int newIndex){ CheckReentrancy(); T removedItem = this[oldIndex]; base.RemoveItem(oldIndex); base.InsertItem(newIndex, removedItem); OnIndexerPropertyChanged(); OnCollectionChanged(NotifyCollectionChangedAction.Move, removedItem, newIndex, oldIndex);}好吧，微软真省事儿，不止代码中的每个字母都相同，就连注释都一样……MoveItem 所做的就是在旧的位置移除元素，并将其插入到新的位置。于是，优化的重心就在于引发 CollectionChanged 事件时传入的参数了，都是传入 NotifyCollectionChangedAction.Move。由于 UWP 没有开源，从源码级别我们只能分析 WPF 为此枚举所做的事情。在 WPF 中，ListView 为此所做的判断仅一处，就是其基类 ItemsControl 类的 AdjustItemInfos 方法。然而此方法内部对 Move 的实现几乎就是 Remove 和 Add 的叠加。但是 UWP 中我们可以做更多的试验。比如我们直接移除掉原来的一项，然后延迟再添加一个新的：var item = EditableCollection.FirstOrDefault(x =&amp;gt; x.EditingText == &quot;E&quot;);EditableCollection.Remove(item);await Task.Delay(2000);EditableCollection.Insert(random.Next(EditableCollection.Count), item);或者我们直接添加一个跟原来不同的项：var item = EditableCollection.FirstOrDefault(x =&amp;gt; x.EditingText == &quot;E&quot;);EditableCollection.Remove(item);await Task.Delay(2000);EditableCollection.Insert(random.Next(EditableCollection.Count), new EditableModel(&quot;X&quot;));这时运行发现，焦点确实移除了，但 HashCode 依然是原来的 HashCode。基本可以确定，UWP 的 ListBox 做了更多的优化，在根据 DataTemplate 生成控件时，一直在重用之前已经生成好的控件。结论UWP 比 WPF 对 ObservableCollection&amp;lt;T&amp;gt; 的集合操作进行了更好的性能优化，在添加、删除、移动时会重用之前创建好的控件。而在 WPF 中，则简单地创建和销毁这些控件——即便调用了 ObservableCollection&amp;lt;T&amp;gt; 专有的 Move 方法也没有做更多的优化。" }, { "title": "GitHub 的 Pull Request 和 GitLab 的 Merge Request 有区别吗？", "url": "/post/git/pull-request-merge-request.html", "categories": "", "tags": "git", "date": "2017-10-12 09:13:40 +0800", "snippet": "在 GitHub 上混久了，对 Pull Request 就……；在 GitLab 上混久了，对 Merge Request 就……然而它们之间有不同吗？为什么要用两个不同的名称？要追溯这两个名称，需要追溯 GitHub 和 GitLab 引以为傲的 git 工作流。这也是本文参考链接中一定要附上 GitLab 工作流的重要原因。众所周知 git 是一个分布式的版本管理系统，但为了团队成员之间能够高效地协作，必须有至少一个服务器用于给团队所有成员之间同步代码。而这一点又有点类似于集中式的版本管理。对于项目的核心成员，集中式版本管理和分布式版本管理贡献代码的方式并没有多大差异（这里不要纠结个人使用层面的差异，只谈论为仓库贡献代码的方式）。但对于非项目核心成员来说，集中式的版本管理就非常痛苦了，因为他们找不到方式来提交自己的代码（请忽略低效的发邮件补丁吧……）。然而分布式版本管理则解决了这个问题：非项目核心成员可以克隆仓库，这样就得到了一个自己具有完全读写权限的仓库，贡献的代码可以完全同步到这个具有完全读写权限的仓库中。为了让非核心成员提交的代码被核心成员接纳，非核心成员会向核心成员提出“申请（Request）”去自己的仓库指定分支中“拉取(pull)”最新的修改，这便是 Pull Request 的来源。那么 Merge Request 又是什么呢？GitLab 对此的解释是——一样的，没有区别。Merge 只是在强调最后的那个动作“合并（Merge）”。 GitHub、Bitbucket 和码云（Gitee.com）选择 Pull Request 作为这项功能的名称 GitLab 和 Gitorious 选择 Merge Request 作为这项功能的名称参考资料 GitLab Documentation git - Pull request vs Merge request - Stack Overflow 码云平台帮助文档_V1.2" }, { "title": "查询已连接 Wi-Fi 的密码（入门和进阶两种方法）", "url": "/post/windows/find-wifi-password.html", "categories": "", "tags": "windows", "date": "2017-10-09 21:01:31 +0800", "snippet": "新买了手机或者带着朋友去好玩的地方，我自己的 Windows 10 设备连接上了 Wi-Fi，朋友也希望连接上，但是我忘记了密码怎么办？进阶篇其实重点并不是解决问题，而是解决问题的过程；所以使用命令行来解决这个问题当然更加炫酷一些，当然要第一个讲啦！让其他人投来羡慕的目光吧！总共两条命令：netsh wlan show profiles上图是第一条命令执行的结果，其实我们只是为了得到已记住的所有 Wi-Fi 名称而已，如果你知道名称，这一步可以省略。netsh wlan show profiles name=&quot;walterlv&quot; key=Clear第二条命令就是查看 walterlv 网络的信息。其中 name 换成你想查看的任何已记住的网络，key 设置为 Clear 是为了明文显示密码。我的 Wi-Fi 密码在图中可以看得到，被设置成了 lvyi1009。入门篇如果你觉得上面的方法太装了，想朴素一些，那么只需要点点鼠标即可。打开网路和共享中心，然后点击正在连接的网络名称。点击“无线属性”。显示字符就能看到密码了。不过这种方法只能看到当前正在连接的 Wi-Fi 网络的密码。参考资料 2 Ways To Find All Saved Wifi Passwords In Windows 10" }, { "title": "CaptureMouse/CaptureStylus 可能会失败", "url": "/post/wpf/capture-mouse-failed.html", "categories": "", "tags": "wpf", "date": "2017-10-09 19:05:56 +0800", "snippet": "在 WPF 中，如果我们要做拖动效果，通常会调用一下 CaptureMouse/CaptureStylus 以便当鼠标或手指离开控件的时候依然能够响应 Move 和 Up 事件。不知有没有注意到这两个函数其实是有 bool 返回值的？——是的，它们可能会失败。在调试一个项目代码的时候，我就发现了这种失败，观察返回值确实是 false，然而为什么呢？查看 .NET Framework 的源码 我们发现，CaptureMouse 最终调到了 Mouse.Capture 方法：public static bool Capture(IInputElement element){ return Mouse.PrimaryDevice.Capture(element);}然后一步步调到了 bool Capture(IInputElement element, CaptureMode captureMode)，而其中对是否可 Capture 的关键性影响代码就在这个方法内部。为了便于理解，我把他改成了下面这样，是等价的：[Pure]private static bool CanCapture(IInputElement element){ if (element is UIElement e) { return e.IsVisible &amp;amp;&amp;amp; e.IsEnabled; } if (element is ContentElement ce) { return ce.IsEnabled; } if (element is UIElement3D e3D) { return e3D.IsVisible &amp;amp;&amp;amp; e3D.IsEnabled; } return true;}这段代码感兴趣可以拿走，以便在 Capture 之前可以进行预判。从这段代码可以很清楚地知道，如果元素已不可见 (IsVisible 为 false) 或者不可用（IsEnabled 为 false），则不可 Capture。以此为线索，果然发现调试的项目中在 MouseDown 事件里把元素隐藏了。总结： 如果元素不可见或不可用，则 Mouse.Capture 会失败。顺便还发现一个问题，Stylus.Capture(IInputElement) 中居然直接调用的是 Mouse.Capture(IInputElement)。" }, { "title": "彻底删除 Git 仓库中的文件避免占用大量磁盘空间", "url": "/git/2017/09/18/delete-a-file-from-whole-git-history.html", "categories": "", "tags": "git", "date": "2017-09-29 07:36:22 +0800", "snippet": "今天早上照常 git fetch --prune 获取大家写的代码，发现需要好长时间，但没怎么在意。直到下午小伙伴们才发现居然 fetch 了一个多 GB！询问才发现小伙伴 JAKE（其实我是在推荐博客）误传了 1.47GB 的垃圾文件。关键是等发现时，develop 分支上已经有 20+ 个基于这个文件的新提交了。小伙伴说“不要紧，现在我已经删除它了！”突然一阵后背发凉，我们才 900M 的仓库肯定一下子飙到了 2000+M，必须马上处理之。如果你想知道到底发生了什么造成突然多出这么大的文件，请阅读：一个压缩包引发的血案 - niuyanjie’s blog。问题的本质和解决思路有的小伙伴问了，为何删了也会占用仓库空间？这是因为 Git 会记录历史的每一次提交，而且提交中包含了完整的数据。如果有一次提交中增加了一个大文件，即便后面删除了此文件再提交，之前增加文件的提交也在历史中。由于 Git 是分布式仓库，每个人都克隆了完整的 Git 仓库，包含完整的历史，于是这个大文件对空间的吞噬其实影响着每一个 Git 仓库的副本。所以，解决问题的思路其实是——让整个 Git 历史中不存在这个文件！一种方法是修改有问题的提交，使这个提交中不包含对此文件的修改记录；另一种方法就是将这个提交从整个提交历史记录中干掉。后文介绍的方法中，“推荐的方法”属于前者，“不推荐的方法”属于后者。推荐的方法感谢小伙伴 林德熙 的帮助，帮我找到了一篇非常有价值的博客：Git如何永久删除文件(包括历史记录) - shines77 - 博客园。强烈推荐只阅读上面那篇文章而不要阅读本文，因为本文真正用到的方法比上面的更 low。看到 filter-branch，突然想到前几天给 Git 仓库补提交一个文件用的是同一个方法：如何向整个 Git 仓库补提交一个文件，那既然如此，里面各种参数的含义也就读(si)得(dong)懂(fei)了(dong)……（/暗笑）。命令如下：$ git filter-branch --force --index-filter &#39;git rm --cached --ignore-unmatch path-to-your-remove-file&#39; --prune-empty --tag-name-filter cat -- --all把 path-to-your-remove-file 改成那个误传的文件后，写下命令准备运行……运行……运行……然后过了十多分钟还不到 5% 的进度……算了，放弃吧……我们这种数万次提交，900M 的大仓库，这样的命令似乎玩不起啊……这个命令一定还能用，比如指定版本区间什么的，但是我不会……不推荐的方法（但能解决问题）我在本地把 develop 分支 reset 到那次误提交文件的提交之前，然后跳过有问题的提交，将 origin/develop 分支上其它新提交一个个 cherry-pick 到本地的 develop 分支上。需要注意不能 cherry-pick 那些合并的提交（就是那种有两个 parent 的提交）。这样，本地的 develop 分支就刚好跳过那个误传文件的提交，而包含之后的所有提交了。不管哪种方法，执行完之后都要做这些事情上面两种方法执行完之后，都面临一个问题——本地 develop 和远端 origin/develop 分支将不再是快进式的，而且包含相同修改的不同提交。这是因为提交虽然还是之前那些提交，但提交的信息已经改变（SHA-1 和 parent）。我必须让远程 Git 仓库应用我的最新分支才行。必须使用一个危险的命令：git push -f于是去远程服务器上取消了 develop 分支的保护，执行以上命令后重新保护它避免之后的危险操作。（前面不管那种方法都会面临这个危险操作，说它危险，是因为此操作会删除远端服务器上 develop 分支上的提交，如果此前的操作做得不对，可能造成严重的代码丢失的后果！）另外，根据误传文件那个提交的 SHA-1 值，我们找到了远端还存在着包含此提交的其他人的分支，我们需要删除那些分支，确保服务器上任何分支都不包含此提交。使用的是这个命令：git branch --contains &amp;lt;commit&amp;gt;然后删除上面命令找到的远端分支（当然找小伙伴确认过可以删我才敢删，不然被打死了）：$ git push -d origin &amp;lt;branch_name&amp;gt;$ git branch -d &amp;lt;branch_name&amp;gt;这样，远端服务器上的任何分支都不存在包含误传文件的提交了。理论上新克隆的本地仓库将不再有 2000+M 的大小，实测也是如此。但已经克隆并且包含那次提交的小伙伴该怎么办？小伙伴 林德熙 再次提供了一组命令，我和他一起简化后整理如下：git fetch -f -pgit checkout developgit reset origin/develop --hardgit reflog expire --expire=now --allgit gc --prune=now命令的解释小伙伴 林德熙有详细介绍。大体为： 提取远端服务器上最新的提交（这样本地仓库才会包含我修复的那些提交） 切换到 develop 分支（避免影响到小伙伴当前的工作分支，防止丢失工作） 将本地 develop 分支强制重置成远端的 develop 分支（以便丢掉本地有问题的那些提交） 立刻将所有无法跟踪到的提交标记为已过期（以便垃圾回收工具可以回收） 立刻进行垃圾回收（这样误传文件的那次提交包含的 1.47GB 空间就被回收啦）需要注意：必须确保本地和远端没有任何分支可以跟踪到那次误传文件的提交。如果本地没有基于之前的 develop 分支做新的修改，则以上命令足以将本地磁盘的空间收回。如下图：但如果本地还有新的提交，以上命令敲完前三条后就要暂停了。需要将新的提交 cherry-pick 到新的 develop 分支上；随后删除之前提交的那个分支，确保本地也没有任何分支包含误传文件的提交。随后继续敲后面的两条命令，也可以将本地的磁盘空间回收。至此，完结了吗？不！没有。我们肯定还有小伙伴没有删干净，等哪一天再次把那个提交推送……今天算是白干了……不过，好在我们必须经过代码审查才会将功能分支合并到 develop。只要我们能及时发现，告诉大家在 fetch 发现花太长时间的时候立刻 Ctrl+C 取消 fetch，那么我们还能拯救。而这次，只需要一个命令即可解决：$ git push -d origin 死灰复燃的包含误传提交的某个分支名另外再吐个槽，以上一切都做完了，还写完了这篇博客。结果 filter-branch 那个命令依然还跑着没有结束……" }, { "title": "使用 PowerShell 获取 CLR 版本号", "url": "/post/powershell/2017/09/28/get-clr-version-via-powershell.html", "categories": "", "tags": "powershell", "date": "2017-09-28 00:24:08 +0800", "snippet": "在我之前写的一篇文章.NET Framework 4.x 程序到底运行在哪个 CLR 版本之上中，我们说到 CLR 版本和 .NET Framework 基础库之间是有差别的，其版本号更是有差别的。不过其中并没有给出方法获取 CLR 的版本号。本文将给出几种方便的获取 CLR 版本号的方法。写代码获取.NET Framework 的 System.Environment 类型的 Version 属性直接可以获取到版本号。于是只需要简单写一个控制台程序即可获取。Console.WriteLine($&quot;{Environment.Version}&quot;);以上只写关键的一行，其他类啊、Main 函数啊、Console.ReadKey 的都自行脑补即可。因为这不是本文重点。在我的 Windows 10 创造者更新 1703 上得到的结果是：4.0.30319.42000。用 PowerShell 获取考虑到 PowerShell 可以直接使用到 .NET Framework 中的类型，于是上面的代码很容易直接翻译成 PowerShell 脚本：PS C:\\Users\\lvyi&amp;gt; [Environment]::VersionMajor Minor Build Revision----- ----- ----- --------4 0 30319 42000上面的第一行是脚本，后面全是输出，本文之后的 PowerShell 代码部分都是这样。可以看到，虽然格式不同，但依然拿到了跟我们写代码一模一样的结果。本文只是一个引子，你可以拿着 PowerShell 去调用其他 .NET Framework 的类和方法，根本不需要打开 Visual Studio 编译，非常方便！不过既然是 PowerShell，那就有更多可以尝试的方法，比如说直接拿 PowerShell 的全局变量：PS C:\\Users\\lvyi&amp;gt; $PSVersionTableName Value---- -----PSVersion 5.1.15063.608PSEdition DesktopPSCompatibleVersions {1.0, 2.0, 3.0, 4.0...}BuildVersion 10.0.15063.608CLRVersion 4.0.30319.42000WSManStackVersion 3.0PSRemotingProtocolVersion 2.3SerializationVersion 1.1.0.1如果觉得杂乱项太多，直接取里面的 CLRVersion 即可：PS C:\\Users\\lvyi&amp;gt; $PSVersionTable.CLRVersionMajor Minor Build Revision----- ----- ----- --------4 0 30319 42000" }, { "title": "试图在 Windows 10 上安装 .NET Framework 3.5 时提示错误 0x800F081F", "url": "/dotnet/2017/09/23/install-dotnet35-on-windows-10.html", "categories": "", "tags": "dotnet", "date": "2017-09-23 00:15:46 +0800", "snippet": "说到在 Windows 10 上安装 .NET Framework 3.5，想必已经没什么可以多说的了，直接去“启用或关闭 Windows 功能”界面给“.NET Framework 3.5”打个勾就好了。但今天帮助一位朋友安装时却在上述步骤之后出现了错误：0x800F081F。正常安装步骤：错误：这不能忍啊！迅速在网上搜索错误码，然而得到的回答要么是换命令行，要么是重置系统。命令行的方案以前其实尝试过，需要一个本地的安装镜像，然而突然间哪里那么方便找一个安装镜像呢！重置系统损失太大还是算了。虽然命令行我们不用，但还是贴出来参考：DISM /Online /Enable-Feature /FeatureName:NetFx3 /All /LimitAccess /Source:E:\\sources\\sxs其中，E 盘是系统镜像盘。命令不区分大小写。然而，微软官方其实对此问题是有说明的，在 .NET Framework 3.5 installation error: 0x800F0906, 0x800F081F, 0x800F0907 里。 The source files could not be found.Use the “Source” option to specify the location of the files that are required to restore the feature. For more information on specifying a source location, see http://go.microsoft.com/fwlink/?LinkId=243077.The DISM log file can be found at C:\\Windows\\Logs\\DISM\\dism.log也就是说，此错误吗意味着文件没有找到。然而我们选择的安装方式是在线安装，找不到文件意味着根本没有下载下来。再回过头来看看之前安装的最后一个步骤，文案是“从 Windows 更新下载文件”。莫非是 Windows 更新的锅？虽说是我帮助我的朋友安装，但他非常聪明，根据此猜测直接从 Cortana 搜索“服务”进入到服务管理界面，将“Windows Update”服务的启动方式从禁用改为手动。于是再重复本文一开始的步骤，成功啦！总结： 0x800F081F 错误代表用于安装的文件缺失 如果是在线安装，则需要修复 Windows Update 服务参考资料 How to instal .NET Framework 3.5 on Windows 10 - Microsoft Community .NET Framework 3.5 installation error: 0x800F0906, 0x800F081F, 0x800F0907 Net 3.5 framework, cannot install 0x800F081F. Solved - Windows 10 Forums" }, { "title": "设置 .NET Native 运行时指令以支持反射（尤其适用于 UWP）", "url": "/uwp/2017/09/21/reflection-using-dotnet-native-runtime-directive.html", "categories": "", "tags": "uwp", "date": "2017-09-21 07:35:41 +0800", "snippet": "我们经常会尝试用一用反射来解决一部分动态可执行代码的问题，不过这个问题在 UWP 中似乎并不那么轻松。也许你写了一句获取某个类所有属性的代码，结果发现 DEBUG 下跑得好好的，RELEASE 下居然拿不到！尝试反射获取属性你的代码可能是这样的：var properties = typeof(SomeType).GetProperties();或者这样的：var properties = type.GetTypeInfo().DeclaredProperties;但无论哪一种，DEBUG 下 properties 集合中有我们想要的属性集合，如下图：type.GetTypeInfo().DeclaredProperties 帮我们拿到了当前类的属性，typeof(SomeType).GetProperties() 帮我们拿到了当前类和其所有父类的属性。然而，RELEASE 下的结果却是这样的：其中后者虽然有两个实例，却是：这就诡异了，DEBUG 和 RELEASE 下到底有什么区别呢？设置 .NET 本机工具链编译选项经过一番 Google，发现 RELEASE 下编译开启了 .NET 本机工具链选项，这使得 RELEASE 下生成的是静态的本机代码。试着去掉这个选项，果然以上的反射代码能够得到期望的属性集合。然而这样就丢失了 .NET Native 带给我们棒棒的性能优势了啊！设置 .NET Native 运行时指令所以更推荐的做法是什么呢？微软为我们提供了设置 .NET Native 运行时指令的方法，展开解决方案项目的 Properties 文件夹，我们可以找到 Default.rd.xml 文件。查看里面的内容，微软为我们写了很详细的注释：&amp;lt;!-- 此文件包含 .NET Native 使用的运行时指令。此处的默认值适合大多数 开发人员。但可通过修改这些参数来修改 .NET Native 优化程序的行为。 运行时指令记录在 https://go.microsoft.com/fwlink/?LinkID=391919 完全启用对 App1.MyClass 及其所有公共/私有成员的反射 &amp;lt;Type Name=&quot;App1.MyClass&quot; Dynamic=&quot;Required All&quot;/&amp;gt; 通过 System.Int32 启用 AppClass&amp;lt;T&amp;gt; 的特定实例的动态创建 &amp;lt;TypeInstantiation Name=&quot;App1.AppClass&quot; Arguments=&quot;System.Int32&quot; Activate=&quot;Required Public&quot; /&amp;gt; 使用 Namespace 指令将反射策略应用于特定命名空间中的所有类型 &amp;lt;Namespace Name=&quot;DataClasses.ViewModels&quot; Serialize=&quot;All&quot; /&amp;gt;--&amp;gt;注意到微软其实已经直接在注释里告诉了我们此文件的目的和用法了。而且此文件几乎就是设计来解决反射问题的！于是，我们把我们测试用的类放进去试试看，如下：&amp;lt;Directives xmlns=&quot;http://schemas.microsoft.com/netfx/2013/01/metadata&quot;&amp;gt; &amp;lt;Application&amp;gt; &amp;lt;!-- Name=&quot;*Application*&quot; 的程序集元素将应用到应用程序包中的所有程序集。星号不是通配符。--&amp;gt; &amp;lt;Assembly Name=&quot;*Application*&quot; Dynamic=&quot;Required All&quot; /&amp;gt; &amp;lt;!-- 在此处添加应用程序特定的运行时指令。--&amp;gt; &amp;lt;Type Name=&quot;ReflectionDemo.MainPage&quot; Dynamic=&quot;Required All&quot;/&amp;gt; &amp;lt;/Application&amp;gt;&amp;lt;/Directives&amp;gt;结果并没有得到任何改变……但注意到微软同时还有一个注释，*Application*&quot; 的程序集元素将应用到应用程序包中的所有程序集。星号不是通配符。这是说，我们自己项目中的所有程序包其实都是支持反射的，只是我们引用的微软库才不支持。于是将我们测试用的类 MainPage 的基类都放进去，为了简单，我按照微软的注释写成了命名空间。&amp;lt;Directives xmlns=&quot;http://schemas.microsoft.com/netfx/2013/01/metadata&quot;&amp;gt; &amp;lt;Application&amp;gt; &amp;lt;!-- Name=&quot;*Application*&quot; 的程序集元素将应用到应用程序包中的所有程序集。星号不是通配符。--&amp;gt; &amp;lt;Assembly Name=&quot;*Application*&quot; Dynamic=&quot;Required All&quot; /&amp;gt; &amp;lt;!-- 在此处添加应用程序特定的运行时指令。--&amp;gt; &amp;lt;Namespace Name=&quot;Windows.UI.Xaml&quot; Serialize=&quot;All&quot;/&amp;gt; &amp;lt;/Application&amp;gt;&amp;lt;/Directives&amp;gt;再次运行，已经可以反射获取到所有的属性了。经过尝试，在写了 Windows.UI.Xaml 命名空间后，它的子命名空间 Windows.UI.Xaml.Controls 是可以不用写的。参考资料 c# - Type.GetProperties() doesn’t work in Release - Stack Overflow c# - Adding runtime directives for generic types in UWP app - Stack Overflow .NET Native Deep Dive: Dynamic Features in Static Code" }, { "title": "使用 filter-branch 从 Git 历史中删除一个文件", "url": "/git/2017/09/19/delete-file-using-filter-branch.html", "categories": "", "tags": "git", "date": "2017-09-19 20:19:04 +0800", "snippet": "昨天帮助小伙伴从 Git 提交历史中删除了一个文件，虽然一开始尝试使用 filter-branch，但是因为需要的时间太久，就放弃了，转而使用 cherry-pick 的方案。但是，毕竟 Git 官方给的方案是 filter-branch，所以今天就在另一位小伙伴的帮助下好好阅读 Git 官方文档：Git - 重写历史 和 Git - git-filter-branch Documentation。原来参数中是可以指定查找范围的！几万个提交的仓库，既然是当天加的文件，当然没必要遍历整个仓库，数了数大概是 20+ 个提交之前加的，于是写出了如下命令：git filter-branch --tree-filter &#39;git rm file-name-to-remove.zip&#39; HEAD~30..HEAD最后那个参数就是从当前分支的前 30 次提交开始遍历，这样就会快很多。下面的输入和输出是我在拿上一篇博客文件做试验，删掉那篇博客。整个仓库有 125 次提交，但只需遍历参数里指定的 5 个。$ git filter-branch --tree-filter &#39;rm _posts/2017-09-18-delete-a-file-from-whole-git-history.md&#39; HEAD~5..HEADRewrite f74ff6c8057dcfdf96822989a09c357ae07cd2f8 (5/5) (2 seconds passed, remaining 0 predicted)Ref &#39;refs/heads/master&#39; was rewritten参考资料 Git - 重写历史 Git - git-filter-branch Documentation Link Intersystems – Remove directories and files permanently from git" }, { "title": "Why Unload Twice", "url": "/wpf/2017/09/19/why-unload-twice.html", "categories": "", "tags": "wpf", "date": "2017-09-19 18:32:39 +0800", "snippet": "Sometimes WPF raise unload event twice. In this case, it happens when a logical tree is build all by myself. Why unload twice? It really confused me.Any help would be appreciated! The repo: walterlv/why-unload-twice @ GitHubWhy the _problemChild unloaded twice?How to reproduce it ? Clone this repository; Run/Debug; Click Add Child button several times; Every time you click Delete Child, you’ll got Content Unloaded output twice.Key points A non-generic style is added. When removing an FrameworkElement from a visual tree, it is also been removed from a logical tree at the same time. The visual tree and the logical tree is different.Key points(zh-CHS) - 复现此问题的关键 为一个 TemplatedControl（CustomControl） 定制非默认模板（不放在 Generic.xaml 中的模板）； 这个控件包含视觉子级和逻辑子级，并且这两个不是同一个对象； 将这个控件同时从视觉树和逻辑树中移除（两个移除顺序不重要，但一定是无中断的）；这时你会观察到从这个控件的逻辑子级开始向所有子节点递归引发 Unloaded 事件，然后又从这个控件本身开始向所有子节点递归引发 Unloaded 事件，于是所有子节点都会连续发生两次 Unloaded 事件。Key points(zh-CHT) - 復現此問題的關鍵 為一個 TemplatedControl（CustomControl） 定制非默認模板（不放在 Generic.xaml 中的模板）； 這個控件包含視覺子級和邏輯子級，並且這兩個不是同一個對象； 將這個控件同時從視覺樹和邏輯樹中移除（兩個移除順序不重要，但一定是無中斷的）；這時你會觀察到從這個控件的邏輯子級開始向所有子節點遞歸引發Unloaded 事件，然後又從這個控件本身開始向所有子節點遞歸引發Unloaded 事件，於是所有子節點都會連續發生兩次Unloaded 事件。Stacks of this issueWhen a non-generic style of Child is added, the Unloaded event will be raised of these two operations.Removing from visual tree with non-generic styleRemoving from logical tree with non-generic styleWhen only the generic style of Child is defined, the Unloaded event will be raised of only one operations.Removing from visual tree with generic style" }, { "title": "找回你 C 盘丢失的空间（SpaceSniffer）", "url": "/windows/2017/09/17/find-lost-space-using-space-sniffer.html", "categories": "", "tags": "windows", "date": "2017-09-17 15:13:33 +0800", "snippet": "什么鬼！C 盘空间满了！我分了 120GB 啊！！！是不是要删软件删游戏，是不是要重装系统？尤其是程序员，那么多开发环境（Visual Studio 不说话 :)）空间占用那叫一个大啊！为了避免重装系统，我找到了一款神奇的软件——SpaceSniffer。话不多说，上神器： SpaceSniffer 官网：Uderzo Software SpaceSniffer SpaceSniffer 官方下载镜像：Download SpaceSniffer Portable下载完后解压：由于是绿色版，下载解压后直接运行即可。需要注意的是，为了能够发现系统文件夹中的大文件元凶，建议使用管理员权限运行。启动后会弹出磁盘选择对话框，由于我 C 盘满了，所以我选择了 C。然后就看着它又炫酷又丑的界面慢慢等待分析吧！等分析的速度放缓，则可以认为它分析完了。因为它还会随时监视文件的修改，所以分析是永远不会结束的，不用等了。我这边分析完之后，发现 AppData 目录居然占了 34.5 GB！一层层点开，发现 Photoshop 临时文件夹占了我 26.6GB！于是这才发现我还开着 Photoshop，关掉它，C 盘空间恢复。如果空间依然不够，继续一层层点开最大的的文件夹，把有问题的干掉： 如果是临时文件，可以关掉程序或直接删掉整个文件夹 如果是程序文件，则可以考虑只卸载这个程序比如我还发现，原来 ReSharper 会占用这么大的空间……最后多说一句，不要吐槽为何我的 C 盘只有 120GB，因为我用的是 Surface pro 啊，总共就 256GB 可用。考虑到系统出问题可以随时重装，重要资料当然不会放到 C 盘。" }, { "title": "如何向整个 Git 仓库补提交一个文件", "url": "/git/2017/09/13/add-file-to-whole-git-repository.html", "categories": "", "tags": "git", "date": "2017-09-13 19:10:47 +0800", "snippet": "微软在 Reference Source 里开放了 .NET Framework 多个版本的源码。为了更方便地阅读这些源码，我们把每一个版本都下载下来后按顺序提交到 git 仓库中。但是！！！居然忘了在第一次提交之前放一个 .gitignore 文件！如果没有这个文件，那我们每次打开源码查看都会带来一大堆不明所以的修改文件。那么多的源码，绝对不会想重新挨个版本再提交一次。于是找到了一条可以解决这个问题的 git 命令。git filter-branch --index-filter &quot;cp /C/仓库外面某个路径下的/.gitignore . &amp;amp;&amp;amp; git add .gitignore&quot;执行之后，C:\\仓库外面某个路径下的\\.gitignore 文件就被添加到了当前分支的第一次提交里面，并且查看后面任何一次提交对应的全部文件时，都会有这个文件。如果希望此操作对所有分支生效，则加一个 --all 参数，即：git filter-branch --index-filter &quot;cp /C/仓库外面某个路径下的/.gitignore . &amp;amp;&amp;amp; git add .gitignore&quot; -- --all写这个命令时需要注意： git 在 Bash 里写的时候，C:\\ 需要写成 /C/。 -- --all 中的 -- 是用来区分路径和提交的，官方说法是：fatal: ambiguous argument &#39;cp /C/仓库外面某个路径下的/.gitignore . &amp;amp;&amp;amp; git add .gitignore&#39;: unknown revision or path not in the working tree.Use &#39;--&#39; to separate paths from revisions, like this:&#39;git &amp;lt;command&amp;gt; [&amp;lt;revision&amp;gt;...] -- [&amp;lt;file&amp;gt;...]&#39;执行了此命令后，所有的提交其实都被重写了，提交号已经改变。如果你从未推送到远端过，那么恭喜，你已经在神不知鬼不觉中添加了一个 .gitignore 文件，就像是第一次提交就加了这个文件一样。但是，如果此前有推送到过远程分支，请慎重！因为你的此次推送的命令和其他人首次拉取的命令将有所改变：推送（所有分支，强制）：$ git push --all -f拉取（获取 + 重置）$ git fetch$ git reset origin/master --hard参考资料 GIT: How do I add a file to the first commit (and rewrite history in the process)?" }, { "title": "Exception.Data 为异常添加更多调试信息", "url": "/dotnet/2017/09/12/exception-data.html", "categories": "", "tags": "dotnet", "date": "2017-09-12 15:44:36 +0800", "snippet": "我们抛出异常是为了知道程序中目前的状态发生了错误。为了能够知道错误的详细信息便于我们将来避免产生这样的错误，我们会选用合适的异常类型，在异常中编写易于理解的 message 信息。但是有时我们需要更多的信息进行调试才能帮忙在将来避免这个异常。System.Exception 类中就自带了这样的属性 Data，它是 IDictionary 类型的：public virtual IDictionary Data { [System.Security.SecuritySafeCritical] // auto-generated get { if (_data == null) if (IsImmutableAgileException(this)) _data = new EmptyReadOnlyDictionaryInternal(); else _data = new ListDictionaryInternal(); return _data; }}别问我为什么把括号放最右边，那是微软自己写的源码 点击这里查看最近在调试 .NET Framework 内部代码的异常时就发现微软就是使用这个属性储存异常的更多细节的：internal void RegisterStylusDeviceCore(StylusDevice stylusDevice){ lock (__stylusDeviceLock) { int stylusDeviceId = stylusDevice.Id; // The map must contain unique entries for each stylus device. if (__stylusDeviceMap.ContainsKey(stylusDeviceId)) { InvalidOperationException ioe = new InvalidOperationException(); // We add a tag here so we can check for this specific exception // in TabletCollection when adding new tablet devices. ioe.Data.Add(&quot;System.Windows.Input.StylusLogic&quot;, &quot;&quot;); throw(ioe); } __stylusDeviceMap[stylusDeviceId] = stylusDevice; }}以上代码出自 .NET Framework 4.6 的 System.Windows.Input.StylusLogic 类型，https://referencesource.microsoft.com 里 .NET Framework 4.7 中找不到。需要注意的是，Exception 的 ToString() 方法并不会把这个字典转成字符串的任意一个部分；所以，如果需要在日志中记录程序中全局捕获的异常，需要自己去遍历异常中的 Data 的每一项。不过，为了解决掉更多的程序错误，我们记录日志的时候不已经写了更多的信息（比如 InnerException）了吗？" }, { "title": "WPF 渲染系统（WPF Render System）", "url": "/wpf/2017/01/16/wpf-render-system.html", "categories": "", "tags": "wpf", "date": "2017-01-16 14:50:00 +0800", "snippet": "一个朋友问我：“为什么几千个 Visual 在视觉树上，增加删除几个能够那么快地渲染出来？”这个问题问倒我了，因为我对 WPF 渲染系统的了解很少，更不知道渲染部分和 UI 逻辑部分是如何分工的。在此机会下，我毫不犹豫地打开 https://referencesource.microsoft.com/ 阅读 WPF 的源码。对探索源码章节不感兴趣的读者，可以直接跳到后面大胆猜想与理论依据章节。探索源码虽然知道 referencesource 上有源码，但从哪个类哪个方法开始也是个问题。寻找入口既然是添加、移除视觉树节点，那么应该在这几个类中找得到相关方法：Visual、VisualTreeHelper、VisualCollection。试着找了下 VisualTreeHelper，结果只有各种 Get 方法；找了下 VisualCollection，结果找到了。public int Add(Visual visual){ // …… （省略部分） if (visual != null) { ConnectChild(addedPosition, visual); } // …… （省略部分）}依此为突破口，应该能一层层找到渲染 Visual 部分的代码吧！层层进入我们看看 ConnectChild 方法，随后一层层进入。private void ConnectChild(int index, Visual value){ // …… （省略部分） _owner.InternalAddVisualChild(value);}其中，_owner 是 Visual 类型。internal void InternalAddVisualChild(Visual child){ this.AddVisualChild(child);}接下来就不那么顺利了，因为 AddVisualChild 方法进去后发现仅设置了标志位，再没有执行实质性的方法。这下杯具了，此路不通。但是 AddVisualChild 方法旁边还有个 RemoveVisualChild 方法，顺手看了下，居然有实质性方法：protected void RemoveVisualChild(Visual child){ // …… （省略部分） for (int i = 0; i &amp;lt; _proxy.Count; i++) { DUCE.Channel channel = _proxy.GetChannel(i); if (child.CheckFlagsAnd(channel, VisualProxyFlags.IsConnectedToParent)) { child.SetFlags(channel, false, VisualProxyFlags.IsConnectedToParent); DUCE.IResource childResource = (DUCE.IResource)child; childResource.RemoveChildFromParent(this, channel); childResource.ReleaseOnChannel(channel); } } // …… （省略部分）}注意到 childResource.RemoveChildFromParent(this, channel); 的调用方是 childResource，而它是从 Visual 强转的 DUCE.IResource 接口对象。由于我们要了解的是实现细节，直接点开接口是看不到的，所以，得看看到底是谁实现了这个接口。既然是 Visual 强转得到，那么确定是 Visual 实现。但必须要强转才能调用，这不得不让我怀疑“Visual 类显式实现了接口 DUCE.IResource”。 于是，我在浏览器中按下 Ctrl+F，搜素 RemoveChildFromParent，结果不出所料：/// &amp;lt;summary&amp;gt;/// Sends a command to compositor to remove the child/// from its parent on the channel./// &amp;lt;/summary&amp;gt;void DUCE.IResource.RemoveChildFromParent( DUCE.IResource parent, DUCE.Channel channel){ DUCE.CompositionNode.RemoveChild( parent.GetHandle(channel), _proxy.GetHandle(channel), channel);}其实我们可以继续去看 RemoveChild 方法，但注释却让我感到意外。 Sends a command to compositor to remove the child from its parent on the channel.在 channel 中向 compositor 发送一个移除视觉子级的命令。莫非到头来都不会真实地执行任何渲染相关的方法？channel 是什么？compositor 又是什么？一个一个调查！查到最后RemoveChild 方法如下，果不其然，真的只是在通道中发送了一条移除视觉子级的命令。/// &amp;lt;SecurityNote&amp;gt;/// Critical: This code accesses an unsafe code block/// TreatAsSafe: Operation is ok to call. It does not return any pointers and sending a pointer to a channel is safe/// &amp;lt;/SecurityNote&amp;gt;[SecurityCritical, SecurityTreatAsSafe]internal static void RemoveChild( DUCE.ResourceHandle hCompositionNode, DUCE.ResourceHandle hChild, Channel channel){ DUCE.MILCMD_VISUAL_REMOVECHILD command; command.Type = MILCMD.MilCmdVisualRemoveChild; command.Handle = hCompositionNode; command.hChild = hChild; unsafe { channel.SendCommand( (byte*)&amp;amp;command, sizeof(DUCE.MILCMD_VISUAL_REMOVECHILD) ); }}channel 是 DUCE.Channel 类型的，在 msdn 上搜索 DUCE.Channel 没有得到正式的定义，但是搜到的一篇文章却间接地描述了它的用途。 WPF Render Thread FailuresThe render thread only synchronizes with the UI thread in a few locations, so the callstacks above are typically where you notice the problem, not where it actually occurred. The most common locations when they synchronize are when a window’s settings are updated (size, position, etc.) or as a result of the UI thread handling a “channel” message from DirectX.渲染线程只在少数几处与 UI 线程进行同步，这也是为什么你看到的堆栈信息是这么几处，而不是真实发生错误的代码。通常进行线程同步的几个地方是 window 的尺寸、位置等发生变换时或者 UI 线程从 DirectX 处理通道中的消息时。从原文中的错误堆栈中和上文里面我们可以知道 channel 是用来让 UI 线程和渲染线程进行通信的通道。记得刚开始 AddVisualChild 方法中没有找到相关方法吗？想知道为什么。于是我又通过 DUCE.Channel 反向查找，最终发现对应的方法其实在 Visual.Render 方法中。internal void Render(RenderContext ctx, UInt32 childIndex){ // …… （省略部分） DUCE.CompositionNode.InsertChildAt( ctx.Root, _proxy.GetHandle(channel), childIndex, channel); // …… （省略部分）}大胆猜想继续找，发现 DUCE.Channel 类型中只有发送/提交命令的方法，没有获取命令的方法；而且发送命令执行的都是非托管代码。而如果获取命令的方法也是托管代码，那么 DUCE.Channel 中一定有方法获取到命令的。所以，大胆猜测，获取方法仅在非托管代码中实现。也就是说，UI 线程由托管代码实现，但视觉树改变后仅发送一个命令通知渲染线程实现，而渲染线程由非托管代码实现。理论依据Google 搜索“WPF Render”关键字，我找到了这篇文章：A Critical Deep Dive into the WPF Rendering System从这篇文章中，得到了很多 WPF 渲染系统的启发，这也许能解释本文开始的一部分现象。" }, { "title": "解决XAML设计器中遇到的那些错误", "url": "/wpf/2016/07/31/solve-xaml-designer-errors.html", "categories": "", "tags": "wpf", "date": "2016-08-02 14:33:38 +0800", "snippet": "使用 Visual Studio 开发 WPF 程序时，XAML 设计器能够极大提高我们的开发效率。不止是写出的代码无需运行就能看到效果，还有能够直接在设计器中点击定位元素以及拖拽改变属性。但是，XAML 开发不总是那么幸运！因为我们总能在设计器中看到这样的一幕：如果你看完之后无奈又无助，那这篇文章正好将帮你分析 XAML 设计器出错的各种可能原因以及解决这些问题的思路。XAML 设计器出错的种类总结起来，XAML 设计器错误有这些种类： 加载错误； 你会在设计器中看到各种各样的异常。 设计时类型不匹配； 你会发现设计器异常提示无法将某种类型转换为另一种类型。 资源未找到； 你会发现设计器里的控件样式变成了默认。 控件尺寸难以接受或相互重叠； 有时你可能不得不将控件的尺寸设为 0；或者将多个控件放一起以至于重叠，看不见最底层的那个。 控件缺少用以显示的数据。 这种情况多见于绑定 ViewModel，尤其是列表类控件。 严格来说，只有前两种算是错误；但后三种也是让我们为设计器抓狂的罪魁祸首，所以也一并说了吧。解决 XAML 设计器错误的一般思路未完待续……阅读并猜测异常发生的来源未完待续……用 VS 调试 VS未完待续……实战解决几个典型的 XAML 设计器错误未完待续……参考资料MSDN - Troubleshooting Designer Load FailuresMSDN - How to: Debug a Designer Load Failure" }, { "title": "使用链接共享 Visual Studio 中的代码文件", "url": "/visualstudio/2016/08/01/share-code-with-add-as-link.html", "categories": "", "tags": "visualstudio, msbuild", "date": "2016-08-01 11:04:42 +0800", "snippet": "如果你还在通过复制来共享代码就太 out 了！我们知道，将公共的代码抽取成库是非常好的代码复用手段，但有时我们需要复用的代码（或文件）无法提取到库中。这时，Visual Studio 自带的 Link 功能就派上用场了。链接的文件长这样如上图，链接文件其图标上会有一个小图标。图中的 A 和 B 两个项目都是应用程序项目（不是类库），所需的图标和数据库是需要共享的，于是将其设为了链接。怎么创建链接文件？普通的方法（适用于 Visual Studio 2019/2017/2015/2013/2012）在 Visual Studio 项目上或文件夹上 右键-&amp;gt;Add-&amp;gt;ExistingItem，选好文件后，不要直接点右下角的 [Add] 按钮，而是点击 [Add] 按钮旁边的下拉按钮，选择 Add As Link。后文即将说的快速方法不适用于 Visual Studio 2019（其实是不适用于 SDK 风格的项目文件），这个 bug 我已经报给微软了，请参见： Link a file using Alt-Dragging is lost in the new SDK style project. - Developer Community关于 SDK 风格的项目文件，可阅读： 将 WPF、UWP 以及其他各种类型的旧 csproj 迁移成 Sdk 风格的 csproj - walterlv最快的方法（适用于 Visual Studio 2017/2015/2013/2012）按住 Alt 键，在 Visual Studio 中将一个文件拖拽到另一个文件夹中即可完成文件的链接。如果你想同时拖拽多个文件，你需要先拖拽，再在拖拽的过程中按住 Alt 键，否则只能拖一个文件出来（不知 Visual Studio 2015/2017 为什么要这么设计）。这个过程发生了什么？我们观察下包含链接的项目文件：...&amp;lt;!-- 这是普通的文件 --&amp;gt;&amp;lt;None Include=&quot;Log.config&quot;/&amp;gt;...&amp;lt;!-- 这是链接的文件 --&amp;gt;&amp;lt;None Include=&quot;..\\Project B\\icon.ico&quot;&amp;gt; &amp;lt;Link&amp;gt;icon.ico&amp;lt;/Link&amp;gt;&amp;lt;/None&amp;gt;...可以发现，Include 实际上是指向另一个项目中的文件，这样，msbuild 在编译的时候直接读取 include 的文件路径即可实现编译，都不需要特殊考虑。在标签内部，有一个 Link 标签，告诉 Visual Studio 在此项目中应该显示到哪个文件夹下，是什么文件名。参考资料 MSDN - Share code with Add as Link" }, { "title": "KeyDown/PreviewKeyDown 事件中监听 Alt 键按下", "url": "/wpf/2016/05/09/know-alt-is-pressed-in-key-down-event.html", "categories": "", "tags": "wpf", "date": "2016-05-09 10:59:00 +0800", "snippet": "在 WPF 应用程序（或者其他 Windows 应用程序中），为了监听 Alt 键按下，我们可以在 KeyDown 事件中写源码。然而，运行一看，发现并没有什么用。打个断点看下会发现，e.Key 的值是 Key.System。这就奇怪了，Key.System 是个什么鬼？一个坑在WPF应用程序（或者其他 Windows 应用程序中），为了监听 Alt 键按下，我们可以尝试写出这样的代码：PreviewKeyDown += (s, e) =&amp;gt;{ if (e.Key == Key.LeftAlt || e.Key == Key.RightAlt) { // A: 做些什么。 }};然而，运行一看，发现并没有什么用。A处的代码根本就没执行。打个断点看下，会发现，e.Key 的值是 Key.System。这就奇怪了，Key.System 是个什么鬼？一段源码看看 KeyEventArgs 中的源码，我们发现微软写了这么个注释：/// &amp;lt;summary&amp;gt;/// The Key referenced by the event, if the key is not being /// handled specially./// &amp;lt;/summary&amp;gt;public Key Key{ get {return _key;}}如果按键没有被特殊处理， Key 属性才会返回正确的按键。这么说，当我们按下 Alt 键时，其实 Windows 或者 WPF 某一层特殊处理了这个按键。继续阅读源码，发现这个属性后面还有这样一个属性：/// &amp;lt;summary&amp;gt;/// The Key referenced by the event, if the key is going to be/// processed by an system./// &amp;lt;/summary&amp;gt;public Key SystemKey{ get { return (_key == Key.System) ? _realKey : Key.None;}}跟刚刚的 Key 属性相反，这个属性指进行特殊处理时返回的按键。所以，截至这里，问题算是解决了，因为我们可以写出这样的代码：PreviewKeyDown += (s, e) =&amp;gt;{ Key key = (e.Key == Key.System ? e.SystemKey : e.Key); if (key == Key.LeftAlt || key == Key.RightAlt) { // A: 做些什么。 }};一个解释然而事情肯定不能这样就结束了，微软为什么要设计这样奇怪的机制？为什么 Alt 键要成为特殊系统按键？经过一系列搜索，我找到了解释： 在 Windows 系统中，Alt 键会被特殊处理。当单独按下 Alt 键，或者按下一个带有 Alt 的组合键时，操作系统会将此事件视为“系统按键”（System keypress）。系统按键与普通按键相比，其处理过程是不同的。 首先，无论是系统按键还是普通按键，Windows都会将这些事件传递给应用程序。如果是普通按键，则传递 WM_KEYDOWN ，但如果是 Alt 键，则传递 WM_SYSKEYDOWN ；同理， WM_KEYUP 也会转变成 WM_SYSKEYUP。 在 Windows 中（包括 WPF 中），Alt 键如此特殊是为了处理应用程序中那些带有“特殊标记”文字的菜单项（MenuItems）、按钮（Buttons）和其它标签（Labels）的。举个例子，如果按钮的文字内容被设置成“Say _Hi”，那么 Alt+H 快捷键就会被转变成为一次按钮点击（Click）事件。 这段解释可以在这里 https://stackoverflow.com/questions/3099472/previewkeydown-is-not-seeing-alt-modifiers 得到更详细的信息。" }, { "title": "关联一个文件扩展名或协议", "url": "/windows/2015/07/07/associate-with-file-or-protocol.html", "categories": "", "tags": "windows", "date": "2015-07-07 20:00:00 +0800", "snippet": "在 Windows 中关联程序或协议是通过注册表项实现的，编写任意一个程序甚至只是个脚本来写注册表即可实现。注册表项的位置在这里：HKEY_CLASSES_ROOT\\XXX\\shell\\open\\command" }, { "title": "未知的编译错误：“已添加具有相同键的项。Unknown build error, &#39;An item with the same key has already been added.&#39;”", "url": "/post/unkown-build-error-item-same-key-added.html", "categories": "", "tags": "visualstudio", "date": "2015-06-30 20:13:00 +0800", "snippet": "未知的编译错误：“已添加具有相同键的项。”Unknown build error, ‘An item with the same key has already been added.’本文将解释编译时产生此问题的原因，并提供解决方法。出现此问题的原因出现此问题的原因是：csproj 文件中存在两个对相同文件的引用行。例如：&amp;lt;ItemGroup&amp;gt; &amp;lt;Resource Include=&quot;Walterlv\\Demo\\Icon\\Clear.png&quot; /&amp;gt; &amp;lt;Resource Include=&quot;Walterlv\\Demo\\Icon\\Clear.png&quot; /&amp;gt;&amp;lt;/ItemGroup&amp;gt;出现此问题时，只需要去掉某一个重复行即可，如果找不到是哪个文件，则可以使用正则表达式匹配。(?s)(&amp;lt;.+?&amp;gt;).*?\\1此正则表达式的作用是查找文件中的相同行。或者写一个简短的程序来查找：namespace Walterlv.Tools{ class Program { static void Main(string[] args) { List&amp;lt;string&amp;gt; lines = new List&amp;lt;string&amp;gt;(); foreach (string line in File.ReadAllLines(args[0]).Where(x=&amp;gt;!String.IsNullOrEmpty(x)).Select(x =&amp;gt; x.Trim())) { if (lines.Contains(line)) Console.WriteLine(line); else lines.Add(line); } Console.Read(); } }}此代码的作用是输出指定文件中所有相同的行。一个让VS复现此问题的步骤如下图，将一个已排除到项目之外的文件拖拽到另一个文件夹，并覆盖项目内的同名文件，则必现此问题。所以，平时开发的过程中，如果要到处拖拽文件的话，小心哦！正在录制" }, { "title": "为程序签名", "url": "/windows/2015/03/31/sign-for-desktop-application.html", "categories": "", "tags": "windows", "date": "2015-03-31 16:46:00 +0800", "snippet": "给应用程序签名，可以让系统知道你的程序是受信任的程序。一部分操作，系统只会为受信任的程序开启。创建私人证书makecert -r -pe -n &quot;CN=Test Certificate - For Internal Use Only&quot; -ss PrivateCertStore testcert.cer安装私人证书certmgr.exe -add testcert.cer -s -r localMachine root给程序集签名SignTool sign /v /s PrivateCertStore /n &quot;Test Certificate - For Internal Use Only&quot; /t http://timestamp.verisign.com/scripts/timestamp.dll APP.exe" }, { "title": "减速动画 AnimationShiftKey", "url": "/windows/2014/12/28/decelerate-windows-animation.html", "categories": "", "tags": "windows", "date": "2014-12-28 15:57:00 +0800", "snippet": "想不想让你 Windows 自带的各种动画都变得缓慢？这可别有一番风味啊！顺便还能观察下系统的动画是怎么实现的呢。修改注册表即可实现：Windows Registry Editor Version 5.00[HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\DWM]&quot;AnimationsShiftKey&quot;=dword:00000001" }, { "title": "为什么桌面上可能有两个同名文件？", "url": "/windows/2014/09/25/why-two-same-file-can-be-existed-on-desktop.html", "categories": "", "tags": "windows", "date": "2014-09-25 18:11:00 +0800", "snippet": "是否见过桌面上同时存在两个同名的文件？这其实是可能的。我们见过这样的情况：当打开隐藏文件和系统文件时，桌面上会看到这样两个同名的文件。虽然 Windows 不允许在一个文件夹中同时存在两个同名的文件，但我们知道“桌面”不是普通的文件夹。在默认的 Windows 系统设置中，桌面上显示的图标不仅来自于当前用户帐户专有的“桌面”配置文件夹，也来自于所有用户帐户共有的“公共桌面”配置文件夹。前者提供的图标仅在当前用户帐户的桌面上显示；后者提供的图标在所有用户帐户的桌面上显示。由于这两个“桌面”配置文件夹都有自己的 Desktop.ini，所以当我们允许显示隐含的文件时，两个 Desktop.ini 都将出现在桌面上。请注意“对象名称”，其中指示两个文件存在于不同路径。" }, { "title": "FileSystemWatcher 监视文件改变", "url": "/dotnet/2014/09/23/FileSystemWatcher-monitor-filesystem-changed.html", "categories": "", "tags": "dotnet", "date": "2014-09-23 20:22:00 +0800", "snippet": "要监视文件或文件夹的改变，可使用 FileSystemWatcher。FileSystemWatcher fileWatcher = new FileSystemWatcher{ Path = watchingFolder, NotifyFilter = NotifyFilters.Size | NotifyFilters.LastWrite, Filter = &quot;*.log&quot;, EnableRaisingEvents = true,};_fileWatcher.Changed += FileWatcher_Changed;private void FileWatcher_Changed(object sender, FileSystemEventArgs e){ if (e.ChangeType == WatcherChangeTypes.Changed) { }}需要注意的是，并不是按照以上这种写法就能立即收到改变通知。有些程序写入文件是立即写入磁盘的（如记事本），在写入时能够通过以上方法立即获得通知；但有一些不是立即写入磁盘（如 Log4Net），它会有一个缓冲区，程序写入到缓冲区时以上方法不会收到通知。然而，只要有任何一个进程读取了这个文件（哪怕是只有一个字节），Windows 就会立刻将缓冲区写入磁盘，以上方法也就会收到改变通知了。" }, { "title": "FileShare 读取一个其它进程正在写的文件", "url": "/dotnet/2014/09/22/FileShare-read-file-which-is-written-by-another-process.html", "categories": "", "tags": "dotnet", "date": "2014-09-22 22:36:00 +0800", "snippet": "Windows 允许多个应用程序同时读取一个文件，即便这个文件正在被写入。private string[] ReadLogLines(string key){ FileStream fs = new FileStream(_watchingFileNameDictionary[key], FileMode.Open, FileAccess.Read, FileShare.ReadWrite); StreamReader sr = new StreamReader(fs, Encoding.GetEncoding(&quot;GBK&quot;)); string[] lines = sr.ReadToEnd().Split(new[] {Environment.NewLine}, StringSplitOptions.RemoveEmptyEntries); sr.Close(); fs.Close(); return lines;}关键在于不单要与只读方式打开文件，而是需要共享锁，还必须要选择 FlieShare 方式为 ReadWrite。（读方与写方都需要是 ReadWrite。） 如果要一个程序要监视另一个程序的写入，然后读取写入的内容，可参考 FileSystemWatcher。" }, { "title": "Windows DPI Awareness for WPF", "url": "/windows/2014/09/20/windows-dpi-awareness-for-wpf.html", "categories": "", "tags": "windows", "date": "2014-09-20 16:56:00 +0800", "snippet": "对于 WPF 程序，要控制程序的 DPI 感知程度，可在 App.manifest 中添加如下代码。本文知识已经陈旧，你可以阅读这两篇文章来了解更新的 Windows DPI 应用知识： Windows 下的高 DPI 应用开发（UWP / WPF / Windows Forms / Win32） - walterlv 支持 Windows 10 最新 PerMonitorV2 特性的 WPF 高 DPI 应用开发 - walterlv原文内容： &amp;lt;asmv3:application xmlns:asmv3=&quot;urn:schemas-microsoft-com:asm.v3&quot;&amp;gt; &amp;lt;asmv3:windowsSettings xmlns=&quot;http://schemas.microsoft.com/SMI/2005/WindowsSettings&quot;&amp;gt; &amp;lt;!-- 此应用程序将使用以下 DPI 感知级别。（默认情况下是系统 DPI 感知级别。）--&amp;gt; &amp;lt;!-- 应用程序不对 DPI 感知，将由 DWM （Desktop Window Manager）进行 DPI 缩放控制。 --&amp;gt; &amp;lt;!--&amp;lt;dpiAware&amp;gt;False&amp;lt;/dpiAware&amp;gt;--&amp;gt; &amp;lt;!-- 应用程序具有系统级别的 DPI 感知能力。 --&amp;gt; &amp;lt;!--&amp;lt;dpiAware&amp;gt;True&amp;lt;/dpiAware&amp;gt;--&amp;gt; &amp;lt;!-- 应用程序对每个显示器的 DPI 都具备感知能力。 --&amp;gt; &amp;lt;dpiAware&amp;gt;True/PM&amp;lt;/dpiAware&amp;gt; &amp;lt;/asmv3:windowsSettings&amp;gt; &amp;lt;/asmv3:application&amp;gt;" }, { "title": "CallerMemberName", "url": "/dotnet/2014/09/12/CallerMemberName.html", "categories": "", "tags": "dotnet", "date": "2014-09-12 10:19:00 +0800", "snippet": "从 .NET Framework 4.5 开始，有了几个快速获取调用方信息的 Attribute。 Attribute 描述 CallerMemberName 允许您打算调用方的方法或属性名称传递给方法。 CallerLineNumber 允许您打算在调用方法的源文件中的行号。 CallerFilePath 允许您获取包含调用方源文件的完整路径。这是文件路径在生成时。 这样，在实现用于 XAML 绑定的类型中，可以更方便更高效地进行属性更改通知。[NotifyPropertyChangedInvocator]protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = null){ PropertyChangedEventHandler handler = PropertyChanged; if (handler != null) handler(this, new PropertyChangedEventArgs(propertyName));}当使用 OnPropertyChanged() 句子调用以上方法时，参数 propertyName 会被自动赋值。protected bool SetProperty&amp;lt;T&amp;gt;(ref T storage, T value, [CallerMemberName] string propertyName = null){ if (Equals(storage, value)) return false; storage = value; OnPropertyChanged(propertyName); return true;}可在类型中添加以上方法，使得属性更改变得更加简单：private string _notifyMessage;public string Notification{ get { return _notifyMessage; } set { SetProperty(ref _notifyMessage, value); }}详细信息可阅读：Using CallerMemberName for property change notification in XAML apps" } ]
