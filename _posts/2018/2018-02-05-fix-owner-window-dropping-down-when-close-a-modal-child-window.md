---
title: "关闭模态窗口后，父窗口居然跑到了其他窗口的后面"
date: 2018-02-05 13:58:49 +0800
categories: dotnet csharp windows
---

显示一个模态窗口，正常而普遍的操作。然而却一直有一个难缠的 BUG：当关闭模态窗口时，父窗口有时会跑到其他程序窗口的后面！

而最近读到了微软工程师写过的话之后，明白了这个 BUG 的产生缘由以及解决方法。

---

### 这是什么 BUG？

![弹出模态窗口](/static/posts/2018-02-05-13-28-37.png)

1. 弹出一个模态窗口，然后将模态窗口的父窗口设置为自身窗口；
1. 切换到其他程序窗口中（比如 Windows 资源管理器窗口）；
1. 切换回此模态窗口，然后关闭这个模态窗口上。

你会发现，模态窗口关闭后，父窗口并没有回到当前的顶层显示中。取而代之的，是其他程序的窗口（比如 Windows 资源管理器窗口）。
用一张图来描述这个 BUG，将是这样的：

有这两个窗口，其中右边那个是我们开发的：

![两个窗口](/static/posts/2018-02-05-13-38-32.png)

我们的窗口在资源管理器上面。然后，我们弹出模态子窗口：

![我们在上面](/static/posts/2018-02-05-13-40-18.png)

现在，我们操作一下资源管理器：

![操作资源管理器](/static/posts/2018-02-05-13-46-41.png)

然后，回到模态子窗口中，把它关掉：

![关掉模态子窗口](/static/posts/2018-02-05-13-43-35.png)

我们期待模态子窗口关掉后，它的父窗口会在顶层继续供我们操作，但实际上，Windows 资源管理器却成为了顶层，我们的程序“掉下去了”：

![不符合预期的结果](/static/posts/2018-02-05-13-48-18.png)

### 解释和解决方法

在《Windows 进化启示录》书中，微软有说到：

> 当销毁模态对话框时，这个对话框刚好是拥有前台焦点的窗口。现在，窗口管理器需要找到其他的窗口并把前台焦点交给这个窗口。
> 窗口管理器会首先试着把前台焦点交给对话框的所有者窗口，但此时这个窗口却仍然是禁止的，因此窗口管理器将跳过所有者窗口，并继续查找没有被禁止的窗口。

这很明显是 Windows 的 BUG，然而让微软感到无奈的是，经常有程序喜欢依赖于微软的 BUG 进行开发，一旦微软修复了 BUG，那些依赖于 BUG 开发的程序将变得不正常！

为解决兼容性问题的微软工程师默哀一分钟……

我曾经尝试在模态子窗口关闭后激活一下父窗口，但这样会导致窗口的层级闪烁一下（Windows 资源管理器会短暂地显示到我们的窗口之上）。

而这本书作者推荐的方法是：

> 1. 重新激活所有者窗口
> 1. 销毁模态对话框

于是，我试着监听模态子窗口的 `Closing` 事件，在其中写下主窗口的激活调用，自此 BUG 才算解决。

```csharp
public ChildModalWindow()
{
    Closing += (sender, e) => Owner?.Activate();
}
```

将这样的解决办法封装成附加属性给所有的模态子窗口，这样设置附加属性即可解决问题。或者统一模态子窗口的窗口样式，在样式中解决这个 BUG，这样，所有使用了此窗口样式的模态子窗口也将解决问题。

---

#### 参考资料

- 《伟大的产品 —— Windows 进化启示录》by 微软软件工程师 Raymond Chen
